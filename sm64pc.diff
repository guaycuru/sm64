diff --git a/.gitignore b/.gitignore
index 9b111cc..6c157d2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,7 +12,6 @@
 *.pch
 
 # Libraries
-*.lib
 *.a
 *.la
 *.lo
@@ -50,6 +49,8 @@ build/*
 *.z64
 *.map
 .assets-local.txt
+sm64_save_file.bin
+sm64config.txt
 
 # Assets. Generally ignored, but ones with "custom" in the name are fine.
 /levels/**/*.png
diff --git a/Makefile b/Makefile
index 26c76d3..edc162a 100644
--- a/Makefile
+++ b/Makefile
@@ -19,6 +19,20 @@ COMPARE ?= 1
 NON_MATCHING ?= 0
 # Build for the N64 (turn this off for ports)
 TARGET_N64 ?= 1
+# Build for Emscripten/WebGL
+TARGET_WEB ?= 0
+
+# Automatic settings only for ports
+ifeq ($(TARGET_N64),0)
+  NON_MATCHING := 1
+  GRUCODE := f3dex2e
+  WINDOWS_BUILD := 0
+  ifeq ($(TARGET_WEB),0)
+    ifeq ($(OS),Windows_NT)
+      WINDOWS_BUILD := 1
+    endif
+  endif
+endif
 
 # Release
 
@@ -63,6 +77,11 @@ ifeq ($(GRUCODE), f3dex2) # Fast3DEX2
   TARGET := $(TARGET).f3dex2
   COMPARE := 0
 else
+ifeq ($(GRUCODE), f3dex2e) # Fast3DEX2 Extended (for PC)
+  GRUCODE_CFLAGS := -DF3DEX_GBI_2E
+  TARGET := $(TARGET).f3dex2e
+  COMPARE := 0
+else
 ifeq ($(GRUCODE),f3d_new) # Fast3D 2.0H (Shindou)
   GRUCODE_CFLAGS := -DF3D_NEW
   GRUCODE_ASFLAGS := --defsym F3D_NEW=1
@@ -79,9 +98,6 @@ endif
 endif
 endif
 endif
-
-ifeq ($(TARGET_N64),0)
-  NON_MATCHING := 1
 endif
 
 ifeq ($(NON_MATCHING),1)
@@ -89,6 +105,10 @@ ifeq ($(NON_MATCHING),1)
   COMPARE := 0
 endif
 
+ifeq ($(TARGET_WEB),1)
+  VERSION_CFLAGS := $(VERSION_CFLAGS) -DTARGET_WEB
+endif
+
 ################### Universal Dependencies ###################
 
 # (This is a bit hacky, but a lot of rules implicitly depend
@@ -120,9 +140,26 @@ endif
 
 # BUILD_DIR is location where all build artifacts are placed
 BUILD_DIR_BASE := build
-BUILD_DIR := $(BUILD_DIR_BASE)/$(VERSION)
+ifeq ($(TARGET_N64),1)
+  BUILD_DIR := $(BUILD_DIR_BASE)/$(VERSION)
+else
+ifeq ($(TARGET_WEB),1)
+  BUILD_DIR := $(BUILD_DIR_BASE)/$(VERSION)_web
+else
+  BUILD_DIR := $(BUILD_DIR_BASE)/$(VERSION)_pc
+endif
+endif
 
 LIBULTRA := $(BUILD_DIR)/libultra.a
+ifeq ($(TARGET_WEB),1)
+EXE := $(BUILD_DIR)/$(TARGET).html
+else
+ifeq ($(WINDOWS_BUILD),1)
+EXE := $(BUILD_DIR)/$(TARGET).exe
+else
+EXE := $(BUILD_DIR)/$(TARGET)
+endif
+endif
 ROM := $(BUILD_DIR)/$(TARGET).z64
 ELF := $(BUILD_DIR)/$(TARGET).elf
 LD_SCRIPT := sm64.ld
@@ -134,7 +171,13 @@ LEVEL_DIRS := $(patsubst levels/%,%,$(dir $(wildcard levels/*/header.h)))
 
 # Directories containing source files
 SRC_DIRS := src src/engine src/game src/audio src/menu src/buffers actors levels bin data assets
-ASM_DIRS := asm lib
+ASM_DIRS := lib
+ifeq ($(TARGET_N64),1)
+  ASM_DIRS := asm $(ASM_DIRS)
+else
+  SRC_DIRS := $(SRC_DIRS) src/pc src/pc/gfx src/pc/audio src/pc/controller
+  ASM_DIRS :=
+endif
 BIN_DIRS := bin bin/$(VERSION)
 
 ULTRA_SRC_DIRS := lib/src lib/src/math
@@ -152,17 +195,83 @@ else
   OPT_FLAGS := -g
 endif
 
+ifeq ($(TARGET_WEB),1)
+  OPT_FLAGS := -O2 -g4 --source-map-base http://localhost:8080/
+endif
+
 # File dependencies and variables for specific files
 include Makefile.split
 
 # Source code files
 LEVEL_C_FILES := $(wildcard levels/*/leveldata.c) $(wildcard levels/*/script.c) $(wildcard levels/*/geo.c)
 C_FILES := $(foreach dir,$(SRC_DIRS),$(wildcard $(dir)/*.c)) $(LEVEL_C_FILES)
+CXX_FILES := $(foreach dir,$(SRC_DIRS),$(wildcard $(dir)/*.cpp))
 S_FILES := $(foreach dir,$(ASM_DIRS),$(wildcard $(dir)/*.s))
 ULTRA_C_FILES := $(foreach dir,$(ULTRA_SRC_DIRS),$(wildcard $(dir)/*.c))
 GODDARD_C_FILES := $(foreach dir,$(GODDARD_SRC_DIRS),$(wildcard $(dir)/*.c))
-ULTRA_S_FILES := $(foreach dir,$(ULTRA_ASM_DIRS),$(wildcard $(dir)/*.s))
-GENERATED_C_FILES := $(BUILD_DIR)/assets/mario_anim_data.c $(BUILD_DIR)/assets/demo_data.c
+ifeq ($(TARGET_N64),1)
+  ULTRA_S_FILES := $(foreach dir,$(ULTRA_ASM_DIRS),$(wildcard $(dir)/*.s))
+endif
+GENERATED_C_FILES := $(BUILD_DIR)/assets/mario_anim_data.c $(BUILD_DIR)/assets/demo_data.c \
+  $(addprefix $(BUILD_DIR)/bin/,$(addsuffix _skybox.c,$(notdir $(basename $(wildcard textures/skyboxes/*.png)))))
+
+ifeq ($(WINDOWS_BUILD),0)
+  CXX_FILES :=
+endif
+
+ifneq ($(TARGET_N64),1)
+  ULTRA_C_FILES_SKIP := \
+    sqrtf.c \
+    string.c \
+    sprintf.c \
+    _Printf.c \
+    kdebugserver.c \
+    osInitialize.c \
+    osCreateThread.c \
+    osDestroyThread.c \
+    osStartThread.c \
+    osSetThreadPri.c \
+    osPiStartDma.c \
+    osPiRawStartDma.c \
+    osPiRawReadIo.c \
+    osPiGetCmdQueue.c \
+    osJamMesg.c \
+    osSendMesg.c \
+    osRecvMesg.c \
+    osSetEventMesg.c \
+    osTimer.c \
+    osSetTimer.c \
+    osSetTime.c \
+    osCreateViManager.c \
+    osViSetSpecialFeatures.c \
+    osVirtualToPhysical.c \
+    osViBlack.c \
+    osViSetEvent.c \
+    osViSetMode.c \
+    osViSwapBuffer.c \
+    osSpTaskLoadGo.c \
+    osCreatePiManager.c \
+    osGetTime.c \
+    osEepromProbe.c \
+    osEepromWrite.c \
+    osEepromLongWrite.c \
+    osEepromRead.c \
+    osEepromLongRead.c \
+    osContInit.c \
+    osContStartReadData.c \
+    osAiGetLength.c \
+    osAiSetFrequency.c \
+    osAiSetNextBuffer.c \
+    __osViInit.c \
+    __osSyncPutChars.c \
+    __osAtomicDec.c \
+    __osSiRawStartDma.c \
+    __osViSwapContext.c \
+    __osViGetCurrentContext.c
+
+  C_FILES := $(filter-out src/game/main.c,$(C_FILES))
+  ULTRA_C_FILES := $(filter-out $(addprefix lib/src/,$(ULTRA_C_FILES_SKIP)),$(ULTRA_C_FILES))
+endif
 
 SOUND_BANK_FILES := $(wildcard sound/sound_banks/*.json)
 SOUND_SEQUENCE_FILES := $(wildcard sound/sequences/$(VERSION)/*.m64) \
@@ -181,6 +290,7 @@ SOUND_OBJ_FILES := $(SOUND_BIN_DIR)/sound_data.ctl.o \
 
 # Object files
 O_FILES := $(foreach file,$(C_FILES),$(BUILD_DIR)/$(file:.c=.o)) \
+           $(foreach file,$(CXX_FILES),$(BUILD_DIR)/$(file:.cpp=.o)) \
            $(foreach file,$(S_FILES),$(BUILD_DIR)/$(file:.s=.o)) \
            $(foreach file,$(GENERATED_C_FILES),$(file:.c=.o))
 
@@ -193,14 +303,20 @@ GODDARD_O_FILES := $(foreach file,$(GODDARD_C_FILES),$(BUILD_DIR)/$(file:.c=.o))
 DEP_FILES := $(O_FILES:.o=.d) $(ULTRA_O_FILES:.o=.d) $(GODDARD_O_FILES:.o=.d) $(BUILD_DIR)/$(LD_SCRIPT).d
 
 # Files with GLOBAL_ASM blocks
+ifneq ($(NON_MATCHING),1)
 GLOBAL_ASM_C_FILES != grep -rl 'GLOBAL_ASM(' $(wildcard src/audio/*.c) $(wildcard src/game/*.c)
 GLOBAL_ASM_O_FILES = $(foreach file,$(GLOBAL_ASM_C_FILES),$(BUILD_DIR)/$(file:.c=.o))
 GLOBAL_ASM_DEP = $(BUILD_DIR)/src/audio/non_matching_dep
+endif
 
 # Segment elf files
 SEG_FILES := $(SEGMENT_ELF_FILES) $(ACTOR_ELF_FILES) $(LEVEL_ELF_FILES)
 
 ##################### Compiler Options #######################
+INCLUDE_CFLAGS := -I include -I $(BUILD_DIR) -I $(BUILD_DIR)/include -I src -I .
+ENDIAN_BITWIDTH := $(BUILD_DIR)/endian-and-bitwidth
+
+ifeq ($(TARGET_N64),1)
 IRIX_ROOT := tools/ido5.3_compiler
 
 ifeq ($(shell type mips-linux-gnu-ld >/dev/null 2>/dev/null; echo $$?), 0)
@@ -231,8 +347,6 @@ ifeq ($(TARGET_N64),1)
   CC_CFLAGS := -fno-builtin
 endif
 
-INCLUDE_CFLAGS := -I include -I $(BUILD_DIR) -I $(BUILD_DIR)/include -I src -I .
-
 # Check code syntax with host compiler
 CC_CHECK := gcc -fsyntax-only -fsigned-char $(CC_CFLAGS) $(TARGET_CFLAGS) $(INCLUDE_CFLAGS) -std=gnu90 -Wall -Wextra -Wno-format-security -DNON_MATCHING -DAVOID_UB $(VERSION_CFLAGS) $(GRUCODE_CFLAGS)
 
@@ -251,6 +365,50 @@ else
   CC_CHECK += -m32
 endif
 
+else # TARGET_N64
+
+AS := as
+ifneq ($(TARGET_WEB),1)
+  CC := gcc
+  CXX := g++
+else
+  CC := emcc
+endif
+ifeq ($(WINDOWS_BUILD),1)
+  LD := $(CXX)
+else
+  LD := $(CC)
+endif
+CPP := cpp -P
+OBJDUMP := objdump
+OBJCOPY := objcopy
+PYTHON := python3
+
+ifeq ($(WINDOWS_BUILD),1)
+CC_CHECK := $(CC) -fsyntax-only -fsigned-char $(INCLUDE_CFLAGS) -Wall -Wextra -Wno-format-security $(VERSION_CFLAGS) $(GRUCODE_CFLAGS) `sdl2-config --cflags`
+CFLAGS := $(OPT_FLAGS) $(INCLUDE_CFLAGS) $(VERSION_CFLAGS) $(GRUCODE_CFLAGS) -fno-strict-aliasing -fwrapv `sdl2-config --cflags`
+else ifeq ($(TARGET_WEB),1)
+CC_CHECK := $(CC) -fsyntax-only -fsigned-char $(INCLUDE_CFLAGS) -Wall -Wextra -Wno-format-security $(VERSION_CFLAGS) $(GRUCODE_CFLAGS) -s USE_SDL=2
+CFLAGS := $(OPT_FLAGS) $(INCLUDE_CFLAGS) $(VERSION_CFLAGS) $(GRUCODE_CFLAGS) -fno-strict-aliasing -fwrapv -s USE_SDL=2
+else
+CC_CHECK := $(CC) -fsyntax-only -fsigned-char $(INCLUDE_CFLAGS) -Wall -Wextra -Wno-format-security $(VERSION_CFLAGS) $(GRUCODE_CFLAGS) `pkg-config --cflags libusb-1.0 glfw3` `sdl2-config --cflags`
+CFLAGS := $(OPT_FLAGS) $(INCLUDE_CFLAGS) $(VERSION_CFLAGS) $(GRUCODE_CFLAGS) -fno-strict-aliasing -fwrapv `pkg-config --cflags libusb-1.0 glfw3` `sdl2-config --cflags`
+endif
+
+ASFLAGS := -I include -I $(BUILD_DIR) $(VERSION_ASFLAGS)
+
+ifeq ($(TARGET_WEB),1)
+LDFLAGS := -lm -lGL -lSDL2 -no-pie -s TOTAL_MEMORY=20MB -g4 --source-map-base http://localhost:8080/ -s "EXTRA_EXPORTED_RUNTIME_METHODS=['callMain']"
+else
+ifeq ($(WINDOWS_BUILD),1)
+LDFLAGS := -lm -no-pie src/pc/gfx/dxsdk/`cat $(ENDIAN_BITWIDTH) | tr ' ' '\n' | tail -1`/*.lib -lxinput9_1_0 -lOle32 -static -mwindows
+else
+LDFLAGS := -lm -lGL `sdl2-config --libs` -no-pie -lpthread `pkg-config --libs libusb-1.0 glfw3` -lasound -lX11 -lXrandr -lpulse
+endif
+endif
+
+endif
+
 ####################### Other Tools #########################
 
 # N64 tools
@@ -273,19 +431,25 @@ SHA1SUM = sha1sum
 
 ###################### Dependency Check #####################
 
+ifeq ($(TARGET_N64),1)
 BINUTILS_VER_MAJOR := $(shell $(LD) --version | grep ^GNU | sed 's/^.* //; s/\..*//g')
 BINUTILS_VER_MINOR := $(shell $(LD) --version | grep ^GNU | sed 's/^[^.]*\.//; s/\..*//g')
 BINUTILS_DEPEND := $(shell expr $(BINUTILS_VER_MAJOR) \>= 2 \& $(BINUTILS_VER_MINOR) \>= 27)
 ifeq ($(BINUTILS_DEPEND),0)
 $(error binutils version 2.27 required, version $(BINUTILS_VER_MAJOR).$(BINUTILS_VER_MINOR) detected)
 endif
+endif
 
 ######################## Targets #############################
 
+ifeq ($(TARGET_N64),1)
 all: $(ROM)
 ifeq ($(COMPARE),1)
 	@$(SHA1SUM) -c $(TARGET).sha1 || (echo 'The build succeeded, but did not match the official ROM. This is expected if you are making changes to the game.\nTo silence this message, use "make COMPARE=0"'. && false)
 endif
+else
+all: $(EXE)
+endif
 
 clean:
 	$(RM) -r $(BUILD_DIR_BASE)
@@ -366,6 +530,7 @@ $(BUILD_DIR)/%.ci4: %.ci4.png
 
 # compressed segment generation
 
+ifeq ($(TARGET_N64),1)
 # TODO: ideally this would be `-Trodata-segment=0x07000000` but that doesn't set the address
 
 $(BUILD_DIR)/bin/%.elf: $(BUILD_DIR)/bin/%.o
@@ -395,6 +560,7 @@ $(BUILD_DIR)/%.mio0.o: $(BUILD_DIR)/%.mio0.s
 
 $(BUILD_DIR)/%.mio0.s: $(BUILD_DIR)/%.mio0
 	printf ".section .data\n\n.incbin \"$<\"\n" > $@
+endif
 
 $(BUILD_DIR)/%.table: %.aiff
 	$(AIFF_EXTRACT_CODEBOOK) $< >$@
@@ -427,8 +593,30 @@ $(SOUND_BIN_DIR)/%.m64: $(SOUND_BIN_DIR)/%.o
 $(SOUND_BIN_DIR)/%.o: $(SOUND_BIN_DIR)/%.s
 	$(AS) $(ASFLAGS) -o $@ $<
 
+ifeq ($(TARGET_N64),1)
 $(SOUND_BIN_DIR)/%.s: $(SOUND_BIN_DIR)/%
 	printf ".section .data\n\n.incbin \"$<\"\n" > $@
+else
+$(SOUND_BIN_DIR)/sound_data.ctl.c: $(SOUND_BIN_DIR)/sound_data.ctl
+	echo "unsigned char gSoundDataADSR[] = {" > $@
+	hexdump -v -e '1/1 "0x%X,"' $< >> $@
+	echo "};" >> $@
+
+$(SOUND_BIN_DIR)/sound_data.tbl.c: $(SOUND_BIN_DIR)/sound_data.tbl
+	echo "unsigned char gSoundDataRaw[] = {" > $@
+	hexdump -v -e '1/1 "0x%X,"' $< >> $@
+	echo "};" >> $@
+
+$(SOUND_BIN_DIR)/sequences.bin.c: $(SOUND_BIN_DIR)/sequences.bin
+	echo "unsigned char gMusicData[] = {" > $@
+	hexdump -v -e '1/1 "0x%X,"' $< >> $@
+	echo "};" >> $@
+
+$(SOUND_BIN_DIR)/bank_sets.c: $(SOUND_BIN_DIR)/bank_sets
+	echo "unsigned char gBankSetsData[] = {" > $@
+	hexdump -v -e '1/1 "0x%X,"' $< >> $@
+	echo "};" >> $@
+endif
 
 $(BUILD_DIR)/levels/scripts.o: $(BUILD_DIR)/include/level_headers.h
 
@@ -472,6 +660,10 @@ $(GLOBAL_ASM_DEP).$(NON_MATCHING):
 	@rm -f $(GLOBAL_ASM_DEP).*
 	touch $@
 
+$(BUILD_DIR)/%.o: %.cpp
+ @$(CXX) -fsyntax-only $(CFLAGS) -MMD -MP -MT $@ -MF $(BUILD_DIR)/$*.d $<
+ $(CXX) -c $(CFLAGS) -o $@ $<
+
 $(BUILD_DIR)/%.o: %.c
 	@$(CC_CHECK) -MMD -MP -MT $@ -MF $(BUILD_DIR)/$*.d $<
 	$(CC) -c $(CFLAGS) -o $@ $<
@@ -484,6 +676,7 @@ $(BUILD_DIR)/%.o: $(BUILD_DIR)/%.c
 $(BUILD_DIR)/%.o: %.s
 	$(AS) $(ASFLAGS) -MD $(BUILD_DIR)/$*.d -o $@ $<
 
+ifeq ($(TARGET_N64),1)
 $(BUILD_DIR)/$(LD_SCRIPT): $(LD_SCRIPT)
 	$(CPP) $(VERSION_CFLAGS) -MMD -MP -MT $@ -MF $@.d -I include/ -I . -DBUILD_DIR=$(BUILD_DIR) -o $@ $<
 
@@ -504,6 +697,11 @@ $(ROM): $(ELF)
 $(BUILD_DIR)/$(TARGET).objdump: $(ELF)
 	$(OBJDUMP) -D $< > $@
 
+else
+$(EXE): $(O_FILES) $(MIO0_FILES:.mio0=.o) $(SOUND_OBJ_FILES) $(ULTRA_O_FILES) $(GODDARD_O_FILES)
+ $(LD) -L $(BUILD_DIR) -o $@ $(O_FILES) $(SOUND_OBJ_FILES) $(ULTRA_O_FILES) $(GODDARD_O_FILES) $(LDFLAGS)
+endif
+
 
 
 .PHONY: all clean distclean default diff test load libultra
diff --git a/bin/segment2.c b/bin/segment2.c
index 97763d9..607531b 100644
--- a/bin/segment2.c
+++ b/bin/segment2.c
@@ -2499,6 +2499,7 @@ static const Lights1 segment2_lights_unused = gdSPDefLights1(
 
 // 0x02014470 - 0x020144B0
 static const Mtx matrix_identity = {
+#ifdef TARGET_N64
     {{0x00010000, 0x00000000,
       0x00000001, 0x00000000},
      {0x00000000, 0x00010000,
@@ -2507,19 +2508,32 @@ static const Mtx matrix_identity = {
       0x00000000, 0x00000000},
      {0x00000000, 0x00000000,
       0x00000000, 0x00000000}}
+#else
+    {{1.0f, 0.0f, 0.0f, 0.0f},
+    {0.0f, 1.0f, 0.0f, 0.0f},
+    {0.0f, 0.0f, 1.0f, 0.0f},
+    {0.0f, 0.0f, 0.0f, 1.0f}}
+#endif
 };
 
 
 // 0x020144B0 - 0x020144F0
 static const Mtx matrix_fullscreen = {
+#if TARGET_N64
     {{0x00000000, 0x00000000,
       0x00000000, 0x00000000},
      {0x00000000, 0xffff0000,
       0xffffffff, 0xffff0001},
-     {0x01990000, 0x00000000,
-      0x00000222, 0x00000000},
+     {((65536 * 2 / SCREEN_WIDTH) << 16) | 0, 0x00000000,
+      (0 << 16) | (65536 * 2 / SCREEN_HEIGHT), 0x00000000},
      {0x00000000, 0x00000000,
       0x00000000, 0x00000000}}
+#else
+    {{2.0f / SCREEN_WIDTH, 0.0f, 0.0f, 0.0f},
+    {0.0f, 2.0f / SCREEN_HEIGHT, 0.0f, 0.0f},
+    {0.0f, 0.0f, -1.0f, 0.0f},
+    {-1.0f, -1.0f, -1.0f, 1.0f}}
+#endif
 };
 
 
diff --git a/extract_assets.py b/extract_assets.py
index 512767d..91e5dd5 100755
--- a/extract_assets.py
+++ b/extract_assets.py
@@ -164,15 +164,17 @@ def main():
         assets = todo[key]
         lang, mio0 = key
         if mio0 == "@sound":
-            with tempfile.NamedTemporaryFile(prefix="ctl") as ctl_file:
-                with tempfile.NamedTemporaryFile(prefix="tbl") as tbl_file:
+            with tempfile.NamedTemporaryFile(prefix="ctl", delete=False) as ctl_file:
+                with tempfile.NamedTemporaryFile(prefix="tbl", delete=False) as tbl_file:
                     rom = roms[lang]
                     size, locs = asset_map["@sound ctl " + lang]
                     offset = locs[lang][0]
                     ctl_file.write(rom[offset : offset + size])
+                    ctl_file.close()
                     size, locs = asset_map["@sound tbl " + lang]
                     offset = locs[lang][0]
                     tbl_file.write(rom[offset : offset + size])
+                    tbl_file.close()
                     args = [
                         "python3",
                         "tools/disassemble_sound.py",
@@ -183,7 +185,11 @@ def main():
                     for (asset, pos, size, meta) in assets:
                         print("extracting", asset)
                         args.append(asset + ":" + str(pos))
-                    subprocess.run(args, check=True)
+                    try:
+                        subprocess.run(args, check=True)
+                    finally:
+                        os.unlink(ctl_file.name)
+                        os.unlink(tbl_file.name)
             continue
 
         if mio0 is not None:
@@ -194,7 +200,7 @@ def main():
                     "-o",
                     str(mio0),
                     "baserom." + lang + ".z64",
-                    "/dev/stdout",
+                    "-",
                 ],
                 check=True,
                 stdout=subprocess.PIPE,
diff --git a/include/PR/gbi.h b/include/PR/gbi.h
index e459bd3..414e56a 100644
--- a/include/PR/gbi.h
+++ b/include/PR/gbi.h
@@ -87,6 +87,12 @@
  *
  */
 
+#ifdef F3DEX_GBI_2E
+# ifndef F3DEX_GBI_2
+#  define F3DEX_GBI_2
+# endif
+#endif
+
 #ifdef    F3DEX_GBI_2
 # ifndef  F3DEX_GBI
 #  define F3DEX_GBI
@@ -1103,7 +1109,11 @@
  * Vertex (set up for use with colors)
  */
 typedef struct {
+#ifdef TARGET_N64
 	short		ob[3];	/* x, y, z */
+#else
+	float		ob[3];	/* x, y, z */
+#endif
 	unsigned short	flag;
 	short		tc[2];	/* texture coord */
 	unsigned char	cn[4];	/* color & alpha */
@@ -1113,7 +1123,11 @@ typedef struct {
  * Vertex (set up for use with normals)
  */
 typedef struct {
+#ifdef TARGET_N64
 	short		ob[3];	/* x, y, z */
+#else
+	float		ob[3];	/* x, y, z */
+#endif
 	unsigned short	flag;
 	short		tc[2];	/* texture coord */
 	signed char	n[3];	/* normal */
@@ -1162,6 +1176,7 @@ typedef struct {
 	unsigned char	v[3];
 } Tri;
 
+#ifdef TARGET_N64
 /*
  * 4x4 matrix, fixed point s15.16 format.
  * First 8 words are integer portion of the 4x4 matrix
@@ -1173,6 +1188,11 @@ typedef union {
     Mtx_t		m;
     long long int	force_structure_alignment;
 } Mtx;
+#else
+typedef struct {
+    float m[4][4];
+} Mtx;
+#endif
 
 /*
  * Viewport
@@ -4396,6 +4416,26 @@ typedef union {
 }}
 
 /* Fraction never used in fill */
+#ifdef F3DEX_GBI_2E
+#define	gDPFillRectangle(pkt, ulx, uly, lrx, lry)			\
+{									\
+	Gfx *_g0 = (Gfx *)(pkt), *_g1 = (Gfx *)(pkt);			\
+	_g0->words.w0 = _SHIFTL(G_FILLRECT, 24, 8) | 			\
+		       _SHIFTL((lrx), 2, 22);				\
+	_g0->words.w1 = _SHIFTL((lry), 2, 22);				\
+        _g1->words.w0 = _SHIFTL((ulx), 2, 22);				\
+	_g1->words.w1 = _SHIFTL((uly), 2, 22);				\
+}
+#define	gsDPFillRectangle(ulx, uly, lrx, lry)				\
+{{									\
+	(_SHIFTL(G_FILLRECT, 24, 8) | _SHIFTL((lrx), 2, 22)),		\
+	_SHIFTL((lry), 2, 22),						\
+}},									\
+{{									\
+	_SHIFTL((ulx), 2, 22),						\
+	_SHIFTL((uly), 2, 22),						\
+}}
+#else
 #define	gDPFillRectangle(pkt, ulx, uly, lrx, lry)			\
 {									\
 	Gfx *_g = (Gfx *)(pkt);						\
@@ -4404,6 +4444,13 @@ typedef union {
 			_SHIFTL((lrx), 14, 10) | _SHIFTL((lry), 2, 10));\
 	_g->words.w1 = (_SHIFTL((ulx), 14, 10) | _SHIFTL((uly), 2, 10));\
 }
+#define	gsDPFillRectangle(ulx, uly, lrx, lry)				\
+{{									\
+	(_SHIFTL(G_FILLRECT, 24, 8) | _SHIFTL((lrx), 14, 10) | 		\
+	 _SHIFTL((lry), 2, 10)),					\
+	(_SHIFTL((ulx), 14, 10) | _SHIFTL((uly), 2, 10))		\
+}}
+#endif
 
 #define	gsDPFillRectangle(ulx, uly, lrx, lry)				\
 {{									\
@@ -4413,6 +4460,7 @@ typedef union {
 }}
 
 /* like gDPFillRectangle but accepts negative arguments */
+#ifndef F3DEX_GBI_2E
 #define	gDPScisFillRectangle(pkt, ulx, uly, lrx, lry)			\
 {									\
 	Gfx *_g = (Gfx *)(pkt);						\
@@ -4423,6 +4471,7 @@ typedef union {
 	_g->words.w1 = (_SHIFTL(MAX((ulx),0), 14, 10) | 		\
 			_SHIFTL(MAX((uly),0), 2, 10));			\
 }
+#endif
 
 #define	gDPSetConvert(pkt, k0, k1, k2, k3, k4, k5)			\
 {									\
@@ -4620,6 +4669,46 @@ typedef union {
     gImmp1(pkt, G_RDPHALF_2, (_SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16)));	\
     gImmp1(pkt, G_RDPHALF_CONT, (_SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16))); \
 }
+#elif defined(F3DEX_GBI_2E)
+# define gSPTextureRectangle(pkt, xl, yl, xh, yh, tile, s, t, dsdx, dtdy)\
+{                  \
+    Gfx *_g0 = (Gfx *)(pkt), *_g1 = (Gfx *)(pkt), *_g2 = (Gfx *)(pkt); \
+                 \
+    _g0->words.w0 = _SHIFTL(G_TEXRECT, 24, 8) |      \
+          _SHIFTL((xh), 0, 24);        \
+    _g0->words.w1 = _SHIFTL((yh), 0, 24);        \
+    _g1->words.w0 = (_SHIFTL(tile, 24, 3) | _SHIFTL((xl), 0, 24)); \
+    _g1->words.w1 = _SHIFTL((yl), 0, 24);        \
+    _g2->words.w0 = (_SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16));    \
+    _g2->words.w1 = (_SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16));  \
+}
+
+# define gsSPTextureRectangle(xl, yl, xh, yh, tile, s, t, dsdx, dtdy)  \
+{{                 \
+    (_SHIFTL(G_TEXRECT, 24, 8) | _SHIFTL((xh), 0, 24)),      \
+    _SHIFTL((yh), 0, 24),            \
+}},                  \
+{{                 \
+    (_SHIFTL((tile), 24, 3) | _SHIFTL((xl), 0, 24)),     \
+    _SHIFTL((yl), 0, 24),            \
+}},                  \
+{{                 \
+    _SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16),        \
+    _SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16)     \
+}}
+
+# define gSPTextureRectangleFlip(pkt, xl, yl, xh, yh, tile, s, t, dsdx, dtdy) \
+{                  \
+    Gfx *_g0 = (Gfx *)(pkt), *_g1 = (Gfx *)(pkt), *_g2 = (Gfx *)(pkt); \
+                 \
+    _g0->words.w0 = _SHIFTL(G_TEXRECTFLIP, 24, 8) |      \
+          _SHIFTL((xh), 0, 24);        \
+    _g0->words.w1 = _SHIFTL((yh), 0, 24);        \
+    _g1->words.w0 = (_SHIFTL(tile, 24, 3) | _SHIFTL((xl), 0, 24)); \
+    _g1->words.w1 = _SHIFTL((yl), 0, 24);        \
+    _g2->words.w0 = (_SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16));    \
+    _g2->words.w1 = (_SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16));  \
+}
 #else
 # define gSPTextureRectangle(pkt, xl, yl, xh, yh, tile, s, t, dsdx, dtdy)\
 {									\
diff --git a/include/PR/os_cont.h b/include/PR/os_cont.h
index 2754f25..15ee60f 100644
--- a/include/PR/os_cont.h
+++ b/include/PR/os_cont.h
@@ -53,14 +53,14 @@ extern "C" {
 typedef struct {
 	u16     type;                   /* Controller Type */
 	u8      status;                 /* Controller status */
-	u8	errno;
+	u8	errnum;
 }OSContStatus;
 
 typedef struct {
 	u16     button;
 	s8      stick_x;		/* -80 <= stick_x <= 80 */
 	s8      stick_y;		/* -80 <= stick_y <= 80 */
-	u8	errno;
+	u8	errnum;
 } OSContPad;
 
 typedef struct {
@@ -68,7 +68,7 @@ typedef struct {
 	u8      databuffer[32];         /* address of the data buffer */
         u8      addressCrc;             /* CRC code for address */
 	u8      dataCrc;                /* CRC code for data */
-	u8	errno;
+	u8	errnum;
 } OSContRamIo;
 
 
diff --git a/include/PR/ultratypes.h b/include/PR/ultratypes.h
index 1f0d3e0..8a00490 100644
--- a/include/PR/ultratypes.h
+++ b/include/PR/ultratypes.h
@@ -37,6 +37,8 @@ typedef s32 intptr_t;
 typedef s32 ptrdiff_t;
 #else
 #include <stddef.h>
+#include <stdint.h>
+typedef ptrdiff_t ssize_t;
 #endif
 
 #endif
diff --git a/include/config.h b/include/config.h
index 795bed9..8db5c44 100644
--- a/include/config.h
+++ b/include/config.h
@@ -28,6 +28,11 @@
 #define SCREEN_HEIGHT 240
 
 // Border Height Define for NTSC Versions
+#ifdef TARGET_N64
 #define BORDER_HEIGHT 8
+#else
+// What's the point of having a border?
+#define BORDER_HEIGHT 0
+#endif
 
 #endif
diff --git a/include/level_commands.h b/include/level_commands.h
index 2ce2192..214709e 100644
--- a/include/level_commands.h
+++ b/include/level_commands.h
@@ -275,4 +275,10 @@
 #define GET_OR_SET(op, var) \
     CMD_BBBB(0x3C, 0x04, op, var)
 
+#define ADV_DEMO() \
+    CMD_BBH(0x3D, 0x04, 0x0000)
+    
+#define CLEAR_DEMO_PTR() \
+    CMD_BBH(0x3E, 0x04, 0x0000)
+
 #endif
diff --git a/include/level_misc_macros.h b/include/level_misc_macros.h
index 4b8cc8b..4810507 100644
--- a/include/level_misc_macros.h
+++ b/include/level_misc_macros.h
@@ -2,7 +2,7 @@
 #define LEVEL_MISC_MACROS_H
 
 #define MACRO_OBJECT_WITH_BEH_PARAM(preset, yaw, posX, posY, posZ, behParam) \
-    (((yaw * 0x10 / 45) << 9) | (preset + 0x1F)), posX, posY, posZ, behParam
+    ((s16)((yaw * 0x10 / 45) << 9) | (preset + 0x1F)), posX, posY, posZ, behParam
 
 #define MACRO_OBJECT(preset, yaw, posX, posY, posZ) \
     MACRO_OBJECT_WITH_BEH_PARAM(preset, yaw, posX, posY, posZ, 0)
diff --git a/include/macros.h b/include/macros.h
index 87daedd..f927d9e 100644
--- a/include/macros.h
+++ b/include/macros.h
@@ -42,6 +42,7 @@
 #define ALIGNED16
 #endif
 
+#ifdef TARGET_N64
 // convert a virtual address to physical.
 #define VIRTUAL_TO_PHYSICAL(addr)   ((uintptr_t)(addr) & 0x1FFFFFFF)
 
@@ -50,5 +51,11 @@
 
 // another way of converting virtual to physical
 #define VIRTUAL_TO_PHYSICAL2(addr)  ((u8 *)(addr) - 0x80000000U)
+#else
+// no conversion for pc port other than cast
+#define VIRTUAL_TO_PHYSICAL(addr)   ((uintptr_t)(addr))
+#define PHYSICAL_TO_VIRTUAL(addr)   ((uintptr_t)(addr))
+#define VIRTUAL_TO_PHYSICAL2(addr)  ((void *)(addr))
+#endif
 
 #endif
diff --git a/include/segment_symbols.h b/include/segment_symbols.h
index 20d53b7..77adc15 100644
--- a/include/segment_symbols.h
+++ b/include/segment_symbols.h
@@ -1,9 +1,15 @@
 #ifndef SEGMENT_SYMBOLS_H
 #define SEGMENT_SYMBOLS_H
 
+#ifdef TARGET_N64
 #define DECLARE_SEGMENT(name) \
     extern u8 _##name##SegmentRomStart[]; \
     extern u8 _##name##SegmentRomEnd[];
+#else
+#define DECLARE_SEGMENT(name) \
+    static u8 _##name##SegmentRomStart[1]; \
+    static u8 _##name##SegmentRomEnd[1];
+#endif
 
 #define DECLARE_ACTOR_SEGMENT(name) \
     DECLARE_SEGMENT(name##_mio0) \
@@ -37,7 +43,11 @@ DECLARE_ACTOR_SEGMENT(group17)
 DECLARE_SEGMENT(behavior)
 DECLARE_SEGMENT(scripts)
 DECLARE_SEGMENT(goddard)
+#ifdef TARGET_N64
 extern u8 _goddardSegmentStart[];
+#else
+static u8 _goddardSegmentStart[1];
+#endif
 
 DECLARE_LEVEL_SEGMENT(menu)
 DECLARE_LEVEL_SEGMENT(intro)
diff --git a/levels/intro/script.c b/levels/intro/script.c
index 3ffd785..7cbfa59 100644
--- a/levels/intro/script.c
+++ b/levels/intro/script.c
@@ -44,50 +44,34 @@ const LevelScript level_intro_entry_2[] = {
     INIT_LEVEL(),
     BLACKOUT(/*active*/ TRUE),
     FIXED_LOAD(/*loadAddr*/ _goddardSegmentStart, /*romStart*/ _goddardSegmentRomStart, /*romEnd*/ _goddardSegmentRomEnd),
-    LOAD_MARIO_HEAD(/*loadHeadID*/ REGULAR_FACE),
+    //LOAD_MARIO_HEAD(/*loadHeadID*/ REGULAR_FACE),
     LOAD_RAW(/*seg*/ 0x13, _behaviorSegmentRomStart, _behaviorSegmentRomEnd),
     LOAD_MIO0_TEXTURE(/*seg*/ 0x0A, _title_screen_bg_mio0SegmentRomStart, _title_screen_bg_mio0SegmentRomEnd),
     ALLOC_LEVEL_POOL(),
 
-    AREA(/*index*/ 1, intro_geo_00035C),
-    END_AREA(),
+    //AREA(/*index*/ 1, intro_geo_00035C),
+    //END_AREA(),
 
     FREE_LEVEL_POOL(),
     SLEEP(/*frames*/ 2),
     BLACKOUT(/*active*/ FALSE),
-    LOAD_AREA(/*area*/ 1),
+    //LOAD_AREA(/*area*/ 1),
+    CLEAR_DEMO_PTR(), // we need to do this or else file select will be tainted with inputs
+    GET_OR_SET(/*op*/ OP_GET, /*var*/ 5),
+    JUMP_IF(/*op*/ OP_EQ, /*arg*/ 1, script_intro_L1), // was start pressed when demo ended last time?
     SET_MENU_MUSIC(/*seq*/ 0x0002),
     TRANSITION(/*transType*/ WARP_TRANSITION_FADE_FROM_STAR, /*time*/ 20, /*color*/ 0x00, 0x00, 0x00),
     SLEEP(/*frames*/ 20),
-    CALL_LOOP(/*arg*/ 1, /*func*/ LevelProc_8016F508),
-    JUMP_IF(/*op*/ OP_EQ, /*arg*/ 100, script_intro_L1),
-    JUMP_IF(/*op*/ OP_EQ, /*arg*/ 101, script_intro_L2),
-    JUMP(script_intro_L4),
+    //CALL_LOOP(/*arg*/ 1, /*func*/ LevelProc_8016F508),
+    //JUMP_IF(/*op*/ OP_EQ, /*arg*/ 100, script_intro_L1),
+    //JUMP_IF(/*op*/ OP_EQ, /*arg*/ 101, script_intro_L2),
+    //JUMP(script_intro_L4),
+    ADV_DEMO(), // advance the demo ID manually with a new command which sets the level as script register
+    JUMP(script_intro_L4), // go to ingame
 };
 
 const LevelScript level_intro_entry_3[] = {
-    INIT_LEVEL(),
-    BLACKOUT(/*active*/ TRUE),
-    FIXED_LOAD(/*loadAddr*/ _goddardSegmentStart, /*romStart*/ _goddardSegmentRomStart, /*romEnd*/ _goddardSegmentRomEnd),
-    LOAD_MARIO_HEAD(/*loadHeadID*/ DIZZY_FACE),
-    LOAD_RAW(/*seg*/ 0x13, _behaviorSegmentRomStart, _behaviorSegmentRomEnd),
-    LOAD_MIO0_TEXTURE(/*seg*/ 0x0A, _title_screen_bg_mio0SegmentRomStart, _title_screen_bg_mio0SegmentRomEnd),
-    ALLOC_LEVEL_POOL(),
-
-    AREA(/*index*/ 1, intro_geo_0003B8),
-    END_AREA(),
-
-    FREE_LEVEL_POOL(),
-    SLEEP(/*frames*/ 2),
-    BLACKOUT(/*active*/ FALSE),
-    LOAD_AREA(/*area*/ 1),
-    SET_MENU_MUSIC(/*seq*/ 0x0082),
-    TRANSITION(/*transType*/ WARP_TRANSITION_FADE_FROM_STAR, /*time*/ 20, /*color*/ 0x00, 0x00, 0x00),
-    SLEEP(/*frames*/ 20),
-    CALL_LOOP(/*arg*/ 2, /*func*/ LevelProc_8016F508),
-    JUMP_IF(/*op*/ OP_EQ, /*arg*/ 100, script_intro_L1),
-    JUMP_IF(/*op*/ OP_EQ, /*arg*/ 101, script_intro_L2),
-    JUMP(script_intro_L4),
+    JUMP(level_intro_entry_2),
 };
 
 const LevelScript level_intro_entry_4[] = {
diff --git a/levels/menu/script.c b/levels/menu/script.c
index a447975..46cd066 100644
--- a/levels/menu/script.c
+++ b/levels/menu/script.c
@@ -50,7 +50,7 @@ const LevelScript level_main_menu_entry_1[] = {
     GET_OR_SET(/*op*/ OP_SET, /*var*/ VAR_CURR_SAVE_FILE_NUM),
     STOP_MUSIC(/*fadeOutTime*/ 0x00BE),
     TRANSITION(/*transType*/ WARP_TRANSITION_FADE_INTO_COLOR, /*time*/ 16, /*color*/ 0xFF, 0xFF, 0xFF),
-    SLEEP(/*frames*/ 16),
+    SLEEP(/*frames*/ 24),
     CLEAR_LEVEL(),
     SLEEP_BEFORE_EXIT(/*frames*/ 1),
     SET_REG(/*value*/ LEVEL_CASTLE_GROUNDS),
@@ -72,15 +72,24 @@ const LevelScript level_main_menu_entry_2[] = {
 
     /*25*/ FREE_LEVEL_POOL(),
     /*26*/ LOAD_AREA(/*area*/ 2),
+#ifndef TARGET_N64
+           // sVisibleStars is set to 0 during FIXED_LOAD above on N64, but not on PC-port.
+           // lvl_init_act_selector_values_and_stars must be called here otherwise the
+           // previous value is retained and causes incorrect drawing during the 16 transition
+           // frames.
+           CALL(/*arg*/ 0, /*func*/ lvl_init_act_selector_values_and_stars),
+#endif
     /*27*/ TRANSITION(/*transType*/ WARP_TRANSITION_FADE_FROM_COLOR, /*time*/ 16, /*color*/ 0xFF, 0xFF, 0xFF),
     /*29*/ SLEEP(/*frames*/ 16),
     /*30*/ SET_MENU_MUSIC(/*seq*/ 0x000D),
+#ifdef TARGET_N64
     /*31*/ CALL(/*arg*/ 0, /*func*/ lvl_init_act_selector_values_and_stars),
+#endif
     /*33*/ CALL_LOOP(/*arg*/ 0, /*func*/ lvl_update_obj_and_load_act_button_actions),
     /*35*/ GET_OR_SET(/*op*/ OP_SET, /*var*/ VAR_CURR_ACT_NUM),
     /*36*/ STOP_MUSIC(/*fadeOutTime*/ 0x00BE),
     /*37*/ TRANSITION(/*transType*/ WARP_TRANSITION_FADE_INTO_COLOR, /*time*/ 16, /*color*/ 0xFF, 0xFF, 0xFF),
-    /*39*/ SLEEP(/*frames*/ 16),
+    /*39*/ SLEEP(/*frames*/ 24),
     /*40*/ CLEAR_LEVEL(),
     /*41*/ SLEEP_BEFORE_EXIT(/*frames*/ 1),
     // L1:
diff --git a/lib/src/guMtxF2L.c b/lib/src/guMtxF2L.c
index 3b69559..e08528e 100644
--- a/lib/src/guMtxF2L.c
+++ b/lib/src/guMtxF2L.c
@@ -1,5 +1,9 @@
 #include "libultra_internal.h"
+#ifndef TARGET_N64
+#include <string.h>
+#endif
 
+#ifdef TARGET_N64
 void guMtxF2L(float mf[4][4], Mtx *m) {
     int r, c;
     s32 tmp1;
@@ -35,6 +39,11 @@ void guMtxL2F(float mf[4][4], Mtx *m) {
         }
     }
 }
+#else
+void guMtxF2L(float mf[4][4], Mtx *m) {
+    memcpy(m, mf, sizeof(Mtx));
+}
+#endif
 
 void guMtxIdentF(float mf[4][4]) {
     int r, c;
@@ -49,7 +58,11 @@ void guMtxIdentF(float mf[4][4]) {
     }
 }
 void guMtxIdent(Mtx *m) {
+#ifdef TARGET_N64
     float mf[4][4];
     guMtxIdentF(mf);
     guMtxF2L(mf, m);
+#else
+    guMtxIdentF(m->m);
+#endif
 }
diff --git a/lib/src/osContInit.c b/lib/src/osContInit.c
index dce651c..fa26b45 100644
--- a/lib/src/osContInit.c
+++ b/lib/src/osContInit.c
@@ -58,8 +58,8 @@ void __osContGetInitData(u8 *a0, OSContStatus *status) {
     sp14 = &(D_80365CE0[0].request);
     for (i = 0; i < _osCont_numControllers; i++, sp14++, status++) {
         spc = *(OSContPackedRequest *) sp14;
-        status->errno = (spc.unk02 & 0xc0) >> 4;
-        if (status->errno == 0) {
+        status->errnum = (spc.unk02 & 0xc0) >> 4;
+        if (status->errnum == 0) {
             status->type = spc.unk05 << 8 | spc.unk04;
             status->status = spc.unk06;
 
diff --git a/lib/src/osContStartReadData.c b/lib/src/osContStartReadData.c
index 7844c3d..927e80b 100644
--- a/lib/src/osContStartReadData.c
+++ b/lib/src/osContStartReadData.c
@@ -36,8 +36,8 @@ void osContGetReadData(OSContPad *pad) {
     spc = &D_80365CE0[0].read;
     for (i = 0; i < _osCont_numControllers; i++, spc++, pad++) {
         sp4 = *spc;
-        pad->errno = (sp4.unk02 & 0xc0) >> 4;
-        if (pad->errno == 0) {
+        pad->errnum = (sp4.unk02 & 0xc0) >> 4;
+        if (pad->errnum == 0) {
             pad->button = sp4.button;
             pad->stick_x = sp4.rawStickX;
             pad->stick_y = sp4.rawStickY;
diff --git a/src/audio/external.c b/src/audio/external.c
index a195aba..b8bfe19 100644
--- a/src/audio/external.c
+++ b/src/audio/external.c
@@ -525,6 +525,7 @@ static void func_8031D838(s32 player, FadeT fadeInTime, u8 targetVolume) {
     seqPlayer->fadeTimer = fadeInTime;
 }
 
+#ifdef TARGET_N64
 struct SPTask *create_next_audio_frame_task(void) {
     u32 samplesRemainingInAI;
     s32 writtenCmds;
@@ -628,6 +629,22 @@ struct SPTask *create_next_audio_frame_task(void) {
     decrease_sample_dma_ttls();
     return gAudioTask;
 }
+#else
+struct SPTask *create_next_audio_frame_task(void) {
+    return NULL;
+}
+void create_next_audio_buffer(s16 *samples, u32 num_samples) {
+    gAudioFrameCount++;
+    if (sGameLoopTicked != 0) {
+        update_game_sound();
+        sGameLoopTicked = 0;
+    }
+    s32 writtenCmds;
+    synthesis_execute(gAudioCmdBuffers[0], &writtenCmds, samples, num_samples);
+    gAudioRandom = ((gAudioRandom + gAudioFrameCount) * gAudioFrameCount);
+    decrease_sample_dma_ttls();
+}
+#endif
 
 void play_sound(s32 soundBits, f32 *pos) {
     sSoundRequests[sSoundRequestCount].soundBits = soundBits;
diff --git a/src/audio/load.c b/src/audio/load.c
index c67feeb..b03a264 100644
--- a/src/audio/load.c
+++ b/src/audio/load.c
@@ -675,7 +675,7 @@ void audio_init() {
     s32 i, j, k;
     s32 lim1, lim2, lim3;
     u32 size;
-    u64 *ptr64;
+    UNUSED u64 *ptr64;
     void *data;
     UNUSED s32 pad2;
 
@@ -692,6 +692,7 @@ void audio_init() {
         ((u64 *) gAudioHeap)[i] = 0;
     }
 
+#ifndef AVOID_UB
     i = 0;
     lim3 = ((uintptr_t) &gAudioGlobalsEndMarker - (uintptr_t) &gAudioGlobalsStartMarker) / 8;
     ptr64 = &gAudioGlobalsStartMarker - 1;
@@ -699,6 +700,7 @@ void audio_init() {
         i++;
         ptr64[i] = 0;
     }
+#endif
 
     for (i = 0; i < NUMAIBUFFERS; i++) {
         gAiBufferLengths[i] = 0x00a0;
diff --git a/src/audio/memory.c b/src/audio/memory.c
index 73a68af..5728b2e 100644
--- a/src/audio/memory.c
+++ b/src/audio/memory.c
@@ -375,10 +375,12 @@ void decrease_reverb_gain(void) {
  */
 void wait_for_audio_frames(s32 frames) {
     gAudioFrameCount = 0;
+#ifdef TARGET_N64
     // Sound thread will update gAudioFrameCount
     while (gAudioFrameCount < frames) {
         // spin
     }
+#endif
 }
 
 void audio_reset_session(struct AudioSessionSettings *preset) {
diff --git a/src/audio/synthesis.c b/src/audio/synthesis.c
index ec869f8..c207f3b 100644
--- a/src/audio/synthesis.c
+++ b/src/audio/synthesis.c
@@ -8,6 +8,10 @@
 #include "seqplayer.h"
 #include "external.h"
 
+#ifndef TARGET_N64
+#include "../pc/mixer.h"
+#endif
+
 #define DMEM_ADDR_TEMP 0x0
 #define DMEM_ADDR_UNCOMPRESSED_NOTE 0x180
 #define DMEM_ADDR_ADPCM_RESAMPLED 0x20
diff --git a/src/buffers/buffers.c b/src/buffers/buffers.c
index a5a9bb0..ccb00e6 100644
--- a/src/buffers/buffers.c
+++ b/src/buffers/buffers.c
@@ -33,4 +33,4 @@ ALIGNED8 struct SaveBuffer gSaveBuffer;
 ALIGNED8 u8 gGfxSPTaskStack[SP_DRAM_STACK_SIZE8];
 
 // 0x190a0 bytes
-struct GfxPool gGfxPools[2];
+struct GfxPool gGfxPools[GFX_NUM_POOLS];
diff --git a/src/buffers/buffers.h b/src/buffers/buffers.h
index 4196824..3ac0506 100644
--- a/src/buffers/buffers.h
+++ b/src/buffers/buffers.h
@@ -24,6 +24,11 @@ extern struct SaveBuffer gSaveBuffer;
 
 extern u8 gGfxSPTaskStack[];
 
-extern struct GfxPool gGfxPools[2];
+#ifdef TARGET_N64
+#define GFX_NUM_POOLS 2
+#else
+#define GFX_NUM_POOLS 1
+#endif
+extern struct GfxPool gGfxPools[GFX_NUM_POOLS];
 
 #endif
diff --git a/src/engine/level_script.c b/src/engine/level_script.c
index bad25cf..49db58e 100644
--- a/src/engine/level_script.c
+++ b/src/engine/level_script.c
@@ -1,4 +1,7 @@
 #include <ultra64.h>
+#ifndef TARGET_N64
+#include <string.h>
+#endif
 
 #include "sm64.h"
 #include "audio/external.h"
@@ -20,6 +23,8 @@
 #include "math_util.h"
 #include "surface_collision.h"
 #include "surface_load.h"
+#include "game/game.h"
+#include "level_table.h"
 
 #define CMD_SIZE_SHIFT (sizeof(void *) >> 3)
 #define CMD_PROCESS_OFFSET(offset) ((offset & 3) | ((offset & ~3) << CMD_SIZE_SHIFT))
@@ -593,7 +598,17 @@ static void level_cmd_set_gamma(void) {
 
 static void level_cmd_set_terrain_data(void) {
     if (sCurrAreaIndex != -1) {
+#ifdef TARGET_N64
         gAreas[sCurrAreaIndex].terrainData = segmented_to_virtual(CMD_GET(void *, 4));
+#else
+        Collision *data;
+        u32 size;
+
+        data = segmented_to_virtual(CMD_GET(void *, 4));
+        size = get_area_terrain_size(data) * sizeof(Collision);
+        gAreas[sCurrAreaIndex].terrainData = alloc_only_pool_alloc(sLevelPool, size);
+        memcpy(gAreas[sCurrAreaIndex].terrainData, data, size);
+#endif
     }
     sCurrentCmd = CMD_NEXT;
 }
@@ -607,7 +622,17 @@ static void level_cmd_set_rooms(void) {
 
 static void level_cmd_set_macro_objects(void) {
     if (sCurrAreaIndex != -1) {
+#ifdef TARGET_N64
         gAreas[sCurrAreaIndex].macroObjects = segmented_to_virtual(CMD_GET(void *, 4));
+#else
+        MacroObject *data = segmented_to_virtual(CMD_GET(void *, 4));
+        s32 len = 0;
+        while (data[len++] != 0x001E) {
+            len += 4;
+        }
+        gAreas[sCurrAreaIndex].macroObjects = alloc_only_pool_alloc(sLevelPool, len * sizeof(MacroObject));
+        memcpy(gAreas[sCurrAreaIndex].macroObjects, data, len * sizeof(MacroObject));
+#endif
     }
     sCurrentCmd = CMD_NEXT;
 }
@@ -688,6 +713,8 @@ static void level_cmd_38(void) {
     sCurrentCmd = CMD_NEXT;
 }
 
+extern int gPressedStart;
+
 static void level_cmd_get_or_set_var(void) {
     if (CMD_GET(u8, 2) == 0) {
         switch (CMD_GET(u8, 3)) {
@@ -706,6 +733,9 @@ static void level_cmd_get_or_set_var(void) {
             case 4:
                 gCurrAreaIndex = sRegister;
                 break;
+            case 5: 
+                gPressedStart = sRegister; 
+                break;
         }
     } else {
         switch (CMD_GET(u8, 3)) {
@@ -724,12 +754,48 @@ static void level_cmd_get_or_set_var(void) {
             case 4:
                 sRegister = gCurrAreaIndex;
                 break;
+            case 5: 
+                sRegister = gPressedStart; 
+                break;
         }
     }
 
     sCurrentCmd = CMD_NEXT;
 }
 
+int gDemoLevels[7] = {
+    LEVEL_BOWSER_1,
+    LEVEL_WF,
+    LEVEL_CCM,
+    LEVEL_BBH,
+    LEVEL_JRB,
+    LEVEL_HMC,
+    LEVEL_PSS
+};
+
+int gDemoLevelID = 0;
+int gDemoInputListID_2 = 0;
+
+extern void start_demo(int);
+
+static void level_cmd_advdemo(void)
+{
+    start_demo(0);
+    if(gDemoLevelID == 6) {
+        sRegister = gDemoLevels[6];
+        gDemoLevelID = 0;
+    } else {
+        sRegister = gDemoLevels[gDemoLevelID++];
+    }
+    sCurrentCmd = CMD_NEXT;
+}
+
+static void level_cmd_cleardemoptr(void)
+{
+    gCurrDemoInput = NULL;
+    sCurrentCmd = CMD_NEXT;
+}
+
 static void (*LevelScriptJumpTable[])(void) = {
     /*00*/ level_cmd_load_and_execute,
     /*01*/ level_cmd_exit_and_execute,
@@ -792,6 +858,8 @@ static void (*LevelScriptJumpTable[])(void) = {
     /*3A*/ level_cmd_3A,
     /*3B*/ level_cmd_create_whirlpool,
     /*3C*/ level_cmd_get_or_set_var,
+    /*3D*/ level_cmd_advdemo,
+    /*3E*/ level_cmd_cleardemoptr,
 };
 
 struct LevelCommand *level_script_execute(struct LevelCommand *cmd) {
diff --git a/src/engine/surface_load.c b/src/engine/surface_load.c
index 757692b..30d088f 100644
--- a/src/engine/surface_load.c
+++ b/src/engine/surface_load.c
@@ -525,6 +525,57 @@ void alloc_surface_pools(void) {
     reset_red_coins_collected();
 }
 
+#ifndef TARGET_N64
+/**
+ * Get the size of the terrain data, to get the correct size when copying later.
+ */
+u32 get_area_terrain_size(s16 *data) {
+    s16 *startPos = data;
+    s32 end = FALSE;
+    s16 terrainLoadType;
+    s32 numVertices;
+    s32 numRegions;
+    s32 numSurfaces;
+    s16 hasForce;
+
+    while (!end) {
+        terrainLoadType = *data++;
+
+        switch (terrainLoadType) {
+            case TERRAIN_LOAD_VERTICES:
+                numVertices = *data++;
+                data += 3 * numVertices;
+                break;
+
+            case TERRAIN_LOAD_OBJECTS:
+                data += get_special_objects_size(data);
+                break;
+
+            case TERRAIN_LOAD_ENVIRONMENT:
+                numRegions = *data++;
+                data += 6 * numRegions;
+                break;
+
+            case TERRAIN_LOAD_CONTINUE:
+                continue;
+
+            case TERRAIN_LOAD_END:
+                end = TRUE;
+                break;
+
+            default:
+                numSurfaces = *data++;
+                hasForce = surface_has_force(terrainLoadType);
+                data += (3 + hasForce) * numSurfaces;
+                break;
+        }
+    }
+
+    return data - startPos;
+}
+#endif
+
+
 /**
  * Process the level file, loading in vertices, surfaces, some objects, and environmental
  * boxes (water, gas, JRB fog).
diff --git a/src/engine/surface_load.h b/src/engine/surface_load.h
index 9be3686..943317c 100644
--- a/src/engine/surface_load.h
+++ b/src/engine/surface_load.h
@@ -28,6 +28,9 @@ extern struct Surface *sSurfacePool;
 extern s16 sSurfacePoolSize;
 
 void alloc_surface_pools(void);
+#ifndef TARGET_N64
+u32 get_area_terrain_size(s16 *data);
+#endif
 void load_area_terrain(s16 index, s16 *data, s8 *surfaceRooms, s16 *macroObjects);
 void clear_dynamic_surfaces(void);
 void load_object_collision_model(void);
diff --git a/src/game/area.c b/src/game/area.c
index 240605d..1becbd4 100644
--- a/src/game/area.c
+++ b/src/game/area.c
@@ -2,6 +2,7 @@
 
 #include "area.h"
 #include "sm64.h"
+#include "gfx_dimensions.h"
 #include "behavior_data.h"
 #include "game.h"
 #include "display.h"
@@ -20,6 +21,8 @@
 #include "engine/geo_layout.h"
 #include "save_file.h"
 
+#include "gfx_dimensions.h"
+
 struct SpawnInfo gPlayerSpawnInfos[1];
 struct GraphNode *D_8033A160[0x100];
 struct Area gAreaData[8];
@@ -93,6 +96,11 @@ void set_warp_transition_rgb(u8 red, u8 green, u8 blue) {
     gWarpTransBlue = blue;
 }
 
+static int scale_x_to_correct_aspect_center(int x) {
+    f32 aspect = GFX_DIMENSIONS_ASPECT_RATIO;
+    return x + (SCREEN_HEIGHT * aspect / 2) - (SCREEN_WIDTH / 2);
+}
+
 void print_intro_text(void) {
 #ifdef VERSION_EU
     int language = eu_get_language();
@@ -100,9 +108,9 @@ void print_intro_text(void) {
     if ((gGlobalTimer & 0x1F) < 20) {
         if (gControllerBits == 0) {
 #ifdef VERSION_EU
-            print_text_centered(160, 20, gNoControllerMsg[language]);
+            print_text_centered(SCREEN_WIDTH / 2, 20, gNoControllerMsg[language]);
 #else
-            print_text_centered(160, 20, "NO CONTROLLER");
+            print_text_centered(scale_x_to_correct_aspect_center(SCREEN_WIDTH / 2), 20, "NO CONTROLLER");
 #endif
         } else {
 #ifdef VERSION_EU
@@ -115,6 +123,22 @@ void print_intro_text(void) {
     }
 }
 
+void print_intro_text2(void)
+{
+    if (gControllerBits == 0)
+    {
+        print_text_centered(160, 20, "NO CONTROLLER");
+    }
+    else
+    {
+        print_text_centered(160, 164, "SUPER MARIO 64 PC");
+        print_text_centered(160, 128, "ORIGINAL GAME");
+        print_text_centered(160, 110, "BY NINTENDO");
+        print_text_centered(160, 38, "PRESS START");
+        print_text_centered(160, 20, "COPYRIGHT 1996");
+    }
+}
+
 u32 get_mario_spawn_type(struct Object *o) {
     s32 i;
     const BehaviorScript *behavior = virtual_to_segmented(0x13, o->behavior);
diff --git a/src/game/crash_screen.c b/src/game/crash_screen.c
index deea5dc..bef2161 100644
--- a/src/game/crash_screen.c
+++ b/src/game/crash_screen.c
@@ -4,7 +4,7 @@
 
 #include "sm64.h"
 
-#ifdef VERSION_EU
+#if defined(TARGET_N64) && defined(VERSION_EU)
 
 s32 _Printf(char *(*prout)(char *, const char *, size_t), char *dst, const char *fmt, va_list args);
 
diff --git a/src/game/display.c b/src/game/display.c
index a42e20c..849f5d8 100644
--- a/src/game/display.c
+++ b/src/game/display.c
@@ -1,6 +1,7 @@
 #include <ultra64.h>
 
 #include "sm64.h"
+#include "gfx_dimensions.h"
 #include "audio/external.h"
 #include "buffers/buffers.h"
 #include "buffers/gfx_output_buffer.h"
@@ -101,8 +102,9 @@ void clear_frame_buffer(s32 a) {
     gDPSetCycleType(gDisplayListHead++, G_CYC_FILL);
 
     gDPSetFillColor(gDisplayListHead++, a);
-    gDPFillRectangle(gDisplayListHead++, 0, BORDER_HEIGHT, SCREEN_WIDTH - 1,
-                     SCREEN_HEIGHT - 1 - BORDER_HEIGHT);
+    gDPFillRectangle(gDisplayListHead++,
+                     GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(0), BORDER_HEIGHT,
+                     GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(0) - 1, SCREEN_HEIGHT - BORDER_HEIGHT - 1);
 
     gDPPipeSync(gDisplayListHead++);
 
@@ -113,16 +115,21 @@ void clear_frame_buffer(s32 a) {
 void clear_viewport(Vp *viewport, s32 b) {
     s16 vpUlx = (viewport->vp.vtrans[0] - viewport->vp.vscale[0]) / 4 + 1;
     s16 vpUly = (viewport->vp.vtrans[1] - viewport->vp.vscale[1]) / 4 + 1;
-    s16 VpLrx = (viewport->vp.vtrans[0] + viewport->vp.vscale[0]) / 4 - 2;
+    s16 vpLrx = (viewport->vp.vtrans[0] + viewport->vp.vscale[0]) / 4 - 2;
     s16 vpLry = (viewport->vp.vtrans[1] + viewport->vp.vscale[1]) / 4 - 2;
 
+#ifndef TARGET_N64
+    vpUlx = GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(vpUlx);
+    vpLrx = GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(SCREEN_WIDTH - vpLrx);
+#endif
+
     gDPPipeSync(gDisplayListHead++);
 
     gDPSetRenderMode(gDisplayListHead++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
     gDPSetCycleType(gDisplayListHead++, G_CYC_FILL);
 
     gDPSetFillColor(gDisplayListHead++, b);
-    gDPFillRectangle(gDisplayListHead++, vpUlx, vpUly, VpLrx, vpLry);
+    gDPFillRectangle(gDisplayListHead++, vpUlx, vpUly, vpLrx, vpLry);
 
     gDPPipeSync(gDisplayListHead++);
 
@@ -140,9 +147,11 @@ void draw_screen_borders(void) {
     gDPSetFillColor(gDisplayListHead++, GPACK_RGBA5551(0, 0, 0, 0) << 16 | GPACK_RGBA5551(0, 0, 0, 0));
 
 #if BORDER_HEIGHT != 0
-    gDPFillRectangle(gDisplayListHead++, 0, 0, SCREEN_WIDTH - 1, BORDER_HEIGHT - 1);
-    gDPFillRectangle(gDisplayListHead++, 0, SCREEN_HEIGHT - BORDER_HEIGHT, SCREEN_WIDTH - 1,
-                     SCREEN_HEIGHT - 1);
+    gDPFillRectangle(gDisplayListHead++, GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(0), 0,
+                     GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(0) - 1, BORDER_HEIGHT - 1);
+    gDPFillRectangle(gDisplayListHead++,
+                     GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(0), SCREEN_HEIGHT - BORDER_HEIGHT,
+                     GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(0) - 1, SCREEN_HEIGHT - 1);
 #endif
 }
 
@@ -166,11 +175,13 @@ void create_task_structure(void) {
     gGfxSPTask->msgqueue = &D_80339CB8;
     gGfxSPTask->msg = (OSMesg) 2;
     gGfxSPTask->task.t.type = M_GFXTASK;
+#if TARGET_N64
     gGfxSPTask->task.t.ucode_boot = rspF3DBootStart;
     gGfxSPTask->task.t.ucode_boot_size = ((u8 *) rspF3DBootEnd - (u8 *) rspF3DBootStart);
     gGfxSPTask->task.t.flags = 0;
     gGfxSPTask->task.t.ucode = rspF3DStart;
     gGfxSPTask->task.t.ucode_data = rspF3DDataStart;
+#endif
     gGfxSPTask->task.t.ucode_size = SP_UCODE_SIZE; // (this size is ignored)
     gGfxSPTask->task.t.ucode_data_size = SP_UCODE_DATA_SIZE;
     gGfxSPTask->task.t.dram_stack = (u64 *) gGfxSPTaskStack;
@@ -251,7 +262,7 @@ void func_80247ED8(void) {
 }
 
 void func_80247FAC(void) {
-    gGfxPool = &gGfxPools[gGlobalTimer % 2];
+    gGfxPool = &gGfxPools[gGlobalTimer % GFX_NUM_POOLS];
     set_segment_base_addr(1, gGfxPool->buffer);
     gGfxSPTask = &gGfxPool->spTask;
     gDisplayListHead = gGfxPool->buffer;
diff --git a/src/game/game.c b/src/game/game.c
index ad80083..cc512f0 100644
--- a/src/game/game.c
+++ b/src/game/game.c
@@ -290,10 +290,16 @@ void setup_game_memory(void) {
     load_segment_decompress(2, _segment2_mio0SegmentRomStart, _segment2_mio0SegmentRomEnd);
 }
 
+#ifndef TARGET_N64
+static struct LevelCommand *levelCommandAddr;
+#endif
+
 // main game loop thread. runs forever as long as the game
 // continues.
 void thread5_game_loop(UNUSED void *arg) {
-    struct LevelCommand *addr;
+#ifdef TARGET_N64
+    struct LevelCommand *levelCommandAddr;
+#endif
 
     setup_game_memory();
     init_controllers();
@@ -301,18 +307,30 @@ void thread5_game_loop(UNUSED void *arg) {
 
     set_vblank_handler(2, &gGameVblankHandler, &gGameVblankQueue, (OSMesg) 1);
 
-    // point addr to the entry point into the level script data.
-    addr = segmented_to_virtual(level_script_entry);
+    // point levelCommandAddr to the entry point into the level script data.
+    levelCommandAddr = segmented_to_virtual(level_script_entry);
 
     play_music(2, SEQUENCE_ARGS(0, SEQ_SOUND_PLAYER), 0);
     set_sound_mode(save_file_get_sound_mode());
+
+#ifdef TARGET_N64
     func_80247ED8();
 
     while (1) {
+#else
+    gGlobalTimer++;
+}
+
+void game_loop_one_iteration(void) {
+#endif
         // if the reset timer is active, run the process to reset the game.
         if (gResetTimer) {
             func_80247D84();
+#ifdef TARGET_N64
             continue;
+#else
+            return;
+#endif
         }
         profiler_log_thread5_time(THREAD5_START);
 
@@ -325,7 +343,7 @@ void thread5_game_loop(UNUSED void *arg) {
         audio_game_loop_tick();
         func_80247FAC();
         read_controller_inputs();
-        addr = level_script_execute(addr);
+        levelCommandAddr = level_script_execute(levelCommandAddr);
         display_and_vsync();
 
         // when debug info is enabled, print the "BUF %d" information.
@@ -334,5 +352,7 @@ void thread5_game_loop(UNUSED void *arg) {
             // amount of free space remaining.
             print_text_fmt_int(180, 20, "BUF %d", gGfxPoolEnd - (u8 *) gDisplayListHead);
         }
+#ifdef TARGET_N64
     }
+#endif
 }
diff --git a/src/game/geo_misc.c b/src/game/geo_misc.c
index 6d4b3c4..826f1eb 100644
--- a/src/game/geo_misc.c
+++ b/src/game/geo_misc.c
@@ -46,7 +46,11 @@ s8 gFlyingCarpetState;
  *
  * Texture coordinates are s10.5 fixed-point, which means you should left-shift the actual coordinates by 5.
  */
+#ifdef TARGET_N64
 void make_vertex(Vtx *vtx, s32 n, s16 x, s16 y, s16 z, s16 tx, s16 ty, u8 r, u8 g, u8 b, u8 a) {
+#else
+void make_vertex(Vtx *vtx, s32 n, f32 x, f32 y, f32 z, s16 tx, s16 ty, u8 r, u8 g, u8 b, u8 a) {
+#endif
     vtx[n].v.ob[0] = x;
     vtx[n].v.ob[1] = y;
     vtx[n].v.ob[2] = z;
diff --git a/src/game/geo_misc.h b/src/game/geo_misc.h
index d44975b..a62c4d9 100644
--- a/src/game/geo_misc.h
+++ b/src/game/geo_misc.h
@@ -12,9 +12,15 @@ enum FlyingCarpetState
 
 extern s8 gFlyingCarpetState;
 
+#ifdef TARGET_N64
 extern void make_vertex(
     Vtx *vtx, s32 n, s16 x, s16 y, s16 z, s16 tx, s16 ty, u8 r, u8 g, u8 b, u8 a
 );
+#else
+extern void make_vertex(
+    Vtx *vtx, s32 n, f32 x, f32 y, f32 z, s16 tx, s16 ty, u8 r, u8 g, u8 b, u8 a
+);
+#endif
 extern s16 round_float(f32);
 extern Gfx *geo_exec_inside_castle_light(s32 callContext, struct GraphNode *node, f32 mtx[4][4]);
 extern Gfx *geo_exec_flying_carpet_timer_update(s32 callContext, struct GraphNode *node,
diff --git a/src/game/hud.c b/src/game/hud.c
index 7ab1977..b72821d 100644
--- a/src/game/hud.c
+++ b/src/game/hud.c
@@ -1,6 +1,7 @@
 #include <ultra64.h>
 
 #include "sm64.h"
+#include "gfx_dimensions.h"
 #include "display.h"
 #include "game.h"
 #include "level_update.h"
@@ -265,9 +266,9 @@ void render_hud_power_meter(void) {
  * Renders the amount of lives Mario has.
  */
 void render_hud_mario_lives(void) {
-    print_text(22, HUD_TOP_Y, ","); // 'Mario Head' glyph
-    print_text(38, HUD_TOP_Y, "*"); // 'X' glyph
-    print_text_fmt_int(54, HUD_TOP_Y, "%d", gHudDisplay.lives);
+    print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(22), HUD_TOP_Y, ","); // 'Mario Head' glyph
+    print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(38), HUD_TOP_Y, "*"); // 'X' glyph
+    print_text_fmt_int(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(54), HUD_TOP_Y, "%d", gHudDisplay.lives);
 }
 
 /**
@@ -280,9 +281,9 @@ void render_hud_coins(void) {
 }
 
 #ifdef VERSION_JP
-#define HUD_STARS_X 247
+#define HUD_STARS_X 73
 #else
-#define HUD_STARS_X 242
+#define HUD_STARS_X 78
 #endif
 
 /**
@@ -300,11 +301,12 @@ void render_hud_stars(void) {
         showX = 1;
     }
 
-    print_text(HUD_STARS_X, HUD_TOP_Y, "-"); // 'Star' glyph
+    print_text(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(HUD_STARS_X), HUD_TOP_Y, "-"); // 'Star' glyph
     if (showX == 1) {
-        print_text((HUD_STARS_X + 16), HUD_TOP_Y, "*"); // 'X' glyph
+        print_text(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(HUD_STARS_X) + 16, HUD_TOP_Y, "*"); // 'X' glyph
     }
-    print_text_fmt_int(((showX * 14) + (HUD_STARS_X + 16)), HUD_TOP_Y, "%d", gHudDisplay.stars);
+    print_text_fmt_int((showX * 14) + GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(HUD_STARS_X - 16),
+                       HUD_TOP_Y, "%d", gHudDisplay.stars);
 }
 
 /**
@@ -334,13 +336,13 @@ void render_hud_timer(void) {
 #ifdef VERSION_EU
     switch (eu_get_language()) {
         case LANGUAGE_ENGLISH:
-            print_text(170, 185, "TIME");
+            print_text(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(150), 185, "TIME");
             break;
         case LANGUAGE_FRENCH:
-            print_text(165, 185, "TEMPS");
+            print_text(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(155), 185, "TEMPS");
             break;
         case LANGUAGE_GERMAN:
-            print_text(170, 185, "ZEIT");
+            print_text(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(150), 185, "ZEIT");
             break;
     }
 #endif
@@ -349,14 +351,14 @@ void render_hud_timer(void) {
 
     timerFracSecs = ((timerValFrames - (timerMins * 1800) - (timerSecs * 30)) & 0xFFFF) / 3;
 #ifndef VERSION_EU
-    print_text(170, 185, "TIME");
+    print_text(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(150), 185, "TIME");
 #endif
-    print_text_fmt_int(229, 185, "%0d", timerMins);
-    print_text_fmt_int(249, 185, "%02d", timerSecs);
-    print_text_fmt_int(283, 185, "%d", timerFracSecs);
+    print_text_fmt_int(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(91), 185, "%0d", timerMins);
+    print_text_fmt_int(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(71), 185, "%02d", timerSecs);
+    print_text_fmt_int(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(37), 185, "%d", timerFracSecs);
     gSPDisplayList(gDisplayListHead++, dl_hud_img_begin);
-    render_hud_tex_lut(239, 32, (*hudLUT)[GLYPH_APOSTROPHE]);
-    render_hud_tex_lut(274, 32, (*hudLUT)[GLYPH_DOUBLE_QUOTE]);
+    render_hud_tex_lut(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(81), 32, (*hudLUT)[GLYPH_APOSTROPHE]);
+    render_hud_tex_lut(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(46), 32, (*hudLUT)[GLYPH_DOUBLE_QUOTE]);
     gSPDisplayList(gDisplayListHead++, dl_hud_img_end);
 }
 
@@ -378,7 +380,7 @@ void render_hud_camera_status(void) {
     s32 y;
 
     cameraLUT = segmented_to_virtual(&main_hud_camera_lut);
-    x = 266;
+    x = GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(54);
     y = 205;
 
     if (sCameraHUD.status == CAM_STATUS_NONE) {
diff --git a/src/game/ingame_menu.c b/src/game/ingame_menu.c
index 98709f9..14499ab 100644
--- a/src/game/ingame_menu.c
+++ b/src/game/ingame_menu.c
@@ -1,6 +1,7 @@
 #include <ultra64.h>
 
 #include "sm64.h"
+#include "gfx_dimensions.h"
 #include "memory.h"
 #include "types.h"
 #include "audio/external.h"
@@ -126,6 +127,7 @@ void create_dl_identity_matrix(void) {
         return;
     }
 
+#ifdef TARGET_N64
     matrix->m[0][0] = 0x00010000;
     matrix->m[1][0] = 0x00000000;
     matrix->m[2][0] = 0x00000000;
@@ -145,6 +147,9 @@ void create_dl_identity_matrix(void) {
     matrix->m[1][3] = 0x00000001;
     matrix->m[2][3] = 0x00000000;
     matrix->m[3][3] = 0x00000000;
+#else
+    guMtxIdent(matrix);
+#endif
 
     gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(matrix), G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);
     gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(matrix), G_MTX_PROJECTION | G_MTX_LOAD | G_MTX_NOPUSH);
@@ -1815,13 +1820,26 @@ void render_dialog_entries(void) {
 
     render_dialog_box_type(dialog, dialog->linesPerBox);
 
-    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, ensure_nonnegative(dialog->leftOffset),
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE,
+#ifdef TARGET_N64
+                  ensure_nonnegative(dialog->leftOffset),
+#else
+                  0,
+#endif
                   ensure_nonnegative(DIAG_VAL2 - dialog->width),
 #ifdef VERSION_EU
+#ifdef TARGET_N64
                   ensure_nonnegative(dialog->leftOffset + DIAG_VAL3 / gDialogBoxScale),
+#else
+                  SCREEN_WIDTH,
+#endif
                   ensure_nonnegative((240 - dialog->width) + ((dialog->linesPerBox * 80) / DIAG_VAL4) / gDialogBoxScale));
 #else
+#ifdef TARGET_N64
                   ensure_nonnegative(DIAG_VAL3 + dialog->leftOffset),
+#else
+                  SCREEN_WIDTH,
+#endif
                   ensure_nonnegative(240 + ((dialog->linesPerBox * 80) / DIAG_VAL4) - dialog->width));
 #endif
 #ifdef VERSION_JP
@@ -2120,8 +2138,17 @@ void change_dialog_camera_angle(void) {
 }
 
 void shade_screen(void) {
-    create_dl_translation_matrix(MENU_MTX_PUSH, 0, 240.0f, 0);
+    create_dl_translation_matrix(MENU_MTX_PUSH, GFX_DIMENSIONS_FROM_LEFT_EDGE(0), 240.0f, 0);
+
+    // This is a bit weird. It reuses the dialog text box (width 130, height -80),
+    // so scale to at least fit the screen.
+#ifdef TARGET_N64
     create_dl_scale_matrix(MENU_MTX_NOPUSH, 2.6f, 3.4f, 1.0f);
+#else
+    create_dl_scale_matrix(MENU_MTX_NOPUSH,
+                           GFX_DIMENSIONS_ASPECT_RATIO * SCREEN_HEIGHT / 130.0f, 3.0f, 1.0f);
+#endif
+
     gDPSetEnvColor(gDisplayListHead++, 0, 0, 0, 110);
     gSPDisplayList(gDisplayListHead++, dl_draw_text_bg_box);
     gSPPopMatrix(gDisplayListHead++, G_MTX_MODELVIEW);
@@ -2157,7 +2184,7 @@ void render_pause_red_coins(void) {
     s8 x;
 
     for (x = 0; x < gRedCoinsCollected; x++) {
-        print_animated_red_coin(290 - x * 20, 16);
+        print_animated_red_coin(GFX_DIMENSIONS_FROM_RIGHT_EDGE(30) - x * 20, 16);
     }
 }
 
@@ -2449,7 +2476,8 @@ void print_hud_pause_colorful_str(void) {
     gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, gDialogTextAlpha);
 
 #ifdef VERSION_EU
-    print_hud_lut_string(HUD_LUT_GLOBAL, get_str_x_pos_from_center_scale(160, textPause, 12.0f), 81, textPause);
+    print_hud_lut_string(HUD_LUT_GLOBAL, get_str_x_pos_from_center_scale(
+                         SCREEN_WIDTH / 2, textPause, 12.0f), 81, textPause);
 #else
     print_hud_lut_string(HUD_LUT_GLOBAL, 123, 81, textPause);
 #endif
diff --git a/src/game/level_update.c b/src/game/level_update.c
index 179b3e2..8fbb7c2 100644
--- a/src/game/level_update.c
+++ b/src/game/level_update.c
@@ -937,14 +937,18 @@ void basic_update(UNUSED s16 *arg) {
     }
 }
 
+extern void print_intro_text2(void);
+int gPressedStart = 0;
+
 s32 play_mode_normal(void) {
     if (gCurrDemoInput != NULL) {
-        print_intro_text();
+        print_intro_text2();
         if (gPlayer1Controller->buttonPressed & END_DEMO) {
             level_trigger_warp(gMarioState,
                                gCurrLevelNum == LEVEL_PSS ? WARP_OP_DEMO_END : WARP_OP_DEMO_NEXT);
         } else if (!gWarpTransition.isActive && sDelayedWarpOp == WARP_OP_NONE
                    && (gPlayer1Controller->buttonPressed & START_BUTTON)) {
+            gPressedStart = 1;
             level_trigger_warp(gMarioState, WARP_OP_DEMO_NEXT);
         }
     }
diff --git a/src/game/macro_special_objects.c b/src/game/macro_special_objects.c
index fca73cf..6972676 100644
--- a/src/game/macro_special_objects.c
+++ b/src/game/macro_special_objects.c
@@ -327,3 +327,49 @@ void spawn_special_objects(s16 areaIndex, s16 **specialObjList) {
         }
     }
 }
+
+#ifndef TARGET_N64
+u32 get_special_objects_size(s16 *data) {
+    s16 *startPos = data;
+    s32 numOfSpecialObjects;
+    s32 i;
+    u8 presetID;
+    s32 offset;
+
+    numOfSpecialObjects = *data++;
+
+    for (i = 0; i < numOfSpecialObjects; i++) {
+        presetID = (u8) *data++;
+        data += 3;
+        offset = 0;
+
+        while (TRUE) {
+            if (SpecialObjectPresets[offset].preset_id == presetID) {
+                break;
+            }
+            offset++;
+        }
+
+        switch (SpecialObjectPresets[offset].type) {
+            case SPTYPE_NO_YROT_OR_PARAMS:
+                break;
+            case SPTYPE_YROT_NO_PARAMS:
+                data++;
+                break;
+            case SPTYPE_PARAMS_AND_YROT:
+                data += 2;
+                break;
+            case SPTYPE_UNKNOWN:
+                data += 3;
+                break;
+            case SPTYPE_DEF_PARAM_AND_YROT:
+                data++;
+                break;
+            default:
+                break;
+        }
+    }
+
+    return data - startPos;
+}
+#endif
diff --git a/src/game/macro_special_objects.h b/src/game/macro_special_objects.h
index bacc842..33fee18 100644
--- a/src/game/macro_special_objects.h
+++ b/src/game/macro_special_objects.h
@@ -16,5 +16,8 @@ extern void spawn_macro_abs_special(u32 model, const BehaviorScript *behavior, s
 extern void spawn_macro_objects(s16 areaIndex, s16 * macroObjList);
 extern void spawn_macro_objects_hardcoded(s16 areaIndex, s16 * macroObjList);
 extern void spawn_special_objects(s16 areaIndex, s16 ** specialObjList);
+#ifndef TARGET_N64
+extern u32 get_special_objects_size(s16 *data);
+#endif
 
 #endif /* MACRO_SPECIAL_OBJECTS_H */
diff --git a/src/game/mario_actions_cutscene.c b/src/game/mario_actions_cutscene.c
index 0e54f94..6f12575 100644
--- a/src/game/mario_actions_cutscene.c
+++ b/src/game/mario_actions_cutscene.c
@@ -1,6 +1,7 @@
 #include <ultra64.h>
 
 #include "sm64.h"
+#include "gfx_dimensions.h"
 #include "game.h"
 #include "sound_init.h"
 #include "level_update.h"
@@ -100,6 +101,10 @@ s32 get_credits_str_width(char *str) {
     return length;
 }
 
+#define CREDIT_TEXT_MARGIN_X ((s32)(GFX_DIMENSIONS_ASPECT_RATIO * 21))
+#define CREDIT_TEXT_X_LEFT GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(CREDIT_TEXT_MARGIN_X)
+#define CREDIT_TEXT_X_RIGHT GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(CREDIT_TEXT_MARGIN_X)
+
 /**
  * print_displaying_credits_entry: Print the current displaying Credits Entry
  * Called in render_game. This function checks if sDispCreditsEntry points to a
@@ -134,27 +139,27 @@ void print_displaying_credits_entry(void) {
 #endif
 
         dl_rgba16_begin_cutscene_msg_fade();
-        print_credits_str_ascii(28, strY, titleStr);
+        print_credits_str_ascii(CREDIT_TEXT_X_LEFT, strY, titleStr);
 
 #ifndef VERSION_JP
         switch (numLines) {
             case 4:
-                print_credits_str_ascii(28, strY + 24, *currStrPtr++);
+                print_credits_str_ascii(CREDIT_TEXT_X_LEFT, strY + 24, *currStrPtr++);
                 numLines = 2;
                 lineHeight = 24;
                 break;
             case 5:
-                print_credits_str_ascii(28, strY + 16, *currStrPtr++);
+                print_credits_str_ascii(CREDIT_TEXT_X_LEFT, strY + 16, *currStrPtr++);
                 numLines = 3;
                 break;
 #ifdef VERSION_EU
             case 6:
-                print_credits_str_ascii(28, strY + 32, *currStrPtr++);
+                print_credits_str_ascii(CREDIT_TEXT_X_LEFT, strY + 32, *currStrPtr++);
                 numLines = 3;
                 break;
             case 7:
-                print_credits_str_ascii(28, strY + 16, *currStrPtr++);
-                print_credits_str_ascii(28, strY + 32, *currStrPtr++);
+                print_credits_str_ascii(CREDIT_TEXT_X_LEFT, strY + 16, *currStrPtr++);
+                print_credits_str_ascii(CREDIT_TEXT_X_LEFT, strY + 32, *currStrPtr++);
                 numLines = 3;
                 break;
 #endif
@@ -164,7 +169,7 @@ void print_displaying_credits_entry(void) {
         // smart dev here, thinking ahead for when the cosmic ray hits the rdram
         // chips 23 years later and nearly causes upwarp 2
         while (numLines-- > 0) {
-            print_credits_str_ascii((320 - 28) - get_credits_str_width(*currStrPtr), strY, *currStrPtr);
+            print_credits_str_ascii(CREDIT_TEXT_X_RIGHT - get_credits_str_width(*currStrPtr), strY, *currStrPtr);
 
 #ifdef VERSION_JP
             strY += 16;
diff --git a/src/game/memory.c b/src/game/memory.c
index b287d09..6454edc 100644
--- a/src/game/memory.c
+++ b/src/game/memory.c
@@ -1,4 +1,7 @@
 #include <ultra64.h>
+#ifndef TARGET_N64
+#include <string.h>
+#endif
 
 #include "sm64.h"
 
@@ -67,6 +70,7 @@ void *get_segment_base_addr(s32 segment) {
     return (void *) (sSegmentTable[segment] | 0x80000000);
 }
 
+#ifdef TARGET_N64
 void *segmented_to_virtual(const void *addr) {
     size_t segment = (uintptr_t) addr >> 24;
     size_t offset = (uintptr_t) addr & 0x00FFFFFF;
@@ -86,6 +90,18 @@ void move_segment_table_to_dmem(void) {
     for (i = 0; i < 16; i++)
         gMoveWd(gDisplayListHead++, 6, i * 4, sSegmentTable[i]);
 }
+#else
+void *segmented_to_virtual(const void *addr) {
+    return (void *) addr;
+}
+
+void *virtual_to_segmented(u32 segment, const void *addr) {
+    return (void *) addr;
+}
+
+void move_segment_table_to_dmem(void) {
+}
+#endif
 
 /**
  * Initialize the main memory pool. This pool is conceptually a pair of stacks
@@ -224,7 +240,7 @@ u32 main_pool_pop_state(void) {
  */
 static void dma_read(u8 *dest, u8 *srcStart, u8 *srcEnd) {
     u32 size = ALIGN16(srcEnd - srcStart);
-
+#ifdef TARGET_N64
     osInvalDCache(dest, size);
     while (size != 0) {
         u32 copySize = (size >= 0x1000) ? 0x1000 : size;
@@ -237,6 +253,9 @@ static void dma_read(u8 *dest, u8 *srcStart, u8 *srcEnd) {
         srcStart += copySize;
         size -= copySize;
     }
+#else
+    memcpy(dest, srcStart, srcEnd - srcStart);
+#endif
 }
 
 /**
@@ -254,6 +273,7 @@ static void *dynamic_dma_read(u8 *srcStart, u8 *srcEnd, u32 side) {
     return dest;
 }
 
+#ifdef TARGET_N64
 /**
  * Load data from ROM into a newly allocated block, and set the segment base
  * address to this block.
@@ -348,6 +368,7 @@ void load_engine_code_segment(void) {
     osInvalICache(startAddr, totalSize);
     osInvalDCache(startAddr, totalSize);
 }
+#endif
 
 /**
  * Allocate an allocation-only pool from the main pool. This pool doesn't
diff --git a/src/game/memory.h b/src/game/memory.h
index d47d247..934d4ef 100644
--- a/src/game/memory.h
+++ b/src/game/memory.h
@@ -37,11 +37,19 @@ u32 main_pool_available(void);
 u32 main_pool_push_state(void);
 u32 main_pool_pop_state(void);
 
+#ifdef TARGET_N64
 void *load_segment(s32 segment, u8 *srcStart, u8 *srcEnd, u32 side);
 void *load_to_fixed_pool_addr(u8 *destAddr, u8 *srcStart, u8 *srcEnd);
 void *load_segment_decompress(s32 segment, u8 *srcStart, u8 *srcEnd);
 void *func_80278304(u32 segment, u8 *srcStart, u8 *srcEnd);
 void load_engine_code_segment(void);
+#else
+#define load_segment(...)
+#define load_to_fixed_pool_addr(...)
+#define load_segment_decompress(...)
+#define func_80278304(...)
+#define load_engine_code_segment(...)
+#endif
 
 struct AllocOnlyPool *alloc_only_pool_init(u32 size, u32 side);
 void *alloc_only_pool_alloc(struct AllocOnlyPool *pool, s32 size);
diff --git a/src/game/paintings.c b/src/game/paintings.c
index de350ea..900a87d 100644
--- a/src/game/paintings.c
+++ b/src/game/paintings.c
@@ -780,6 +780,24 @@ void reset_painting(struct Painting *painting) {
     painting->currMarioUnderPainting = 0;
     painting->marioNewlyUnderPainting = 0;
     ripplingPainting = NULL;
+#ifndef TARGET_N64
+    // Make sure all variables are reset correctly.
+    // On N64 the segments that contain the relevant
+    // Painting structs are reloaded from ROM upon level load.
+    painting->rippleStatus = RIPPLE_STATE_NONE;
+    painting->currRippleMag = 0.0f;
+    painting->rippleMagMultiplier = 1.0f;
+    painting->currRippleRate = 0.0f;
+    painting->dispersionFactor = 0.0f;
+    painting->rippleTimer = 0.0f;
+    painting->horizontalRippleSpot = 0.0f;
+    painting->verticalRippleSpot = 0.0f;
+    if (painting == &ddd_painting) {
+        // Move DDD painting to initial position, in case the animation
+        // that moves the painting stops during level unload.
+        painting->vXPos = 3456.0f;
+    }
+#endif
 }
 
 void update_ddd_painting(struct Painting *painting, float frontPos, float backPos,
diff --git a/src/game/print.c b/src/game/print.c
index 6249691..0920b57 100644
--- a/src/game/print.c
+++ b/src/game/print.c
@@ -1,6 +1,7 @@
 #include <ultra64.h>
 
 #include "sm64.h"
+#include "gfx_dimensions.h"
 #include "game.h"
 #include "mario.h"
 #include "memory.h"
@@ -27,7 +28,7 @@ struct TextLabel {
  * Stores the text to be rendered on screen
  * and how they are to be rendered.
  */
-struct TextLabel *sTextLabels[52];
+struct TextLabel *sTextLabels[256];
 s16 sTextLabelsCount = 0;
 
 /**
@@ -369,6 +370,7 @@ void add_glyph_texture(s8 glyphIndex) {
     gSPDisplayList(gDisplayListHead++, dl_hud_img_load_tex_block);
 }
 
+#ifdef TARGET_N64
 /**
  * Clips textrect into the boundaries defined.
  */
@@ -389,6 +391,7 @@ void clip_to_bounds(s32 *x, s32 *y) {
         *y = TEXRECT_MAX_Y;
     }
 }
+#endif
 
 /**
  * Renders the glyph that's set at the given position.
@@ -399,7 +402,9 @@ void render_textrect(s32 x, s32 y, s32 pos) {
     s32 rectX;
     s32 rectY;
 
+#ifdef TARGET_N64
     clip_to_bounds(&rectBaseX, &rectBaseY);
+#endif
     rectX = rectBaseX;
     rectY = rectBaseY;
     gSPTextureRectangle(gDisplayListHead++, rectX << 2, rectY << 2, (rectX + 15) << 2,
diff --git a/src/game/rendering_graph_node.c b/src/game/rendering_graph_node.c
index 01ba06c..bf61908 100644
--- a/src/game/rendering_graph_node.c
+++ b/src/game/rendering_graph_node.c
@@ -1,6 +1,7 @@
 #include <ultra64.h>
 
 #include "sm64.h"
+#include "gfx_dimensions.h"
 #include "main.h"
 #include "display.h"
 #include "print.h"
@@ -506,13 +507,18 @@ static void geo_process_background(struct GraphNodeBackground *node) {
     if (list != 0) {
         geo_append_display_list((void *) VIRTUAL_TO_PHYSICAL(list), node->fnNode.node.flags >> 8);
     } else if (gCurGraphNodeMasterList != NULL) {
+#ifdef TARGET_N64
         Gfx *gfxStart = alloc_display_list(sizeof(Gfx) * 7);
+#else
+        Gfx *gfxStart = alloc_display_list(sizeof(Gfx) * 8);
+#endif
         Gfx *gfx = gfxStart;
 
         gDPPipeSync(gfx++);
         gDPSetCycleType(gfx++, G_CYC_FILL);
         gDPSetFillColor(gfx++, node->background);
-        gDPFillRectangle(gfx++, 0, BORDER_HEIGHT, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1 - BORDER_HEIGHT);
+        gDPFillRectangle(gfx++, GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(0), BORDER_HEIGHT,
+        GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(0) - 1, SCREEN_HEIGHT - BORDER_HEIGHT - 1);
         gDPPipeSync(gfx++);
         gDPSetCycleType(gfx++, G_CYC_1CYCLE);
         gSPEndDisplayList(gfx++);
@@ -752,6 +758,10 @@ static int obj_is_in_view(struct GraphNodeObject *node, Mat4 matrix) {
     // the amount of units between the center of the screen and the horizontal edge
     // given the distance from the object to the camera.
 
+#ifndef TARGET_N64
+    hScreenEdge *= GFX_DIMENSIONS_ASPECT_RATIO;
+#endif
+
     if (geo != NULL && geo->type == GRAPH_NODE_TYPE_CULLING_RADIUS) {
         cullingRadius =
             (f32)((struct GraphNodeCullingRadius *) geo)->cullingRadius; //! Why is there a f32 cast?
diff --git a/src/game/screen_transition.c b/src/game/screen_transition.c
index 5fc9e63..3f091c5 100644
--- a/src/game/screen_transition.c
+++ b/src/game/screen_transition.c
@@ -1,6 +1,7 @@
 #include <ultra64.h>
 
 #include "sm64.h"
+#include "gfx_dimensions.h"
 #include "area.h"
 #include "game.h"
 #include "engine/math_util.h"
@@ -48,10 +49,10 @@ Vtx *vertex_transition_color(struct WarpTransitionData *transData, u8 alpha) {
     u8 b = transData->blue;
 
     if (verts != NULL) {
-        make_vertex(verts, 0, 0, 0, -1, 0, 0, r, g, b, alpha);
-        make_vertex(verts, 1, SCREEN_WIDTH, 0, -1, 0, 0, r, g, b, alpha);
-        make_vertex(verts, 2, SCREEN_WIDTH, SCREEN_HEIGHT, -1, 0, 0, r, g, b, alpha);
-        make_vertex(verts, 3, 0, SCREEN_HEIGHT, -1, 0, 0, r, g, b, alpha);
+        make_vertex(verts, 0, GFX_DIMENSIONS_FROM_LEFT_EDGE(0), 0, -1, 0, 0, r, g, b, alpha);
+        make_vertex(verts, 1, GFX_DIMENSIONS_FROM_RIGHT_EDGE(0), 0, -1, 0, 0, r, g, b, alpha);
+        make_vertex(verts, 2, GFX_DIMENSIONS_FROM_RIGHT_EDGE(0), SCREEN_HEIGHT, -1, 0, 0, r, g, b, alpha);
+        make_vertex(verts, 3, GFX_DIMENSIONS_FROM_LEFT_EDGE(0), SCREEN_HEIGHT, -1, 0, 0, r, g, b, alpha);
     } else {
     }
     return verts;
@@ -183,7 +184,7 @@ s32 render_textured_transition(s8 fadeTimer, s8 transTime, struct WarpTransition
         gDPSetCombineMode(gDisplayListHead++, G_CC_MODULATEIDECALA, G_CC_MODULATEIDECALA);
         gDPSetRenderMode(gDisplayListHead++, G_RM_AA_XLU_SURF, G_RM_AA_XLU_SURF2);
         gDPSetTextureFilter(gDisplayListHead++, G_TF_BILERP); 
-    switch (transTexType) {
+        switch (transTexType) {
         case TRANS_TYPE_MIRROR:
             gDPLoadTextureBlock(gDisplayListHead++, sTextureTransitionID[texID], G_IM_FMT_IA, G_IM_SIZ_8b, 32, 64, 0,
                 G_TX_WRAP | G_TX_MIRROR, G_TX_WRAP | G_TX_MIRROR, 5, 6, G_TX_NOLOD, G_TX_NOLOD);
@@ -240,8 +241,13 @@ int render_screen_transition(s8 fadeTimer, s8 transType, u8 transTime, struct Wa
 }
 
 Gfx *render_cannon_circle_base(void) {
+#ifdef TARGET_N64
     Vtx *verts = alloc_display_list(4 * sizeof(*verts));
     Gfx *dlist = alloc_display_list(16 * sizeof(*dlist));
+#else
+    Vtx *verts = alloc_display_list(8 * sizeof(*verts));
+    Gfx *dlist = alloc_display_list(20 * sizeof(*dlist));
+#endif
     Gfx *g = dlist;
 
     if (verts != NULL && dlist != NULL) {
@@ -250,6 +256,13 @@ Gfx *render_cannon_circle_base(void) {
         make_vertex(verts, 2, SCREEN_WIDTH, SCREEN_HEIGHT, -1, 1152, 192, 0, 0, 0, 255);
         make_vertex(verts, 3, 0, SCREEN_HEIGHT, -1, -1152, 192, 0, 0, 0, 255);
 
+#ifndef TARGET_N64
+        make_vertex(verts, 4, GFX_DIMENSIONS_FROM_LEFT_EDGE(0), 0, -1, 0, 0, 0, 0, 0, 255);
+        make_vertex(verts, 5, GFX_DIMENSIONS_FROM_RIGHT_EDGE(0), 0, -1, 0, 0, 0, 0, 0, 255);
+        make_vertex(verts, 6, GFX_DIMENSIONS_FROM_RIGHT_EDGE(0), SCREEN_HEIGHT, -1, 0, 0, 0, 0, 0, 255);
+        make_vertex(verts, 7, GFX_DIMENSIONS_FROM_LEFT_EDGE(0), SCREEN_HEIGHT, -1, 0, 0, 0, 0, 0, 255);
+#endif
+
         gSPDisplayList(g++, dl_proj_mtx_fullscreen);
         gDPSetCombineMode(g++, G_CC_MODULATEIDECALA, G_CC_MODULATEIDECALA);
         gDPSetTextureFilter(g++, G_TF_BILERP);
@@ -259,6 +272,12 @@ Gfx *render_cannon_circle_base(void) {
         gSPVertex(g++, VIRTUAL_TO_PHYSICAL(verts), 4, 0);
         gSPDisplayList(g++, dl_draw_quad_verts_0123);
         gSPTexture(g++, 0xFFFF, 0xFFFF, 0, G_TX_RENDERTILE, G_OFF);
+#ifndef TARGET_N64
+        gDPSetCombineMode(g++, G_CC_SHADE, G_CC_SHADE);
+        gSPVertex(g++, VIRTUAL_TO_PHYSICAL(verts + 4), 4, 4);
+        gSP2Triangles(g++, 4, 0, 3, 0, 4, 3, 7, 0);
+        gSP2Triangles(g++, 1, 5, 6, 0, 1, 6, 2, 0);
+#endif
         gSPDisplayList(g++, dl_screen_transition_end);
         gSPEndDisplayList(g);
     } else {
diff --git a/src/game/skybox.c b/src/game/skybox.c
index 4f48665..f11c170 100644
--- a/src/game/skybox.c
+++ b/src/game/skybox.c
@@ -1,6 +1,7 @@
 #include <ultra64.h>
 
 #include "sm64.h"
+#include "gfx_dimensions.h"
 #include "engine/math_util.h"
 #include "memory.h"
 #include "area.h"
@@ -246,6 +247,16 @@ void *create_skybox_ortho_matrix(s8 player) {
     f32 top = sSkyBoxInfo[player].scaledY;
     Mtx *mtx = alloc_display_list(sizeof(*mtx));
 
+#ifndef TARGET_N64
+    f32 half_width = (4.0f / 3.0f) / GFX_DIMENSIONS_ASPECT_RATIO * SCREEN_WIDTH / 2;
+    f32 center = (sSkyBoxInfo[player].scaledX + SCREEN_WIDTH / 2);
+    if (half_width < SCREEN_WIDTH / 2) {
+        // A wider screen than 4:3
+        left = center - half_width;
+        right = center + half_width;
+    }
+#endif
+
     if (mtx != NULL) {
         guOrtho(mtx, left, right, bottom, top, 0.0f, 3.0f, 1.0f);
     } else {
@@ -258,7 +269,7 @@ void *create_skybox_ortho_matrix(s8 player) {
  * Creates the skybox's display list, then draws the 3x3 grid of tiles.
  */
 Gfx *init_skybox_display_list(s8 player, s8 background, s8 colorIndex) {
-    s32 dlCommandCount = 5 + 9 * 7; // 5 for the start and end, plus 9 skybox tiles
+    s32 dlCommandCount = 5 + (3 * 3) * 7; // 5 for the start and end, plus 9 skybox tiles
     void *skybox = alloc_display_list(dlCommandCount * sizeof(Gfx));
     Gfx *dlist = skybox;
 
diff --git a/src/goddard/debug_utils.c b/src/goddard/debug_utils.c
index 61a0992..6bd0764 100644
--- a/src/goddard/debug_utils.c
+++ b/src/goddard/debug_utils.c
@@ -124,6 +124,10 @@ void remove_all_memtrackers(void) {
         sMemTrackers[i].end = 0.0f;
         sMemTrackers[i].total = 0.0f;
     }
+
+#ifdef AVOID_UB
+    sNumActiveMemTrackers = 0;
+#endif
 }
 
 /* 23AE20 -> 23AE44; orig name: func_8018C650 */
diff --git a/src/goddard/draw_objects.c b/src/goddard/draw_objects.c
index d39f51e..be7624a 100644
--- a/src/goddard/draw_objects.c
+++ b/src/goddard/draw_objects.c
@@ -15,6 +15,8 @@
 #include "prevent_bss_reordering.h"
 #include "draw_objects.h"
 
+#include "gfx_dimensions.h"
+
 /**
  * @file draw_objects.c
  * This file contains the functions and helpers for rendering the various
@@ -694,14 +696,17 @@ void func_80179B64(struct ObjGroup *group) {
                                 (applyproc_t) Unknown80179ACC, group);
 }
 
-/* 22836C -> 228498 */
-void func_80179B9C(struct GdVec3f *pos, struct ObjCamera *cam, struct ObjView *view) {
+// plc again
+void func_80179B9C(struct GdVec3f *pos, struct ObjCamera *cam, struct ObjView *view)
+{
+    f32 aspect = GFX_DIMENSIONS_ASPECT_RATIO;
+    aspect *= 0.75;
     func_80196430(pos, &cam->unkE8);
     if (pos->z > -256.0f) {
         return;
     }
-
-    pos->x *= 256.0 / -pos->z;
+    
+    pos->x *= 256.0 / -pos->z / aspect;
     pos->y *= 256.0 / pos->z;
     pos->x += view->lowerRight.x / 2.0f;
     pos->y += view->lowerRight.y / 2.0f;
diff --git a/src/goddard/renderer.c b/src/goddard/renderer.c
index 6e60445..60debc7 100644
--- a/src/goddard/renderer.c
+++ b/src/goddard/renderer.c
@@ -20,12 +20,20 @@
 #include "gd_math.h"
 #include "shape_helper.h"
 
+#include "gfx_dimensions.h"
+
 #define MAX_GD_DLS 1000
 #define OS_MESG_SI_COMPLETE 0x33333333
 
+#ifdef TARGET_N64
 #define GD_VIRTUAL_TO_PHYSICAL(addr) ((uintptr_t)(addr) &0x0FFFFFFF)
 #define GD_LOWER_24(addr) ((uintptr_t)(addr) &0x00FFFFFF)
 #define GD_LOWER_29(addr) (((uintptr_t)(addr)) & 0x1FFFFFFF)
+#else
+#define GD_VIRTUAL_TO_PHYSICAL(addr) (addr)
+#define GD_LOWER_24(addr) ((uintptr_t)(addr))
+#define GD_LOWER_29(addr) (((uintptr_t)(addr)))
+#endif
 
 #define MTX_INTPART_PACK(w1, w2) (((w1) &0xFFFF0000) | (((w2) >> 16) & 0xFFFF))
 #define MTX_FRACPART_PACK(w1, w2) ((((w1) << 16) & 0xFFFF0000) | ((w2) &0xFFFF))
@@ -1660,6 +1668,7 @@ u32 Unknown8019EC88(Gfx *dl, UNUSED s32 arg1) {
 
 /* 24D4C4 -> 24D63C; orig name: func_8019ECF4 */
 void mat4_to_mtx(const Mat4f *src, Mtx *dst) {
+#ifdef TARGET_N64
     s32 i; // 14
     s32 j; // 10
     s32 w1;
@@ -1677,6 +1686,9 @@ void mat4_to_mtx(const Mat4f *src, Mtx *dst) {
             mtxFrc++;
         }
     }
+#else
+    guMtxF2L(src, dst);
+#endif
 }
 
 /* 24D63C -> 24D6E4; orig name: func_8019EE6C */
@@ -2310,7 +2322,9 @@ void parse_p1_controller(void) {
     OSContPad *p1contPrev;    // 30
     u8 *gdCtrlBytes;          // 2C
     u8 *prevGdCtrlBytes;      // 28
-
+    f32 aspect = GFX_DIMENSIONS_ASPECT_RATIO;
+    aspect *= 0.75;
+ 
     gdctrl = &gGdCtrl;
     gdCtrlBytes = (u8 *) gdctrl;
     prevGdCtrlBytes = (u8 *) gdctrl->prevFrame;
@@ -2407,14 +2421,14 @@ void parse_p1_controller(void) {
         gdctrl->csrY -= gdctrl->stickY * 0.1; //? 0.1f
     }
     // border checks? is this for the cursor finger movement?
-    if ((f32) gdctrl->csrX < (sScreenView2->parent->upperLeft.x + 16.0f)) {
-        gdctrl->csrX = (s32)(sScreenView2->parent->upperLeft.x + 16.0f);
+    if ((f32) gdctrl->csrX < (sScreenView2->parent->upperLeft.x + (16.0f/aspect))) {
+        gdctrl->csrX = (s32)(sScreenView2->parent->upperLeft.x + (16.0f/aspect));
     }
 
     if ((f32) gdctrl->csrX
-        > (sScreenView2->parent->upperLeft.x + sScreenView2->parent->lowerRight.x - 48.0f)) {
+        > (sScreenView2->parent->upperLeft.x + sScreenView2->parent->lowerRight.x - (48.0/aspect))) {
         gdctrl->csrX =
-            (s32)(sScreenView2->parent->upperLeft.x + sScreenView2->parent->lowerRight.x - 48.0f);
+            (s32)(sScreenView2->parent->upperLeft.x + sScreenView2->parent->lowerRight.x - (48.0/aspect));
     }
 
     if ((f32) gdctrl->csrY < (sScreenView2->parent->upperLeft.y + 16.0f)) {
@@ -3402,10 +3416,13 @@ void Unknown801A5FF8(struct ObjGroup *arg0) {
 }
 
 /* 254AC0 -> 254DFC; orig name: PutSprite */
+// thanks to gamemasterplc again for fixing this
 void gd_put_sprite(u16 *sprite, s32 x, s32 y, s32 wx, s32 wy) {
     s32 c; // 5c
     s32 r; // 58
-
+    f32 aspect = GFX_DIMENSIONS_ASPECT_RATIO * 0.75;
+    x *= aspect;
+    
     gSPDisplayList(next_gfx(), osVirtualToPhysical(gd_dl_sprite_start_tex_block));
     for (r = 0; r < wy; r += 0x20) {
         for (c = 0; c < wx; c += 0x20) {
@@ -3592,6 +3609,7 @@ void Unknown801A6E30(UNUSED u32 a0) {
 void Unknown801A6E44(UNUSED u32 a0) {
 }
 
+#ifdef TARGET_N64
 /* 255628 -> 255704; orig name: func_801A6E58 */
 void gd_block_dma(u32 devAddr, void *vAddr, s32 size) {
     s32 transfer; // 2c
@@ -3669,6 +3687,11 @@ struct GdObj *load_dynlist(struct DynList *dynlist) {
 
     return loadedList;
 }
+#else
+struct GdObj *load_dynlist(struct DynList *dynlist) {
+    return proc_dynlist(dynlist);
+}
+#endif
 
 /* 255988 -> 25599C */
 void stub_801A71B8(UNUSED u32 a0) {
diff --git a/src/goddard/skin.c b/src/goddard/skin.c
index 65a7f18..4abc2e6 100644
--- a/src/goddard/skin.c
+++ b/src/goddard/skin.c
@@ -303,7 +303,9 @@ void convert_gd_verts_to_Vn(struct ObjGroup *grp) {
     u8 nx, ny, nz; // 24, 25, 26
     UNUSED u32 pad20;
     register struct VtxLink *vtxlink; // a1
+#ifdef TARGET_N64
     register s16 *vnPos;              // a2
+#endif
     register s16 x;                   // a3
     register s16 y;                   // t0
     register s16 z;                   // t1
@@ -323,11 +325,18 @@ void convert_gd_verts_to_Vn(struct ObjGroup *grp) {
         nz = (u8)(vtx->normal.z * 255.0f);
 
         for (vtxlink = vtx->gbiVerts; vtxlink != NULL; vtxlink = vtxlink->prev) {
+#ifdef TARGET_N64
             vnPos = vtxlink->data->n.ob;
             vn = vtxlink->data;
             *vnPos++ = x;
             *vnPos++ = y;
             *vnPos++ = z;
+#else
+            vn = vtxlink->data;
+            vn->n.ob[0] = x;
+            vn->n.ob[1] = y;
+            vn->n.ob[2] = z;
+#endif
             vn->n.n[0] = nx;
             vn->n.n[1] = ny;
             vn->n.n[2] = nz;
@@ -339,7 +348,9 @@ void convert_gd_verts_to_Vn(struct ObjGroup *grp) {
 void convert_gd_verts_to_Vtx(struct ObjGroup *grp) {
     UNUSED u32 pad24[6];
     register struct VtxLink *vtxlink; // a1
+#ifdef TARGET_N64
     register s16 *vtxcoords;          // a2
+#endif
     register s16 x;                   // a3
     register s16 y;                   // t0
     register s16 z;                   // t1
@@ -355,10 +366,16 @@ void convert_gd_verts_to_Vtx(struct ObjGroup *grp) {
         z = (s16) vtx->pos.z;
 
         for (vtxlink = vtx->gbiVerts; vtxlink != NULL; vtxlink = vtxlink->prev) {
+#ifdef TARGET_N64
             vtxcoords = vtxlink->data->v.ob;
             vtxcoords[0] = x;
             vtxcoords[1] = y;
             vtxcoords[2] = z;
+#else
+            vtxlink->data->v.ob[0] = x;
+            vtxlink->data->v.ob[1] = y;
+            vtxlink->data->v.ob[2] = z;
+#endif
         }
     }
 }
diff --git a/src/menu/intro_geo.c b/src/menu/intro_geo.c
index 8dc3a87..2894408 100644
--- a/src/menu/intro_geo.c
+++ b/src/menu/intro_geo.c
@@ -7,6 +7,8 @@
 #include "game/segment7.h"
 #include "intro_geo.h"
 
+#include "gfx_dimensions.h"
+
 // frame counts for the zoom in, hold, and zoom out of title model
 #define INTRO_STEPS_ZOOM_IN 20
 #define INTRO_STEPS_HOLD_1 75
@@ -167,11 +169,15 @@ Gfx *intro_backdrop_one_image(u32 index, s8 *backgroundTable) {
     Gfx *displayListIter;             // sp54
     const u8 *const *vIntroBgTable;   // sp50
     s32 i;                            // sp4c
+    f32 aspect = GFX_DIMENSIONS_ASPECT_RATIO;
+ int num_tiles_h = (((aspect*SCREEN_HEIGHT)+79)/80);
+ float x_ofs = (SCREEN_WIDTH/2)-(aspect*SCREEN_HEIGHT/2);
+ 
     mtx = alloc_display_list(sizeof(*mtx));
     displayList = alloc_display_list(36 * sizeof(*displayList));
     displayListIter = displayList;
-    vIntroBgTable = segmented_to_virtual(introBackgroundTextureType[backgroundTable[index]]);
-    guTranslate(mtx, introBackgroundOffsetX[index], introBackgroundOffsetY[index], 0.0f);
+    vIntroBgTable = segmented_to_virtual(introBackgroundTextureType[backgroundTable[0]]);
+    guTranslate(mtx, ((index%num_tiles_h)*80)+x_ofs, (index/num_tiles_h)*80, 0.0f);
     gSPMatrix(displayListIter++, mtx, G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_PUSH);
     gSPDisplayList(displayListIter++, &title_screen_bg_dl_0A000118);
     for (i = 0; i < 4; ++i) {
@@ -196,13 +202,16 @@ Gfx *geo18_intro_backdrop(u32 sp48, struct GraphNode *sp4c, UNUSED void *context
     backgroundTable = introBackgroundTables[index];
     displayList = NULL;
     displayListIter = NULL;
+    f32 aspect = GFX_DIMENSIONS_ASPECT_RATIO;
+ int num_tiles_h = (((aspect*SCREEN_HEIGHT)+79)/80);
+ 
     if (sp48 == 1) {
-        displayList = alloc_display_list(16 * sizeof(*displayList));
+        displayList = alloc_display_list(((num_tiles_h*3)+4) * sizeof(*displayList));
         displayListIter = displayList;
         graphNode->node.flags = (graphNode->node.flags & 0xFF) | 0x100;
         gSPDisplayList(displayListIter++, &dl_proj_mtx_fullscreen);
         gSPDisplayList(displayListIter++, &title_screen_bg_dl_0A000100);
-        for (i = 0; i < 12; ++i) {
+        for (i = 0; i < num_tiles_h*3; ++i) {
             gSPDisplayList(displayListIter++, intro_backdrop_one_image(i, backgroundTable));
         }
         gSPDisplayList(displayListIter++, &title_screen_bg_dl_0A000190);
@@ -220,6 +229,9 @@ Gfx *geo18_game_over_tile(u32 sp40, struct GraphNode *sp44, UNUSED void *context
     graphNode = sp44;
     displayList = NULL;
     displayListIter = NULL;
+    f32 aspect = GFX_DIMENSIONS_ASPECT_RATIO;
+ int num_tiles_h = (((aspect*SCREEN_HEIGHT)+79)/80);
+ 
     if (sp40 != 1) {
         gGameOverFrameCounter = 0;
         gGameOverTableIndex = -2;
@@ -227,7 +239,7 @@ Gfx *geo18_game_over_tile(u32 sp40, struct GraphNode *sp44, UNUSED void *context
             gameOverBackgroundTable[i] = INTRO_BACKGROUND_GAME_OVER;
         }
     } else {
-        displayList = alloc_display_list(16 * sizeof(*displayList));
+        displayList = alloc_display_list(((num_tiles_h*3)+4) * sizeof(*displayList));
         displayListIter = displayList;
         if (gGameOverTableIndex == -2) {
             if (gGameOverFrameCounter == 180) {
@@ -248,7 +260,7 @@ Gfx *geo18_game_over_tile(u32 sp40, struct GraphNode *sp44, UNUSED void *context
         graphNode->flags = (graphNode->flags & 0xFF) | 0x100;
         gSPDisplayList(displayListIter++, &dl_proj_mtx_fullscreen);
         gSPDisplayList(displayListIter++, &title_screen_bg_dl_0A000100);
-        for (j = 0; j < (s32) sizeof(gameOverBackgroundTable); ++j) {
+        for (j = 0; j < (s32) num_tiles_h*3; ++j) {
             gSPDisplayList(displayListIter++, intro_backdrop_one_image(j, gameOverBackgroundTable));
         }
         gSPDisplayList(displayListIter++, &title_screen_bg_dl_0A000190);
diff --git a/src/menu/level_select_menu.c b/src/menu/level_select_menu.c
index 26df262..bd23c4d 100644
--- a/src/menu/level_select_menu.c
+++ b/src/menu/level_select_menu.c
@@ -70,6 +70,29 @@ int run_press_start_demo_timer(s32 timer) {
     return timer;
 }
 
+extern int gDemoInputListID_2;
+extern int gPressedStart;
+
+int start_demo(int timer)
+{
+ gCurrDemoInput = NULL;
+ gPressedStart = 0;
+    // start the mario demo animation for the demo list.
+    func_80278AD4(&gDemo, gDemoInputListID_2);
+
+    // if the next demo sequence ID is the count limit, reset it back to
+    // the first sequence.
+
+    if((++gDemoInputListID_2) == gDemo.animDmaTable->count)
+        gDemoInputListID_2 = 0;
+
+    gCurrDemoInput = ((struct DemoInput *) gDemo.targetAnim) + 1; // add 1 (+4) to the pointer to skip the demoID.
+    timer = (s8)((struct DemoInput *) gDemo.targetAnim)->timer; // TODO: see if making timer s8 matches
+    gCurrSaveFileNum = 1;
+    gCurrActNum = 6;
+    return timer;
+}
+
 // input loop for the level select menu. updates the selected stage
 // count if an input was received. signals the stage to be started
 // or the level select to be exited if start or the quit combo is
@@ -135,28 +158,22 @@ s16 level_select_input_loop(void) {
     return 0;
 }
 
+
 int func_8016F3CC(void) {
     s32 sp1C = 0;
 
 #ifndef VERSION_JP
     if (D_U_801A7C34 == 1) {
-        if (gGlobalTimer < 0x81) {
-            play_sound(SOUND_MARIO_HELLO, gDefaultSoundArgs);
-        } else {
-            play_sound(SOUND_MARIO_PRESS_START_TO_PLAY, gDefaultSoundArgs);
-        }
+        play_sound(SOUND_MARIO_HELLO, gDefaultSoundArgs);
         D_U_801A7C34 = 0;
     }
 #endif
     print_intro_text();
 
     if (gPlayer1Controller->buttonPressed & START_BUTTON) {
-#ifdef VERSION_JP
-        play_sound(SOUND_MENU_STAR_SOUND, gDefaultSoundArgs);
-        sp1C = 100 + gDebugLevelSelect;
-#else
         play_sound(SOUND_MENU_STAR_SOUND, gDefaultSoundArgs);
         sp1C = 100 + gDebugLevelSelect;
+#ifndef VERSION_JP        
         D_U_801A7C34 = 1;
 #endif
     }
diff --git a/tools/aiff_extract_codebook.c b/tools/aiff_extract_codebook.c
index cdbef01..78864e3 100644
--- a/tools/aiff_extract_codebook.c
+++ b/tools/aiff_extract_codebook.c
@@ -169,32 +169,7 @@ int main(int argc, char **argv)
     fclose(ifile);
 
     if (coefTable == NULL) {
-        // Missing codebook, execute tabledesign instead
-        const char *procDirs[] = {
-            "/proc/self/exe", // Linux
-            "/proc/curproc/exe", // FreeBSD
-            "/proc/self/path/a.out", // Solaris
-        };
-        char buf[0x1000 + 0x100];
-        s32 bufSize = 0x1000, found = 0;
-        for (s32 i = 0; i < 3; i++) {
-            ssize_t ret = readlink(procDirs[i], buf, bufSize);
-            if (ret > 0 && ret < bufSize) {
-                found = 1;
-                break;
-            }
-        }
-        if (!found) {
-            // Not able to determine filename, let's guess
-            strcpy(buf, "./tools/");
-        }
-        char *sep = strrchr(buf, '/');
-        if (sep == NULL) {
-            sep = buf + strlen(buf);
-        }
-        *sep++ = '/';
-        strcpy(sep, "tabledesign");
-        execl(buf, "tabledesign", "-s", "1", infilename, NULL);
+        execl("./tools/tabledesign", "tabledesign", "-s", "1", infilename, NULL);
     } else {
         printf("%d\n%d\n", order, npredictors);
         for (s32 i = 0; i < npredictors; i++) {
diff --git a/tools/libmio0.c b/tools/libmio0.c
index b106b34..2c7a493 100644
--- a/tools/libmio0.c
+++ b/tools/libmio0.c
@@ -1,6 +1,10 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#if defined(_WIN32) || defined(_WIN64)
+#include <io.h>
+#include <fcntl.h>
+#endif
 
 #include "libmio0.h"
 #include "utils.h"
@@ -291,6 +295,17 @@ int mio0_encode(const unsigned char *in, unsigned int length, unsigned char *out
    return bytes_written;
 }
 
+static FILE *mio0_open_out_file(const char *out_file) {
+   if (strcmp(out_file, "-") == 0) {
+#if defined(_WIN32) || defined(_WIN64)
+      _setmode(_fileno(stdout), _O_BINARY);
+#endif
+      return stdout;
+   } else {
+      return fopen(out_file, "wb");
+   }
+}
+
 int mio0_decode_file(const char *in_file, unsigned long offset, const char *out_file)
 {
    mio0_header_t head;
@@ -339,7 +354,7 @@ int mio0_decode_file(const char *in_file, unsigned long offset, const char *out_
    }
 
    // open output file
-   out = fopen(out_file, "wb");
+   out = mio0_open_out_file(out_file);
    if (out == NULL) {
       ret_val = 4;
       goto free_all;
@@ -352,7 +367,9 @@ int mio0_decode_file(const char *in_file, unsigned long offset, const char *out_
    }
 
    // clean up
-   fclose(out);
+   if (out != stdout) {
+      fclose(out);
+   }
 free_all:
    if (out_buf) {
       free(out_buf);
@@ -402,7 +419,7 @@ int mio0_encode_file(const char *in_file, const char *out_file)
    bytes_encoded = mio0_encode(in_buf, file_size, out_buf);
 
    // open output file
-   out = fopen(out_file, "wb");
+   out = mio0_open_out_file(out_file);
    if (out == NULL) {
       ret_val = 4;
       goto free_all;
@@ -415,7 +432,9 @@ int mio0_encode_file(const char *in_file, const char *out_file)
    }
 
    // clean up
-   fclose(out);
+   if (out != stdout) {
+      fclose(out);
+   }
 free_all:
    if (out_buf) {
       free(out_buf);
@@ -459,7 +478,7 @@ static void print_usage(void)
          "\n"
          "File arguments:\n"
          " FILE        input file\n"
-         " [OUTPUT]    output file (default: FILE.out)\n");
+         " [OUTPUT]    output file (default: FILE.out), \"-\" for stdout\n");
    exit(1);
 }
 
@@ -473,7 +492,7 @@ static void parse_arguments(int argc, char *argv[], arg_config *config)
       exit(1);
    }
    for (i = 1; i < argc; i++) {
-      if (argv[i][0] == '-') {
+      if (argv[i][0] == '-' && argv[i][1] != '\0') {
          switch (argv[i][1]) {
             case 'c':
                config->compress = 1;
diff --git a/include/gfx_dimensions.h b/include/gfx_dimensions.h
new file mode 100644
index 0000000..dfc0394
--- /dev/null
+++ b/include/gfx_dimensions.h
@@ -0,0 +1,20 @@
+#ifndef GFX_DIMENSIONS_H
+#define GFX_DIMENSIONS_H
+
+#ifndef TARGET_N64
+#include <math.h>
+#include "pc/gfx/gfx_pc.h"
+#define GFX_DIMENSIONS_FROM_LEFT_EDGE(v) (SCREEN_WIDTH / 2 - SCREEN_HEIGHT / 2 * gfx_current_dimensions.aspect_ratio + (v))
+#define GFX_DIMENSIONS_FROM_RIGHT_EDGE(v) (SCREEN_WIDTH / 2 + SCREEN_HEIGHT / 2 * gfx_current_dimensions.aspect_ratio - (v))
+#define GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(v) floorf(GFX_DIMENSIONS_FROM_LEFT_EDGE(v))
+#define GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(v) ceilf(GFX_DIMENSIONS_FROM_RIGHT_EDGE(v))
+#define GFX_DIMENSIONS_ASPECT_RATIO (gfx_current_dimensions.aspect_ratio)
+#else
+#define GFX_DIMENSIONS_FROM_LEFT_EDGE(v) (v)
+#define GFX_DIMENSIONS_FROM_RIGHT_EDGE(v) (SCREEN_WIDTH - (v))
+#define GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(v) (v)
+#define GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(v) (SCREEN_WIDTH - (v))
+#define GFX_DIMENSIONS_ASPECT_RATIO (4.0f / 3.0f)
+#endif
+
+#endif
diff --git a/src/pc/audio/audio_alsa.c b/src/pc/audio/audio_alsa.c
new file mode 100644
index 0000000..014167d
--- /dev/null
+++ b/src/pc/audio/audio_alsa.c
@@ -0,0 +1,167 @@
+#if defined(__linux__) && !defined(TARGET_WEB)
+/*
+    Simple sound playback using ALSA API and libasound.
+    Dependencies: libasound, alsa
+    Build-Dependencies: liasound-dev
+    Compile: gcc -lasound -o play sound_playback.c
+    Usage: ./play <sample_rate> <channels> < <file>
+    Examples:
+        ./play 44100 2 5 < /dev/urandom
+        ./play 22050 1 8 < /path/to/file.wav
+ 
+    Copyright (C) 2009 Alessandro Ghedini <al3xbio@gmail.com>
+    --------------------------------------------------------------
+    "THE BEER-WARE LICENSE" (Revision 42):
+    Alessandro Ghedini wrote this file. As long as you retain this 
+    notice you can do whatever you want with this stuff. If we 
+    meet some day, and you think this stuff is worth it, you can 
+    buy me a beer in return.
+    --------------------------------------------------------------
+*/
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <poll.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netinet/tcp.h>
+
+#include <time.h>
+
+#include <alsa/asoundlib.h>
+#include <stdio.h>
+
+#include "audio_api.h"
+
+#define PCM_DEVICE "default"
+static snd_pcm_t *pcm_handle;
+static unsigned long int alsa_buffer_size;
+
+static unsigned long get_time(void) {
+ struct timespec ts;
+ clock_gettime(CLOCK_MONOTONIC, &ts);
+ return (unsigned long)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
+}
+
+static bool audio_alsa_init(void) {
+ unsigned int pcm, tmp, dir;
+ unsigned int rate, channels;
+ snd_pcm_hw_params_t *params;
+ snd_pcm_uframes_t frames;
+
+ rate   = 32000;
+ channels = 2;
+
+ /* Open the PCM device in playback mode */
+ if (pcm = snd_pcm_open(&pcm_handle, PCM_DEVICE,
+         SND_PCM_STREAM_PLAYBACK, 0) < 0) {
+   printf("ERROR: Can't open \"%s\" PCM device. %s\n",
+         PCM_DEVICE, snd_strerror(pcm));
+        return false;
+    }
+
+ /* Allocate parameters object and fill it with default values*/
+ snd_pcm_hw_params_alloca(&params);
+
+ snd_pcm_hw_params_any(pcm_handle, params);
+
+ /* Set parameters */
+ if (pcm = snd_pcm_hw_params_set_access(pcm_handle, params,
+         SND_PCM_ACCESS_RW_INTERLEAVED) < 0)
+   printf("ERROR: Can't set interleaved mode. %s\n", snd_strerror(pcm));
+
+ if (pcm = snd_pcm_hw_params_set_format(pcm_handle, params,
+           SND_PCM_FORMAT_S16_LE) < 0)
+   printf("ERROR: Can't set format. %s\n", snd_strerror(pcm));
+
+ if (pcm = snd_pcm_hw_params_set_channels(pcm_handle, params, channels) < 0)
+   printf("ERROR: Can't set channels number. %s\n", snd_strerror(pcm));
+
+ if (pcm = snd_pcm_hw_params_set_rate_near(pcm_handle, params, &rate, 0) < 0)
+   printf("ERROR: Can't set rate. %s\n", snd_strerror(pcm));
+
+ alsa_buffer_size = 1600 + 528 + 544; // five audio buffers from the game
+ if (pcm = snd_pcm_hw_params_set_buffer_size_near(pcm_handle, params, &alsa_buffer_size))
+   printf("ERROR: Can't set buffer size. %s\n", snd_strerror(pcm));
+
+ /* Write parameters */
+ if (pcm = snd_pcm_hw_params(pcm_handle, params) < 0)
+   printf("ERROR: Can't set harware parameters. %s\n", snd_strerror(pcm));
+
+ /* Resume information */
+ printf("PCM name: '%s'\n", snd_pcm_name(pcm_handle));
+
+ printf("PCM state: %s\n", snd_pcm_state_name(snd_pcm_state(pcm_handle)));
+
+ snd_pcm_hw_params_get_channels(params, &tmp);
+ printf("channels: %i ", tmp);
+
+ if (tmp == 1)
+   printf("(mono)\n");
+ else if (tmp == 2)
+   printf("(stereo)\n");
+
+ snd_pcm_hw_params_get_rate(params, &tmp, 0);
+ printf("rate: %d bps\n", tmp);
+
+ snd_pcm_hw_params_get_buffer_size(params, &alsa_buffer_size);
+ printf("buffer size: %lu\n", alsa_buffer_size);
+
+ /* Allocate buffer to hold single period */
+ snd_pcm_hw_params_get_period_size(params, &frames, 0);
+ printf("frames: %u\n", frames);
+
+ snd_pcm_hw_params_get_period_time(params, &tmp, NULL);
+ printf("time: %d\n", tmp);
+
+    return true;
+}
+
+static int audio_alsa_buffered(void) {
+    if (!pcm_handle) {
+        return 0;
+    }
+    snd_pcm_sframes_t ret = snd_pcm_avail(pcm_handle);
+    if (ret < 0) {
+        return 0;
+    }
+    ret = alsa_buffer_size - ret;
+    return ret < 0 ? 0 : ret;
+}
+
+static int audio_alsa_get_desired_buffered(void) {
+    return 1100;
+}
+
+static void audio_alsa_play(const uint8_t* buff, size_t len) {
+    if (!pcm_handle) {
+        audio_alsa_init();
+    }
+ //unsigned long t1 = get_time();
+    int frames = len / 4;
+    int pcm;
+ if (pcm = snd_pcm_writei(pcm_handle, buff, frames) == -EPIPE) {
+   printf("XRUN.\n");
+   snd_pcm_prepare(pcm_handle);
+        // Add some silence to avoid another XRUN
+        char buf[1100 * 4 + len];
+        memset(buf, 0, 1100 * 4);
+        memcpy(buf + 1100 * 4, buff, len);
+   if ((pcm = snd_pcm_writei(pcm_handle, buf, 1100 + frames)) < 0) {
+     printf("Failed again %d\n", pcm);
+   }
+ } else if (pcm < 0) {
+   printf("ERROR. Can't write to PCM device. %s\n", snd_strerror(pcm));
+   return;
+ }
+ //fprintf(stderr, "%u ", get_time() - t1);
+}
+
+struct AudioAPI audio_alsa = {
+    audio_alsa_init,
+    audio_alsa_buffered,
+    audio_alsa_get_desired_buffered,
+    audio_alsa_play
+};
+
+#endif
diff --git a/src/pc/audio/audio_alsa.h b/src/pc/audio/audio_alsa.h
new file mode 100644
index 0000000..ba404ff
--- /dev/null
+++ b/src/pc/audio/audio_alsa.h
@@ -0,0 +1,11 @@
+#ifndef AUDIO_ALSA_H
+#define AUDIO_ALSA_H
+
+#ifdef __linux__
+extern struct AudioAPI audio_alsa;
+#define HAVE_ALSA 1
+#else
+#define HAVE_ALSA 0
+#endif
+
+#endif
diff --git a/src/pc/audio/audio_api.h b/src/pc/audio/audio_api.h
new file mode 100644
index 0000000..26794dd
--- /dev/null
+++ b/src/pc/audio/audio_api.h
@@ -0,0 +1,15 @@
+#ifndef AUDIO_API_H
+#define AUDIO_API_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stddef.h>
+
+struct AudioAPI {
+    bool (*init)(void);
+    int (*buffered)(void);
+    int (*get_desired_buffered)(void);
+    void (*play)(const uint8_t *buf, size_t len);
+};
+
+#endif
diff --git a/src/pc/audio/audio_null.c b/src/pc/audio/audio_null.c
new file mode 100644
index 0000000..8a244e4
--- /dev/null
+++ b/src/pc/audio/audio_null.c
@@ -0,0 +1,23 @@
+#include "audio_api.h"
+
+static bool audio_null_init(void) {
+    return true;
+}
+
+static int audio_null_buffered(void) {
+    return 0;
+}
+
+static int audio_null_get_desired_buffered(void) {
+    return 0;
+}
+
+static void audio_null_play(const uint8_t *buf, size_t len) {
+}
+
+struct AudioAPI audio_null = {
+    audio_null_init,
+    audio_null_buffered,
+    audio_null_get_desired_buffered,
+    audio_null_play
+};
diff --git a/src/pc/audio/audio_null.h b/src/pc/audio/audio_null.h
new file mode 100644
index 0000000..59748bc
--- /dev/null
+++ b/src/pc/audio/audio_null.h
@@ -0,0 +1,8 @@
+#ifndef AUDIO_NULL_H
+#define AUDIO_NULL_H
+
+#include "audio_api.h"
+
+extern struct AudioAPI audio_null;
+
+#endif
diff --git a/src/pc/audio/audio_pulse.c b/src/pc/audio/audio_pulse.c
new file mode 100644
index 0000000..a783949
--- /dev/null
+++ b/src/pc/audio/audio_pulse.c
@@ -0,0 +1,199 @@
+#ifdef __linux__
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <pulse/pulseaudio.h>
+
+#include "audio_api.h"
+
+static struct {
+    pa_mainloop *mainloop;
+    pa_context *context;
+    pa_stream *stream;
+    pa_buffer_attr attr;
+    bool write_complete;
+} pas;
+
+static void pas_context_state_cb(pa_context *c, void *userdata) {
+    switch (pa_context_get_state(c)) {
+        case PA_CONTEXT_READY:
+        case PA_CONTEXT_TERMINATED:
+        case PA_CONTEXT_FAILED:
+            *((bool *)userdata) = true;
+            break;
+        default:
+            break;
+    }
+}
+
+static void pas_stream_state_cb(pa_stream *s, void *userdata) {
+    switch (pa_stream_get_state(s)) {
+        case PA_STREAM_READY:
+        case PA_STREAM_FAILED:
+        case PA_STREAM_TERMINATED:
+            *((bool *)userdata) = true;
+            break;
+        default:
+            break;
+    }
+}
+
+static void pas_stream_write_cb(pa_stream *s, size_t length, void *userdata) {
+    size_t ws = pa_stream_writable_size(pas.stream);
+    //printf("write cb: %d %d\n", (int)length, (int)ws);
+}
+
+static bool audio_pulse_init(void) {
+    // Create mainloop
+    pas.mainloop = pa_mainloop_new();
+    if (pas.mainloop == NULL) {
+        return false;
+    }
+    
+    // Create context and connect
+    pas.context = pa_context_new(pa_mainloop_get_api(pas.mainloop), "Super Mario 64");
+    if (pas.context == NULL) {
+        goto fail;
+    }
+    
+    bool done = false;
+    pa_context_set_state_callback(pas.context, pas_context_state_cb, &done);
+    
+    if (pa_context_connect(pas.context, NULL, 0, NULL) < 0) {
+        goto fail;
+    }
+    
+    while (!done) {
+        pa_mainloop_iterate(pas.mainloop, true, NULL);
+    }
+    pa_context_set_state_callback(pas.context, NULL, NULL);
+    if (pa_context_get_state(pas.context) != PA_CONTEXT_READY) {
+        goto fail;
+    }
+    
+    // Create stream
+    pa_sample_spec ss;
+    ss.format = PA_SAMPLE_S16LE;
+    ss.rate = 32000;
+    ss.channels = 2;
+    
+    pa_buffer_attr attr;
+    attr.maxlength = (1600 + 544 + 528 + 1600) * 4;
+    attr.tlength = (528*2 + 544) * 4;
+    attr.prebuf = 1500 * 4;
+    attr.minreq = 161 * 4;
+    attr.fragsize = (uint32_t)-1;
+    
+    pas.stream = pa_stream_new(pas.context, "mario", &ss, NULL);
+    if (pas.stream == NULL) {
+        goto fail;
+    }
+    
+    done = false;
+    pa_stream_set_state_callback(pas.stream, pas_stream_state_cb, &done);
+    pa_stream_set_write_callback(pas.stream, pas_stream_write_cb, NULL);
+    if (pa_stream_connect_playback(pas.stream, NULL, &attr, PA_STREAM_ADJUST_LATENCY, NULL, NULL) < 0) {
+        goto fail;
+    }
+    
+    while (!done) {
+        pa_mainloop_iterate(pas.mainloop, true, NULL);
+    }
+    pa_stream_set_state_callback(pas.stream, NULL, NULL);
+    if (pa_stream_get_state(pas.stream) != PA_STREAM_READY) {
+        goto fail;
+    }
+    
+    const pa_buffer_attr *applied_attr = pa_stream_get_buffer_attr(pas.stream);
+    printf("maxlength: %u\ntlength: %u\nprebuf: %u\nminreq: %u\nfragsize: %u\n",
+           applied_attr->maxlength, applied_attr->tlength, applied_attr->prebuf, applied_attr->minreq, applied_attr->fragsize);
+    pas.attr = *applied_attr;
+    
+    return true;
+
+fail:
+    if (pas.stream != NULL) {
+        pa_stream_unref(pas.stream);
+        pas.stream = NULL;
+    }
+    if (pas.context != NULL) {
+        pa_context_disconnect(pas.context);
+        pa_context_unref(pas.context);
+        pas.context = NULL;
+    }
+    if (pas.mainloop != NULL) {
+        pa_mainloop_free(pas.mainloop);
+        pas.mainloop = NULL;
+    }
+    return false;
+}
+
+static void pas_update_complete(pa_stream *stream, int success, void *userdata) {
+    *(bool *)userdata = true;
+}
+
+static void pas_update(void) {
+    bool done = false;
+    pa_stream_update_timing_info(pas.stream, pas_update_complete, &done);
+    while (!done) {
+        pa_mainloop_iterate(pas.mainloop, true, NULL);
+    }
+}
+
+static void pas_write_complete(void *p) {
+    pas.write_complete = true;
+}
+
+static int audio_pulse_buffered(void) {
+    if (pas.stream == NULL) {
+        return 0;
+    }
+    pas_update();
+    const pa_timing_info *info = pa_stream_get_timing_info(pas.stream);
+    /*int diff = info->write_index - info->read_index + (int)(info->sink_usec * 0.128);
+    pa_usec_t usec;
+    pa_stream_get_time(pas.stream, &usec);
+    int32_t t = info->timestamp.tv_sec * 1000000 + info->timestamp.tv_usec - (usec - info->transport_usec);
+    static int t0;
+    if (t0 == 0) t0 = t;*/
+    
+    /*int r = pa_mainloop_iterate(pas.mainloop, false, NULL);
+    size_t ws = pa_stream_writable_size(pas.stream);
+    printf("Writable: %d (%d) %d %d %d %d %llu %d\n", (int)ws, r, (int)(info->write_index - info->read_index), diff, (int)info->sink_usec, (int)info->transport_usec, (unsigned long long)usec, t - t0);*/
+    //return (pas.attr.tlength - ws) / 4;
+    return (info->write_index - info->read_index) / 4;
+}
+
+static int audio_pulse_get_desired_buffered(void) {
+    return 1100;
+}
+
+static void audio_pulse_play(const uint8_t *buf, size_t len) {
+    if (pas.stream == NULL) {
+        if (!audio_pulse_init()) {
+            return;
+        }
+    }
+    //size_t ws = pa_stream_writable_size(pas.stream);
+    size_t ws = pas.attr.maxlength - audio_pulse_buffered() * 4;
+    if (ws < len) {
+        printf("Warning: can't write everything: %d vs %d\n", (int)len, (int)ws);
+    }
+    if (pa_stream_write(pas.stream, buf, len, pas_write_complete, 0LL, PA_SEEK_RELATIVE) < 0) {
+        printf("pa_stream_write failed\n");
+        return;
+    }
+    while (!pas.write_complete) {
+        pa_mainloop_iterate(pas.mainloop, true, NULL);
+    }
+    pas.write_complete = false;
+}
+
+struct AudioAPI audio_pulse = {
+    audio_pulse_init,
+    audio_pulse_buffered,
+    audio_pulse_get_desired_buffered,
+    audio_pulse_play
+};
+
+#endif
diff --git a/src/pc/audio/audio_pulse.h b/src/pc/audio/audio_pulse.h
new file mode 100644
index 0000000..8be9ea5
--- /dev/null
+++ b/src/pc/audio/audio_pulse.h
@@ -0,0 +1,11 @@
+#ifndef AUDIO_PULSE_H
+#define AUDIO_PULSE_H
+
+#ifdef __linux__
+extern struct AudioAPI audio_pulse;
+#define HAVE_PULSE_AUDIO 1
+#else
+#define HAVE_PULSE_AUDIO 0
+#endif
+
+#endif
diff --git a/src/pc/audio/audio_sdl.c b/src/pc/audio/audio_sdl.c
new file mode 100644
index 0000000..3f020f9
--- /dev/null
+++ b/src/pc/audio/audio_sdl.c
@@ -0,0 +1,56 @@
+#if !defined(_WIN32) && !defined(_WIN64)
+
+#ifdef __MINGW32__
+#include "SDL.h"
+#else
+#include "SDL2/SDL.h"
+#endif
+
+#include "audio_api.h"
+
+static SDL_AudioDeviceID dev;
+
+static bool audio_sdl_init(void) {
+    if (SDL_Init(SDL_INIT_AUDIO) != 0) {
+        fprintf(stderr, "SDL init error: %s\n", SDL_GetError());
+        return false;
+    }
+    SDL_AudioSpec want, have;
+    SDL_zero(want);
+    want.freq = 32000;
+    want.format = AUDIO_S16;
+    want.channels = 2;
+    want.samples = 512;
+    want.callback = NULL;
+    dev = SDL_OpenAudioDevice(NULL, 0, &want, &have, 0);
+    if (dev == 0) {
+        fprintf(stderr, "SDL_OpenAudio error: %s\n", SDL_GetError());
+        return false;
+    }
+    SDL_PauseAudioDevice(dev, 0);
+    return true;
+}
+
+static int audio_sdl_buffered(void) {
+    return SDL_GetQueuedAudioSize(dev) / 4;
+}
+
+static int audio_sdl_get_desired_buffered(void) {
+    return 1100;
+}
+
+static void audio_sdl_play(const uint8_t *buf, size_t len) {
+    if (audio_sdl_buffered() < 6000) {
+        // Don't fill the audio buffer too much in case this happens
+        SDL_QueueAudio(dev, buf, len);
+    }
+}
+
+struct AudioAPI audio_sdl = {
+    audio_sdl_init,
+    audio_sdl_buffered,
+    audio_sdl_get_desired_buffered,
+    audio_sdl_play
+};
+
+#endif
diff --git a/src/pc/audio/audio_sdl.h b/src/pc/audio/audio_sdl.h
new file mode 100644
index 0000000..e553239
--- /dev/null
+++ b/src/pc/audio/audio_sdl.h
@@ -0,0 +1,6 @@
+#ifndef AUDIO_SDL_H
+#define AUDIO_SDL_H
+
+extern struct AudioAPI audio_sdl;
+
+#endif
diff --git a/src/pc/audio/audio_wasapi.cpp b/src/pc/audio/audio_wasapi.cpp
new file mode 100644
index 0000000..9f1724d
--- /dev/null
+++ b/src/pc/audio/audio_wasapi.cpp
@@ -0,0 +1,210 @@
+#if defined(_WIN32) || defined(_WIN64)
+
+#include <stdint.h>
+#include <string.h>
+
+#include <windows.h>
+#include <wrl/client.h>
+#include "Objbase.h"
+#include "Mmdeviceapi.h"
+#include "audioclient.h"
+
+#include "audio_api.h"
+
+// These constants are currently missing from the MinGW headers.
+#ifndef AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM
+# define AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM  0x80000000
+#endif
+#ifndef AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY
+# define AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY  0x08000000
+#endif
+
+using namespace Microsoft::WRL;
+
+const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
+const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
+const IID IID_IAudioClient = __uuidof(IAudioClient);
+const IID IID_IAudioRenderClient = __uuidof(IAudioRenderClient);
+
+static ComPtr<IMMDeviceEnumerator> immdev_enumerator;
+
+static struct WasapiState {
+    ComPtr<IMMDevice> device;
+    ComPtr<IAudioClient> client;
+    ComPtr<IAudioRenderClient> rclient;
+    UINT32 buffer_frame_count;
+    bool initialized;
+    bool started;
+} wasapi;
+
+static class NotificationClient : public IMMNotificationClient {
+    LONG refcount;
+public:
+    NotificationClient() : refcount(1) {
+    }
+
+    virtual HRESULT STDMETHODCALLTYPE OnDeviceStateChanged(LPCWSTR pwstrDeviceId, DWORD dwNewState) {
+        return S_OK;
+    }
+
+    virtual HRESULT STDMETHODCALLTYPE OnDeviceAdded(LPCWSTR pwstrDeviceId) {
+        return S_OK;
+    }
+
+    virtual HRESULT STDMETHODCALLTYPE OnDeviceRemoved(LPCWSTR pwstrDeviceId) {
+        return S_OK;
+    }
+
+    virtual HRESULT STDMETHODCALLTYPE OnDefaultDeviceChanged(EDataFlow flow, ERole role, LPCWSTR pwstrDefaultDeviceId) {
+        if (flow == eRender && role == eConsole) {
+            // This callback runs on a separate thread,
+            // but it's not important how fast this write takes effect.
+            wasapi.initialized = false;
+        }
+        return S_OK;
+    }
+
+    virtual HRESULT STDMETHODCALLTYPE OnPropertyValueChanged(LPCWSTR pwstrDeviceId, const PROPERTYKEY key) {
+        return S_OK;
+    }
+
+    virtual ULONG STDMETHODCALLTYPE AddRef() {
+        return InterlockedIncrement(&refcount);
+    }
+
+    virtual ULONG STDMETHODCALLTYPE Release() {
+        ULONG rc = InterlockedDecrement(&refcount);
+        if (rc == 0) {
+            delete this;
+        }
+        return rc;
+    }
+
+    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, VOID **ppvInterface) {
+        if (riid == __uuidof(IUnknown)) {
+            AddRef();
+            *ppvInterface = (IUnknown *)this;
+        } else if (riid == __uuidof(IMMNotificationClient)) {
+            AddRef();
+            *ppvInterface = (IMMNotificationClient *)this;
+        } else {
+            *ppvInterface = nullptr;
+            return E_NOINTERFACE;
+        }
+        return S_OK;
+    }
+} notification_client;
+
+static void ThrowIfFailed(HRESULT res) {
+    if (FAILED(res)) {
+        throw res;
+    }
+}
+
+bool audio_wasapi_init(void) {
+    try {
+        ThrowIfFailed(CoCreateInstance(CLSID_MMDeviceEnumerator, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&immdev_enumerator)));
+    } catch (HRESULT res) {
+        return false;
+    }
+
+    ThrowIfFailed(immdev_enumerator->RegisterEndpointNotificationCallback(new NotificationClient()));
+
+    return true;
+}
+
+static bool audio_wasapi_setup_stream(void) {
+    wasapi = WasapiState();
+
+    try {
+        ThrowIfFailed(immdev_enumerator->GetDefaultAudioEndpoint(eRender, eConsole, &wasapi.device));
+        ThrowIfFailed(wasapi.device->Activate(IID_IAudioClient, CLSCTX_ALL, nullptr, IID_PPV_ARGS_Helper(&wasapi.client)));
+
+        WAVEFORMATEX desired;
+        desired.wFormatTag = WAVE_FORMAT_PCM;
+        desired.nChannels = 2;
+        desired.nSamplesPerSec = 32000;
+        desired.nAvgBytesPerSec = 32000 * 2 * 2;
+        desired.nBlockAlign = 4;
+        desired.wBitsPerSample = 16;
+        desired.cbSize = 0;
+
+        ThrowIfFailed(wasapi.client->Initialize(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM | AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY, 2000000, 0, &desired, nullptr));
+
+        ThrowIfFailed(wasapi.client->GetBufferSize(&wasapi.buffer_frame_count));
+        ThrowIfFailed(wasapi.client->GetService(IID_PPV_ARGS(&wasapi.rclient)));
+
+        wasapi.started = false;
+        wasapi.initialized = true;
+    } catch (HRESULT res) {
+        wasapi = WasapiState();
+        return false;
+    }
+
+    return true;
+}
+
+static int audio_wasapi_buffered(void) {
+    if (!wasapi.initialized) {
+        if (!audio_wasapi_setup_stream()) {
+            return 0;
+        }
+    }
+    try {
+        UINT32 padding;
+        ThrowIfFailed(wasapi.client->GetCurrentPadding(&padding));
+        return padding;
+    } catch (HRESULT res) {
+        wasapi = WasapiState();
+        return 0;
+    }
+}
+
+static int audio_wasapi_get_desired_buffered(void) {
+    return 1100;
+}
+
+//#include <stdio.h>
+static void audio_wasapi_play(const uint8_t *buf, size_t len) {
+    if (!wasapi.initialized) {
+        if (!audio_wasapi_setup_stream()) {
+            return;
+        }
+    }
+    try {
+        UINT32 frames = len / 4;
+
+        UINT32 padding;
+        ThrowIfFailed(wasapi.client->GetCurrentPadding(&padding));
+        //printf("%u %u\n", frames, padding);
+
+        UINT32 available = wasapi.buffer_frame_count - padding;
+        if (available < frames) {
+            frames = available;
+        }
+        if (available == 0) {
+            return;
+        }
+
+        BYTE *data;
+        ThrowIfFailed(wasapi.rclient->GetBuffer(frames, &data));
+        memcpy(data, buf, frames * 4);
+        ThrowIfFailed(wasapi.rclient->ReleaseBuffer(frames, 0));
+
+        if (!wasapi.started && padding + frames > 1500) {
+            wasapi.started = true;
+            ThrowIfFailed(wasapi.client->Start());
+        }
+    } catch (HRESULT res) {
+        wasapi = WasapiState();
+    }
+}
+
+struct AudioAPI audio_wasapi = {
+    audio_wasapi_init,
+    audio_wasapi_buffered,
+    audio_wasapi_get_desired_buffered,
+    audio_wasapi_play
+};
+
+#endif
diff --git a/src/pc/audio/audio_wasapi.h b/src/pc/audio/audio_wasapi.h
new file mode 100644
index 0000000..b0aab11
--- /dev/null
+++ b/src/pc/audio/audio_wasapi.h
@@ -0,0 +1,12 @@
+#ifndef AUDIO_WASAPI_H
+#define AUDIO_WASAPI_H
+
+#if defined(_WIN32) || defined(_WIN64)
+#include "audio_api.h"
+extern struct AudioAPI audio_wasapi;
+#define HAVE_WASAPI 1
+#else
+#define HAVE_WASAPI 0
+#endif
+
+#endif
diff --git a/src/pc/configfile.c b/src/pc/configfile.c
new file mode 100644
index 0000000..10ff1e6
--- /dev/null
+++ b/src/pc/configfile.c
@@ -0,0 +1,236 @@
+// configfile.c - handles loading and saving the configuration options
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <ctype.h>
+
+#include "configfile.h"
+
+#define ARRAY_LEN(arr) (sizeof(arr) / sizeof(arr[0]))
+
+enum ConfigOptionType {
+    CONFIG_TYPE_BOOL,
+    CONFIG_TYPE_UINT,
+    CONFIG_TYPE_FLOAT,
+};
+
+struct ConfigOption {
+    const char *name;
+    enum ConfigOptionType type;
+    union {
+        bool *boolValue;
+        unsigned int *uintValue;
+        float *floatValue;
+    };
+};
+
+/*
+ *Config options and default values
+ */
+bool configFullscreen            = false;
+// Keyboard mappings (scancode values)
+unsigned int configKeyA          = 0x26;
+unsigned int configKeyB          = 0x33;
+unsigned int configKeyStart      = 0x39;
+unsigned int configKeyR          = 0x36;
+unsigned int configKeyZ          = 0x25;
+unsigned int configKeyCUp        = 0x148;
+unsigned int configKeyCDown      = 0x150;
+unsigned int configKeyCLeft      = 0x14B;
+unsigned int configKeyCRight     = 0x14D;
+unsigned int configKeyStickUp    = 0x11;
+unsigned int configKeyStickDown  = 0x1F;
+unsigned int configKeyStickLeft  = 0x1E;
+unsigned int configKeyStickRight = 0x20;
+
+
+static const struct ConfigOption options[] = {
+    {.name = "fullscreen",     .type = CONFIG_TYPE_BOOL, .boolValue = &configFullscreen},
+    {.name = "key_a",          .type = CONFIG_TYPE_UINT, .uintValue = &configKeyA},
+    {.name = "key_b",          .type = CONFIG_TYPE_UINT, .uintValue = &configKeyB},
+    {.name = "key_start",      .type = CONFIG_TYPE_UINT, .uintValue = &configKeyStart},
+    {.name = "key_r",          .type = CONFIG_TYPE_UINT, .uintValue = &configKeyR},
+    {.name = "key_z",          .type = CONFIG_TYPE_UINT, .uintValue = &configKeyZ},
+    {.name = "key_cup",        .type = CONFIG_TYPE_UINT, .uintValue = &configKeyCUp},
+    {.name = "key_cdown",      .type = CONFIG_TYPE_UINT, .uintValue = &configKeyCDown},
+    {.name = "key_cleft",      .type = CONFIG_TYPE_UINT, .uintValue = &configKeyCLeft},
+    {.name = "key_cright",     .type = CONFIG_TYPE_UINT, .uintValue = &configKeyCRight},
+    {.name = "key_stickup",    .type = CONFIG_TYPE_UINT, .uintValue = &configKeyStickUp},
+    {.name = "key_stickdown",  .type = CONFIG_TYPE_UINT, .uintValue = &configKeyStickDown},
+    {.name = "key_stickleft",  .type = CONFIG_TYPE_UINT, .uintValue = &configKeyStickLeft},
+    {.name = "key_stickright", .type = CONFIG_TYPE_UINT, .uintValue = &configKeyStickRight},
+};
+
+// Reads an entire line from a file (excluding the newline character) and returns an allocated string
+// Returns NULL if no lines could be read from the file
+static char *read_file_line(FILE *file) {
+    char *buffer;
+    size_t bufferSize = 8;
+    size_t offset = 0; // offset in buffer to write
+
+    buffer = malloc(bufferSize);
+    while (1) {
+        // Read a line from the file
+        if (fgets(buffer + offset, bufferSize - offset, file) == NULL) {
+            free(buffer);
+            return NULL; // Nothing could be read.
+        }
+        offset = strlen(buffer);
+        assert(offset > 0);
+
+        // If a newline was found, remove the trailing newline and exit
+        if (buffer[offset - 1] == '\n') {
+            buffer[offset - 1] = '\0';
+            break;
+        }
+
+        if (feof(file)) // EOF was reached
+            break;
+
+        // If no newline or EOF was reached, then the whole line wasn't read.
+        bufferSize *= 2; // Increase buffer size
+        buffer = realloc(buffer, bufferSize);
+        assert(buffer != NULL);
+    }
+
+    return buffer;
+}
+
+// Returns the position of the first non-whitespace character
+static char *skip_whitespace(char *str) {
+    while (isspace(*str))
+        str++;
+    return str;
+}
+
+// NULL-terminates the current whitespace-delimited word, and returns a pointer to the next word
+static char *word_split(char *str) {
+    // Precondition: str must not point to whitespace
+    assert(!isspace(*str));
+
+    // Find either the next whitespace char or end of string
+    while (!isspace(*str) && *str != '\0')
+        str++;
+    if (*str == '\0') // End of string
+        return str;
+
+    // Terminate current word
+    *(str++) = '\0';
+
+    // Skip whitespace to next word
+    return skip_whitespace(str);
+}
+
+// Splits a string into words, and stores the words into the 'tokens' array
+// 'maxTokens' is the length of the 'tokens' array
+// Returns the number of tokens parsed
+static unsigned int tokenize_string(char *str, int maxTokens, char **tokens) {
+    int count = 0;
+
+    str = skip_whitespace(str);
+    while (str[0] != '\0' && count < maxTokens) {
+        tokens[count] = str;
+        str = word_split(str);
+        count++;
+    }
+    return count;
+}
+
+// Loads the config file specified by 'filename'
+void configfile_load(const char *filename) {
+    FILE *file;
+    char *line;
+
+    printf("Loading configuration from '%s'\n", filename);
+
+    file = fopen(filename, "r");
+    if (file == NULL) {
+        // Create a new config file and save defaults
+        printf("Config file '%s' not found. Creating it.\n", filename);
+        configfile_save(filename);
+        return;
+    }
+
+    // Go through each line in the file
+    while ((line = read_file_line(file)) != NULL) {
+        char *p = line;
+        char *tokens[2];
+        int numTokens;
+
+        while (isspace(*p))
+            p++;
+        numTokens = tokenize_string(p, 2, tokens);
+        if (numTokens != 0) {
+            if (numTokens == 2) {
+                const struct ConfigOption *option = NULL;
+
+                for (unsigned int i = 0; i < ARRAY_LEN(options); i++) {
+                    if (strcmp(tokens[0], options[i].name) == 0) {
+                        option = &options[i];
+                        break;
+                    }
+                }
+                if (option == NULL)
+                    printf("unknown option '%s'\n", tokens[0]);
+                else {
+                    switch (option->type) {
+                        case CONFIG_TYPE_BOOL:
+                            if (strcmp(tokens[1], "true") == 0)
+                                *option->boolValue = true;
+                            else if (strcmp(tokens[1], "false") == 0)
+                                *option->boolValue = false;
+                            break;
+                        case CONFIG_TYPE_UINT:
+                            sscanf(tokens[1], "%u", option->uintValue);
+                            break;
+                        case CONFIG_TYPE_FLOAT:
+                            sscanf(tokens[1], "%f", option->floatValue);
+                            break;
+                        default:
+                            assert(0); // bad type
+                    }
+                    printf("option: '%s', value: '%s'\n", tokens[0], tokens[1]);
+                }
+            } else
+                puts("error: expected value");
+        }
+        free(line);
+    }
+
+    fclose(file);
+}
+
+// Writes the config file to 'filename'
+void configfile_save(const char *filename) {
+    FILE *file;
+
+    printf("Saving configuration to '%s'\n", filename);
+
+    file = fopen(filename, "w");
+    if (file == NULL) {
+        // error
+        return;
+    }
+
+    for (unsigned int i = 0; i < ARRAY_LEN(options); i++) {
+        const struct ConfigOption *option = &options[i];
+
+        switch (option->type) {
+            case CONFIG_TYPE_BOOL:
+                fprintf(file, "%s %s\n", option->name, *option->boolValue ? "true" : "false");
+                break;
+            case CONFIG_TYPE_UINT:
+                fprintf(file, "%s %u\n", option->name, *option->uintValue);
+                break;
+            case CONFIG_TYPE_FLOAT:
+                fprintf(file, "%s %f\n", option->name, *option->floatValue);
+                break;
+            default:
+                assert(0); // unknown type
+        }
+    }
+
+    fclose(file);
+}
diff --git a/src/pc/configfile.h b/src/pc/configfile.h
new file mode 100644
index 0000000..ae9070b
--- /dev/null
+++ b/src/pc/configfile.h
@@ -0,0 +1,22 @@
+#ifndef CONFIGFILE_H
+#define CONFIGFILE_H
+
+extern bool         configFullscreen;
+extern unsigned int configKeyA;
+extern unsigned int configKeyB;
+extern unsigned int configKeyStart;
+extern unsigned int configKeyR;
+extern unsigned int configKeyZ;
+extern unsigned int configKeyCUp;
+extern unsigned int configKeyCDown;
+extern unsigned int configKeyCLeft;
+extern unsigned int configKeyCRight;
+extern unsigned int configKeyStickUp;
+extern unsigned int configKeyStickDown;
+extern unsigned int configKeyStickLeft;
+extern unsigned int configKeyStickRight;
+
+void configfile_load(const char *filename);
+void configfile_save(const char *filename);
+
+#endif
diff --git a/src/pc/controller/controller_api.h b/src/pc/controller/controller_api.h
new file mode 100644
index 0000000..dd318a8
--- /dev/null
+++ b/src/pc/controller/controller_api.h
@@ -0,0 +1,11 @@
+#ifndef CONTROLLER_API
+#define CONTROLLER_API
+
+#include <ultra64.h>
+
+struct ControllerAPI {
+    void (*init)(void);
+    void (*read)(OSContPad *pad);
+};
+
+#endif
diff --git a/src/pc/controller/controller_emscripten_keyboard.c b/src/pc/controller/controller_emscripten_keyboard.c
new file mode 100644
index 0000000..cf78cf6
--- /dev/null
+++ b/src/pc/controller/controller_emscripten_keyboard.c
@@ -0,0 +1,151 @@
+#ifdef TARGET_WEB
+
+#include <string.h>
+#include <emscripten/html5.h>
+#include "macros.h"
+#include "controller_keyboard.h"
+
+static const struct {
+    const char *code;
+    int scancode;
+} keymap_browser[] = {
+    {"Escape", 0x01},
+    {"Digit1", 0x02 },
+    {"Digit2", 0x03 },
+    {"Digit3", 0x04 },
+    {"Digit4", 0x05 },
+    {"Digit5", 0x06 },
+    {"Digit6", 0x07 },
+    {"Digit7", 0x08 },
+    {"Digit8", 0x09 },
+    {"Digit9", 0x0a },
+    {"Digit0", 0x0b },
+    {"Minus", 0x0c },
+    {"Equal", 0x0d },
+    {"Backspace", 0x0e },
+    {"Tab", 0x0f },
+    {"KeyQ", 0x10 },
+    {"KeyW", 0x11 },
+    {"KeyE", 0x12 },
+    {"KeyR", 0x13 },
+    {"KeyT", 0x14 },
+    {"KeyY", 0x15 },
+    {"KeyU", 0x16 },
+    {"KeyI", 0x17 },
+    {"KeyO", 0x18 },
+    {"KeyP", 0x19 },
+    {"BracketLeft", 0x1a },
+    {"BracketRight", 0x1b },
+    {"Enter", 0x1c },
+    {"ControlLeft", 0x1d },
+    {"KeyA", 0x1e },
+    {"KeyS", 0x1f },
+    {"KeyD", 0x20 },
+    {"KeyF", 0x21 },
+    {"KeyG", 0x22 },
+    {"KeyH", 0x23 },
+    {"KeyJ", 0x24 },
+    {"KeyK", 0x25 },
+    {"KeyL", 0x26 },
+    {"Semicolon", 0x27 },
+    {"Quote", 0x28 },
+    {"Backquote", 0x29 },
+    {"ShiftLeft", 0x2a },
+    {"Backslash", 0x2b },
+    {"KeyZ", 0x2c },
+    {"KeyX", 0x2d },
+    {"KeyC", 0x2e },
+    {"KeyV", 0x2f },
+    {"KeyB", 0x30 },
+    {"KeyN", 0x31 },
+    {"KeyM", 0x32 },
+    {"Comma", 0x33 },
+    {"Period", 0x34 },
+    {"Slash", 0x35 },
+    {"ShiftRight", 0x36 },
+    {"NumpadMultiply", 0x37 },
+    {"AltLeft", 0x38 },
+    {"Space", 0x39 },
+    {"CapsLock", 0x3a },
+    {"F1", 0x3b },
+    {"F2", 0x3c },
+    {"F3", 0x3d },
+    {"F4", 0x3e },
+    {"F5", 0x3f },
+    {"F6", 0x40 },
+    {"F7", 0x41 },
+    {"F8", 0x42 },
+    {"F9", 0x43 },
+    {"F10", 0x44 },
+    {"NumLock", 0x45 },
+    {"ScrollLock", 0x46 },
+    {"Numpad7", 0x47 },
+    {"Numpad8", 0x48 },
+    {"Numpad9", 0x49 },
+    {"NumpadSubtract", 0x4a },
+    {"Numpad4", 0x4b },
+    {"Numpad5", 0x4c },
+    {"Numpad6", 0x4d },
+    {"NumpadAdd", 0x4e },
+    {"Numpad1", 0x4f },
+    {"Numpad2", 0x50 },
+    {"Numpad3", 0x51 },
+    {"Numpad0", 0x52 },
+    {"NumpadDecimal", 0x53 },
+    {"PrintScreen", 0x54 },
+    // 0x55
+    {"IntlBackslash", 0x56 },
+    {"F11", 0x57 },
+    {"F12", 0x58 },
+    {"IntlRo", 0x59 },
+    //{"Katakana", 0 },
+    //{"Hiragana", 0 },
+    {"NumpadEnter", 0x11c },
+    {"ControlRight", 0x11d },
+    {"NumpadDivide", 0x135 },
+    {"AltRight", 0x138 },
+    {"Home", 0x147 },
+    {"ArrowUp", 0x148 },
+    {"PageUp", 0x149 },
+    {"ArrowLeft", 0x14b },
+    {"ArrowRight", 0x14d },
+    {"End", 0x14f },
+    {"ArrowDown", 0x150 },
+    {"PageDown", 0x151 },
+    {"Insert", 0x152 },
+    {"Delete", 0x153 },
+    {"Pause", 0x21d },
+    {"MetaLeft", 0x15b },
+    {"MetaRight", 0x15c },
+    {"ContextMenu", 0x15d },
+};
+
+static EM_BOOL controller_emscripten_keyboard_handler(int event_type, const EmscriptenKeyboardEvent *key_event, UNUSED void *user_data) {
+    for (size_t i = 0; i < sizeof(keymap_browser) / sizeof(keymap_browser[0]); i++) {
+        if (strcmp(key_event->code, keymap_browser[i].code) == 0) {
+            if (event_type == EMSCRIPTEN_EVENT_KEYDOWN) {
+                return keyboard_on_key_down(keymap_browser[i].scancode);
+            } else if (event_type == EMSCRIPTEN_EVENT_KEYUP) {
+                return keyboard_on_key_up(keymap_browser[i].scancode);
+            }
+            break;
+        }
+    }
+    return EM_FALSE;
+}
+
+static EM_BOOL controller_emscripten_keyboard_blur_handler(UNUSED int event_type, UNUSED const EmscriptenFocusEvent *focus_event, UNUSED void *user_data) {
+    keyboard_on_all_keys_up();
+    return EM_TRUE;
+}
+
+void controller_emscripten_keyboard_init(void) {
+    // Should be #window according to docs, but that crashes
+    const char *target = EMSCRIPTEN_EVENT_TARGET_WINDOW;
+
+    emscripten_set_keydown_callback(target, NULL, EM_FALSE, controller_emscripten_keyboard_handler);
+    emscripten_set_keyup_callback(target, NULL, EM_FALSE, controller_emscripten_keyboard_handler);
+    emscripten_set_blur_callback(target, NULL, EM_FALSE, controller_emscripten_keyboard_blur_handler);
+}
+
+#endif
diff --git a/src/pc/controller/controller_emscripten_keyboard.h b/src/pc/controller/controller_emscripten_keyboard.h
new file mode 100644
index 0000000..9b72873
--- /dev/null
+++ b/src/pc/controller/controller_emscripten_keyboard.h
@@ -0,0 +1,8 @@
+#ifndef CONTROLLER_KEYBOARD_EMSCRIPTEN_H
+#define CONTROLLER_KEYBOARD_EMSCRIPTEN_H
+
+#ifdef TARGET_WEB
+void controller_emscripten_keyboard_init(void);
+#endif
+
+#endif
diff --git a/src/pc/controller/controller_entry_point.c b/src/pc/controller/controller_entry_point.c
new file mode 100644
index 0000000..e10637c
--- /dev/null
+++ b/src/pc/controller/controller_entry_point.c
@@ -0,0 +1,51 @@
+#include "lib/src/libultra_internal.h"
+#include "lib/src/osContInternal.h"
+
+#include "controller_recorded_tas.h"
+#include "controller_keyboard.h"
+
+#if defined(_WIN32) || defined(_WIN64)
+#include "controller_xinput.h"
+#else
+#include "controller_sdl.h"
+#endif
+
+#ifdef __linux__
+#include "controller_wup.h"
+#endif
+
+static struct ControllerAPI *controller_implementations[] = {
+    &controller_recorded_tas,
+#if defined(_WIN32) || defined(_WIN64)
+    &controller_xinput,
+#else
+    &controller_sdl,
+#endif
+#ifdef __linux__
+    &controller_wup,
+#endif
+    &controller_keyboard,
+};
+
+s32 osContInit(OSMesgQueue *mq, u8 *controllerBits, OSContStatus *status) {
+    for (size_t i = 0; i < sizeof(controller_implementations) / sizeof(struct ControllerAPI *); i++) {
+        controller_implementations[i]->init();
+    }
+    *controllerBits = 1;
+    return 0;
+}
+
+s32 osContStartReadData(OSMesgQueue *mesg) {
+    return 0;
+}
+
+void osContGetReadData(OSContPad *pad) {
+    pad->button = 0;
+    pad->stick_x = 0;
+    pad->stick_y = 0;
+    pad->errnum = 0;
+
+    for (size_t i = 0; i < sizeof(controller_implementations) / sizeof(struct ControllerAPI *); i++) {
+        controller_implementations[i]->read(pad);
+    }
+}
diff --git a/src/pc/controller/controller_keyboard.c b/src/pc/controller/controller_keyboard.c
new file mode 100644
index 0000000..a49b86a
--- /dev/null
+++ b/src/pc/controller/controller_keyboard.c
@@ -0,0 +1,88 @@
+#include <stdbool.h>
+#include <ultra64.h>
+
+#include "controller_api.h"
+
+#ifdef TARGET_WEB
+#include "controller_emscripten_keyboard.h"
+#endif
+
+#include "../configfile.h"
+
+static int keyboard_buttons_down;
+
+static int keyboard_mapping[13][2];
+
+static int keyboard_map_scancode(int scancode) {
+    int ret = 0;
+    for (size_t i = 0; i < sizeof(keyboard_mapping) / sizeof(keyboard_mapping[0]); i++) {
+        if (keyboard_mapping[i][0] == scancode) {
+            ret |= keyboard_mapping[i][1];
+        }
+    }
+    return ret;
+}
+
+bool keyboard_on_key_down(int scancode) {
+    int mapped = keyboard_map_scancode(scancode);
+    keyboard_buttons_down |= mapped;
+    return mapped != 0;
+}
+
+bool keyboard_on_key_up(int scancode) {
+    int mapped = keyboard_map_scancode(scancode);
+    keyboard_buttons_down &= ~mapped;
+    return mapped != 0;
+}
+
+void keyboard_on_all_keys_up(void) {
+    keyboard_buttons_down = 0;
+}
+
+static void set_keyboard_mapping(int index, int mask, int scancode) {
+    keyboard_mapping[index][0] = scancode;
+    keyboard_mapping[index][1] = mask;
+}
+
+static void keyboard_init(void) {
+    int i = 0;
+
+    set_keyboard_mapping(i++, 0x80000,      configKeyStickUp);
+    set_keyboard_mapping(i++, 0x10000,      configKeyStickLeft);
+    set_keyboard_mapping(i++, 0x40000,      configKeyStickDown);
+    set_keyboard_mapping(i++, 0x20000,      configKeyStickRight);
+    set_keyboard_mapping(i++, A_BUTTON,     configKeyA);
+    set_keyboard_mapping(i++, B_BUTTON,     configKeyB);
+    set_keyboard_mapping(i++, Z_TRIG,       configKeyZ);
+    set_keyboard_mapping(i++, U_CBUTTONS,   configKeyCUp);
+    set_keyboard_mapping(i++, L_CBUTTONS,   configKeyCLeft);
+    set_keyboard_mapping(i++, D_CBUTTONS,   configKeyCDown);
+    set_keyboard_mapping(i++, R_CBUTTONS,   configKeyCRight);
+    set_keyboard_mapping(i++, R_TRIG,       configKeyR);
+    set_keyboard_mapping(i++, START_BUTTON, configKeyStart);
+
+#ifdef TARGET_WEB
+    controller_emscripten_keyboard_init();
+#endif
+}
+
+static void keyboard_read(OSContPad *pad) {
+    pad->button |= keyboard_buttons_down;
+    if ((keyboard_buttons_down & 0x30000) == 0x10000) {
+        pad->stick_x = -128;
+    }
+    if ((keyboard_buttons_down & 0x30000) == 0x20000) {
+        pad->stick_x = 127;
+    }
+    if ((keyboard_buttons_down & 0xc0000) == 0x40000) {
+        pad->stick_y = -128;
+    }
+    if ((keyboard_buttons_down & 0xc0000) == 0x80000) {
+        pad->stick_y = 127;
+    }
+}
+
+struct ControllerAPI controller_keyboard = {
+    keyboard_init,
+    keyboard_read
+};
diff --git a/src/pc/controller/controller_keyboard.h b/src/pc/controller/controller_keyboard.h
new file mode 100644
index 0000000..e2c0858
--- /dev/null
+++ b/src/pc/controller/controller_keyboard.h
@@ -0,0 +1,19 @@
+#ifndef CONTROLLER_KEYBOARD_H
+#define CONTROLLER_KEYBOARD_H
+
+#include <stdbool.h>
+#include "controller_api.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+bool keyboard_on_key_down(int scancode);
+bool keyboard_on_key_up(int scancode);
+void keyboard_on_all_keys_up(void);
+#ifdef __cplusplus
+}
+#endif
+
+extern struct ControllerAPI controller_keyboard;
+
+#endif
diff --git a/src/pc/controller/controller_recorded_tas.c b/src/pc/controller/controller_recorded_tas.c
new file mode 100644
index 0000000..4f5c1bb
--- /dev/null
+++ b/src/pc/controller/controller_recorded_tas.c
@@ -0,0 +1,29 @@
+#include <stdio.h>
+#include <ultra64.h>
+
+#include "controller_api.h"
+
+static FILE *fp;
+
+static void tas_init(void) {
+    fp = fopen("cont.m64", "rb");
+    if (fp != NULL) {
+        uint8_t buf[0x400];
+        fread(buf, 1, sizeof(buf), fp);
+    }
+}
+
+static void tas_read(OSContPad *pad) {
+    if (fp != NULL) {
+        uint8_t bytes[4] = {0};
+        fread(bytes, 1, 4, fp);
+        pad->button = (bytes[0] << 8) | bytes[1];
+        pad->stick_x = bytes[2];
+        pad->stick_y = bytes[3];
+    }
+}
+
+struct ControllerAPI controller_recorded_tas = {
+    tas_init,
+    tas_read
+};
diff --git a/src/pc/controller/controller_recorded_tas.h b/src/pc/controller/controller_recorded_tas.h
new file mode 100644
index 0000000..15ead4b
--- /dev/null
+++ b/src/pc/controller/controller_recorded_tas.h
@@ -0,0 +1,8 @@
+#ifndef CONTROLLER_RECORDED_TAS_H
+#define CONTROLLER_RECORDED_TAS_H
+
+#include "controller_api.h"
+
+extern struct ControllerAPI controller_recorded_tas;
+
+#endif
diff --git a/src/pc/controller/controller_sdl.c b/src/pc/controller/controller_sdl.c
new file mode 100644
index 0000000..c3ab242
--- /dev/null
+++ b/src/pc/controller/controller_sdl.c
@@ -0,0 +1,102 @@
+#if !defined(_WIN32) && !defined(_WIN64)
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <math.h>
+
+#include <SDL2/SDL.h>
+
+#include <ultra64.h>
+
+#include "controller_api.h"
+
+#define DEADZONE 4960
+
+static bool init_ok;
+static SDL_GameController *sdl_cntrl;
+
+static void controller_sdl_init(void) {
+    if (SDL_Init(SDL_INIT_GAMECONTROLLER) != 0) {
+        fprintf(stderr, "SDL init error: %s\n", SDL_GetError());
+        return;
+    }
+
+    init_ok = true;
+}
+
+static void controller_sdl_read(OSContPad *pad) {
+    if (!init_ok) {
+        return;
+    }
+
+    SDL_GameControllerUpdate();
+
+    if (sdl_cntrl != NULL && !SDL_GameControllerGetAttached(sdl_cntrl)) {
+        SDL_GameControllerClose(sdl_cntrl);
+        sdl_cntrl = NULL;
+    }
+    if (sdl_cntrl == NULL) {
+        for (int i = 0; i < SDL_NumJoysticks(); i++) {
+            if (SDL_IsGameController(i)) {
+                sdl_cntrl = SDL_GameControllerOpen(i);
+                if (sdl_cntrl != NULL) {
+                    break;
+                }
+            }
+        }
+        if (sdl_cntrl == NULL) {
+            return;
+        }
+    }
+
+    if (SDL_GameControllerGetButton(sdl_cntrl, SDL_CONTROLLER_BUTTON_START)) pad->button |= START_BUTTON;
+    if (SDL_GameControllerGetButton(sdl_cntrl, SDL_CONTROLLER_BUTTON_LEFTSHOULDER)) pad->button |= Z_TRIG;
+    if (SDL_GameControllerGetButton(sdl_cntrl, SDL_CONTROLLER_BUTTON_RIGHTSHOULDER)) pad->button |= R_TRIG;
+    if (SDL_GameControllerGetButton(sdl_cntrl, SDL_CONTROLLER_BUTTON_A)) pad->button |= A_BUTTON;
+    if (SDL_GameControllerGetButton(sdl_cntrl, SDL_CONTROLLER_BUTTON_X)) pad->button |= B_BUTTON;
+
+    int16_t leftx = SDL_GameControllerGetAxis(sdl_cntrl, SDL_CONTROLLER_AXIS_LEFTX);
+    int16_t lefty = SDL_GameControllerGetAxis(sdl_cntrl, SDL_CONTROLLER_AXIS_LEFTY);
+    int16_t rightx = SDL_GameControllerGetAxis(sdl_cntrl, SDL_CONTROLLER_AXIS_RIGHTX);
+    int16_t righty = SDL_GameControllerGetAxis(sdl_cntrl, SDL_CONTROLLER_AXIS_RIGHTY);
+
+    int16_t ltrig = SDL_GameControllerGetAxis(sdl_cntrl, SDL_CONTROLLER_AXIS_TRIGGERLEFT);
+    int16_t rtrig = SDL_GameControllerGetAxis(sdl_cntrl, SDL_CONTROLLER_AXIS_TRIGGERRIGHT);
+
+#ifdef TARGET_WEB
+    // Firefox has a bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1606562
+    // It sets down y to 32768.0f / 32767.0f, which is greater than the allowed 1.0f,
+    // which SDL then converts to a int16_t by multiplying by 32767.0f, which overflows into -32768.
+    // Maximum up will hence never become -32768 with the current version of SDL2,
+    // so this workaround should be safe in compliant browsers.
+    if (lefty == -32768) {
+        lefty = 32767;
+    }
+    if (righty == -32768) {
+        righty = 32767;
+    }
+#endif
+
+    if (rightx < -0x4000) pad->button |= L_CBUTTONS;
+    if (rightx > 0x4000) pad->button |= R_CBUTTONS;
+    if (righty < -0x4000) pad->button |= U_CBUTTONS;
+    if (righty > 0x4000) pad->button |= D_CBUTTONS;
+
+    if (ltrig > 30 * 256) pad->button |= Z_TRIG;
+    if (rtrig > 30 * 256) pad->button |= R_TRIG;
+
+    uint32_t magnitude_sq = (uint32_t)(leftx * leftx) + (uint32_t)(lefty * lefty);
+    if (magnitude_sq > (uint32_t)(DEADZONE * DEADZONE)) {
+        pad->stick_x = leftx / 0x100;
+        int stick_y = -lefty / 0x100;
+        pad->stick_y = stick_y == 128 ? 127 : stick_y;
+    }
+}
+
+struct ControllerAPI controller_sdl = {
+    controller_sdl_init,
+    controller_sdl_read
+};
+
+#endif
diff --git a/src/pc/controller/controller_sdl.h b/src/pc/controller/controller_sdl.h
new file mode 100644
index 0000000..02aec8d
--- /dev/null
+++ b/src/pc/controller/controller_sdl.h
@@ -0,0 +1,8 @@
+#ifndef CONTROLLER_SDL_H
+#define CONTROLLER_SDL_H
+
+#include "controller_api.h"
+
+extern struct ControllerAPI controller_sdl;
+
+#endif
diff --git a/src/pc/controller/controller_wup.c b/src/pc/controller/controller_wup.c
new file mode 100644
index 0000000..0a675ff
--- /dev/null
+++ b/src/pc/controller/controller_wup.c
@@ -0,0 +1,51 @@
+#ifdef __linux__
+
+#include <stdbool.h>
+#include <pthread.h>
+
+#include <ultra64.h>
+
+#include "controller_api.h"
+
+void *wup_start(void *a);
+bool wup_get_controller_input(uint16_t *buttons, uint8_t axis[6]);
+
+static int8_t saturate(int v) {
+    v = v * 3 / 2;
+    return v < -128 ? -128 : v > 127 ? 127 : v;
+}
+
+static void controller_wup_init(void) {
+    pthread_t pid;
+    pthread_create(&pid, NULL, wup_start, NULL);
+}
+
+static void controller_wup_read(OSContPad *pad) {
+    uint16_t buttons;
+    uint8_t axis[6];
+    if (wup_get_controller_input(&buttons, axis)) {
+        if (buttons & 0x0001) pad->button |= START_BUTTON;
+        if (buttons & 0x0008) pad->button |= Z_TRIG;
+        if (buttons & 0x0004) pad->button |= R_TRIG;
+        if (buttons & 0x0100) pad->button |= A_BUTTON;
+        if (buttons & 0x0200) pad->button |= B_BUTTON;
+        if (buttons & 0x1000) pad->button |= L_TRIG;
+        if (axis[2] < 0x40) pad->button |= L_CBUTTONS;
+        if (axis[2] > 0xC0) pad->button |= R_CBUTTONS;
+        if (axis[3] < 0x40) pad->button |= D_CBUTTONS;
+        if (axis[3] > 0xC0) pad->button |= U_CBUTTONS;
+        int8_t stick_x = saturate(axis[0] - 128 - 0);
+        int8_t stick_y = saturate(axis[1] - 128 - 0);
+        if (stick_x != 0 || stick_y != 0) {
+            pad->stick_x = stick_x;
+            pad->stick_y = stick_y;
+        }
+    }
+}
+
+struct ControllerAPI controller_wup = {
+    controller_wup_init,
+    controller_wup_read
+};
+
+#endif
diff --git a/src/pc/controller/controller_wup.h b/src/pc/controller/controller_wup.h
new file mode 100644
index 0000000..3c5674c
--- /dev/null
+++ b/src/pc/controller/controller_wup.h
@@ -0,0 +1,12 @@
+#ifndef CONTROLLER_WUP_H
+#define CONTROLLER_WUP_H
+
+#ifdef __linux__
+
+#include "controller_api.h"
+
+extern struct ControllerAPI controller_wup;
+
+#endif
+
+#endif
diff --git a/src/pc/controller/controller_xinput.c b/src/pc/controller/controller_xinput.c
new file mode 100644
index 0000000..bb44bc1
--- /dev/null
+++ b/src/pc/controller/controller_xinput.c
@@ -0,0 +1,49 @@
+#if defined(_WIN32) || defined(_WIN64)
+
+#include <windows.h>
+#include <xinput.h>
+
+#include <ultra64.h>
+
+#include "controller_api.h"
+
+#define DEADZONE 4960
+
+static void xinput_init(void) {
+}
+
+static void xinput_read(OSContPad *pad) {
+    for (int i = 0; i < XUSER_MAX_COUNT; i++) {
+        XINPUT_STATE state;
+        memset(&state, 0, sizeof(XINPUT_STATE));
+        if (XInputGetState(i, &state) == ERROR_SUCCESS) {
+            XINPUT_GAMEPAD *gp = &state.Gamepad;
+            if (gp->wButtons & XINPUT_GAMEPAD_START) pad->button |= START_BUTTON;
+            if (gp->wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER) pad->button |= Z_TRIG;
+            if (gp->bLeftTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD) pad->button |= Z_TRIG;
+            if (gp->wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER) pad->button |= R_TRIG;
+            if (gp->bRightTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD) pad->button |= R_TRIG;
+            if (gp->wButtons & XINPUT_GAMEPAD_A) pad->button |= A_BUTTON;
+            if (gp->wButtons & XINPUT_GAMEPAD_X) pad->button |= B_BUTTON;
+            if (gp->wButtons & XINPUT_GAMEPAD_DPAD_LEFT) pad->button |= L_TRIG;
+            if (gp->sThumbRX < -0x4000) pad->button |= L_CBUTTONS;
+            if (gp->sThumbRX > 0x4000) pad->button |= R_CBUTTONS;
+            if (gp->sThumbRY < -0x4000) pad->button |= D_CBUTTONS;
+            if (gp->sThumbRY > 0x4000) pad->button |= U_CBUTTONS;
+
+            uint32_t magnitude_sq = (uint32_t)(gp->sThumbLX * gp->sThumbLX) + (uint32_t)(gp->sThumbLY * gp->sThumbLY);
+            if (magnitude_sq > (uint32_t)(DEADZONE * DEADZONE)) {
+                pad->stick_x = gp->sThumbLX / 0x100;
+                pad->stick_y = gp->sThumbLY / 0x100;
+            }
+            break;
+        }
+    }
+}
+
+struct ControllerAPI controller_xinput = {
+    xinput_init,
+    xinput_read
+};
+
+#endif
diff --git a/src/pc/controller/controller_xinput.h b/src/pc/controller/controller_xinput.h
new file mode 100644
index 0000000..be1e68c
--- /dev/null
+++ b/src/pc/controller/controller_xinput.h
@@ -0,0 +1,12 @@
+#ifndef CONTROLLER_XINPUT_H
+#define CONTROLLER_XINPUT_H
+
+#if defined(_WIN32) || defined(_WIN64)
+
+#include "controller_api.h"
+
+extern struct ControllerAPI controller_xinput;
+
+#endif
+
+#endif
diff --git a/src/pc/controller/wup.c b/src/pc/controller/wup.c
new file mode 100644
index 0000000..52cc3f3
--- /dev/null
+++ b/src/pc/controller/wup.c
@@ -0,0 +1,360 @@
+#if !defined(__MINGW32__) && !defined(TARGET_WEB)
+// See LICENSE for license
+
+#define _XOPEN_SOURCE 600
+
+#include <time.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <linux/input.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <signal.h>
+#include <errno.h>
+
+//#include <libudev.h>
+#include <libusb.h>
+#include <pthread.h>
+
+#if (!defined(LIBUSBX_API_VERSION) || LIBUSBX_API_VERSION < 0x01000102) && (!defined(LIBUSB_API_VERSION) || LIBUSB_API_VERSION < 0x01000102)
+#error libusb(x) 1.0.16 or higher is required
+#endif
+
+#define EP_IN  0x81
+#define EP_OUT 0x02
+
+#define STATE_NORMAL   0x10
+#define STATE_WAVEBIRD 0x20
+
+const int BUTTON_OFFSET_VALUES[16] = {
+   BTN_START,
+   BTN_TR2,
+   BTN_TR,
+   BTN_TL,
+   -1,
+   -1,
+   -1,
+   -1,
+   BTN_SOUTH,
+   BTN_WEST,
+   BTN_EAST,
+   BTN_NORTH,
+   BTN_DPAD_LEFT,
+   BTN_DPAD_RIGHT,
+   BTN_DPAD_DOWN,
+   BTN_DPAD_UP,
+};
+
+const int AXIS_OFFSET_VALUES[6] = {
+   ABS_X,
+   ABS_Y,
+   ABS_RX,
+   ABS_RY,
+   ABS_Z,
+   ABS_RZ
+};
+
+struct ports
+{
+   bool connected;
+   bool extra_power;
+   unsigned char type;
+   uint16_t buttons;
+   uint8_t axis[6];
+};
+
+struct adapter
+{
+   volatile bool quitting;
+   struct libusb_device *device;
+   struct libusb_device_handle *handle;
+   pthread_t thread;
+   unsigned char rumble[5];
+   struct ports controllers[4];
+   struct adapter *next;
+};
+
+static bool raw_mode;
+
+static volatile int quitting;
+
+static struct adapter adapters;
+
+static const char *uinput_path;
+
+bool wup_get_controller_input(uint16_t* buttons, uint8_t axis[6]) {
+    struct adapter *adapter = adapters.next;
+    if (adapter != NULL) {
+        *buttons = adapter->controllers[0].buttons;
+        memcpy(axis, adapter->controllers[0].axis, 6);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+static unsigned char connected_type(unsigned char status)
+{
+   unsigned char type = status & (STATE_NORMAL | STATE_WAVEBIRD);
+   switch (type)
+   {
+      case STATE_NORMAL:
+      case STATE_WAVEBIRD:
+         return type;
+      default:
+         return 0;
+   }
+}
+
+static void handle_payload(int i, struct ports *port, unsigned char *payload)
+{
+   unsigned char status = payload[0];
+   unsigned char type = connected_type(status);
+
+   if (type != 0 && !port->connected)
+   {
+      //uinput_create(i, port, type);
+       port->type = type;
+       port->connected = true;
+   }
+   else if (type == 0 && port->connected)
+   {
+      //uinput_destroy(i, port);
+       port->connected = false;
+   }
+
+   if (!port->connected)
+      return;
+
+   port->extra_power = ((status & 0x04) != 0);
+
+   if (type != port->type)
+   {
+      fprintf(stderr, "controller on port %d changed controller type???", i+1);
+      port->type = type;
+   }
+
+   uint16_t btns = (uint16_t) payload[1] << 8 | (uint16_t) payload[2];
+   port->buttons = btns;
+   //printf("Btns: %04x\n", btns);
+
+   //printf("Axis:");
+   for (int j = 0; j < 6; j++)
+   {
+      unsigned char value = payload[j+3];
+      port->axis[j] = value;
+      //printf(" %02x", value);
+   }
+   //puts("");
+}
+
+static int64_t to_ms(struct timespec* t) {
+    return t->tv_sec * 1000 + t->tv_nsec / 1000000;
+}
+
+static void *adapter_thread(void *data)
+{
+   struct adapter *a = (struct adapter *)data;
+
+    int bytes_transferred;
+    unsigned char payload[1] = { 0x13 };
+
+    int transfer_ret = libusb_interrupt_transfer(a->handle, EP_OUT, payload, sizeof(payload), &bytes_transferred, 0);
+
+    if (transfer_ret != 0) {
+        fprintf(stderr, "libusb_interrupt_transfer: %s\n", libusb_error_name(transfer_ret));
+        return NULL;
+    }
+    if (bytes_transferred != sizeof(payload)) {
+        fprintf(stderr, "libusb_interrupt_transfer %d/%d bytes transferred.\n", bytes_transferred, sizeof(payload));
+        return NULL;
+    }
+
+   while (!a->quitting)
+   {
+      struct timespec time_before = { 0 }, time_after = { 0 };
+      unsigned char payload[37];
+      int size = 0;
+      //clock_gettime(CLOCK_MONOTONIC, &time_before);
+      int transfer_ret = libusb_interrupt_transfer(a->handle, EP_IN, payload, sizeof(payload), &size, 0);
+      //clock_gettime(CLOCK_MONOTONIC, &time_after);
+      //printf("Time taken: %d\n", (int)(to_ms(&time_after) - to_ms(&time_before)));
+      if (transfer_ret != 0) {
+         fprintf(stderr, "libusb_interrupt_transfer error %d\n", transfer_ret);
+         a->quitting = true;
+         break;
+      }
+      if (size != 37 || payload[0] != 0x21)
+         continue;
+      
+      unsigned char *controller = &payload[1];
+
+      unsigned char rumble[5] = { 0x11, 0, 0, 0, 0 };
+      //struct timespec current_time = { 0 };
+      //clock_gettime(CLOCK_REALTIME, &current_time);
+      //printf("Time: %d %d\n", (int)current_time.tv_sec, (int)current_time.tv_nsec);
+      for (int i = 0; i < 4; i++, controller += 9)
+      {
+         handle_payload(i, &a->controllers[i], controller);
+         rumble[i+1] = 0;
+         /*if (a->controllers[i].extra_power && a->controllers[i].type == STATE_NORMAL)
+         {
+            for (int j = 0; j < MAX_FF_EVENTS; j++)
+            {
+               struct ff_event *e = &a->controllers[i].ff_events[j];
+               if (e->in_use)
+               {
+                  if (ts_lessthan(&e->start_time, &current_time) && ts_greaterthan(&e->end_time, &current_time))
+                     rumble[i+1] = 1;
+                  else
+                     update_ff_start_stop(e, &current_time);
+               }
+            }
+         }*/
+      }
+
+      if (memcmp(rumble, a->rumble, sizeof(rumble)) != 0)
+      {
+         memcpy(a->rumble, rumble, sizeof(rumble));
+         transfer_ret = libusb_interrupt_transfer(a->handle, EP_OUT, a->rumble, sizeof(a->rumble), &size, 0);
+         if (transfer_ret != 0) {
+            fprintf(stderr, "libusb_interrupt_transfer error %d\n", transfer_ret);
+            a->quitting = true;
+            break;
+         }
+      }
+   }
+
+   for (int i = 0; i < 4; i++)
+   {
+      /*if (a->controllers[i].connected)
+         uinput_destroy(i, &a->controllers[i]);*/
+   }
+
+   return NULL;
+}
+
+static void add_adapter(struct libusb_device *dev)
+{
+   struct adapter *a = calloc(1, sizeof(struct adapter));
+   if (a == NULL)
+   {
+      fprintf(stderr, "FATAL: calloc() failed");
+      exit(-1);
+   }
+   a->device = dev;
+
+   if (libusb_open(a->device, &a->handle) != 0)
+   {
+      fprintf(stderr, "Error opening device 0x%p\n", a->device);
+      return;
+   }
+
+   if (libusb_kernel_driver_active(a->handle, 0) == 1) {
+       fprintf(stderr, "Detaching kernel driver\n");
+       if (libusb_detach_kernel_driver(a->handle, 0)) {
+           fprintf(stderr, "Error detaching handle 0x%p from kernel\n", a->handle);
+           return;
+       }
+   }
+
+   struct adapter *old_head = adapters.next;
+   adapters.next = a;
+   a->next = old_head;
+
+   pthread_create(&a->thread, NULL, adapter_thread, a);
+
+   fprintf(stderr, "adapter 0x%p connected\n", a->device);
+}
+
+static void remove_adapter(struct libusb_device *dev)
+{
+   struct adapter *a = &adapters;
+   while (a->next != NULL)
+   {
+      if (a->next->device == dev)
+      {
+         a->next->quitting = true;
+         pthread_join(a->next->thread, NULL);
+         fprintf(stderr, "adapter 0x%p disconnected\n", a->next->device);
+         libusb_close(a->next->handle);
+         struct adapter *new_next = a->next->next;
+         free(a->next);
+         a->next = new_next;
+         return;
+      }
+
+      a = a->next;
+   }
+}
+
+static int LIBUSB_CALL hotplug_callback(struct libusb_context *ctx, struct libusb_device *dev, libusb_hotplug_event event, void *user_data)
+{
+   (void)ctx;
+   (void)user_data;
+   if (event == LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED)
+   {
+      add_adapter(dev);
+   }
+   else if (event == LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT)
+   {
+      remove_adapter(dev);
+   }
+
+   return 0;
+}
+
+void* wup_start(void* a)
+{
+   libusb_init(NULL);
+
+   struct libusb_device **devices;
+
+   int count = libusb_get_device_list(NULL, &devices);
+
+   for (int i = 0; i < count; i++)
+   {
+      struct libusb_device_descriptor desc;
+      libusb_get_device_descriptor(devices[i], &desc);
+      if (desc.idVendor == 0x057e && desc.idProduct == 0x0337)
+         add_adapter(devices[i]);
+   }
+
+   if (count > 0)
+      libusb_free_device_list(devices, 1);
+
+   libusb_hotplug_callback_handle callback;
+
+   int hotplug_capability = libusb_has_capability(LIBUSB_CAP_HAS_HOTPLUG);
+   if (hotplug_capability) {
+       int hotplug_ret = libusb_hotplug_register_callback(NULL,
+             LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED | LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT,
+             LIBUSB_HOTPLUG_NO_FLAGS, 0x057e, 0x0337,
+             LIBUSB_HOTPLUG_MATCH_ANY, hotplug_callback, NULL, &callback);
+
+       if (hotplug_ret != LIBUSB_SUCCESS) {
+           fprintf(stderr, "cannot register hotplug callback, hotplugging not enabled\n");
+           hotplug_capability = 0;
+       }
+   }
+
+   // pump events until shutdown & all helper threads finish cleaning up
+   while (!quitting)
+      libusb_handle_events_completed(NULL, (int *)&quitting);
+
+   while (adapters.next)
+      remove_adapter(adapters.next->device);
+
+   if (hotplug_capability)
+      libusb_hotplug_deregister_callback(NULL, callback);
+
+   libusb_exit(NULL);
+   return (void*)0;
+}
+#endif
diff --git a/src/pc/gfx/dxsdk/d3d12.h b/src/pc/gfx/dxsdk/d3d12.h
new file mode 100644
index 0000000..0c1c815
--- /dev/null
+++ b/src/pc/gfx/dxsdk/d3d12.h
@@ -0,0 +1,17258 @@
+/*-------------------------------------------------------------------------------------
+ *
+ * Copyright (c) Microsoft Corporation
+ *
+ *-------------------------------------------------------------------------------------*/
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 8.01.0622 */
+
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 500
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif /* __RPCNDR_H_VERSION__ */
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __d3d12_h__
+#define __d3d12_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __ID3D12Object_FWD_DEFINED__
+#define __ID3D12Object_FWD_DEFINED__
+typedef interface ID3D12Object ID3D12Object;
+
+#endif   /* __ID3D12Object_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DeviceChild_FWD_DEFINED__
+#define __ID3D12DeviceChild_FWD_DEFINED__
+typedef interface ID3D12DeviceChild ID3D12DeviceChild;
+
+#endif   /* __ID3D12DeviceChild_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12RootSignature_FWD_DEFINED__
+#define __ID3D12RootSignature_FWD_DEFINED__
+typedef interface ID3D12RootSignature ID3D12RootSignature;
+
+#endif   /* __ID3D12RootSignature_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12RootSignatureDeserializer_FWD_DEFINED__
+#define __ID3D12RootSignatureDeserializer_FWD_DEFINED__
+typedef interface ID3D12RootSignatureDeserializer ID3D12RootSignatureDeserializer;
+
+#endif   /* __ID3D12RootSignatureDeserializer_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12VersionedRootSignatureDeserializer_FWD_DEFINED__
+#define __ID3D12VersionedRootSignatureDeserializer_FWD_DEFINED__
+typedef interface ID3D12VersionedRootSignatureDeserializer ID3D12VersionedRootSignatureDeserializer;
+
+#endif   /* __ID3D12VersionedRootSignatureDeserializer_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Pageable_FWD_DEFINED__
+#define __ID3D12Pageable_FWD_DEFINED__
+typedef interface ID3D12Pageable ID3D12Pageable;
+
+#endif   /* __ID3D12Pageable_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Heap_FWD_DEFINED__
+#define __ID3D12Heap_FWD_DEFINED__
+typedef interface ID3D12Heap ID3D12Heap;
+
+#endif   /* __ID3D12Heap_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Resource_FWD_DEFINED__
+#define __ID3D12Resource_FWD_DEFINED__
+typedef interface ID3D12Resource ID3D12Resource;
+
+#endif   /* __ID3D12Resource_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12CommandAllocator_FWD_DEFINED__
+#define __ID3D12CommandAllocator_FWD_DEFINED__
+typedef interface ID3D12CommandAllocator ID3D12CommandAllocator;
+
+#endif   /* __ID3D12CommandAllocator_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Fence_FWD_DEFINED__
+#define __ID3D12Fence_FWD_DEFINED__
+typedef interface ID3D12Fence ID3D12Fence;
+
+#endif   /* __ID3D12Fence_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Fence1_FWD_DEFINED__
+#define __ID3D12Fence1_FWD_DEFINED__
+typedef interface ID3D12Fence1 ID3D12Fence1;
+
+#endif   /* __ID3D12Fence1_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12PipelineState_FWD_DEFINED__
+#define __ID3D12PipelineState_FWD_DEFINED__
+typedef interface ID3D12PipelineState ID3D12PipelineState;
+
+#endif   /* __ID3D12PipelineState_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DescriptorHeap_FWD_DEFINED__
+#define __ID3D12DescriptorHeap_FWD_DEFINED__
+typedef interface ID3D12DescriptorHeap ID3D12DescriptorHeap;
+
+#endif   /* __ID3D12DescriptorHeap_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12QueryHeap_FWD_DEFINED__
+#define __ID3D12QueryHeap_FWD_DEFINED__
+typedef interface ID3D12QueryHeap ID3D12QueryHeap;
+
+#endif   /* __ID3D12QueryHeap_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12CommandSignature_FWD_DEFINED__
+#define __ID3D12CommandSignature_FWD_DEFINED__
+typedef interface ID3D12CommandSignature ID3D12CommandSignature;
+
+#endif   /* __ID3D12CommandSignature_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12CommandList_FWD_DEFINED__
+#define __ID3D12CommandList_FWD_DEFINED__
+typedef interface ID3D12CommandList ID3D12CommandList;
+
+#endif   /* __ID3D12CommandList_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12GraphicsCommandList_FWD_DEFINED__
+#define __ID3D12GraphicsCommandList_FWD_DEFINED__
+typedef interface ID3D12GraphicsCommandList ID3D12GraphicsCommandList;
+
+#endif   /* __ID3D12GraphicsCommandList_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12GraphicsCommandList1_FWD_DEFINED__
+#define __ID3D12GraphicsCommandList1_FWD_DEFINED__
+typedef interface ID3D12GraphicsCommandList1 ID3D12GraphicsCommandList1;
+
+#endif   /* __ID3D12GraphicsCommandList1_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12GraphicsCommandList2_FWD_DEFINED__
+#define __ID3D12GraphicsCommandList2_FWD_DEFINED__
+typedef interface ID3D12GraphicsCommandList2 ID3D12GraphicsCommandList2;
+
+#endif   /* __ID3D12GraphicsCommandList2_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12CommandQueue_FWD_DEFINED__
+#define __ID3D12CommandQueue_FWD_DEFINED__
+typedef interface ID3D12CommandQueue ID3D12CommandQueue;
+
+#endif   /* __ID3D12CommandQueue_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Device_FWD_DEFINED__
+#define __ID3D12Device_FWD_DEFINED__
+typedef interface ID3D12Device ID3D12Device;
+
+#endif   /* __ID3D12Device_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12PipelineLibrary_FWD_DEFINED__
+#define __ID3D12PipelineLibrary_FWD_DEFINED__
+typedef interface ID3D12PipelineLibrary ID3D12PipelineLibrary;
+
+#endif   /* __ID3D12PipelineLibrary_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12PipelineLibrary1_FWD_DEFINED__
+#define __ID3D12PipelineLibrary1_FWD_DEFINED__
+typedef interface ID3D12PipelineLibrary1 ID3D12PipelineLibrary1;
+
+#endif   /* __ID3D12PipelineLibrary1_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Device1_FWD_DEFINED__
+#define __ID3D12Device1_FWD_DEFINED__
+typedef interface ID3D12Device1 ID3D12Device1;
+
+#endif   /* __ID3D12Device1_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Device2_FWD_DEFINED__
+#define __ID3D12Device2_FWD_DEFINED__
+typedef interface ID3D12Device2 ID3D12Device2;
+
+#endif   /* __ID3D12Device2_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Device3_FWD_DEFINED__
+#define __ID3D12Device3_FWD_DEFINED__
+typedef interface ID3D12Device3 ID3D12Device3;
+
+#endif   /* __ID3D12Device3_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12ProtectedSession_FWD_DEFINED__
+#define __ID3D12ProtectedSession_FWD_DEFINED__
+typedef interface ID3D12ProtectedSession ID3D12ProtectedSession;
+
+#endif   /* __ID3D12ProtectedSession_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12ProtectedResourceSession_FWD_DEFINED__
+#define __ID3D12ProtectedResourceSession_FWD_DEFINED__
+typedef interface ID3D12ProtectedResourceSession ID3D12ProtectedResourceSession;
+
+#endif   /* __ID3D12ProtectedResourceSession_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Device4_FWD_DEFINED__
+#define __ID3D12Device4_FWD_DEFINED__
+typedef interface ID3D12Device4 ID3D12Device4;
+
+#endif   /* __ID3D12Device4_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12LifetimeOwner_FWD_DEFINED__
+#define __ID3D12LifetimeOwner_FWD_DEFINED__
+typedef interface ID3D12LifetimeOwner ID3D12LifetimeOwner;
+
+#endif   /* __ID3D12LifetimeOwner_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12SwapChainAssistant_FWD_DEFINED__
+#define __ID3D12SwapChainAssistant_FWD_DEFINED__
+typedef interface ID3D12SwapChainAssistant ID3D12SwapChainAssistant;
+
+#endif   /* __ID3D12SwapChainAssistant_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12LifetimeTracker_FWD_DEFINED__
+#define __ID3D12LifetimeTracker_FWD_DEFINED__
+typedef interface ID3D12LifetimeTracker ID3D12LifetimeTracker;
+
+#endif   /* __ID3D12LifetimeTracker_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12StateObject_FWD_DEFINED__
+#define __ID3D12StateObject_FWD_DEFINED__
+typedef interface ID3D12StateObject ID3D12StateObject;
+
+#endif   /* __ID3D12StateObject_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12StateObjectProperties_FWD_DEFINED__
+#define __ID3D12StateObjectProperties_FWD_DEFINED__
+typedef interface ID3D12StateObjectProperties ID3D12StateObjectProperties;
+
+#endif   /* __ID3D12StateObjectProperties_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Device5_FWD_DEFINED__
+#define __ID3D12Device5_FWD_DEFINED__
+typedef interface ID3D12Device5 ID3D12Device5;
+
+#endif   /* __ID3D12Device5_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DeviceRemovedExtendedDataSettings_FWD_DEFINED__
+#define __ID3D12DeviceRemovedExtendedDataSettings_FWD_DEFINED__
+typedef interface ID3D12DeviceRemovedExtendedDataSettings ID3D12DeviceRemovedExtendedDataSettings;
+
+#endif   /* __ID3D12DeviceRemovedExtendedDataSettings_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DeviceRemovedExtendedData_FWD_DEFINED__
+#define __ID3D12DeviceRemovedExtendedData_FWD_DEFINED__
+typedef interface ID3D12DeviceRemovedExtendedData ID3D12DeviceRemovedExtendedData;
+
+#endif   /* __ID3D12DeviceRemovedExtendedData_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Device6_FWD_DEFINED__
+#define __ID3D12Device6_FWD_DEFINED__
+typedef interface ID3D12Device6 ID3D12Device6;
+
+#endif   /* __ID3D12Device6_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Resource1_FWD_DEFINED__
+#define __ID3D12Resource1_FWD_DEFINED__
+typedef interface ID3D12Resource1 ID3D12Resource1;
+
+#endif   /* __ID3D12Resource1_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Heap1_FWD_DEFINED__
+#define __ID3D12Heap1_FWD_DEFINED__
+typedef interface ID3D12Heap1 ID3D12Heap1;
+
+#endif   /* __ID3D12Heap1_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12GraphicsCommandList3_FWD_DEFINED__
+#define __ID3D12GraphicsCommandList3_FWD_DEFINED__
+typedef interface ID3D12GraphicsCommandList3 ID3D12GraphicsCommandList3;
+
+#endif   /* __ID3D12GraphicsCommandList3_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12MetaCommand_FWD_DEFINED__
+#define __ID3D12MetaCommand_FWD_DEFINED__
+typedef interface ID3D12MetaCommand ID3D12MetaCommand;
+
+#endif   /* __ID3D12MetaCommand_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12GraphicsCommandList4_FWD_DEFINED__
+#define __ID3D12GraphicsCommandList4_FWD_DEFINED__
+typedef interface ID3D12GraphicsCommandList4 ID3D12GraphicsCommandList4;
+
+#endif   /* __ID3D12GraphicsCommandList4_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Tools_FWD_DEFINED__
+#define __ID3D12Tools_FWD_DEFINED__
+typedef interface ID3D12Tools ID3D12Tools;
+
+#endif   /* __ID3D12Tools_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12GraphicsCommandList5_FWD_DEFINED__
+#define __ID3D12GraphicsCommandList5_FWD_DEFINED__
+typedef interface ID3D12GraphicsCommandList5 ID3D12GraphicsCommandList5;
+
+#endif   /* __ID3D12GraphicsCommandList5_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "oaidl.h"
+#include "ocidl.h"
+#include "dxgicommon.h"
+#include "dxgiformat.h"
+#include "d3dcommon.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_d3d12_0000_0000 */
+/* [local] */ 
+
+#include <winapifamily.h>
+#pragma region App Family
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_GAMES)
+#ifndef _D3D12_CONSTANTS
+#define _D3D12_CONSTANTS
+#define  D3D12_16BIT_INDEX_STRIP_CUT_VALUE ( 0xffff )
+
+#define  D3D12_32BIT_INDEX_STRIP_CUT_VALUE ( 0xffffffff )
+
+#define  D3D12_8BIT_INDEX_STRIP_CUT_VALUE  ( 0xff )
+
+#define  D3D12_APPEND_ALIGNED_ELEMENT  ( 0xffffffff )
+
+#define  D3D12_ARRAY_AXIS_ADDRESS_RANGE_BIT_COUNT  ( 9 )
+
+#define  D3D12_CLIP_OR_CULL_DISTANCE_COUNT ( 8 )
+
+#define  D3D12_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT ( 2 )
+
+#define  D3D12_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT ( 14 )
+
+#define  D3D12_COMMONSHADER_CONSTANT_BUFFER_COMPONENTS ( 4 )
+
+#define  D3D12_COMMONSHADER_CONSTANT_BUFFER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_COMMONSHADER_CONSTANT_BUFFER_HW_SLOT_COUNT  ( 15 )
+
+#define  D3D12_COMMONSHADER_CONSTANT_BUFFER_PARTIAL_UPDATE_EXTENTS_BYTE_ALIGNMENT  ( 16 )
+
+#define  D3D12_COMMONSHADER_CONSTANT_BUFFER_REGISTER_COMPONENTS  ( 4 )
+
+#define  D3D12_COMMONSHADER_CONSTANT_BUFFER_REGISTER_COUNT ( 15 )
+
+#define  D3D12_COMMONSHADER_CONSTANT_BUFFER_REGISTER_READS_PER_INST  ( 1 )
+
+#define  D3D12_COMMONSHADER_CONSTANT_BUFFER_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_COMMONSHADER_FLOWCONTROL_NESTING_LIMIT  ( 64 )
+
+#define  D3D12_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_COMPONENTS  ( 4 )
+
+#define  D3D12_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_COUNT ( 1 )
+
+#define  D3D12_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_READS_PER_INST  ( 1 )
+
+#define  D3D12_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_COMMONSHADER_IMMEDIATE_VALUE_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_COMMONSHADER_INPUT_RESOURCE_REGISTER_COMPONENTS ( 1 )
+
+#define  D3D12_COMMONSHADER_INPUT_RESOURCE_REGISTER_COUNT  ( 128 )
+
+#define  D3D12_COMMONSHADER_INPUT_RESOURCE_REGISTER_READS_PER_INST ( 1 )
+
+#define  D3D12_COMMONSHADER_INPUT_RESOURCE_REGISTER_READ_PORTS ( 1 )
+
+#define  D3D12_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT  ( 128 )
+
+#define  D3D12_COMMONSHADER_SAMPLER_REGISTER_COMPONENTS  ( 1 )
+
+#define  D3D12_COMMONSHADER_SAMPLER_REGISTER_COUNT ( 16 )
+
+#define  D3D12_COMMONSHADER_SAMPLER_REGISTER_READS_PER_INST  ( 1 )
+
+#define  D3D12_COMMONSHADER_SAMPLER_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_COMMONSHADER_SAMPLER_SLOT_COUNT ( 16 )
+
+#define  D3D12_COMMONSHADER_SUBROUTINE_NESTING_LIMIT ( 32 )
+
+#define  D3D12_COMMONSHADER_TEMP_REGISTER_COMPONENTS ( 4 )
+
+#define  D3D12_COMMONSHADER_TEMP_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_COMMONSHADER_TEMP_REGISTER_COUNT  ( 4096 )
+
+#define  D3D12_COMMONSHADER_TEMP_REGISTER_READS_PER_INST ( 3 )
+
+#define  D3D12_COMMONSHADER_TEMP_REGISTER_READ_PORTS ( 3 )
+
+#define  D3D12_COMMONSHADER_TEXCOORD_RANGE_REDUCTION_MAX ( 10 )
+
+#define  D3D12_COMMONSHADER_TEXCOORD_RANGE_REDUCTION_MIN ( -10 )
+
+#define  D3D12_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE  ( -8 )
+
+#define  D3D12_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE  ( 7 )
+
+#define  D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT  ( 256 )
+
+#define  D3D12_CS_4_X_BUCKET00_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 256 )
+
+#define  D3D12_CS_4_X_BUCKET00_MAX_NUM_THREADS_PER_GROUP ( 64 )
+
+#define  D3D12_CS_4_X_BUCKET01_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 240 )
+
+#define  D3D12_CS_4_X_BUCKET01_MAX_NUM_THREADS_PER_GROUP ( 68 )
+
+#define  D3D12_CS_4_X_BUCKET02_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 224 )
+
+#define  D3D12_CS_4_X_BUCKET02_MAX_NUM_THREADS_PER_GROUP ( 72 )
+
+#define  D3D12_CS_4_X_BUCKET03_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 208 )
+
+#define  D3D12_CS_4_X_BUCKET03_MAX_NUM_THREADS_PER_GROUP ( 76 )
+
+#define  D3D12_CS_4_X_BUCKET04_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 192 )
+
+#define  D3D12_CS_4_X_BUCKET04_MAX_NUM_THREADS_PER_GROUP ( 84 )
+
+#define  D3D12_CS_4_X_BUCKET05_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 176 )
+
+#define  D3D12_CS_4_X_BUCKET05_MAX_NUM_THREADS_PER_GROUP ( 92 )
+
+#define  D3D12_CS_4_X_BUCKET06_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 160 )
+
+#define  D3D12_CS_4_X_BUCKET06_MAX_NUM_THREADS_PER_GROUP ( 100 )
+
+#define  D3D12_CS_4_X_BUCKET07_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 144 )
+
+#define  D3D12_CS_4_X_BUCKET07_MAX_NUM_THREADS_PER_GROUP ( 112 )
+
+#define  D3D12_CS_4_X_BUCKET08_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 128 )
+
+#define  D3D12_CS_4_X_BUCKET08_MAX_NUM_THREADS_PER_GROUP ( 128 )
+
+#define  D3D12_CS_4_X_BUCKET09_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 112 )
+
+#define  D3D12_CS_4_X_BUCKET09_MAX_NUM_THREADS_PER_GROUP ( 144 )
+
+#define  D3D12_CS_4_X_BUCKET10_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 96 )
+
+#define  D3D12_CS_4_X_BUCKET10_MAX_NUM_THREADS_PER_GROUP ( 168 )
+
+#define  D3D12_CS_4_X_BUCKET11_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 80 )
+
+#define  D3D12_CS_4_X_BUCKET11_MAX_NUM_THREADS_PER_GROUP ( 204 )
+
+#define  D3D12_CS_4_X_BUCKET12_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 64 )
+
+#define  D3D12_CS_4_X_BUCKET12_MAX_NUM_THREADS_PER_GROUP ( 256 )
+
+#define  D3D12_CS_4_X_BUCKET13_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 48 )
+
+#define  D3D12_CS_4_X_BUCKET13_MAX_NUM_THREADS_PER_GROUP ( 340 )
+
+#define  D3D12_CS_4_X_BUCKET14_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 32 )
+
+#define  D3D12_CS_4_X_BUCKET14_MAX_NUM_THREADS_PER_GROUP ( 512 )
+
+#define  D3D12_CS_4_X_BUCKET15_MAX_BYTES_TGSM_WRITABLE_PER_THREAD  ( 16 )
+
+#define  D3D12_CS_4_X_BUCKET15_MAX_NUM_THREADS_PER_GROUP ( 768 )
+
+#define  D3D12_CS_4_X_DISPATCH_MAX_THREAD_GROUPS_IN_Z_DIMENSION  ( 1 )
+
+#define  D3D12_CS_4_X_RAW_UAV_BYTE_ALIGNMENT ( 256 )
+
+#define  D3D12_CS_4_X_THREAD_GROUP_MAX_THREADS_PER_GROUP ( 768 )
+
+#define  D3D12_CS_4_X_THREAD_GROUP_MAX_X ( 768 )
+
+#define  D3D12_CS_4_X_THREAD_GROUP_MAX_Y ( 768 )
+
+#define  D3D12_CS_4_X_UAV_REGISTER_COUNT ( 1 )
+
+#define  D3D12_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION ( 65535 )
+
+#define  D3D12_CS_TGSM_REGISTER_COUNT  ( 8192 )
+
+#define  D3D12_CS_TGSM_REGISTER_READS_PER_INST ( 1 )
+
+#define  D3D12_CS_TGSM_RESOURCE_REGISTER_COMPONENTS  ( 1 )
+
+#define  D3D12_CS_TGSM_RESOURCE_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_CS_THREADGROUPID_REGISTER_COMPONENTS  ( 3 )
+
+#define  D3D12_CS_THREADGROUPID_REGISTER_COUNT ( 1 )
+
+#define  D3D12_CS_THREADIDINGROUPFLATTENED_REGISTER_COMPONENTS ( 1 )
+
+#define  D3D12_CS_THREADIDINGROUPFLATTENED_REGISTER_COUNT  ( 1 )
+
+#define  D3D12_CS_THREADIDINGROUP_REGISTER_COMPONENTS  ( 3 )
+
+#define  D3D12_CS_THREADIDINGROUP_REGISTER_COUNT ( 1 )
+
+#define  D3D12_CS_THREADID_REGISTER_COMPONENTS ( 3 )
+
+#define  D3D12_CS_THREADID_REGISTER_COUNT  ( 1 )
+
+#define  D3D12_CS_THREAD_GROUP_MAX_THREADS_PER_GROUP ( 1024 )
+
+#define  D3D12_CS_THREAD_GROUP_MAX_X ( 1024 )
+
+#define  D3D12_CS_THREAD_GROUP_MAX_Y ( 1024 )
+
+#define  D3D12_CS_THREAD_GROUP_MAX_Z ( 64 )
+
+#define  D3D12_CS_THREAD_GROUP_MIN_X ( 1 )
+
+#define  D3D12_CS_THREAD_GROUP_MIN_Y ( 1 )
+
+#define  D3D12_CS_THREAD_GROUP_MIN_Z ( 1 )
+
+#define  D3D12_CS_THREAD_LOCAL_TEMP_REGISTER_POOL  ( 16384 )
+
+#define D3D12_DEFAULT_BLEND_FACTOR_ALPHA ( 1.0f )
+#define D3D12_DEFAULT_BLEND_FACTOR_BLUE  ( 1.0f )
+#define D3D12_DEFAULT_BLEND_FACTOR_GREEN ( 1.0f )
+#define D3D12_DEFAULT_BLEND_FACTOR_RED ( 1.0f )
+#define D3D12_DEFAULT_BORDER_COLOR_COMPONENT ( 0.0f )
+#define  D3D12_DEFAULT_DEPTH_BIAS  ( 0 )
+
+#define D3D12_DEFAULT_DEPTH_BIAS_CLAMP ( 0.0f )
+#define  D3D12_DEFAULT_MAX_ANISOTROPY  ( 16 )
+
+#define D3D12_DEFAULT_MIP_LOD_BIAS ( 0.0f )
+#define  D3D12_DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT ( 4194304 )
+
+#define  D3D12_DEFAULT_RENDER_TARGET_ARRAY_INDEX ( 0 )
+
+#define  D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT  ( 65536 )
+
+#define  D3D12_DEFAULT_SAMPLE_MASK ( 0xffffffff )
+
+#define  D3D12_DEFAULT_SCISSOR_ENDX  ( 0 )
+
+#define  D3D12_DEFAULT_SCISSOR_ENDY  ( 0 )
+
+#define  D3D12_DEFAULT_SCISSOR_STARTX  ( 0 )
+
+#define  D3D12_DEFAULT_SCISSOR_STARTY  ( 0 )
+
+#define D3D12_DEFAULT_SLOPE_SCALED_DEPTH_BIAS  ( 0.0f )
+#define  D3D12_DEFAULT_STENCIL_READ_MASK ( 0xff )
+
+#define  D3D12_DEFAULT_STENCIL_REFERENCE ( 0 )
+
+#define  D3D12_DEFAULT_STENCIL_WRITE_MASK  ( 0xff )
+
+#define  D3D12_DEFAULT_VIEWPORT_AND_SCISSORRECT_INDEX  ( 0 )
+
+#define  D3D12_DEFAULT_VIEWPORT_HEIGHT ( 0 )
+
+#define D3D12_DEFAULT_VIEWPORT_MAX_DEPTH ( 0.0f )
+#define D3D12_DEFAULT_VIEWPORT_MIN_DEPTH ( 0.0f )
+#define  D3D12_DEFAULT_VIEWPORT_TOPLEFTX ( 0 )
+
+#define  D3D12_DEFAULT_VIEWPORT_TOPLEFTY ( 0 )
+
+#define  D3D12_DEFAULT_VIEWPORT_WIDTH  ( 0 )
+
+#define  D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND  ( 0xffffffff )
+
+#define  D3D12_DRIVER_RESERVED_REGISTER_SPACE_VALUES_END ( 0xfffffff7 )
+
+#define  D3D12_DRIVER_RESERVED_REGISTER_SPACE_VALUES_START ( 0xfffffff0 )
+
+#define  D3D12_DS_INPUT_CONTROL_POINTS_MAX_TOTAL_SCALARS ( 3968 )
+
+#define  D3D12_DS_INPUT_CONTROL_POINT_REGISTER_COMPONENTS  ( 4 )
+
+#define  D3D12_DS_INPUT_CONTROL_POINT_REGISTER_COMPONENT_BIT_COUNT ( 32 )
+
+#define  D3D12_DS_INPUT_CONTROL_POINT_REGISTER_COUNT ( 32 )
+
+#define  D3D12_DS_INPUT_CONTROL_POINT_REGISTER_READS_PER_INST  ( 2 )
+
+#define  D3D12_DS_INPUT_CONTROL_POINT_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_COMPONENTS ( 3 )
+
+#define  D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_COUNT  ( 1 )
+
+#define  D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_READS_PER_INST ( 2 )
+
+#define  D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_READ_PORTS ( 1 )
+
+#define  D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_COMPONENTS ( 4 )
+
+#define  D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_COUNT  ( 32 )
+
+#define  D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_READS_PER_INST ( 2 )
+
+#define  D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_READ_PORTS ( 1 )
+
+#define  D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_COMPONENTS ( 1 )
+
+#define  D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_COUNT  ( 1 )
+
+#define  D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_READS_PER_INST ( 2 )
+
+#define  D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_READ_PORTS ( 1 )
+
+#define  D3D12_DS_OUTPUT_REGISTER_COMPONENTS ( 4 )
+
+#define  D3D12_DS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_DS_OUTPUT_REGISTER_COUNT  ( 32 )
+
+#define D3D12_FLOAT16_FUSED_TOLERANCE_IN_ULP ( 0.6 )
+#define D3D12_FLOAT32_MAX  ( 3.402823466e+38f )
+#define D3D12_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP  ( 0.6f )
+#define D3D12_FLOAT_TO_SRGB_EXPONENT_DENOMINATOR ( 2.4f )
+#define D3D12_FLOAT_TO_SRGB_EXPONENT_NUMERATOR ( 1.0f )
+#define D3D12_FLOAT_TO_SRGB_OFFSET ( 0.055f )
+#define D3D12_FLOAT_TO_SRGB_SCALE_1  ( 12.92f )
+#define D3D12_FLOAT_TO_SRGB_SCALE_2  ( 1.055f )
+#define D3D12_FLOAT_TO_SRGB_THRESHOLD  ( 0.0031308f )
+#define D3D12_FTOI_INSTRUCTION_MAX_INPUT ( 2147483647.999f )
+#define D3D12_FTOI_INSTRUCTION_MIN_INPUT ( -2147483648.999f )
+#define D3D12_FTOU_INSTRUCTION_MAX_INPUT ( 4294967295.999f )
+#define D3D12_FTOU_INSTRUCTION_MIN_INPUT ( 0.0f )
+#define  D3D12_GS_INPUT_INSTANCE_ID_READS_PER_INST ( 2 )
+
+#define  D3D12_GS_INPUT_INSTANCE_ID_READ_PORTS ( 1 )
+
+#define  D3D12_GS_INPUT_INSTANCE_ID_REGISTER_COMPONENTS  ( 1 )
+
+#define  D3D12_GS_INPUT_INSTANCE_ID_REGISTER_COMPONENT_BIT_COUNT ( 32 )
+
+#define  D3D12_GS_INPUT_INSTANCE_ID_REGISTER_COUNT ( 1 )
+
+#define  D3D12_GS_INPUT_PRIM_CONST_REGISTER_COMPONENTS ( 1 )
+
+#define  D3D12_GS_INPUT_PRIM_CONST_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_GS_INPUT_PRIM_CONST_REGISTER_COUNT  ( 1 )
+
+#define  D3D12_GS_INPUT_PRIM_CONST_REGISTER_READS_PER_INST ( 2 )
+
+#define  D3D12_GS_INPUT_PRIM_CONST_REGISTER_READ_PORTS ( 1 )
+
+#define  D3D12_GS_INPUT_REGISTER_COMPONENTS  ( 4 )
+
+#define  D3D12_GS_INPUT_REGISTER_COMPONENT_BIT_COUNT ( 32 )
+
+#define  D3D12_GS_INPUT_REGISTER_COUNT ( 32 )
+
+#define  D3D12_GS_INPUT_REGISTER_READS_PER_INST  ( 2 )
+
+#define  D3D12_GS_INPUT_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_GS_INPUT_REGISTER_VERTICES  ( 32 )
+
+#define  D3D12_GS_MAX_INSTANCE_COUNT ( 32 )
+
+#define  D3D12_GS_MAX_OUTPUT_VERTEX_COUNT_ACROSS_INSTANCES ( 1024 )
+
+#define  D3D12_GS_OUTPUT_ELEMENTS  ( 32 )
+
+#define  D3D12_GS_OUTPUT_REGISTER_COMPONENTS ( 4 )
+
+#define  D3D12_GS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_GS_OUTPUT_REGISTER_COUNT  ( 32 )
+
+#define  D3D12_HS_CONTROL_POINT_PHASE_INPUT_REGISTER_COUNT ( 32 )
+
+#define  D3D12_HS_CONTROL_POINT_PHASE_OUTPUT_REGISTER_COUNT  ( 32 )
+
+#define  D3D12_HS_CONTROL_POINT_REGISTER_COMPONENTS  ( 4 )
+
+#define  D3D12_HS_CONTROL_POINT_REGISTER_COMPONENT_BIT_COUNT ( 32 )
+
+#define  D3D12_HS_CONTROL_POINT_REGISTER_READS_PER_INST  ( 2 )
+
+#define  D3D12_HS_CONTROL_POINT_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_HS_FORK_PHASE_INSTANCE_COUNT_UPPER_BOUND  ( 0xffffffff )
+
+#define  D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_COMPONENTS ( 1 )
+
+#define  D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_COUNT  ( 1 )
+
+#define  D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_READS_PER_INST ( 2 )
+
+#define  D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_READ_PORTS ( 1 )
+
+#define  D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_COMPONENTS ( 1 )
+
+#define  D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_COUNT  ( 1 )
+
+#define  D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_READS_PER_INST ( 2 )
+
+#define  D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_READ_PORTS ( 1 )
+
+#define  D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_COMPONENTS ( 1 )
+
+#define  D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_COUNT  ( 1 )
+
+#define  D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_READS_PER_INST ( 2 )
+
+#define  D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_READ_PORTS ( 1 )
+
+#define  D3D12_HS_JOIN_PHASE_INSTANCE_COUNT_UPPER_BOUND  ( 0xffffffff )
+
+#define D3D12_HS_MAXTESSFACTOR_LOWER_BOUND ( 1.0f )
+#define D3D12_HS_MAXTESSFACTOR_UPPER_BOUND ( 64.0f )
+#define  D3D12_HS_OUTPUT_CONTROL_POINTS_MAX_TOTAL_SCALARS  ( 3968 )
+
+#define  D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_COMPONENTS  ( 1 )
+
+#define  D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_COMPONENT_BIT_COUNT ( 32 )
+
+#define  D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_COUNT ( 1 )
+
+#define  D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_READS_PER_INST  ( 2 )
+
+#define  D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_COMPONENTS  ( 4 )
+
+#define  D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_COMPONENT_BIT_COUNT ( 32 )
+
+#define  D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_COUNT ( 32 )
+
+#define  D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_READS_PER_INST  ( 2 )
+
+#define  D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_SCALAR_COMPONENTS ( 128 )
+
+#define  D3D12_IA_DEFAULT_INDEX_BUFFER_OFFSET_IN_BYTES ( 0 )
+
+#define  D3D12_IA_DEFAULT_PRIMITIVE_TOPOLOGY ( 0 )
+
+#define  D3D12_IA_DEFAULT_VERTEX_BUFFER_OFFSET_IN_BYTES  ( 0 )
+
+#define  D3D12_IA_INDEX_INPUT_RESOURCE_SLOT_COUNT  ( 1 )
+
+#define  D3D12_IA_INSTANCE_ID_BIT_COUNT  ( 32 )
+
+#define  D3D12_IA_INTEGER_ARITHMETIC_BIT_COUNT ( 32 )
+
+#define  D3D12_IA_PATCH_MAX_CONTROL_POINT_COUNT  ( 32 )
+
+#define  D3D12_IA_PRIMITIVE_ID_BIT_COUNT ( 32 )
+
+#define  D3D12_IA_VERTEX_ID_BIT_COUNT  ( 32 )
+
+#define  D3D12_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT ( 32 )
+
+#define  D3D12_IA_VERTEX_INPUT_STRUCTURE_ELEMENTS_COMPONENTS ( 128 )
+
+#define  D3D12_IA_VERTEX_INPUT_STRUCTURE_ELEMENT_COUNT ( 32 )
+
+#define  D3D12_INTEGER_DIVIDE_BY_ZERO_QUOTIENT ( 0xffffffff )
+
+#define  D3D12_INTEGER_DIVIDE_BY_ZERO_REMAINDER  ( 0xffffffff )
+
+#define  D3D12_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL ( 0xffffffff )
+
+#define  D3D12_KEEP_UNORDERED_ACCESS_VIEWS ( 0xffffffff )
+
+#define D3D12_LINEAR_GAMMA ( 1.0f )
+#define  D3D12_MAJOR_VERSION ( 12 )
+
+#define D3D12_MAX_BORDER_COLOR_COMPONENT ( 1.0f )
+#define D3D12_MAX_DEPTH  ( 1.0f )
+#define  D3D12_MAX_LIVE_STATIC_SAMPLERS  ( 2032 )
+
+#define  D3D12_MAX_MAXANISOTROPY ( 16 )
+
+#define  D3D12_MAX_MULTISAMPLE_SAMPLE_COUNT  ( 32 )
+
+#define D3D12_MAX_POSITION_VALUE ( 3.402823466e+34f )
+#define  D3D12_MAX_ROOT_COST ( 64 )
+
+#define  D3D12_MAX_SHADER_VISIBLE_DESCRIPTOR_HEAP_SIZE_TIER_1  ( 1000000 )
+
+#define  D3D12_MAX_SHADER_VISIBLE_DESCRIPTOR_HEAP_SIZE_TIER_2  ( 1000000 )
+
+#define  D3D12_MAX_SHADER_VISIBLE_SAMPLER_HEAP_SIZE  ( 2048 )
+
+#define  D3D12_MAX_TEXTURE_DIMENSION_2_TO_EXP  ( 17 )
+
+#define  D3D12_MAX_VIEW_INSTANCE_COUNT ( 4 )
+
+#define  D3D12_MINOR_VERSION ( 0 )
+
+#define D3D12_MIN_BORDER_COLOR_COMPONENT ( 0.0f )
+#define D3D12_MIN_DEPTH  ( 0.0f )
+#define  D3D12_MIN_MAXANISOTROPY ( 0 )
+
+#define D3D12_MIP_LOD_BIAS_MAX ( 15.99f )
+#define D3D12_MIP_LOD_BIAS_MIN ( -16.0f )
+#define  D3D12_MIP_LOD_FRACTIONAL_BIT_COUNT  ( 8 )
+
+#define  D3D12_MIP_LOD_RANGE_BIT_COUNT ( 8 )
+
+#define D3D12_MULTISAMPLE_ANTIALIAS_LINE_WIDTH ( 1.4f )
+#define  D3D12_NONSAMPLE_FETCH_OUT_OF_RANGE_ACCESS_RESULT  ( 0 )
+
+#define  D3D12_OS_RESERVED_REGISTER_SPACE_VALUES_END ( 0xffffffff )
+
+#define  D3D12_OS_RESERVED_REGISTER_SPACE_VALUES_START ( 0xfffffff8 )
+
+#define  D3D12_PACKED_TILE ( 0xffffffff )
+
+#define  D3D12_PIXEL_ADDRESS_RANGE_BIT_COUNT ( 15 )
+
+#define  D3D12_PRE_SCISSOR_PIXEL_ADDRESS_RANGE_BIT_COUNT ( 16 )
+
+#define  D3D12_PS_CS_UAV_REGISTER_COMPONENTS ( 1 )
+
+#define  D3D12_PS_CS_UAV_REGISTER_COUNT  ( 8 )
+
+#define  D3D12_PS_CS_UAV_REGISTER_READS_PER_INST ( 1 )
+
+#define  D3D12_PS_CS_UAV_REGISTER_READ_PORTS ( 1 )
+
+#define  D3D12_PS_FRONTFACING_DEFAULT_VALUE  ( 0xffffffff )
+
+#define  D3D12_PS_FRONTFACING_FALSE_VALUE  ( 0 )
+
+#define  D3D12_PS_FRONTFACING_TRUE_VALUE ( 0xffffffff )
+
+#define  D3D12_PS_INPUT_REGISTER_COMPONENTS  ( 4 )
+
+#define  D3D12_PS_INPUT_REGISTER_COMPONENT_BIT_COUNT ( 32 )
+
+#define  D3D12_PS_INPUT_REGISTER_COUNT ( 32 )
+
+#define  D3D12_PS_INPUT_REGISTER_READS_PER_INST  ( 2 )
+
+#define  D3D12_PS_INPUT_REGISTER_READ_PORTS  ( 1 )
+
+#define D3D12_PS_LEGACY_PIXEL_CENTER_FRACTIONAL_COMPONENT  ( 0.0f )
+#define  D3D12_PS_OUTPUT_DEPTH_REGISTER_COMPONENTS ( 1 )
+
+#define  D3D12_PS_OUTPUT_DEPTH_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_PS_OUTPUT_DEPTH_REGISTER_COUNT  ( 1 )
+
+#define  D3D12_PS_OUTPUT_MASK_REGISTER_COMPONENTS  ( 1 )
+
+#define  D3D12_PS_OUTPUT_MASK_REGISTER_COMPONENT_BIT_COUNT ( 32 )
+
+#define  D3D12_PS_OUTPUT_MASK_REGISTER_COUNT ( 1 )
+
+#define  D3D12_PS_OUTPUT_REGISTER_COMPONENTS ( 4 )
+
+#define  D3D12_PS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_PS_OUTPUT_REGISTER_COUNT  ( 8 )
+
+#define D3D12_PS_PIXEL_CENTER_FRACTIONAL_COMPONENT ( 0.5f )
+#define  D3D12_RAW_UAV_SRV_BYTE_ALIGNMENT  ( 16 )
+
+#define  D3D12_RAYTRACING_AABB_BYTE_ALIGNMENT  ( 8 )
+
+#define  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT  ( 256 )
+
+#define  D3D12_RAYTRACING_INSTANCE_DESCS_BYTE_ALIGNMENT  ( 16 )
+
+#define  D3D12_RAYTRACING_MAX_ATTRIBUTE_SIZE_IN_BYTES  ( 32 )
+
+#define  D3D12_RAYTRACING_MAX_DECLARABLE_TRACE_RECURSION_DEPTH ( 31 )
+
+#define  D3D12_RAYTRACING_MAX_GEOMETRIES_PER_BOTTOM_LEVEL_ACCELERATION_STRUCTURE ( 16777216 )
+
+#define  D3D12_RAYTRACING_MAX_INSTANCES_PER_TOP_LEVEL_ACCELERATION_STRUCTURE ( 16777216 )
+
+#define  D3D12_RAYTRACING_MAX_PRIMITIVES_PER_BOTTOM_LEVEL_ACCELERATION_STRUCTURE ( 536870912 )
+
+#define  D3D12_RAYTRACING_MAX_RAY_GENERATION_SHADER_THREADS  ( 1073741824 )
+
+#define  D3D12_RAYTRACING_MAX_SHADER_RECORD_STRIDE ( 4096 )
+
+#define  D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT ( 32 )
+
+#define  D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT  ( 64 )
+
+#define  D3D12_RAYTRACING_TRANSFORM3X4_BYTE_ALIGNMENT  ( 16 )
+
+#define  D3D12_REQ_BLEND_OBJECT_COUNT_PER_DEVICE ( 4096 )
+
+#define  D3D12_REQ_BUFFER_RESOURCE_TEXEL_COUNT_2_TO_EXP  ( 27 )
+
+#define  D3D12_REQ_CONSTANT_BUFFER_ELEMENT_COUNT ( 4096 )
+
+#define  D3D12_REQ_DEPTH_STENCIL_OBJECT_COUNT_PER_DEVICE ( 4096 )
+
+#define  D3D12_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP  ( 32 )
+
+#define  D3D12_REQ_DRAW_VERTEX_COUNT_2_TO_EXP  ( 32 )
+
+#define  D3D12_REQ_FILTERING_HW_ADDRESSABLE_RESOURCE_DIMENSION ( 16384 )
+
+#define  D3D12_REQ_GS_INVOCATION_32BIT_OUTPUT_COMPONENT_LIMIT  ( 1024 )
+
+#define  D3D12_REQ_IMMEDIATE_CONSTANT_BUFFER_ELEMENT_COUNT ( 4096 )
+
+#define  D3D12_REQ_MAXANISOTROPY ( 16 )
+
+#define  D3D12_REQ_MIP_LEVELS  ( 15 )
+
+#define  D3D12_REQ_MULTI_ELEMENT_STRUCTURE_SIZE_IN_BYTES ( 2048 )
+
+#define  D3D12_REQ_RASTERIZER_OBJECT_COUNT_PER_DEVICE  ( 4096 )
+
+#define  D3D12_REQ_RENDER_TO_BUFFER_WINDOW_WIDTH ( 16384 )
+
+#define  D3D12_REQ_RESOURCE_SIZE_IN_MEGABYTES_EXPRESSION_A_TERM  ( 128 )
+
+#define D3D12_REQ_RESOURCE_SIZE_IN_MEGABYTES_EXPRESSION_B_TERM ( 0.25f )
+#define  D3D12_REQ_RESOURCE_SIZE_IN_MEGABYTES_EXPRESSION_C_TERM  ( 2048 )
+
+#define  D3D12_REQ_RESOURCE_VIEW_COUNT_PER_DEVICE_2_TO_EXP ( 20 )
+
+#define  D3D12_REQ_SAMPLER_OBJECT_COUNT_PER_DEVICE ( 4096 )
+
+#define  D3D12_REQ_SUBRESOURCES  ( 30720 )
+
+#define  D3D12_REQ_TEXTURE1D_ARRAY_AXIS_DIMENSION  ( 2048 )
+
+#define  D3D12_REQ_TEXTURE1D_U_DIMENSION ( 16384 )
+
+#define  D3D12_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION  ( 2048 )
+
+#define  D3D12_REQ_TEXTURE2D_U_OR_V_DIMENSION  ( 16384 )
+
+#define  D3D12_REQ_TEXTURE3D_U_V_OR_W_DIMENSION  ( 2048 )
+
+#define  D3D12_REQ_TEXTURECUBE_DIMENSION ( 16384 )
+
+#define  D3D12_RESINFO_INSTRUCTION_MISSING_COMPONENT_RETVAL  ( 0 )
+
+#define  D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES ( 0xffffffff )
+
+#define  D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT  ( 2 )
+
+#define  D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES ( 32 )
+
+#define  D3D12_SHADER_MAJOR_VERSION  ( 5 )
+
+#define  D3D12_SHADER_MAX_INSTANCES  ( 65535 )
+
+#define  D3D12_SHADER_MAX_INTERFACES ( 253 )
+
+#define  D3D12_SHADER_MAX_INTERFACE_CALL_SITES ( 4096 )
+
+#define  D3D12_SHADER_MAX_TYPES  ( 65535 )
+
+#define  D3D12_SHADER_MINOR_VERSION  ( 1 )
+
+#define  D3D12_SHIFT_INSTRUCTION_PAD_VALUE ( 0 )
+
+#define  D3D12_SHIFT_INSTRUCTION_SHIFT_VALUE_BIT_COUNT ( 5 )
+
+#define  D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT  ( 8 )
+
+#define  D3D12_SMALL_MSAA_RESOURCE_PLACEMENT_ALIGNMENT ( 65536 )
+
+#define  D3D12_SMALL_RESOURCE_PLACEMENT_ALIGNMENT  ( 4096 )
+
+#define  D3D12_SO_BUFFER_MAX_STRIDE_IN_BYTES ( 2048 )
+
+#define  D3D12_SO_BUFFER_MAX_WRITE_WINDOW_IN_BYTES ( 512 )
+
+#define  D3D12_SO_BUFFER_SLOT_COUNT  ( 4 )
+
+#define  D3D12_SO_DDI_REGISTER_INDEX_DENOTING_GAP  ( 0xffffffff )
+
+#define  D3D12_SO_NO_RASTERIZED_STREAM ( 0xffffffff )
+
+#define  D3D12_SO_OUTPUT_COMPONENT_COUNT ( 128 )
+
+#define  D3D12_SO_STREAM_COUNT ( 4 )
+
+#define  D3D12_SPEC_DATE_DAY ( 14 )
+
+#define  D3D12_SPEC_DATE_MONTH ( 11 )
+
+#define  D3D12_SPEC_DATE_YEAR  ( 2014 )
+
+#define D3D12_SPEC_VERSION ( 1.16 )
+#define D3D12_SRGB_GAMMA ( 2.2f )
+#define D3D12_SRGB_TO_FLOAT_DENOMINATOR_1  ( 12.92f )
+#define D3D12_SRGB_TO_FLOAT_DENOMINATOR_2  ( 1.055f )
+#define D3D12_SRGB_TO_FLOAT_EXPONENT ( 2.4f )
+#define D3D12_SRGB_TO_FLOAT_OFFSET ( 0.055f )
+#define D3D12_SRGB_TO_FLOAT_THRESHOLD  ( 0.04045f )
+#define D3D12_SRGB_TO_FLOAT_TOLERANCE_IN_ULP ( 0.5f )
+#define  D3D12_STANDARD_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_STANDARD_COMPONENT_BIT_COUNT_DOUBLED  ( 64 )
+
+#define  D3D12_STANDARD_MAXIMUM_ELEMENT_ALIGNMENT_BYTE_MULTIPLE  ( 4 )
+
+#define  D3D12_STANDARD_PIXEL_COMPONENT_COUNT  ( 128 )
+
+#define  D3D12_STANDARD_PIXEL_ELEMENT_COUNT  ( 32 )
+
+#define  D3D12_STANDARD_VECTOR_SIZE  ( 4 )
+
+#define  D3D12_STANDARD_VERTEX_ELEMENT_COUNT ( 32 )
+
+#define  D3D12_STANDARD_VERTEX_TOTAL_COMPONENT_COUNT ( 64 )
+
+#define  D3D12_SUBPIXEL_FRACTIONAL_BIT_COUNT ( 8 )
+
+#define  D3D12_SUBTEXEL_FRACTIONAL_BIT_COUNT ( 8 )
+
+#define  D3D12_SYSTEM_RESERVED_REGISTER_SPACE_VALUES_END ( 0xffffffff )
+
+#define  D3D12_SYSTEM_RESERVED_REGISTER_SPACE_VALUES_START ( 0xfffffff0 )
+
+#define  D3D12_TESSELLATOR_MAX_EVEN_TESSELLATION_FACTOR  ( 64 )
+
+#define  D3D12_TESSELLATOR_MAX_ISOLINE_DENSITY_TESSELLATION_FACTOR ( 64 )
+
+#define  D3D12_TESSELLATOR_MAX_ODD_TESSELLATION_FACTOR ( 63 )
+
+#define  D3D12_TESSELLATOR_MAX_TESSELLATION_FACTOR ( 64 )
+
+#define  D3D12_TESSELLATOR_MIN_EVEN_TESSELLATION_FACTOR  ( 2 )
+
+#define  D3D12_TESSELLATOR_MIN_ISOLINE_DENSITY_TESSELLATION_FACTOR ( 1 )
+
+#define  D3D12_TESSELLATOR_MIN_ODD_TESSELLATION_FACTOR ( 1 )
+
+#define  D3D12_TEXEL_ADDRESS_RANGE_BIT_COUNT ( 16 )
+
+#define  D3D12_TEXTURE_DATA_PITCH_ALIGNMENT  ( 256 )
+
+#define  D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT  ( 512 )
+
+#define  D3D12_TILED_RESOURCE_TILE_SIZE_IN_BYTES ( 65536 )
+
+#define  D3D12_TRACKED_WORKLOAD_MAX_INSTANCES  ( 32 )
+
+#define  D3D12_UAV_COUNTER_PLACEMENT_ALIGNMENT ( 4096 )
+
+#define  D3D12_UAV_SLOT_COUNT  ( 64 )
+
+#define  D3D12_UNBOUND_MEMORY_ACCESS_RESULT  ( 0 )
+
+#define  D3D12_VIDEO_DECODE_MAX_ARGUMENTS  ( 10 )
+
+#define  D3D12_VIDEO_DECODE_MAX_HISTOGRAM_COMPONENTS ( 4 )
+
+#define  D3D12_VIDEO_DECODE_MIN_BITSTREAM_OFFSET_ALIGNMENT ( 256 )
+
+#define  D3D12_VIDEO_DECODE_MIN_HISTOGRAM_OFFSET_ALIGNMENT ( 256 )
+
+#define  D3D12_VIDEO_DECODE_STATUS_MACROBLOCKS_AFFECTED_UNKNOWN  ( 0xffffffff )
+
+#define  D3D12_VIDEO_PROCESS_MAX_FILTERS ( 32 )
+
+#define  D3D12_VIDEO_PROCESS_STEREO_VIEWS  ( 2 )
+
+#define  D3D12_VIEWPORT_AND_SCISSORRECT_MAX_INDEX  ( 15 )
+
+#define  D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE  ( 16 )
+
+#define  D3D12_VIEWPORT_BOUNDS_MAX ( 32767 )
+
+#define  D3D12_VIEWPORT_BOUNDS_MIN ( -32768 )
+
+#define  D3D12_VS_INPUT_REGISTER_COMPONENTS  ( 4 )
+
+#define  D3D12_VS_INPUT_REGISTER_COMPONENT_BIT_COUNT ( 32 )
+
+#define  D3D12_VS_INPUT_REGISTER_COUNT ( 32 )
+
+#define  D3D12_VS_INPUT_REGISTER_READS_PER_INST  ( 2 )
+
+#define  D3D12_VS_INPUT_REGISTER_READ_PORTS  ( 1 )
+
+#define  D3D12_VS_OUTPUT_REGISTER_COMPONENTS ( 4 )
+
+#define  D3D12_VS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT  ( 32 )
+
+#define  D3D12_VS_OUTPUT_REGISTER_COUNT  ( 32 )
+
+#define  D3D12_WHQL_CONTEXT_COUNT_FOR_RESOURCE_LIMIT ( 10 )
+
+#define  D3D12_WHQL_DRAWINDEXED_INDEX_COUNT_2_TO_EXP ( 25 )
+
+#define  D3D12_WHQL_DRAW_VERTEX_COUNT_2_TO_EXP ( 25 )
+
+#endif
+
+typedef UINT64 D3D12_GPU_VIRTUAL_ADDRESS;
+
+typedef 
+enum D3D12_COMMAND_LIST_TYPE
+    {
+        D3D12_COMMAND_LIST_TYPE_DIRECT = 0,
+        D3D12_COMMAND_LIST_TYPE_BUNDLE = 1,
+        D3D12_COMMAND_LIST_TYPE_COMPUTE  = 2,
+        D3D12_COMMAND_LIST_TYPE_COPY = 3,
+        D3D12_COMMAND_LIST_TYPE_VIDEO_DECODE = 4,
+        D3D12_COMMAND_LIST_TYPE_VIDEO_PROCESS  = 5,
+        D3D12_COMMAND_LIST_TYPE_VIDEO_ENCODE = 6
+    }  D3D12_COMMAND_LIST_TYPE;
+
+typedef 
+enum D3D12_COMMAND_QUEUE_FLAGS
+    {
+        D3D12_COMMAND_QUEUE_FLAG_NONE  = 0,
+        D3D12_COMMAND_QUEUE_FLAG_DISABLE_GPU_TIMEOUT = 0x1
+    }  D3D12_COMMAND_QUEUE_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_COMMAND_QUEUE_FLAGS );
+typedef 
+enum D3D12_COMMAND_QUEUE_PRIORITY
+    {
+        D3D12_COMMAND_QUEUE_PRIORITY_NORMAL  = 0,
+        D3D12_COMMAND_QUEUE_PRIORITY_HIGH  = 100,
+        D3D12_COMMAND_QUEUE_PRIORITY_GLOBAL_REALTIME = 10000
+    }  D3D12_COMMAND_QUEUE_PRIORITY;
+
+typedef struct D3D12_COMMAND_QUEUE_DESC
+    {
+    D3D12_COMMAND_LIST_TYPE Type;
+    INT Priority;
+    D3D12_COMMAND_QUEUE_FLAGS Flags;
+    UINT NodeMask;
+    }  D3D12_COMMAND_QUEUE_DESC;
+
+typedef 
+enum D3D12_PRIMITIVE_TOPOLOGY_TYPE
+    {
+        D3D12_PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED  = 0,
+        D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT  = 1,
+        D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE = 2,
+        D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE = 3,
+        D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH  = 4
+    }  D3D12_PRIMITIVE_TOPOLOGY_TYPE;
+
+typedef 
+enum D3D12_INPUT_CLASSIFICATION
+    {
+        D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA = 0,
+        D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA = 1
+    }  D3D12_INPUT_CLASSIFICATION;
+
+typedef struct D3D12_INPUT_ELEMENT_DESC
+    {
+    LPCSTR SemanticName;
+    UINT SemanticIndex;
+    DXGI_FORMAT Format;
+    UINT InputSlot;
+    UINT AlignedByteOffset;
+    D3D12_INPUT_CLASSIFICATION InputSlotClass;
+    UINT InstanceDataStepRate;
+    }  D3D12_INPUT_ELEMENT_DESC;
+
+typedef 
+enum D3D12_FILL_MODE
+    {
+        D3D12_FILL_MODE_WIREFRAME  = 2,
+        D3D12_FILL_MODE_SOLID  = 3
+    }  D3D12_FILL_MODE;
+
+typedef D3D_PRIMITIVE_TOPOLOGY D3D12_PRIMITIVE_TOPOLOGY;
+
+typedef D3D_PRIMITIVE D3D12_PRIMITIVE;
+
+typedef 
+enum D3D12_CULL_MODE
+    {
+        D3D12_CULL_MODE_NONE = 1,
+        D3D12_CULL_MODE_FRONT  = 2,
+        D3D12_CULL_MODE_BACK = 3
+    }  D3D12_CULL_MODE;
+
+typedef struct D3D12_SO_DECLARATION_ENTRY
+    {
+    UINT Stream;
+    LPCSTR SemanticName;
+    UINT SemanticIndex;
+    BYTE StartComponent;
+    BYTE ComponentCount;
+    BYTE OutputSlot;
+    }  D3D12_SO_DECLARATION_ENTRY;
+
+typedef struct D3D12_VIEWPORT
+    {
+    FLOAT TopLeftX;
+    FLOAT TopLeftY;
+    FLOAT Width;
+    FLOAT Height;
+    FLOAT MinDepth;
+    FLOAT MaxDepth;
+    }  D3D12_VIEWPORT;
+
+typedef RECT D3D12_RECT;
+
+typedef struct D3D12_BOX
+    {
+    UINT left;
+    UINT top;
+    UINT front;
+    UINT right;
+    UINT bottom;
+    UINT back;
+    }  D3D12_BOX;
+
+typedef 
+enum D3D12_COMPARISON_FUNC
+    {
+        D3D12_COMPARISON_FUNC_NEVER  = 1,
+        D3D12_COMPARISON_FUNC_LESS = 2,
+        D3D12_COMPARISON_FUNC_EQUAL  = 3,
+        D3D12_COMPARISON_FUNC_LESS_EQUAL = 4,
+        D3D12_COMPARISON_FUNC_GREATER  = 5,
+        D3D12_COMPARISON_FUNC_NOT_EQUAL  = 6,
+        D3D12_COMPARISON_FUNC_GREATER_EQUAL  = 7,
+        D3D12_COMPARISON_FUNC_ALWAYS = 8
+    }  D3D12_COMPARISON_FUNC;
+
+typedef 
+enum D3D12_DEPTH_WRITE_MASK
+    {
+        D3D12_DEPTH_WRITE_MASK_ZERO  = 0,
+        D3D12_DEPTH_WRITE_MASK_ALL = 1
+    }  D3D12_DEPTH_WRITE_MASK;
+
+typedef 
+enum D3D12_STENCIL_OP
+    {
+        D3D12_STENCIL_OP_KEEP  = 1,
+        D3D12_STENCIL_OP_ZERO  = 2,
+        D3D12_STENCIL_OP_REPLACE = 3,
+        D3D12_STENCIL_OP_INCR_SAT  = 4,
+        D3D12_STENCIL_OP_DECR_SAT  = 5,
+        D3D12_STENCIL_OP_INVERT  = 6,
+        D3D12_STENCIL_OP_INCR  = 7,
+        D3D12_STENCIL_OP_DECR  = 8
+    }  D3D12_STENCIL_OP;
+
+typedef struct D3D12_DEPTH_STENCILOP_DESC
+    {
+    D3D12_STENCIL_OP StencilFailOp;
+    D3D12_STENCIL_OP StencilDepthFailOp;
+    D3D12_STENCIL_OP StencilPassOp;
+    D3D12_COMPARISON_FUNC StencilFunc;
+    }  D3D12_DEPTH_STENCILOP_DESC;
+
+typedef struct D3D12_DEPTH_STENCIL_DESC
+    {
+    BOOL DepthEnable;
+    D3D12_DEPTH_WRITE_MASK DepthWriteMask;
+    D3D12_COMPARISON_FUNC DepthFunc;
+    BOOL StencilEnable;
+    UINT8 StencilReadMask;
+    UINT8 StencilWriteMask;
+    D3D12_DEPTH_STENCILOP_DESC FrontFace;
+    D3D12_DEPTH_STENCILOP_DESC BackFace;
+    }  D3D12_DEPTH_STENCIL_DESC;
+
+typedef struct D3D12_DEPTH_STENCIL_DESC1
+    {
+    BOOL DepthEnable;
+    D3D12_DEPTH_WRITE_MASK DepthWriteMask;
+    D3D12_COMPARISON_FUNC DepthFunc;
+    BOOL StencilEnable;
+    UINT8 StencilReadMask;
+    UINT8 StencilWriteMask;
+    D3D12_DEPTH_STENCILOP_DESC FrontFace;
+    D3D12_DEPTH_STENCILOP_DESC BackFace;
+    BOOL DepthBoundsTestEnable;
+    }  D3D12_DEPTH_STENCIL_DESC1;
+
+typedef 
+enum D3D12_BLEND
+    {
+        D3D12_BLEND_ZERO = 1,
+        D3D12_BLEND_ONE  = 2,
+        D3D12_BLEND_SRC_COLOR  = 3,
+        D3D12_BLEND_INV_SRC_COLOR  = 4,
+        D3D12_BLEND_SRC_ALPHA  = 5,
+        D3D12_BLEND_INV_SRC_ALPHA  = 6,
+        D3D12_BLEND_DEST_ALPHA = 7,
+        D3D12_BLEND_INV_DEST_ALPHA = 8,
+        D3D12_BLEND_DEST_COLOR = 9,
+        D3D12_BLEND_INV_DEST_COLOR = 10,
+        D3D12_BLEND_SRC_ALPHA_SAT  = 11,
+        D3D12_BLEND_BLEND_FACTOR = 14,
+        D3D12_BLEND_INV_BLEND_FACTOR = 15,
+        D3D12_BLEND_SRC1_COLOR = 16,
+        D3D12_BLEND_INV_SRC1_COLOR = 17,
+        D3D12_BLEND_SRC1_ALPHA = 18,
+        D3D12_BLEND_INV_SRC1_ALPHA = 19
+    }  D3D12_BLEND;
+
+typedef 
+enum D3D12_BLEND_OP
+    {
+        D3D12_BLEND_OP_ADD = 1,
+        D3D12_BLEND_OP_SUBTRACT  = 2,
+        D3D12_BLEND_OP_REV_SUBTRACT  = 3,
+        D3D12_BLEND_OP_MIN = 4,
+        D3D12_BLEND_OP_MAX = 5
+    }  D3D12_BLEND_OP;
+
+typedef 
+enum D3D12_COLOR_WRITE_ENABLE
+    {
+        D3D12_COLOR_WRITE_ENABLE_RED = 1,
+        D3D12_COLOR_WRITE_ENABLE_GREEN = 2,
+        D3D12_COLOR_WRITE_ENABLE_BLUE  = 4,
+        D3D12_COLOR_WRITE_ENABLE_ALPHA = 8,
+        D3D12_COLOR_WRITE_ENABLE_ALL = ( ( ( D3D12_COLOR_WRITE_ENABLE_RED | D3D12_COLOR_WRITE_ENABLE_GREEN )  | D3D12_COLOR_WRITE_ENABLE_BLUE )  | D3D12_COLOR_WRITE_ENABLE_ALPHA ) 
+    }  D3D12_COLOR_WRITE_ENABLE;
+
+typedef 
+enum D3D12_LOGIC_OP
+    {
+        D3D12_LOGIC_OP_CLEAR = 0,
+        D3D12_LOGIC_OP_SET = ( D3D12_LOGIC_OP_CLEAR + 1 ) ,
+        D3D12_LOGIC_OP_COPY  = ( D3D12_LOGIC_OP_SET + 1 ) ,
+        D3D12_LOGIC_OP_COPY_INVERTED = ( D3D12_LOGIC_OP_COPY + 1 ) ,
+        D3D12_LOGIC_OP_NOOP  = ( D3D12_LOGIC_OP_COPY_INVERTED + 1 ) ,
+        D3D12_LOGIC_OP_INVERT  = ( D3D12_LOGIC_OP_NOOP + 1 ) ,
+        D3D12_LOGIC_OP_AND = ( D3D12_LOGIC_OP_INVERT + 1 ) ,
+        D3D12_LOGIC_OP_NAND  = ( D3D12_LOGIC_OP_AND + 1 ) ,
+        D3D12_LOGIC_OP_OR  = ( D3D12_LOGIC_OP_NAND + 1 ) ,
+        D3D12_LOGIC_OP_NOR = ( D3D12_LOGIC_OP_OR + 1 ) ,
+        D3D12_LOGIC_OP_XOR = ( D3D12_LOGIC_OP_NOR + 1 ) ,
+        D3D12_LOGIC_OP_EQUIV = ( D3D12_LOGIC_OP_XOR + 1 ) ,
+        D3D12_LOGIC_OP_AND_REVERSE = ( D3D12_LOGIC_OP_EQUIV + 1 ) ,
+        D3D12_LOGIC_OP_AND_INVERTED  = ( D3D12_LOGIC_OP_AND_REVERSE + 1 ) ,
+        D3D12_LOGIC_OP_OR_REVERSE  = ( D3D12_LOGIC_OP_AND_INVERTED + 1 ) ,
+        D3D12_LOGIC_OP_OR_INVERTED = ( D3D12_LOGIC_OP_OR_REVERSE + 1 ) 
+    }  D3D12_LOGIC_OP;
+
+typedef struct D3D12_RENDER_TARGET_BLEND_DESC
+    {
+    BOOL BlendEnable;
+    BOOL LogicOpEnable;
+    D3D12_BLEND SrcBlend;
+    D3D12_BLEND DestBlend;
+    D3D12_BLEND_OP BlendOp;
+    D3D12_BLEND SrcBlendAlpha;
+    D3D12_BLEND DestBlendAlpha;
+    D3D12_BLEND_OP BlendOpAlpha;
+    D3D12_LOGIC_OP LogicOp;
+    UINT8 RenderTargetWriteMask;
+    }  D3D12_RENDER_TARGET_BLEND_DESC;
+
+typedef struct D3D12_BLEND_DESC
+    {
+    BOOL AlphaToCoverageEnable;
+    BOOL IndependentBlendEnable;
+    D3D12_RENDER_TARGET_BLEND_DESC RenderTarget[ 8 ];
+    }  D3D12_BLEND_DESC;
+
+/* Note, the array size for RenderTarget[] above is D3D12_SIMULTANEOUS_RENDERTARGET_COUNT. 
+   IDL processing/generation of this header replaces the define; this comment is merely explaining what happened. */
+typedef 
+enum D3D12_CONSERVATIVE_RASTERIZATION_MODE
+    {
+        D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF  = 0,
+        D3D12_CONSERVATIVE_RASTERIZATION_MODE_ON = 1
+    }  D3D12_CONSERVATIVE_RASTERIZATION_MODE;
+
+typedef struct D3D12_RASTERIZER_DESC
+    {
+    D3D12_FILL_MODE FillMode;
+    D3D12_CULL_MODE CullMode;
+    BOOL FrontCounterClockwise;
+    INT DepthBias;
+    FLOAT DepthBiasClamp;
+    FLOAT SlopeScaledDepthBias;
+    BOOL DepthClipEnable;
+    BOOL MultisampleEnable;
+    BOOL AntialiasedLineEnable;
+    UINT ForcedSampleCount;
+    D3D12_CONSERVATIVE_RASTERIZATION_MODE ConservativeRaster;
+    }  D3D12_RASTERIZER_DESC;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0000_v0_0_s_ifspec;
+
+#ifndef __ID3D12Object_INTERFACE_DEFINED__
+#define __ID3D12Object_INTERFACE_DEFINED__
+
+/* interface ID3D12Object */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Object;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("c4fec28f-7966-4e95-9f94-f431cb56c3b8")
+    ID3D12Object : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetPrivateData( 
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetPrivateData( 
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetPrivateDataInterface( 
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetName( 
+            _In_z_  LPCWSTR Name) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12ObjectVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Object * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Object * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Object * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Object * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Object * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Object * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Object * This,
+            _In_z_  LPCWSTR Name);
+        
+        END_INTERFACE
+    } ID3D12ObjectVtbl;
+
+    interface ID3D12Object
+    {
+        CONST_VTBL struct ID3D12ObjectVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Object_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Object_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Object_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Object_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Object_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Object_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Object_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Object_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12DeviceChild_INTERFACE_DEFINED__
+#define __ID3D12DeviceChild_INTERFACE_DEFINED__
+
+/* interface ID3D12DeviceChild */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DeviceChild;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("905db94b-a00c-4140-9df5-2b64ca9ea357")
+    ID3D12DeviceChild : public ID3D12Object
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetDevice( 
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DeviceChildVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DeviceChild * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DeviceChild * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DeviceChild * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12DeviceChild * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12DeviceChild * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12DeviceChild * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12DeviceChild * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12DeviceChild * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        END_INTERFACE
+    } ID3D12DeviceChildVtbl;
+
+    interface ID3D12DeviceChild
+    {
+        CONST_VTBL struct ID3D12DeviceChildVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DeviceChild_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DeviceChild_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DeviceChild_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DeviceChild_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12DeviceChild_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12DeviceChild_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12DeviceChild_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12DeviceChild_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DeviceChild_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12RootSignature_INTERFACE_DEFINED__
+#define __ID3D12RootSignature_INTERFACE_DEFINED__
+
+/* interface ID3D12RootSignature */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12RootSignature;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("c54a6b66-72df-4ee8-8be5-a946a1429214")
+    ID3D12RootSignature : public ID3D12DeviceChild
+    {
+    public:
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12RootSignatureVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12RootSignature * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12RootSignature * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12RootSignature * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12RootSignature * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12RootSignature * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12RootSignature * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12RootSignature * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12RootSignature * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        END_INTERFACE
+    } ID3D12RootSignatureVtbl;
+
+    interface ID3D12RootSignature
+    {
+        CONST_VTBL struct ID3D12RootSignatureVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12RootSignature_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12RootSignature_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12RootSignature_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12RootSignature_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12RootSignature_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12RootSignature_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12RootSignature_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12RootSignature_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12RootSignature_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0001 */
+/* [local] */ 
+
+typedef struct D3D12_SHADER_BYTECODE
+    {
+    _Field_size_bytes_full_(BytecodeLength)  const void *pShaderBytecode;
+    SIZE_T BytecodeLength;
+    }  D3D12_SHADER_BYTECODE;
+
+typedef struct D3D12_STREAM_OUTPUT_DESC
+    {
+    _Field_size_full_(NumEntries)  const D3D12_SO_DECLARATION_ENTRY *pSODeclaration;
+    UINT NumEntries;
+    _Field_size_full_(NumStrides)  const UINT *pBufferStrides;
+    UINT NumStrides;
+    UINT RasterizedStream;
+    }  D3D12_STREAM_OUTPUT_DESC;
+
+typedef struct D3D12_INPUT_LAYOUT_DESC
+    {
+    _Field_size_full_(NumElements)  const D3D12_INPUT_ELEMENT_DESC *pInputElementDescs;
+    UINT NumElements;
+    }  D3D12_INPUT_LAYOUT_DESC;
+
+typedef 
+enum D3D12_INDEX_BUFFER_STRIP_CUT_VALUE
+    {
+        D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED  = 0,
+        D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFF  = 1,
+        D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFFFFFF  = 2
+    }  D3D12_INDEX_BUFFER_STRIP_CUT_VALUE;
+
+typedef struct D3D12_CACHED_PIPELINE_STATE
+    {
+    _Field_size_bytes_full_(CachedBlobSizeInBytes)  const void *pCachedBlob;
+    SIZE_T CachedBlobSizeInBytes;
+    }  D3D12_CACHED_PIPELINE_STATE;
+
+typedef 
+enum D3D12_PIPELINE_STATE_FLAGS
+    {
+        D3D12_PIPELINE_STATE_FLAG_NONE = 0,
+        D3D12_PIPELINE_STATE_FLAG_TOOL_DEBUG = 0x1
+    }  D3D12_PIPELINE_STATE_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_PIPELINE_STATE_FLAGS );
+typedef struct D3D12_GRAPHICS_PIPELINE_STATE_DESC
+    {
+    ID3D12RootSignature *pRootSignature;
+    D3D12_SHADER_BYTECODE VS;
+    D3D12_SHADER_BYTECODE PS;
+    D3D12_SHADER_BYTECODE DS;
+    D3D12_SHADER_BYTECODE HS;
+    D3D12_SHADER_BYTECODE GS;
+    D3D12_STREAM_OUTPUT_DESC StreamOutput;
+    D3D12_BLEND_DESC BlendState;
+    UINT SampleMask;
+    D3D12_RASTERIZER_DESC RasterizerState;
+    D3D12_DEPTH_STENCIL_DESC DepthStencilState;
+    D3D12_INPUT_LAYOUT_DESC InputLayout;
+    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue;
+    D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyType;
+    UINT NumRenderTargets;
+    DXGI_FORMAT RTVFormats[ 8 ];
+    DXGI_FORMAT DSVFormat;
+    DXGI_SAMPLE_DESC SampleDesc;
+    UINT NodeMask;
+    D3D12_CACHED_PIPELINE_STATE CachedPSO;
+    D3D12_PIPELINE_STATE_FLAGS Flags;
+    }  D3D12_GRAPHICS_PIPELINE_STATE_DESC;
+
+typedef struct D3D12_COMPUTE_PIPELINE_STATE_DESC
+    {
+    ID3D12RootSignature *pRootSignature;
+    D3D12_SHADER_BYTECODE CS;
+    UINT NodeMask;
+    D3D12_CACHED_PIPELINE_STATE CachedPSO;
+    D3D12_PIPELINE_STATE_FLAGS Flags;
+    }  D3D12_COMPUTE_PIPELINE_STATE_DESC;
+
+struct D3D12_RT_FORMAT_ARRAY
+    {
+    DXGI_FORMAT RTFormats[ 8 ];
+    UINT NumRenderTargets;
+    } ;
+typedef struct D3D12_PIPELINE_STATE_STREAM_DESC
+    {
+    _In_  SIZE_T SizeInBytes;
+    _In_reads_(_Inexpressible_("Dependent on size of subobjects"))  void *pPipelineStateSubobjectStream;
+    }  D3D12_PIPELINE_STATE_STREAM_DESC;
+
+typedef 
+enum D3D12_PIPELINE_STATE_SUBOBJECT_TYPE
+    {
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE = 0,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VS = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VS + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DS = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_HS = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DS + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_GS = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_HS + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CS = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_GS + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CS + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1 = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1 + 1 ) ,
+        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MAX_VALID  = ( D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING + 1 ) 
+    }  D3D12_PIPELINE_STATE_SUBOBJECT_TYPE;
+
+typedef 
+enum D3D12_FEATURE
+    {
+        D3D12_FEATURE_D3D12_OPTIONS  = 0,
+        D3D12_FEATURE_ARCHITECTURE = 1,
+        D3D12_FEATURE_FEATURE_LEVELS = 2,
+        D3D12_FEATURE_FORMAT_SUPPORT = 3,
+        D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS = 4,
+        D3D12_FEATURE_FORMAT_INFO  = 5,
+        D3D12_FEATURE_GPU_VIRTUAL_ADDRESS_SUPPORT  = 6,
+        D3D12_FEATURE_SHADER_MODEL = 7,
+        D3D12_FEATURE_D3D12_OPTIONS1 = 8,
+        D3D12_FEATURE_PROTECTED_RESOURCE_SESSION_SUPPORT = 10,
+        D3D12_FEATURE_ROOT_SIGNATURE = 12,
+        D3D12_FEATURE_ARCHITECTURE1  = 16,
+        D3D12_FEATURE_D3D12_OPTIONS2 = 18,
+        D3D12_FEATURE_SHADER_CACHE = 19,
+        D3D12_FEATURE_COMMAND_QUEUE_PRIORITY = 20,
+        D3D12_FEATURE_D3D12_OPTIONS3 = 21,
+        D3D12_FEATURE_EXISTING_HEAPS = 22,
+        D3D12_FEATURE_D3D12_OPTIONS4 = 23,
+        D3D12_FEATURE_SERIALIZATION  = 24,
+        D3D12_FEATURE_CROSS_NODE = 25,
+        D3D12_FEATURE_D3D12_OPTIONS5 = 27,
+        D3D12_FEATURE_D3D12_OPTIONS6 = 30,
+        D3D12_FEATURE_QUERY_META_COMMAND = 31
+    }  D3D12_FEATURE;
+
+typedef 
+enum D3D12_SHADER_MIN_PRECISION_SUPPORT
+    {
+        D3D12_SHADER_MIN_PRECISION_SUPPORT_NONE  = 0,
+        D3D12_SHADER_MIN_PRECISION_SUPPORT_10_BIT  = 0x1,
+        D3D12_SHADER_MIN_PRECISION_SUPPORT_16_BIT  = 0x2
+    }  D3D12_SHADER_MIN_PRECISION_SUPPORT;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_SHADER_MIN_PRECISION_SUPPORT );
+typedef 
+enum D3D12_TILED_RESOURCES_TIER
+    {
+        D3D12_TILED_RESOURCES_TIER_NOT_SUPPORTED = 0,
+        D3D12_TILED_RESOURCES_TIER_1 = 1,
+        D3D12_TILED_RESOURCES_TIER_2 = 2,
+        D3D12_TILED_RESOURCES_TIER_3 = 3,
+        D3D12_TILED_RESOURCES_TIER_4 = 4
+    }  D3D12_TILED_RESOURCES_TIER;
+
+typedef 
+enum D3D12_RESOURCE_BINDING_TIER
+    {
+        D3D12_RESOURCE_BINDING_TIER_1  = 1,
+        D3D12_RESOURCE_BINDING_TIER_2  = 2,
+        D3D12_RESOURCE_BINDING_TIER_3  = 3
+    }  D3D12_RESOURCE_BINDING_TIER;
+
+typedef 
+enum D3D12_CONSERVATIVE_RASTERIZATION_TIER
+    {
+        D3D12_CONSERVATIVE_RASTERIZATION_TIER_NOT_SUPPORTED  = 0,
+        D3D12_CONSERVATIVE_RASTERIZATION_TIER_1  = 1,
+        D3D12_CONSERVATIVE_RASTERIZATION_TIER_2  = 2,
+        D3D12_CONSERVATIVE_RASTERIZATION_TIER_3  = 3
+    }  D3D12_CONSERVATIVE_RASTERIZATION_TIER;
+
+typedef 
+enum D3D12_FORMAT_SUPPORT1
+    {
+        D3D12_FORMAT_SUPPORT1_NONE = 0,
+        D3D12_FORMAT_SUPPORT1_BUFFER = 0x1,
+        D3D12_FORMAT_SUPPORT1_IA_VERTEX_BUFFER = 0x2,
+        D3D12_FORMAT_SUPPORT1_IA_INDEX_BUFFER  = 0x4,
+        D3D12_FORMAT_SUPPORT1_SO_BUFFER  = 0x8,
+        D3D12_FORMAT_SUPPORT1_TEXTURE1D  = 0x10,
+        D3D12_FORMAT_SUPPORT1_TEXTURE2D  = 0x20,
+        D3D12_FORMAT_SUPPORT1_TEXTURE3D  = 0x40,
+        D3D12_FORMAT_SUPPORT1_TEXTURECUBE  = 0x80,
+        D3D12_FORMAT_SUPPORT1_SHADER_LOAD  = 0x100,
+        D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE  = 0x200,
+        D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE_COMPARISON = 0x400,
+        D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE_MONO_TEXT  = 0x800,
+        D3D12_FORMAT_SUPPORT1_MIP  = 0x1000,
+        D3D12_FORMAT_SUPPORT1_RENDER_TARGET  = 0x4000,
+        D3D12_FORMAT_SUPPORT1_BLENDABLE  = 0x8000,
+        D3D12_FORMAT_SUPPORT1_DEPTH_STENCIL  = 0x10000,
+        D3D12_FORMAT_SUPPORT1_MULTISAMPLE_RESOLVE  = 0x40000,
+        D3D12_FORMAT_SUPPORT1_DISPLAY  = 0x80000,
+        D3D12_FORMAT_SUPPORT1_CAST_WITHIN_BIT_LAYOUT = 0x100000,
+        D3D12_FORMAT_SUPPORT1_MULTISAMPLE_RENDERTARGET = 0x200000,
+        D3D12_FORMAT_SUPPORT1_MULTISAMPLE_LOAD = 0x400000,
+        D3D12_FORMAT_SUPPORT1_SHADER_GATHER  = 0x800000,
+        D3D12_FORMAT_SUPPORT1_BACK_BUFFER_CAST = 0x1000000,
+        D3D12_FORMAT_SUPPORT1_TYPED_UNORDERED_ACCESS_VIEW  = 0x2000000,
+        D3D12_FORMAT_SUPPORT1_SHADER_GATHER_COMPARISON = 0x4000000,
+        D3D12_FORMAT_SUPPORT1_DECODER_OUTPUT = 0x8000000,
+        D3D12_FORMAT_SUPPORT1_VIDEO_PROCESSOR_OUTPUT = 0x10000000,
+        D3D12_FORMAT_SUPPORT1_VIDEO_PROCESSOR_INPUT  = 0x20000000,
+        D3D12_FORMAT_SUPPORT1_VIDEO_ENCODER  = 0x40000000
+    }  D3D12_FORMAT_SUPPORT1;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_FORMAT_SUPPORT1 );
+typedef 
+enum D3D12_FORMAT_SUPPORT2
+    {
+        D3D12_FORMAT_SUPPORT2_NONE = 0,
+        D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_ADD = 0x1,
+        D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_BITWISE_OPS = 0x2,
+        D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_COMPARE_STORE_OR_COMPARE_EXCHANGE = 0x4,
+        D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_EXCHANGE  = 0x8,
+        D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_SIGNED_MIN_OR_MAX = 0x10,
+        D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_UNSIGNED_MIN_OR_MAX = 0x20,
+        D3D12_FORMAT_SUPPORT2_UAV_TYPED_LOAD = 0x40,
+        D3D12_FORMAT_SUPPORT2_UAV_TYPED_STORE  = 0x80,
+        D3D12_FORMAT_SUPPORT2_OUTPUT_MERGER_LOGIC_OP = 0x100,
+        D3D12_FORMAT_SUPPORT2_TILED  = 0x200,
+        D3D12_FORMAT_SUPPORT2_MULTIPLANE_OVERLAY = 0x4000
+    }  D3D12_FORMAT_SUPPORT2;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_FORMAT_SUPPORT2 );
+typedef 
+enum D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS
+    {
+        D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE = 0,
+        D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_TILED_RESOURCE = 0x1
+    }  D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS );
+typedef 
+enum D3D12_CROSS_NODE_SHARING_TIER
+    {
+        D3D12_CROSS_NODE_SHARING_TIER_NOT_SUPPORTED  = 0,
+        D3D12_CROSS_NODE_SHARING_TIER_1_EMULATED = 1,
+        D3D12_CROSS_NODE_SHARING_TIER_1  = 2,
+        D3D12_CROSS_NODE_SHARING_TIER_2  = 3,
+        D3D12_CROSS_NODE_SHARING_TIER_3  = 4
+    }  D3D12_CROSS_NODE_SHARING_TIER;
+
+typedef 
+enum D3D12_RESOURCE_HEAP_TIER
+    {
+        D3D12_RESOURCE_HEAP_TIER_1 = 1,
+        D3D12_RESOURCE_HEAP_TIER_2 = 2
+    }  D3D12_RESOURCE_HEAP_TIER;
+
+typedef 
+enum D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER
+    {
+        D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER_NOT_SUPPORTED = 0,
+        D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER_1 = 1,
+        D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER_2 = 2
+    }  D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER;
+
+typedef 
+enum D3D12_VIEW_INSTANCING_TIER
+    {
+        D3D12_VIEW_INSTANCING_TIER_NOT_SUPPORTED = 0,
+        D3D12_VIEW_INSTANCING_TIER_1 = 1,
+        D3D12_VIEW_INSTANCING_TIER_2 = 2,
+        D3D12_VIEW_INSTANCING_TIER_3 = 3
+    }  D3D12_VIEW_INSTANCING_TIER;
+
+typedef struct D3D12_FEATURE_DATA_D3D12_OPTIONS
+    {
+    _Out_  BOOL DoublePrecisionFloatShaderOps;
+    _Out_  BOOL OutputMergerLogicOp;
+    _Out_  D3D12_SHADER_MIN_PRECISION_SUPPORT MinPrecisionSupport;
+    _Out_  D3D12_TILED_RESOURCES_TIER TiledResourcesTier;
+    _Out_  D3D12_RESOURCE_BINDING_TIER ResourceBindingTier;
+    _Out_  BOOL PSSpecifiedStencilRefSupported;
+    _Out_  BOOL TypedUAVLoadAdditionalFormats;
+    _Out_  BOOL ROVsSupported;
+    _Out_  D3D12_CONSERVATIVE_RASTERIZATION_TIER ConservativeRasterizationTier;
+    _Out_  UINT MaxGPUVirtualAddressBitsPerResource;
+    _Out_  BOOL StandardSwizzle64KBSupported;
+    _Out_  D3D12_CROSS_NODE_SHARING_TIER CrossNodeSharingTier;
+    _Out_  BOOL CrossAdapterRowMajorTextureSupported;
+    _Out_  BOOL VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation;
+    _Out_  D3D12_RESOURCE_HEAP_TIER ResourceHeapTier;
+    }  D3D12_FEATURE_DATA_D3D12_OPTIONS;
+
+typedef struct D3D12_FEATURE_DATA_D3D12_OPTIONS1
+    {
+    _Out_  BOOL WaveOps;
+    _Out_  UINT WaveLaneCountMin;
+    _Out_  UINT WaveLaneCountMax;
+    _Out_  UINT TotalLaneCount;
+    _Out_  BOOL ExpandedComputeResourceStates;
+    _Out_  BOOL Int64ShaderOps;
+    }  D3D12_FEATURE_DATA_D3D12_OPTIONS1;
+
+typedef struct D3D12_FEATURE_DATA_D3D12_OPTIONS2
+    {
+    _Out_  BOOL DepthBoundsTestSupported;
+    _Out_  D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER ProgrammableSamplePositionsTier;
+    }  D3D12_FEATURE_DATA_D3D12_OPTIONS2;
+
+typedef 
+enum D3D_ROOT_SIGNATURE_VERSION
+    {
+        D3D_ROOT_SIGNATURE_VERSION_1 = 0x1,
+        D3D_ROOT_SIGNATURE_VERSION_1_0 = 0x1,
+        D3D_ROOT_SIGNATURE_VERSION_1_1 = 0x2
+    }  D3D_ROOT_SIGNATURE_VERSION;
+
+typedef struct D3D12_FEATURE_DATA_ROOT_SIGNATURE
+    {
+    _Inout_  D3D_ROOT_SIGNATURE_VERSION HighestVersion;
+    }  D3D12_FEATURE_DATA_ROOT_SIGNATURE;
+
+typedef struct D3D12_FEATURE_DATA_ARCHITECTURE
+    {
+    _In_  UINT NodeIndex;
+    _Out_  BOOL TileBasedRenderer;
+    _Out_  BOOL UMA;
+    _Out_  BOOL CacheCoherentUMA;
+    }  D3D12_FEATURE_DATA_ARCHITECTURE;
+
+typedef struct D3D12_FEATURE_DATA_ARCHITECTURE1
+    {
+    _In_  UINT NodeIndex;
+    _Out_  BOOL TileBasedRenderer;
+    _Out_  BOOL UMA;
+    _Out_  BOOL CacheCoherentUMA;
+    _Out_  BOOL IsolatedMMU;
+    }  D3D12_FEATURE_DATA_ARCHITECTURE1;
+
+typedef struct D3D12_FEATURE_DATA_FEATURE_LEVELS
+    {
+    _In_  UINT NumFeatureLevels;
+    _In_reads_(NumFeatureLevels)  const D3D_FEATURE_LEVEL *pFeatureLevelsRequested;
+    _Out_  D3D_FEATURE_LEVEL MaxSupportedFeatureLevel;
+    }  D3D12_FEATURE_DATA_FEATURE_LEVELS;
+
+typedef 
+enum D3D_SHADER_MODEL
+    {
+        D3D_SHADER_MODEL_5_1 = 0x51,
+        D3D_SHADER_MODEL_6_0 = 0x60,
+        D3D_SHADER_MODEL_6_1 = 0x61,
+        D3D_SHADER_MODEL_6_2 = 0x62,
+        D3D_SHADER_MODEL_6_3 = 0x63,
+        D3D_SHADER_MODEL_6_4 = 0x64,
+        D3D_SHADER_MODEL_6_5 = 0x65
+    }  D3D_SHADER_MODEL;
+
+typedef struct D3D12_FEATURE_DATA_SHADER_MODEL
+    {
+    _Inout_  D3D_SHADER_MODEL HighestShaderModel;
+    }  D3D12_FEATURE_DATA_SHADER_MODEL;
+
+typedef struct D3D12_FEATURE_DATA_FORMAT_SUPPORT
+    {
+    _In_  DXGI_FORMAT Format;
+    _Out_  D3D12_FORMAT_SUPPORT1 Support1;
+    _Out_  D3D12_FORMAT_SUPPORT2 Support2;
+    }  D3D12_FEATURE_DATA_FORMAT_SUPPORT;
+
+typedef struct D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS
+    {
+    _In_  DXGI_FORMAT Format;
+    _In_  UINT SampleCount;
+    _In_  D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS Flags;
+    _Out_  UINT NumQualityLevels;
+    }  D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS;
+
+typedef struct D3D12_FEATURE_DATA_FORMAT_INFO
+    {
+    DXGI_FORMAT Format;
+    UINT8 PlaneCount;
+    }  D3D12_FEATURE_DATA_FORMAT_INFO;
+
+typedef struct D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT
+    {
+    UINT MaxGPUVirtualAddressBitsPerResource;
+    UINT MaxGPUVirtualAddressBitsPerProcess;
+    }  D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT;
+
+typedef 
+enum D3D12_SHADER_CACHE_SUPPORT_FLAGS
+    {
+        D3D12_SHADER_CACHE_SUPPORT_NONE  = 0,
+        D3D12_SHADER_CACHE_SUPPORT_SINGLE_PSO  = 0x1,
+        D3D12_SHADER_CACHE_SUPPORT_LIBRARY = 0x2,
+        D3D12_SHADER_CACHE_SUPPORT_AUTOMATIC_INPROC_CACHE  = 0x4,
+        D3D12_SHADER_CACHE_SUPPORT_AUTOMATIC_DISK_CACHE  = 0x8
+    }  D3D12_SHADER_CACHE_SUPPORT_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_SHADER_CACHE_SUPPORT_FLAGS );
+typedef struct D3D12_FEATURE_DATA_SHADER_CACHE
+    {
+    _Out_  D3D12_SHADER_CACHE_SUPPORT_FLAGS SupportFlags;
+    }  D3D12_FEATURE_DATA_SHADER_CACHE;
+
+typedef struct D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY
+    {
+    _In_  D3D12_COMMAND_LIST_TYPE CommandListType;
+    _In_  UINT Priority;
+    _Out_  BOOL PriorityForTypeIsSupported;
+    }  D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY;
+
+typedef 
+enum D3D12_COMMAND_LIST_SUPPORT_FLAGS
+    {
+        D3D12_COMMAND_LIST_SUPPORT_FLAG_NONE = 0,
+        D3D12_COMMAND_LIST_SUPPORT_FLAG_DIRECT = ( 1 << D3D12_COMMAND_LIST_TYPE_DIRECT ) ,
+        D3D12_COMMAND_LIST_SUPPORT_FLAG_BUNDLE = ( 1 << D3D12_COMMAND_LIST_TYPE_BUNDLE ) ,
+        D3D12_COMMAND_LIST_SUPPORT_FLAG_COMPUTE  = ( 1 << D3D12_COMMAND_LIST_TYPE_COMPUTE ) ,
+        D3D12_COMMAND_LIST_SUPPORT_FLAG_COPY = ( 1 << D3D12_COMMAND_LIST_TYPE_COPY ) ,
+        D3D12_COMMAND_LIST_SUPPORT_FLAG_VIDEO_DECODE = ( 1 << D3D12_COMMAND_LIST_TYPE_VIDEO_DECODE ) ,
+        D3D12_COMMAND_LIST_SUPPORT_FLAG_VIDEO_PROCESS  = ( 1 << D3D12_COMMAND_LIST_TYPE_VIDEO_PROCESS ) ,
+        D3D12_COMMAND_LIST_SUPPORT_FLAG_VIDEO_ENCODE = ( 1 << D3D12_COMMAND_LIST_TYPE_VIDEO_ENCODE ) 
+    }  D3D12_COMMAND_LIST_SUPPORT_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_COMMAND_LIST_SUPPORT_FLAGS );
+typedef struct D3D12_FEATURE_DATA_D3D12_OPTIONS3
+    {
+    _Out_  BOOL CopyQueueTimestampQueriesSupported;
+    _Out_  BOOL CastingFullyTypedFormatSupported;
+    _Out_  D3D12_COMMAND_LIST_SUPPORT_FLAGS WriteBufferImmediateSupportFlags;
+    _Out_  D3D12_VIEW_INSTANCING_TIER ViewInstancingTier;
+    _Out_  BOOL BarycentricsSupported;
+    }  D3D12_FEATURE_DATA_D3D12_OPTIONS3;
+
+typedef struct D3D12_FEATURE_DATA_EXISTING_HEAPS
+    {
+    _Out_  BOOL Supported;
+    }  D3D12_FEATURE_DATA_EXISTING_HEAPS;
+
+typedef 
+enum D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER
+    {
+        D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER_0 = 0,
+        D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER_1 = ( D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER_0 + 1 ) 
+    }  D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER;
+
+typedef struct D3D12_FEATURE_DATA_D3D12_OPTIONS4
+    {
+    _Out_  BOOL MSAA64KBAlignedTextureSupported;
+    _Out_  D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER SharedResourceCompatibilityTier;
+    _Out_  BOOL Native16BitShaderOpsSupported;
+    }  D3D12_FEATURE_DATA_D3D12_OPTIONS4;
+
+typedef 
+enum D3D12_HEAP_SERIALIZATION_TIER
+    {
+        D3D12_HEAP_SERIALIZATION_TIER_0  = 0,
+        D3D12_HEAP_SERIALIZATION_TIER_10 = 10
+    }  D3D12_HEAP_SERIALIZATION_TIER;
+
+typedef struct D3D12_FEATURE_DATA_SERIALIZATION
+    {
+    _In_  UINT NodeIndex;
+    _Out_  D3D12_HEAP_SERIALIZATION_TIER HeapSerializationTier;
+    }  D3D12_FEATURE_DATA_SERIALIZATION;
+
+typedef struct D3D12_FEATURE_DATA_CROSS_NODE
+    {
+    D3D12_CROSS_NODE_SHARING_TIER SharingTier;
+    BOOL AtomicShaderInstructions;
+    }  D3D12_FEATURE_DATA_CROSS_NODE;
+
+typedef 
+enum D3D12_RENDER_PASS_TIER
+    {
+        D3D12_RENDER_PASS_TIER_0 = 0,
+        D3D12_RENDER_PASS_TIER_1 = 1,
+        D3D12_RENDER_PASS_TIER_2 = 2
+    }  D3D12_RENDER_PASS_TIER;
+
+typedef 
+enum D3D12_RAYTRACING_TIER
+    {
+        D3D12_RAYTRACING_TIER_NOT_SUPPORTED  = 0,
+        D3D12_RAYTRACING_TIER_1_0  = 10
+    }  D3D12_RAYTRACING_TIER;
+
+typedef struct D3D12_FEATURE_DATA_D3D12_OPTIONS5
+    {
+    _Out_  BOOL SRVOnlyTiledResourceTier3;
+    _Out_  D3D12_RENDER_PASS_TIER RenderPassesTier;
+    _Out_  D3D12_RAYTRACING_TIER RaytracingTier;
+    }  D3D12_FEATURE_DATA_D3D12_OPTIONS5;
+
+typedef 
+enum D3D12_VARIABLE_SHADING_RATE_TIER
+    {
+        D3D12_VARIABLE_SHADING_RATE_TIER_NOT_SUPPORTED = 0,
+        D3D12_VARIABLE_SHADING_RATE_TIER_1 = 1,
+        D3D12_VARIABLE_SHADING_RATE_TIER_2 = 2
+    }  D3D12_VARIABLE_SHADING_RATE_TIER;
+
+typedef struct D3D12_FEATURE_DATA_D3D12_OPTIONS6
+    {
+    _Out_  BOOL AdditionalShadingRatesSupported;
+    _Out_  BOOL PerPrimitiveShadingRateSupportedWithViewportIndexing;
+    _Out_  D3D12_VARIABLE_SHADING_RATE_TIER VariableShadingRateTier;
+    _Out_  UINT ShadingRateImageTileSize;
+    _Out_  BOOL BackgroundProcessingSupported;
+    }  D3D12_FEATURE_DATA_D3D12_OPTIONS6;
+
+typedef struct D3D12_FEATURE_DATA_QUERY_META_COMMAND
+    {
+    _In_  GUID CommandId;
+    _In_  UINT NodeMask;
+    _Field_size_bytes_full_opt_( QueryInputDataSizeInBytes )  const void *pQueryInputData;
+    _In_  SIZE_T QueryInputDataSizeInBytes;
+    _Field_size_bytes_full_( QueryOutputDataSizeInBytes )  void *pQueryOutputData;
+    _In_  SIZE_T QueryOutputDataSizeInBytes;
+    }  D3D12_FEATURE_DATA_QUERY_META_COMMAND;
+
+typedef struct D3D12_RESOURCE_ALLOCATION_INFO
+    {
+    UINT64 SizeInBytes;
+    UINT64 Alignment;
+    }  D3D12_RESOURCE_ALLOCATION_INFO;
+
+typedef struct D3D12_RESOURCE_ALLOCATION_INFO1
+    {
+    UINT64 Offset;
+    UINT64 Alignment;
+    UINT64 SizeInBytes;
+    }  D3D12_RESOURCE_ALLOCATION_INFO1;
+
+typedef 
+enum D3D12_HEAP_TYPE
+    {
+        D3D12_HEAP_TYPE_DEFAULT  = 1,
+        D3D12_HEAP_TYPE_UPLOAD = 2,
+        D3D12_HEAP_TYPE_READBACK = 3,
+        D3D12_HEAP_TYPE_CUSTOM = 4
+    }  D3D12_HEAP_TYPE;
+
+typedef 
+enum D3D12_CPU_PAGE_PROPERTY
+    {
+        D3D12_CPU_PAGE_PROPERTY_UNKNOWN  = 0,
+        D3D12_CPU_PAGE_PROPERTY_NOT_AVAILABLE  = 1,
+        D3D12_CPU_PAGE_PROPERTY_WRITE_COMBINE  = 2,
+        D3D12_CPU_PAGE_PROPERTY_WRITE_BACK = 3
+    }  D3D12_CPU_PAGE_PROPERTY;
+
+typedef 
+enum D3D12_MEMORY_POOL
+    {
+        D3D12_MEMORY_POOL_UNKNOWN  = 0,
+        D3D12_MEMORY_POOL_L0 = 1,
+        D3D12_MEMORY_POOL_L1 = 2
+    }  D3D12_MEMORY_POOL;
+
+typedef struct D3D12_HEAP_PROPERTIES
+    {
+    D3D12_HEAP_TYPE Type;
+    D3D12_CPU_PAGE_PROPERTY CPUPageProperty;
+    D3D12_MEMORY_POOL MemoryPoolPreference;
+    UINT CreationNodeMask;
+    UINT VisibleNodeMask;
+    }  D3D12_HEAP_PROPERTIES;
+
+typedef 
+enum D3D12_HEAP_FLAGS
+    {
+        D3D12_HEAP_FLAG_NONE = 0,
+        D3D12_HEAP_FLAG_SHARED = 0x1,
+        D3D12_HEAP_FLAG_DENY_BUFFERS = 0x4,
+        D3D12_HEAP_FLAG_ALLOW_DISPLAY  = 0x8,
+        D3D12_HEAP_FLAG_SHARED_CROSS_ADAPTER = 0x20,
+        D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES  = 0x40,
+        D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES  = 0x80,
+        D3D12_HEAP_FLAG_HARDWARE_PROTECTED = 0x100,
+        D3D12_HEAP_FLAG_ALLOW_WRITE_WATCH  = 0x200,
+        D3D12_HEAP_FLAG_ALLOW_SHADER_ATOMICS = 0x400,
+        D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES = 0,
+        D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS = 0xc0,
+        D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES  = 0x44,
+        D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES  = 0x84
+    }  D3D12_HEAP_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_HEAP_FLAGS );
+typedef struct D3D12_HEAP_DESC
+    {
+    UINT64 SizeInBytes;
+    D3D12_HEAP_PROPERTIES Properties;
+    UINT64 Alignment;
+    D3D12_HEAP_FLAGS Flags;
+    }  D3D12_HEAP_DESC;
+
+typedef 
+enum D3D12_RESOURCE_DIMENSION
+    {
+        D3D12_RESOURCE_DIMENSION_UNKNOWN = 0,
+        D3D12_RESOURCE_DIMENSION_BUFFER  = 1,
+        D3D12_RESOURCE_DIMENSION_TEXTURE1D = 2,
+        D3D12_RESOURCE_DIMENSION_TEXTURE2D = 3,
+        D3D12_RESOURCE_DIMENSION_TEXTURE3D = 4
+    }  D3D12_RESOURCE_DIMENSION;
+
+typedef 
+enum D3D12_TEXTURE_LAYOUT
+    {
+        D3D12_TEXTURE_LAYOUT_UNKNOWN = 0,
+        D3D12_TEXTURE_LAYOUT_ROW_MAJOR = 1,
+        D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE  = 2,
+        D3D12_TEXTURE_LAYOUT_64KB_STANDARD_SWIZZLE = 3
+    }  D3D12_TEXTURE_LAYOUT;
+
+typedef 
+enum D3D12_RESOURCE_FLAGS
+    {
+        D3D12_RESOURCE_FLAG_NONE = 0,
+        D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET  = 0x1,
+        D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL  = 0x2,
+        D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS = 0x4,
+        D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE = 0x8,
+        D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER  = 0x10,
+        D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS  = 0x20,
+        D3D12_RESOURCE_FLAG_VIDEO_DECODE_REFERENCE_ONLY  = 0x40
+    }  D3D12_RESOURCE_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_RESOURCE_FLAGS );
+typedef struct D3D12_RESOURCE_DESC
+    {
+    D3D12_RESOURCE_DIMENSION Dimension;
+    UINT64 Alignment;
+    UINT64 Width;
+    UINT Height;
+    UINT16 DepthOrArraySize;
+    UINT16 MipLevels;
+    DXGI_FORMAT Format;
+    DXGI_SAMPLE_DESC SampleDesc;
+    D3D12_TEXTURE_LAYOUT Layout;
+    D3D12_RESOURCE_FLAGS Flags;
+    }  D3D12_RESOURCE_DESC;
+
+typedef struct D3D12_DEPTH_STENCIL_VALUE
+    {
+    FLOAT Depth;
+    UINT8 Stencil;
+    }  D3D12_DEPTH_STENCIL_VALUE;
+
+typedef struct D3D12_CLEAR_VALUE
+    {
+    DXGI_FORMAT Format;
+    union 
+        {
+        FLOAT Color[ 4 ];
+        D3D12_DEPTH_STENCIL_VALUE DepthStencil;
+        }  ;
+    }  D3D12_CLEAR_VALUE;
+
+typedef struct D3D12_RANGE
+    {
+    SIZE_T Begin;
+    SIZE_T End;
+    }  D3D12_RANGE;
+
+typedef struct D3D12_RANGE_UINT64
+    {
+    UINT64 Begin;
+    UINT64 End;
+    }  D3D12_RANGE_UINT64;
+
+typedef struct D3D12_SUBRESOURCE_RANGE_UINT64
+    {
+    UINT Subresource;
+    D3D12_RANGE_UINT64 Range;
+    }  D3D12_SUBRESOURCE_RANGE_UINT64;
+
+typedef struct D3D12_SUBRESOURCE_INFO
+    {
+    UINT64 Offset;
+    UINT RowPitch;
+    UINT DepthPitch;
+    }  D3D12_SUBRESOURCE_INFO;
+
+typedef struct D3D12_TILED_RESOURCE_COORDINATE
+    {
+    UINT X;
+    UINT Y;
+    UINT Z;
+    UINT Subresource;
+    }  D3D12_TILED_RESOURCE_COORDINATE;
+
+typedef struct D3D12_TILE_REGION_SIZE
+    {
+    UINT NumTiles;
+    BOOL UseBox;
+    UINT Width;
+    UINT16 Height;
+    UINT16 Depth;
+    }  D3D12_TILE_REGION_SIZE;
+
+typedef 
+enum D3D12_TILE_RANGE_FLAGS
+    {
+        D3D12_TILE_RANGE_FLAG_NONE = 0,
+        D3D12_TILE_RANGE_FLAG_NULL = 1,
+        D3D12_TILE_RANGE_FLAG_SKIP = 2,
+        D3D12_TILE_RANGE_FLAG_REUSE_SINGLE_TILE  = 4
+    }  D3D12_TILE_RANGE_FLAGS;
+
+typedef struct D3D12_SUBRESOURCE_TILING
+    {
+    UINT WidthInTiles;
+    UINT16 HeightInTiles;
+    UINT16 DepthInTiles;
+    UINT StartTileIndexInOverallResource;
+    }  D3D12_SUBRESOURCE_TILING;
+
+typedef struct D3D12_TILE_SHAPE
+    {
+    UINT WidthInTexels;
+    UINT HeightInTexels;
+    UINT DepthInTexels;
+    }  D3D12_TILE_SHAPE;
+
+typedef struct D3D12_PACKED_MIP_INFO
+    {
+    UINT8 NumStandardMips;
+    UINT8 NumPackedMips;
+    UINT NumTilesForPackedMips;
+    UINT StartTileIndexInOverallResource;
+    }  D3D12_PACKED_MIP_INFO;
+
+typedef 
+enum D3D12_TILE_MAPPING_FLAGS
+    {
+        D3D12_TILE_MAPPING_FLAG_NONE = 0,
+        D3D12_TILE_MAPPING_FLAG_NO_HAZARD  = 0x1
+    }  D3D12_TILE_MAPPING_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_TILE_MAPPING_FLAGS );
+typedef 
+enum D3D12_TILE_COPY_FLAGS
+    {
+        D3D12_TILE_COPY_FLAG_NONE  = 0,
+        D3D12_TILE_COPY_FLAG_NO_HAZARD = 0x1,
+        D3D12_TILE_COPY_FLAG_LINEAR_BUFFER_TO_SWIZZLED_TILED_RESOURCE  = 0x2,
+        D3D12_TILE_COPY_FLAG_SWIZZLED_TILED_RESOURCE_TO_LINEAR_BUFFER  = 0x4
+    }  D3D12_TILE_COPY_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_TILE_COPY_FLAGS );
+typedef 
+enum D3D12_RESOURCE_STATES
+    {
+        D3D12_RESOURCE_STATE_COMMON  = 0,
+        D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER  = 0x1,
+        D3D12_RESOURCE_STATE_INDEX_BUFFER  = 0x2,
+        D3D12_RESOURCE_STATE_RENDER_TARGET = 0x4,
+        D3D12_RESOURCE_STATE_UNORDERED_ACCESS  = 0x8,
+        D3D12_RESOURCE_STATE_DEPTH_WRITE = 0x10,
+        D3D12_RESOURCE_STATE_DEPTH_READ  = 0x20,
+        D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE = 0x40,
+        D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE = 0x80,
+        D3D12_RESOURCE_STATE_STREAM_OUT  = 0x100,
+        D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT = 0x200,
+        D3D12_RESOURCE_STATE_COPY_DEST = 0x400,
+        D3D12_RESOURCE_STATE_COPY_SOURCE = 0x800,
+        D3D12_RESOURCE_STATE_RESOLVE_DEST  = 0x1000,
+        D3D12_RESOURCE_STATE_RESOLVE_SOURCE  = 0x2000,
+        D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE = 0x400000,
+        D3D12_RESOURCE_STATE_SHADING_RATE_SOURCE = 0x1000000,
+        D3D12_RESOURCE_STATE_GENERIC_READ  = ( ( ( ( ( 0x1 | 0x2 )  | 0x40 )  | 0x80 )  | 0x200 )  | 0x800 ) ,
+        D3D12_RESOURCE_STATE_PRESENT = 0,
+        D3D12_RESOURCE_STATE_PREDICATION = 0x200,
+        D3D12_RESOURCE_STATE_VIDEO_DECODE_READ = 0x10000,
+        D3D12_RESOURCE_STATE_VIDEO_DECODE_WRITE  = 0x20000,
+        D3D12_RESOURCE_STATE_VIDEO_PROCESS_READ  = 0x40000,
+        D3D12_RESOURCE_STATE_VIDEO_PROCESS_WRITE = 0x80000,
+        D3D12_RESOURCE_STATE_VIDEO_ENCODE_READ = 0x200000,
+        D3D12_RESOURCE_STATE_VIDEO_ENCODE_WRITE  = 0x800000
+    }  D3D12_RESOURCE_STATES;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_RESOURCE_STATES );
+typedef 
+enum D3D12_RESOURCE_BARRIER_TYPE
+    {
+        D3D12_RESOURCE_BARRIER_TYPE_TRANSITION = 0,
+        D3D12_RESOURCE_BARRIER_TYPE_ALIASING = ( D3D12_RESOURCE_BARRIER_TYPE_TRANSITION + 1 ) ,
+        D3D12_RESOURCE_BARRIER_TYPE_UAV  = ( D3D12_RESOURCE_BARRIER_TYPE_ALIASING + 1 ) 
+    }  D3D12_RESOURCE_BARRIER_TYPE;
+
+
+typedef struct D3D12_RESOURCE_TRANSITION_BARRIER
+    {
+    ID3D12Resource *pResource;
+    UINT Subresource;
+    D3D12_RESOURCE_STATES StateBefore;
+    D3D12_RESOURCE_STATES StateAfter;
+    }  D3D12_RESOURCE_TRANSITION_BARRIER;
+
+typedef struct D3D12_RESOURCE_ALIASING_BARRIER
+    {
+    ID3D12Resource *pResourceBefore;
+    ID3D12Resource *pResourceAfter;
+    }  D3D12_RESOURCE_ALIASING_BARRIER;
+
+typedef struct D3D12_RESOURCE_UAV_BARRIER
+    {
+    ID3D12Resource *pResource;
+    }  D3D12_RESOURCE_UAV_BARRIER;
+
+typedef 
+enum D3D12_RESOURCE_BARRIER_FLAGS
+    {
+        D3D12_RESOURCE_BARRIER_FLAG_NONE = 0,
+        D3D12_RESOURCE_BARRIER_FLAG_BEGIN_ONLY = 0x1,
+        D3D12_RESOURCE_BARRIER_FLAG_END_ONLY = 0x2
+    }  D3D12_RESOURCE_BARRIER_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_RESOURCE_BARRIER_FLAGS );
+typedef struct D3D12_RESOURCE_BARRIER
+    {
+    D3D12_RESOURCE_BARRIER_TYPE Type;
+    D3D12_RESOURCE_BARRIER_FLAGS Flags;
+    union 
+        {
+        D3D12_RESOURCE_TRANSITION_BARRIER Transition;
+        D3D12_RESOURCE_ALIASING_BARRIER Aliasing;
+        D3D12_RESOURCE_UAV_BARRIER UAV;
+        }  ;
+    }  D3D12_RESOURCE_BARRIER;
+
+typedef struct D3D12_SUBRESOURCE_FOOTPRINT
+    {
+    DXGI_FORMAT Format;
+    UINT Width;
+    UINT Height;
+    UINT Depth;
+    UINT RowPitch;
+    }  D3D12_SUBRESOURCE_FOOTPRINT;
+
+typedef struct D3D12_PLACED_SUBRESOURCE_FOOTPRINT
+    {
+    UINT64 Offset;
+    D3D12_SUBRESOURCE_FOOTPRINT Footprint;
+    }  D3D12_PLACED_SUBRESOURCE_FOOTPRINT;
+
+typedef 
+enum D3D12_TEXTURE_COPY_TYPE
+    {
+        D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX  = 0,
+        D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT = 1
+    }  D3D12_TEXTURE_COPY_TYPE;
+
+typedef struct D3D12_TEXTURE_COPY_LOCATION
+    {
+    ID3D12Resource *pResource;
+    D3D12_TEXTURE_COPY_TYPE Type;
+    union 
+        {
+        D3D12_PLACED_SUBRESOURCE_FOOTPRINT PlacedFootprint;
+        UINT SubresourceIndex;
+        }  ;
+    }  D3D12_TEXTURE_COPY_LOCATION;
+
+typedef 
+enum D3D12_RESOLVE_MODE
+    {
+        D3D12_RESOLVE_MODE_DECOMPRESS  = 0,
+        D3D12_RESOLVE_MODE_MIN = 1,
+        D3D12_RESOLVE_MODE_MAX = 2,
+        D3D12_RESOLVE_MODE_AVERAGE = 3
+    }  D3D12_RESOLVE_MODE;
+
+typedef struct D3D12_SAMPLE_POSITION
+    {
+    INT8 X;
+    INT8 Y;
+    }  D3D12_SAMPLE_POSITION;
+
+typedef struct D3D12_VIEW_INSTANCE_LOCATION
+    {
+    UINT ViewportArrayIndex;
+    UINT RenderTargetArrayIndex;
+    }  D3D12_VIEW_INSTANCE_LOCATION;
+
+typedef 
+enum D3D12_VIEW_INSTANCING_FLAGS
+    {
+        D3D12_VIEW_INSTANCING_FLAG_NONE  = 0,
+        D3D12_VIEW_INSTANCING_FLAG_ENABLE_VIEW_INSTANCE_MASKING  = 0x1
+    }  D3D12_VIEW_INSTANCING_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_VIEW_INSTANCING_FLAGS );
+typedef struct D3D12_VIEW_INSTANCING_DESC
+    {
+    UINT ViewInstanceCount;
+    _Field_size_full_(ViewInstanceCount)  const D3D12_VIEW_INSTANCE_LOCATION *pViewInstanceLocations;
+    D3D12_VIEW_INSTANCING_FLAGS Flags;
+    }  D3D12_VIEW_INSTANCING_DESC;
+
+typedef 
+enum D3D12_SHADER_COMPONENT_MAPPING
+    {
+        D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0 = 0,
+        D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_1 = 1,
+        D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_2 = 2,
+        D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_3 = 3,
+        D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0 = 4,
+        D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1 = 5
+    }  D3D12_SHADER_COMPONENT_MAPPING;
+
+#define D3D12_SHADER_COMPONENT_MAPPING_MASK 0x7 
+#define D3D12_SHADER_COMPONENT_MAPPING_SHIFT 3 
+#define D3D12_SHADER_COMPONENT_MAPPING_ALWAYS_SET_BIT_AVOIDING_ZEROMEM_MISTAKES (1<<(D3D12_SHADER_COMPONENT_MAPPING_SHIFT*4)) 
+#define D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(Src0,Src1,Src2,Src3) ((((Src0)&D3D12_SHADER_COMPONENT_MAPPING_MASK)| \
+                                                                (((Src1)&D3D12_SHADER_COMPONENT_MAPPING_MASK)<<D3D12_SHADER_COMPONENT_MAPPING_SHIFT)| \
+                                                                (((Src2)&D3D12_SHADER_COMPONENT_MAPPING_MASK)<<(D3D12_SHADER_COMPONENT_MAPPING_SHIFT*2))| \
+                                                                (((Src3)&D3D12_SHADER_COMPONENT_MAPPING_MASK)<<(D3D12_SHADER_COMPONENT_MAPPING_SHIFT*3))| \
+                                                                D3D12_SHADER_COMPONENT_MAPPING_ALWAYS_SET_BIT_AVOIDING_ZEROMEM_MISTAKES))
+#define D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(ComponentToExtract,Mapping) ((D3D12_SHADER_COMPONENT_MAPPING)(Mapping >> (D3D12_SHADER_COMPONENT_MAPPING_SHIFT*ComponentToExtract) & D3D12_SHADER_COMPONENT_MAPPING_MASK))
+#define D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0,1,2,3) 
+typedef 
+enum D3D12_BUFFER_SRV_FLAGS
+    {
+        D3D12_BUFFER_SRV_FLAG_NONE = 0,
+        D3D12_BUFFER_SRV_FLAG_RAW  = 0x1
+    }  D3D12_BUFFER_SRV_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_BUFFER_SRV_FLAGS );
+typedef struct D3D12_BUFFER_SRV
+    {
+    UINT64 FirstElement;
+    UINT NumElements;
+    UINT StructureByteStride;
+    D3D12_BUFFER_SRV_FLAGS Flags;
+    }  D3D12_BUFFER_SRV;
+
+typedef struct D3D12_TEX1D_SRV
+    {
+    UINT MostDetailedMip;
+    UINT MipLevels;
+    FLOAT ResourceMinLODClamp;
+    }  D3D12_TEX1D_SRV;
+
+typedef struct D3D12_TEX1D_ARRAY_SRV
+    {
+    UINT MostDetailedMip;
+    UINT MipLevels;
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    FLOAT ResourceMinLODClamp;
+    }  D3D12_TEX1D_ARRAY_SRV;
+
+typedef struct D3D12_TEX2D_SRV
+    {
+    UINT MostDetailedMip;
+    UINT MipLevels;
+    UINT PlaneSlice;
+    FLOAT ResourceMinLODClamp;
+    }  D3D12_TEX2D_SRV;
+
+typedef struct D3D12_TEX2D_ARRAY_SRV
+    {
+    UINT MostDetailedMip;
+    UINT MipLevels;
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    UINT PlaneSlice;
+    FLOAT ResourceMinLODClamp;
+    }  D3D12_TEX2D_ARRAY_SRV;
+
+typedef struct D3D12_TEX3D_SRV
+    {
+    UINT MostDetailedMip;
+    UINT MipLevels;
+    FLOAT ResourceMinLODClamp;
+    }  D3D12_TEX3D_SRV;
+
+typedef struct D3D12_TEXCUBE_SRV
+    {
+    UINT MostDetailedMip;
+    UINT MipLevels;
+    FLOAT ResourceMinLODClamp;
+    }  D3D12_TEXCUBE_SRV;
+
+typedef struct D3D12_TEXCUBE_ARRAY_SRV
+    {
+    UINT MostDetailedMip;
+    UINT MipLevels;
+    UINT First2DArrayFace;
+    UINT NumCubes;
+    FLOAT ResourceMinLODClamp;
+    }  D3D12_TEXCUBE_ARRAY_SRV;
+
+typedef struct D3D12_TEX2DMS_SRV
+    {
+    UINT UnusedField_NothingToDefine;
+    }  D3D12_TEX2DMS_SRV;
+
+typedef struct D3D12_TEX2DMS_ARRAY_SRV
+    {
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    }  D3D12_TEX2DMS_ARRAY_SRV;
+
+typedef struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS Location;
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV;
+
+typedef 
+enum D3D12_SRV_DIMENSION
+    {
+        D3D12_SRV_DIMENSION_UNKNOWN  = 0,
+        D3D12_SRV_DIMENSION_BUFFER = 1,
+        D3D12_SRV_DIMENSION_TEXTURE1D  = 2,
+        D3D12_SRV_DIMENSION_TEXTURE1DARRAY = 3,
+        D3D12_SRV_DIMENSION_TEXTURE2D  = 4,
+        D3D12_SRV_DIMENSION_TEXTURE2DARRAY = 5,
+        D3D12_SRV_DIMENSION_TEXTURE2DMS  = 6,
+        D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY = 7,
+        D3D12_SRV_DIMENSION_TEXTURE3D  = 8,
+        D3D12_SRV_DIMENSION_TEXTURECUBE  = 9,
+        D3D12_SRV_DIMENSION_TEXTURECUBEARRAY = 10,
+        D3D12_SRV_DIMENSION_RAYTRACING_ACCELERATION_STRUCTURE  = 11
+    }  D3D12_SRV_DIMENSION;
+
+typedef struct D3D12_SHADER_RESOURCE_VIEW_DESC
+    {
+    DXGI_FORMAT Format;
+    D3D12_SRV_DIMENSION ViewDimension;
+    UINT Shader4ComponentMapping;
+    union 
+        {
+        D3D12_BUFFER_SRV Buffer;
+        D3D12_TEX1D_SRV Texture1D;
+        D3D12_TEX1D_ARRAY_SRV Texture1DArray;
+        D3D12_TEX2D_SRV Texture2D;
+        D3D12_TEX2D_ARRAY_SRV Texture2DArray;
+        D3D12_TEX2DMS_SRV Texture2DMS;
+        D3D12_TEX2DMS_ARRAY_SRV Texture2DMSArray;
+        D3D12_TEX3D_SRV Texture3D;
+        D3D12_TEXCUBE_SRV TextureCube;
+        D3D12_TEXCUBE_ARRAY_SRV TextureCubeArray;
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV RaytracingAccelerationStructure;
+        }  ;
+    }  D3D12_SHADER_RESOURCE_VIEW_DESC;
+
+typedef struct D3D12_CONSTANT_BUFFER_VIEW_DESC
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
+    UINT SizeInBytes;
+    }  D3D12_CONSTANT_BUFFER_VIEW_DESC;
+
+typedef 
+enum D3D12_FILTER
+    {
+        D3D12_FILTER_MIN_MAG_MIP_POINT = 0,
+        D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR  = 0x1,
+        D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT  = 0x4,
+        D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR  = 0x5,
+        D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT  = 0x10,
+        D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,
+        D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT  = 0x14,
+        D3D12_FILTER_MIN_MAG_MIP_LINEAR  = 0x15,
+        D3D12_FILTER_ANISOTROPIC = 0x55,
+        D3D12_FILTER_COMPARISON_MIN_MAG_MIP_POINT  = 0x80,
+        D3D12_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 0x81,
+        D3D12_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x84,
+        D3D12_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 0x85,
+        D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 0x90,
+        D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR  = 0x91,
+        D3D12_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 0x94,
+        D3D12_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR = 0x95,
+        D3D12_FILTER_COMPARISON_ANISOTROPIC  = 0xd5,
+        D3D12_FILTER_MINIMUM_MIN_MAG_MIP_POINT = 0x100,
+        D3D12_FILTER_MINIMUM_MIN_MAG_POINT_MIP_LINEAR  = 0x101,
+        D3D12_FILTER_MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT  = 0x104,
+        D3D12_FILTER_MINIMUM_MIN_POINT_MAG_MIP_LINEAR  = 0x105,
+        D3D12_FILTER_MINIMUM_MIN_LINEAR_MAG_MIP_POINT  = 0x110,
+        D3D12_FILTER_MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x111,
+        D3D12_FILTER_MINIMUM_MIN_MAG_LINEAR_MIP_POINT  = 0x114,
+        D3D12_FILTER_MINIMUM_MIN_MAG_MIP_LINEAR  = 0x115,
+        D3D12_FILTER_MINIMUM_ANISOTROPIC = 0x155,
+        D3D12_FILTER_MAXIMUM_MIN_MAG_MIP_POINT = 0x180,
+        D3D12_FILTER_MAXIMUM_MIN_MAG_POINT_MIP_LINEAR  = 0x181,
+        D3D12_FILTER_MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT  = 0x184,
+        D3D12_FILTER_MAXIMUM_MIN_POINT_MAG_MIP_LINEAR  = 0x185,
+        D3D12_FILTER_MAXIMUM_MIN_LINEAR_MAG_MIP_POINT  = 0x190,
+        D3D12_FILTER_MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x191,
+        D3D12_FILTER_MAXIMUM_MIN_MAG_LINEAR_MIP_POINT  = 0x194,
+        D3D12_FILTER_MAXIMUM_MIN_MAG_MIP_LINEAR  = 0x195,
+        D3D12_FILTER_MAXIMUM_ANISOTROPIC = 0x1d5
+    }  D3D12_FILTER;
+
+typedef 
+enum D3D12_FILTER_TYPE
+    {
+        D3D12_FILTER_TYPE_POINT  = 0,
+        D3D12_FILTER_TYPE_LINEAR = 1
+    }  D3D12_FILTER_TYPE;
+
+typedef 
+enum D3D12_FILTER_REDUCTION_TYPE
+    {
+        D3D12_FILTER_REDUCTION_TYPE_STANDARD = 0,
+        D3D12_FILTER_REDUCTION_TYPE_COMPARISON = 1,
+        D3D12_FILTER_REDUCTION_TYPE_MINIMUM  = 2,
+        D3D12_FILTER_REDUCTION_TYPE_MAXIMUM  = 3
+    }  D3D12_FILTER_REDUCTION_TYPE;
+
+#define  D3D12_FILTER_REDUCTION_TYPE_MASK  ( 0x3 )
+
+#define  D3D12_FILTER_REDUCTION_TYPE_SHIFT ( 7 )
+
+#define  D3D12_FILTER_TYPE_MASK  ( 0x3 )
+
+#define  D3D12_MIN_FILTER_SHIFT  ( 4 )
+
+#define  D3D12_MAG_FILTER_SHIFT  ( 2 )
+
+#define  D3D12_MIP_FILTER_SHIFT  ( 0 )
+
+#define  D3D12_ANISOTROPIC_FILTERING_BIT ( 0x40 )
+
+#define D3D12_ENCODE_BASIC_FILTER( min, mag, mip, reduction )                                                     \
+                                   ( ( D3D12_FILTER ) (                                                           \
+                                   ( ( ( min ) & D3D12_FILTER_TYPE_MASK ) << D3D12_MIN_FILTER_SHIFT ) |           \
+                                   ( ( ( mag ) & D3D12_FILTER_TYPE_MASK ) << D3D12_MAG_FILTER_SHIFT ) |           \
+                                   ( ( ( mip ) & D3D12_FILTER_TYPE_MASK ) << D3D12_MIP_FILTER_SHIFT ) |           \
+                                   ( ( ( reduction ) & D3D12_FILTER_REDUCTION_TYPE_MASK ) << D3D12_FILTER_REDUCTION_TYPE_SHIFT ) ) ) 
+#define D3D12_ENCODE_ANISOTROPIC_FILTER( reduction )                                                  \
+                                         ( ( D3D12_FILTER ) (                                         \
+                                         D3D12_ANISOTROPIC_FILTERING_BIT |                            \
+                                         D3D12_ENCODE_BASIC_FILTER( D3D12_FILTER_TYPE_LINEAR,         \
+                                                                    D3D12_FILTER_TYPE_LINEAR,         \
+                                                                    D3D12_FILTER_TYPE_LINEAR,         \
+                                                                    reduction ) ) )                     
+#define D3D12_DECODE_MIN_FILTER( D3D12Filter )                                                              \
+                                 ( ( D3D12_FILTER_TYPE )                                                    \
+                                 ( ( ( D3D12Filter ) >> D3D12_MIN_FILTER_SHIFT ) & D3D12_FILTER_TYPE_MASK ) ) 
+#define D3D12_DECODE_MAG_FILTER( D3D12Filter )                                                              \
+                                 ( ( D3D12_FILTER_TYPE )                                                    \
+                                 ( ( ( D3D12Filter ) >> D3D12_MAG_FILTER_SHIFT ) & D3D12_FILTER_TYPE_MASK ) ) 
+#define D3D12_DECODE_MIP_FILTER( D3D12Filter )                                                              \
+                                 ( ( D3D12_FILTER_TYPE )                                                    \
+                                 ( ( ( D3D12Filter ) >> D3D12_MIP_FILTER_SHIFT ) & D3D12_FILTER_TYPE_MASK ) ) 
+#define D3D12_DECODE_FILTER_REDUCTION( D3D12Filter )                                                        \
+                                 ( ( D3D12_FILTER_REDUCTION_TYPE )                                                      \
+                                 ( ( ( D3D12Filter ) >> D3D12_FILTER_REDUCTION_TYPE_SHIFT ) & D3D12_FILTER_REDUCTION_TYPE_MASK ) ) 
+#define D3D12_DECODE_IS_COMPARISON_FILTER( D3D12Filter )                                                    \
+                                 ( D3D12_DECODE_FILTER_REDUCTION( D3D12Filter ) == D3D12_FILTER_REDUCTION_TYPE_COMPARISON ) 
+#define D3D12_DECODE_IS_ANISOTROPIC_FILTER( D3D12Filter )                                               \
+                            ( ( ( D3D12Filter ) & D3D12_ANISOTROPIC_FILTERING_BIT ) &&                  \
+                            ( D3D12_FILTER_TYPE_LINEAR == D3D12_DECODE_MIN_FILTER( D3D12Filter ) ) &&   \
+                            ( D3D12_FILTER_TYPE_LINEAR == D3D12_DECODE_MAG_FILTER( D3D12Filter ) ) &&   \
+                            ( D3D12_FILTER_TYPE_LINEAR == D3D12_DECODE_MIP_FILTER( D3D12Filter ) ) )      
+typedef 
+enum D3D12_TEXTURE_ADDRESS_MODE
+    {
+        D3D12_TEXTURE_ADDRESS_MODE_WRAP  = 1,
+        D3D12_TEXTURE_ADDRESS_MODE_MIRROR  = 2,
+        D3D12_TEXTURE_ADDRESS_MODE_CLAMP = 3,
+        D3D12_TEXTURE_ADDRESS_MODE_BORDER  = 4,
+        D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE = 5
+    }  D3D12_TEXTURE_ADDRESS_MODE;
+
+typedef struct D3D12_SAMPLER_DESC
+    {
+    D3D12_FILTER Filter;
+    D3D12_TEXTURE_ADDRESS_MODE AddressU;
+    D3D12_TEXTURE_ADDRESS_MODE AddressV;
+    D3D12_TEXTURE_ADDRESS_MODE AddressW;
+    FLOAT MipLODBias;
+    UINT MaxAnisotropy;
+    D3D12_COMPARISON_FUNC ComparisonFunc;
+    FLOAT BorderColor[ 4 ];
+    FLOAT MinLOD;
+    FLOAT MaxLOD;
+    }  D3D12_SAMPLER_DESC;
+
+typedef 
+enum D3D12_BUFFER_UAV_FLAGS
+    {
+        D3D12_BUFFER_UAV_FLAG_NONE = 0,
+        D3D12_BUFFER_UAV_FLAG_RAW  = 0x1
+    }  D3D12_BUFFER_UAV_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_BUFFER_UAV_FLAGS );
+typedef struct D3D12_BUFFER_UAV
+    {
+    UINT64 FirstElement;
+    UINT NumElements;
+    UINT StructureByteStride;
+    UINT64 CounterOffsetInBytes;
+    D3D12_BUFFER_UAV_FLAGS Flags;
+    }  D3D12_BUFFER_UAV;
+
+typedef struct D3D12_TEX1D_UAV
+    {
+    UINT MipSlice;
+    }  D3D12_TEX1D_UAV;
+
+typedef struct D3D12_TEX1D_ARRAY_UAV
+    {
+    UINT MipSlice;
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    }  D3D12_TEX1D_ARRAY_UAV;
+
+typedef struct D3D12_TEX2D_UAV
+    {
+    UINT MipSlice;
+    UINT PlaneSlice;
+    }  D3D12_TEX2D_UAV;
+
+typedef struct D3D12_TEX2D_ARRAY_UAV
+    {
+    UINT MipSlice;
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    UINT PlaneSlice;
+    }  D3D12_TEX2D_ARRAY_UAV;
+
+typedef struct D3D12_TEX3D_UAV
+    {
+    UINT MipSlice;
+    UINT FirstWSlice;
+    UINT WSize;
+    }  D3D12_TEX3D_UAV;
+
+typedef 
+enum D3D12_UAV_DIMENSION
+    {
+        D3D12_UAV_DIMENSION_UNKNOWN  = 0,
+        D3D12_UAV_DIMENSION_BUFFER = 1,
+        D3D12_UAV_DIMENSION_TEXTURE1D  = 2,
+        D3D12_UAV_DIMENSION_TEXTURE1DARRAY = 3,
+        D3D12_UAV_DIMENSION_TEXTURE2D  = 4,
+        D3D12_UAV_DIMENSION_TEXTURE2DARRAY = 5,
+        D3D12_UAV_DIMENSION_TEXTURE3D  = 8
+    }  D3D12_UAV_DIMENSION;
+
+typedef struct D3D12_UNORDERED_ACCESS_VIEW_DESC
+    {
+    DXGI_FORMAT Format;
+    D3D12_UAV_DIMENSION ViewDimension;
+    union 
+        {
+        D3D12_BUFFER_UAV Buffer;
+        D3D12_TEX1D_UAV Texture1D;
+        D3D12_TEX1D_ARRAY_UAV Texture1DArray;
+        D3D12_TEX2D_UAV Texture2D;
+        D3D12_TEX2D_ARRAY_UAV Texture2DArray;
+        D3D12_TEX3D_UAV Texture3D;
+        }  ;
+    }  D3D12_UNORDERED_ACCESS_VIEW_DESC;
+
+typedef struct D3D12_BUFFER_RTV
+    {
+    UINT64 FirstElement;
+    UINT NumElements;
+    }  D3D12_BUFFER_RTV;
+
+typedef struct D3D12_TEX1D_RTV
+    {
+    UINT MipSlice;
+    }  D3D12_TEX1D_RTV;
+
+typedef struct D3D12_TEX1D_ARRAY_RTV
+    {
+    UINT MipSlice;
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    }  D3D12_TEX1D_ARRAY_RTV;
+
+typedef struct D3D12_TEX2D_RTV
+    {
+    UINT MipSlice;
+    UINT PlaneSlice;
+    }  D3D12_TEX2D_RTV;
+
+typedef struct D3D12_TEX2DMS_RTV
+    {
+    UINT UnusedField_NothingToDefine;
+    }  D3D12_TEX2DMS_RTV;
+
+typedef struct D3D12_TEX2D_ARRAY_RTV
+    {
+    UINT MipSlice;
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    UINT PlaneSlice;
+    }  D3D12_TEX2D_ARRAY_RTV;
+
+typedef struct D3D12_TEX2DMS_ARRAY_RTV
+    {
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    }  D3D12_TEX2DMS_ARRAY_RTV;
+
+typedef struct D3D12_TEX3D_RTV
+    {
+    UINT MipSlice;
+    UINT FirstWSlice;
+    UINT WSize;
+    }  D3D12_TEX3D_RTV;
+
+typedef 
+enum D3D12_RTV_DIMENSION
+    {
+        D3D12_RTV_DIMENSION_UNKNOWN  = 0,
+        D3D12_RTV_DIMENSION_BUFFER = 1,
+        D3D12_RTV_DIMENSION_TEXTURE1D  = 2,
+        D3D12_RTV_DIMENSION_TEXTURE1DARRAY = 3,
+        D3D12_RTV_DIMENSION_TEXTURE2D  = 4,
+        D3D12_RTV_DIMENSION_TEXTURE2DARRAY = 5,
+        D3D12_RTV_DIMENSION_TEXTURE2DMS  = 6,
+        D3D12_RTV_DIMENSION_TEXTURE2DMSARRAY = 7,
+        D3D12_RTV_DIMENSION_TEXTURE3D  = 8
+    }  D3D12_RTV_DIMENSION;
+
+typedef struct D3D12_RENDER_TARGET_VIEW_DESC
+    {
+    DXGI_FORMAT Format;
+    D3D12_RTV_DIMENSION ViewDimension;
+    union 
+        {
+        D3D12_BUFFER_RTV Buffer;
+        D3D12_TEX1D_RTV Texture1D;
+        D3D12_TEX1D_ARRAY_RTV Texture1DArray;
+        D3D12_TEX2D_RTV Texture2D;
+        D3D12_TEX2D_ARRAY_RTV Texture2DArray;
+        D3D12_TEX2DMS_RTV Texture2DMS;
+        D3D12_TEX2DMS_ARRAY_RTV Texture2DMSArray;
+        D3D12_TEX3D_RTV Texture3D;
+        }  ;
+    }  D3D12_RENDER_TARGET_VIEW_DESC;
+
+typedef struct D3D12_TEX1D_DSV
+    {
+    UINT MipSlice;
+    }  D3D12_TEX1D_DSV;
+
+typedef struct D3D12_TEX1D_ARRAY_DSV
+    {
+    UINT MipSlice;
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    }  D3D12_TEX1D_ARRAY_DSV;
+
+typedef struct D3D12_TEX2D_DSV
+    {
+    UINT MipSlice;
+    }  D3D12_TEX2D_DSV;
+
+typedef struct D3D12_TEX2D_ARRAY_DSV
+    {
+    UINT MipSlice;
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    }  D3D12_TEX2D_ARRAY_DSV;
+
+typedef struct D3D12_TEX2DMS_DSV
+    {
+    UINT UnusedField_NothingToDefine;
+    }  D3D12_TEX2DMS_DSV;
+
+typedef struct D3D12_TEX2DMS_ARRAY_DSV
+    {
+    UINT FirstArraySlice;
+    UINT ArraySize;
+    }  D3D12_TEX2DMS_ARRAY_DSV;
+
+typedef 
+enum D3D12_DSV_FLAGS
+    {
+        D3D12_DSV_FLAG_NONE  = 0,
+        D3D12_DSV_FLAG_READ_ONLY_DEPTH = 0x1,
+        D3D12_DSV_FLAG_READ_ONLY_STENCIL = 0x2
+    }  D3D12_DSV_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_DSV_FLAGS );
+typedef 
+enum D3D12_DSV_DIMENSION
+    {
+        D3D12_DSV_DIMENSION_UNKNOWN  = 0,
+        D3D12_DSV_DIMENSION_TEXTURE1D  = 1,
+        D3D12_DSV_DIMENSION_TEXTURE1DARRAY = 2,
+        D3D12_DSV_DIMENSION_TEXTURE2D  = 3,
+        D3D12_DSV_DIMENSION_TEXTURE2DARRAY = 4,
+        D3D12_DSV_DIMENSION_TEXTURE2DMS  = 5,
+        D3D12_DSV_DIMENSION_TEXTURE2DMSARRAY = 6
+    }  D3D12_DSV_DIMENSION;
+
+typedef struct D3D12_DEPTH_STENCIL_VIEW_DESC
+    {
+    DXGI_FORMAT Format;
+    D3D12_DSV_DIMENSION ViewDimension;
+    D3D12_DSV_FLAGS Flags;
+    union 
+        {
+        D3D12_TEX1D_DSV Texture1D;
+        D3D12_TEX1D_ARRAY_DSV Texture1DArray;
+        D3D12_TEX2D_DSV Texture2D;
+        D3D12_TEX2D_ARRAY_DSV Texture2DArray;
+        D3D12_TEX2DMS_DSV Texture2DMS;
+        D3D12_TEX2DMS_ARRAY_DSV Texture2DMSArray;
+        }  ;
+    }  D3D12_DEPTH_STENCIL_VIEW_DESC;
+
+typedef 
+enum D3D12_CLEAR_FLAGS
+    {
+        D3D12_CLEAR_FLAG_DEPTH = 0x1,
+        D3D12_CLEAR_FLAG_STENCIL = 0x2
+    }  D3D12_CLEAR_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_CLEAR_FLAGS );
+typedef 
+enum D3D12_FENCE_FLAGS
+    {
+        D3D12_FENCE_FLAG_NONE  = 0,
+        D3D12_FENCE_FLAG_SHARED  = 0x1,
+        D3D12_FENCE_FLAG_SHARED_CROSS_ADAPTER  = 0x2,
+        D3D12_FENCE_FLAG_NON_MONITORED = 0x4
+    }  D3D12_FENCE_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_FENCE_FLAGS );
+typedef 
+enum D3D12_DESCRIPTOR_HEAP_TYPE
+    {
+        D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV = 0,
+        D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER = ( D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV + 1 ) ,
+        D3D12_DESCRIPTOR_HEAP_TYPE_RTV = ( D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER + 1 ) ,
+        D3D12_DESCRIPTOR_HEAP_TYPE_DSV = ( D3D12_DESCRIPTOR_HEAP_TYPE_RTV + 1 ) ,
+        D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES = ( D3D12_DESCRIPTOR_HEAP_TYPE_DSV + 1 ) 
+    }  D3D12_DESCRIPTOR_HEAP_TYPE;
+
+typedef 
+enum D3D12_DESCRIPTOR_HEAP_FLAGS
+    {
+        D3D12_DESCRIPTOR_HEAP_FLAG_NONE  = 0,
+        D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE  = 0x1
+    }  D3D12_DESCRIPTOR_HEAP_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_DESCRIPTOR_HEAP_FLAGS );
+typedef struct D3D12_DESCRIPTOR_HEAP_DESC
+    {
+    D3D12_DESCRIPTOR_HEAP_TYPE Type;
+    UINT NumDescriptors;
+    D3D12_DESCRIPTOR_HEAP_FLAGS Flags;
+    UINT NodeMask;
+    }  D3D12_DESCRIPTOR_HEAP_DESC;
+
+typedef 
+enum D3D12_DESCRIPTOR_RANGE_TYPE
+    {
+        D3D12_DESCRIPTOR_RANGE_TYPE_SRV  = 0,
+        D3D12_DESCRIPTOR_RANGE_TYPE_UAV  = ( D3D12_DESCRIPTOR_RANGE_TYPE_SRV + 1 ) ,
+        D3D12_DESCRIPTOR_RANGE_TYPE_CBV  = ( D3D12_DESCRIPTOR_RANGE_TYPE_UAV + 1 ) ,
+        D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER  = ( D3D12_DESCRIPTOR_RANGE_TYPE_CBV + 1 ) 
+    }  D3D12_DESCRIPTOR_RANGE_TYPE;
+
+typedef struct D3D12_DESCRIPTOR_RANGE
+    {
+    D3D12_DESCRIPTOR_RANGE_TYPE RangeType;
+    UINT NumDescriptors;
+    UINT BaseShaderRegister;
+    UINT RegisterSpace;
+    UINT OffsetInDescriptorsFromTableStart;
+    }  D3D12_DESCRIPTOR_RANGE;
+
+typedef struct D3D12_ROOT_DESCRIPTOR_TABLE
+    {
+    UINT NumDescriptorRanges;
+    _Field_size_full_(NumDescriptorRanges)  const D3D12_DESCRIPTOR_RANGE *pDescriptorRanges;
+    }  D3D12_ROOT_DESCRIPTOR_TABLE;
+
+typedef struct D3D12_ROOT_CONSTANTS
+    {
+    UINT ShaderRegister;
+    UINT RegisterSpace;
+    UINT Num32BitValues;
+    }  D3D12_ROOT_CONSTANTS;
+
+typedef struct D3D12_ROOT_DESCRIPTOR
+    {
+    UINT ShaderRegister;
+    UINT RegisterSpace;
+    }  D3D12_ROOT_DESCRIPTOR;
+
+typedef 
+enum D3D12_SHADER_VISIBILITY
+    {
+        D3D12_SHADER_VISIBILITY_ALL  = 0,
+        D3D12_SHADER_VISIBILITY_VERTEX = 1,
+        D3D12_SHADER_VISIBILITY_HULL = 2,
+        D3D12_SHADER_VISIBILITY_DOMAIN = 3,
+        D3D12_SHADER_VISIBILITY_GEOMETRY = 4,
+        D3D12_SHADER_VISIBILITY_PIXEL  = 5
+    }  D3D12_SHADER_VISIBILITY;
+
+typedef 
+enum D3D12_ROOT_PARAMETER_TYPE
+    {
+        D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE = 0,
+        D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS  = ( D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE + 1 ) ,
+        D3D12_ROOT_PARAMETER_TYPE_CBV  = ( D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS + 1 ) ,
+        D3D12_ROOT_PARAMETER_TYPE_SRV  = ( D3D12_ROOT_PARAMETER_TYPE_CBV + 1 ) ,
+        D3D12_ROOT_PARAMETER_TYPE_UAV  = ( D3D12_ROOT_PARAMETER_TYPE_SRV + 1 ) 
+    }  D3D12_ROOT_PARAMETER_TYPE;
+
+typedef struct D3D12_ROOT_PARAMETER
+    {
+    D3D12_ROOT_PARAMETER_TYPE ParameterType;
+    union 
+        {
+        D3D12_ROOT_DESCRIPTOR_TABLE DescriptorTable;
+        D3D12_ROOT_CONSTANTS Constants;
+        D3D12_ROOT_DESCRIPTOR Descriptor;
+        }  ;
+    D3D12_SHADER_VISIBILITY ShaderVisibility;
+    }  D3D12_ROOT_PARAMETER;
+
+typedef 
+enum D3D12_ROOT_SIGNATURE_FLAGS
+    {
+        D3D12_ROOT_SIGNATURE_FLAG_NONE = 0,
+        D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT = 0x1,
+        D3D12_ROOT_SIGNATURE_FLAG_DENY_VERTEX_SHADER_ROOT_ACCESS = 0x2,
+        D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS = 0x4,
+        D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS = 0x8,
+        D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS = 0x10,
+        D3D12_ROOT_SIGNATURE_FLAG_DENY_PIXEL_SHADER_ROOT_ACCESS  = 0x20,
+        D3D12_ROOT_SIGNATURE_FLAG_ALLOW_STREAM_OUTPUT  = 0x40,
+        D3D12_ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE = 0x80
+    }  D3D12_ROOT_SIGNATURE_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_ROOT_SIGNATURE_FLAGS );
+typedef 
+enum D3D12_STATIC_BORDER_COLOR
+    {
+        D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK  = 0,
+        D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK = ( D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK + 1 ) ,
+        D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE = ( D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK + 1 ) 
+    }  D3D12_STATIC_BORDER_COLOR;
+
+typedef struct D3D12_STATIC_SAMPLER_DESC
+    {
+    D3D12_FILTER Filter;
+    D3D12_TEXTURE_ADDRESS_MODE AddressU;
+    D3D12_TEXTURE_ADDRESS_MODE AddressV;
+    D3D12_TEXTURE_ADDRESS_MODE AddressW;
+    FLOAT MipLODBias;
+    UINT MaxAnisotropy;
+    D3D12_COMPARISON_FUNC ComparisonFunc;
+    D3D12_STATIC_BORDER_COLOR BorderColor;
+    FLOAT MinLOD;
+    FLOAT MaxLOD;
+    UINT ShaderRegister;
+    UINT RegisterSpace;
+    D3D12_SHADER_VISIBILITY ShaderVisibility;
+    }  D3D12_STATIC_SAMPLER_DESC;
+
+typedef struct D3D12_ROOT_SIGNATURE_DESC
+    {
+    UINT NumParameters;
+    _Field_size_full_(NumParameters)  const D3D12_ROOT_PARAMETER *pParameters;
+    UINT NumStaticSamplers;
+    _Field_size_full_(NumStaticSamplers)  const D3D12_STATIC_SAMPLER_DESC *pStaticSamplers;
+    D3D12_ROOT_SIGNATURE_FLAGS Flags;
+    }  D3D12_ROOT_SIGNATURE_DESC;
+
+typedef 
+enum D3D12_DESCRIPTOR_RANGE_FLAGS
+    {
+        D3D12_DESCRIPTOR_RANGE_FLAG_NONE = 0,
+        D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE = 0x1,
+        D3D12_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE  = 0x2,
+        D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE = 0x4,
+        D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC  = 0x8,
+        D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_STATIC_KEEPING_BUFFER_BOUNDS_CHECKS  = 0x10000
+    }  D3D12_DESCRIPTOR_RANGE_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_DESCRIPTOR_RANGE_FLAGS );
+typedef struct D3D12_DESCRIPTOR_RANGE1
+    {
+    D3D12_DESCRIPTOR_RANGE_TYPE RangeType;
+    UINT NumDescriptors;
+    UINT BaseShaderRegister;
+    UINT RegisterSpace;
+    D3D12_DESCRIPTOR_RANGE_FLAGS Flags;
+    UINT OffsetInDescriptorsFromTableStart;
+    }  D3D12_DESCRIPTOR_RANGE1;
+
+typedef struct D3D12_ROOT_DESCRIPTOR_TABLE1
+    {
+    UINT NumDescriptorRanges;
+    _Field_size_full_(NumDescriptorRanges)  const D3D12_DESCRIPTOR_RANGE1 *pDescriptorRanges;
+    }  D3D12_ROOT_DESCRIPTOR_TABLE1;
+
+typedef 
+enum D3D12_ROOT_DESCRIPTOR_FLAGS
+    {
+        D3D12_ROOT_DESCRIPTOR_FLAG_NONE  = 0,
+        D3D12_ROOT_DESCRIPTOR_FLAG_DATA_VOLATILE = 0x2,
+        D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE  = 0x4,
+        D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC = 0x8
+    }  D3D12_ROOT_DESCRIPTOR_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_ROOT_DESCRIPTOR_FLAGS );
+typedef struct D3D12_ROOT_DESCRIPTOR1
+    {
+    UINT ShaderRegister;
+    UINT RegisterSpace;
+    D3D12_ROOT_DESCRIPTOR_FLAGS Flags;
+    }  D3D12_ROOT_DESCRIPTOR1;
+
+typedef struct D3D12_ROOT_PARAMETER1
+    {
+    D3D12_ROOT_PARAMETER_TYPE ParameterType;
+    union 
+        {
+        D3D12_ROOT_DESCRIPTOR_TABLE1 DescriptorTable;
+        D3D12_ROOT_CONSTANTS Constants;
+        D3D12_ROOT_DESCRIPTOR1 Descriptor;
+        }  ;
+    D3D12_SHADER_VISIBILITY ShaderVisibility;
+    }  D3D12_ROOT_PARAMETER1;
+
+typedef struct D3D12_ROOT_SIGNATURE_DESC1
+    {
+    UINT NumParameters;
+    _Field_size_full_(NumParameters)  const D3D12_ROOT_PARAMETER1 *pParameters;
+    UINT NumStaticSamplers;
+    _Field_size_full_(NumStaticSamplers)  const D3D12_STATIC_SAMPLER_DESC *pStaticSamplers;
+    D3D12_ROOT_SIGNATURE_FLAGS Flags;
+    }  D3D12_ROOT_SIGNATURE_DESC1;
+
+typedef struct D3D12_VERSIONED_ROOT_SIGNATURE_DESC
+    {
+    D3D_ROOT_SIGNATURE_VERSION Version;
+    union 
+        {
+        D3D12_ROOT_SIGNATURE_DESC Desc_1_0;
+        D3D12_ROOT_SIGNATURE_DESC1 Desc_1_1;
+        }  ;
+    }  D3D12_VERSIONED_ROOT_SIGNATURE_DESC;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0001_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0001_v0_0_s_ifspec;
+
+#ifndef __ID3D12RootSignatureDeserializer_INTERFACE_DEFINED__
+#define __ID3D12RootSignatureDeserializer_INTERFACE_DEFINED__
+
+/* interface ID3D12RootSignatureDeserializer */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12RootSignatureDeserializer;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("34AB647B-3CC8-46AC-841B-C0965645C046")
+    ID3D12RootSignatureDeserializer : public IUnknown
+    {
+    public:
+        virtual const D3D12_ROOT_SIGNATURE_DESC *STDMETHODCALLTYPE GetRootSignatureDesc( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12RootSignatureDeserializerVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12RootSignatureDeserializer * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12RootSignatureDeserializer * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12RootSignatureDeserializer * This);
+        
+        const D3D12_ROOT_SIGNATURE_DESC *( STDMETHODCALLTYPE *GetRootSignatureDesc )( 
+            ID3D12RootSignatureDeserializer * This);
+        
+        END_INTERFACE
+    } ID3D12RootSignatureDeserializerVtbl;
+
+    interface ID3D12RootSignatureDeserializer
+    {
+        CONST_VTBL struct ID3D12RootSignatureDeserializerVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12RootSignatureDeserializer_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12RootSignatureDeserializer_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12RootSignatureDeserializer_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12RootSignatureDeserializer_GetRootSignatureDesc(This) \
+    ( (This)->lpVtbl -> GetRootSignatureDesc(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12RootSignatureDeserializer_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12VersionedRootSignatureDeserializer_INTERFACE_DEFINED__
+#define __ID3D12VersionedRootSignatureDeserializer_INTERFACE_DEFINED__
+
+/* interface ID3D12VersionedRootSignatureDeserializer */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12VersionedRootSignatureDeserializer;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("7F91CE67-090C-4BB7-B78E-ED8FF2E31DA0")
+    ID3D12VersionedRootSignatureDeserializer : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetRootSignatureDescAtVersion( 
+            D3D_ROOT_SIGNATURE_VERSION convertToVersion,
+            _Out_  const D3D12_VERSIONED_ROOT_SIGNATURE_DESC **ppDesc) = 0;
+        
+        virtual const D3D12_VERSIONED_ROOT_SIGNATURE_DESC *STDMETHODCALLTYPE GetUnconvertedRootSignatureDesc( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12VersionedRootSignatureDeserializerVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12VersionedRootSignatureDeserializer * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12VersionedRootSignatureDeserializer * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12VersionedRootSignatureDeserializer * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRootSignatureDescAtVersion )( 
+            ID3D12VersionedRootSignatureDeserializer * This,
+            D3D_ROOT_SIGNATURE_VERSION convertToVersion,
+            _Out_  const D3D12_VERSIONED_ROOT_SIGNATURE_DESC **ppDesc);
+        
+        const D3D12_VERSIONED_ROOT_SIGNATURE_DESC *( STDMETHODCALLTYPE *GetUnconvertedRootSignatureDesc )( 
+            ID3D12VersionedRootSignatureDeserializer * This);
+        
+        END_INTERFACE
+    } ID3D12VersionedRootSignatureDeserializerVtbl;
+
+    interface ID3D12VersionedRootSignatureDeserializer
+    {
+        CONST_VTBL struct ID3D12VersionedRootSignatureDeserializerVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12VersionedRootSignatureDeserializer_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12VersionedRootSignatureDeserializer_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12VersionedRootSignatureDeserializer_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12VersionedRootSignatureDeserializer_GetRootSignatureDescAtVersion(This,convertToVersion,ppDesc) \
+    ( (This)->lpVtbl -> GetRootSignatureDescAtVersion(This,convertToVersion,ppDesc) ) 
+
+#define ID3D12VersionedRootSignatureDeserializer_GetUnconvertedRootSignatureDesc(This) \
+    ( (This)->lpVtbl -> GetUnconvertedRootSignatureDesc(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12VersionedRootSignatureDeserializer_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0003 */
+/* [local] */ 
+
+typedef HRESULT (WINAPI* PFN_D3D12_SERIALIZE_ROOT_SIGNATURE)(
+                            _In_ const D3D12_ROOT_SIGNATURE_DESC* pRootSignature,
+                            _In_ D3D_ROOT_SIGNATURE_VERSION Version,
+                            _Out_ ID3DBlob** ppBlob,
+                            _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorBlob);
+
+HRESULT WINAPI D3D12SerializeRootSignature(
+                            _In_ const D3D12_ROOT_SIGNATURE_DESC* pRootSignature,
+                            _In_ D3D_ROOT_SIGNATURE_VERSION Version,
+                            _Out_ ID3DBlob** ppBlob,
+                            _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorBlob);
+
+typedef HRESULT (WINAPI* PFN_D3D12_CREATE_ROOT_SIGNATURE_DESERIALIZER)(
+                                     _In_reads_bytes_(SrcDataSizeInBytes) LPCVOID pSrcData,
+                                     _In_ SIZE_T SrcDataSizeInBytes,
+                                     _In_ REFIID pRootSignatureDeserializerInterface,
+                                     _Out_ void** ppRootSignatureDeserializer);
+
+HRESULT WINAPI D3D12CreateRootSignatureDeserializer(
+                                     _In_reads_bytes_(SrcDataSizeInBytes) LPCVOID pSrcData,
+                                     _In_ SIZE_T SrcDataSizeInBytes,
+                                     _In_ REFIID pRootSignatureDeserializerInterface,
+                                     _Out_ void** ppRootSignatureDeserializer);
+
+typedef HRESULT (WINAPI* PFN_D3D12_SERIALIZE_VERSIONED_ROOT_SIGNATURE)(
+                            _In_ const D3D12_VERSIONED_ROOT_SIGNATURE_DESC* pRootSignature,
+                            _Out_ ID3DBlob** ppBlob,
+                            _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorBlob);
+
+HRESULT WINAPI D3D12SerializeVersionedRootSignature(
+                            _In_ const D3D12_VERSIONED_ROOT_SIGNATURE_DESC* pRootSignature,
+                            _Out_ ID3DBlob** ppBlob,
+                            _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorBlob);
+
+typedef HRESULT (WINAPI* PFN_D3D12_CREATE_VERSIONED_ROOT_SIGNATURE_DESERIALIZER)(
+                                     _In_reads_bytes_(SrcDataSizeInBytes) LPCVOID pSrcData,
+                                     _In_ SIZE_T SrcDataSizeInBytes,
+                                     _In_ REFIID pRootSignatureDeserializerInterface,
+                                     _Out_ void** ppRootSignatureDeserializer);
+
+HRESULT WINAPI D3D12CreateVersionedRootSignatureDeserializer(
+                                     _In_reads_bytes_(SrcDataSizeInBytes) LPCVOID pSrcData,
+                                     _In_ SIZE_T SrcDataSizeInBytes,
+                                     _In_ REFIID pRootSignatureDeserializerInterface,
+                                     _Out_ void** ppRootSignatureDeserializer);
+
+typedef struct D3D12_CPU_DESCRIPTOR_HANDLE
+    {
+    SIZE_T ptr;
+    }  D3D12_CPU_DESCRIPTOR_HANDLE;
+
+typedef struct D3D12_GPU_DESCRIPTOR_HANDLE
+    {
+    UINT64 ptr;
+    }  D3D12_GPU_DESCRIPTOR_HANDLE;
+
+// If rects are supplied in D3D12_DISCARD_REGION, below, the resource 
+// must have 2D subresources with all specified subresources the same dimension.
+typedef struct D3D12_DISCARD_REGION
+    {
+    UINT NumRects;
+    _In_reads_(NumRects)  const D3D12_RECT *pRects;
+    UINT FirstSubresource;
+    UINT NumSubresources;
+    }  D3D12_DISCARD_REGION;
+
+typedef 
+enum D3D12_QUERY_HEAP_TYPE
+    {
+        D3D12_QUERY_HEAP_TYPE_OCCLUSION  = 0,
+        D3D12_QUERY_HEAP_TYPE_TIMESTAMP  = 1,
+        D3D12_QUERY_HEAP_TYPE_PIPELINE_STATISTICS  = 2,
+        D3D12_QUERY_HEAP_TYPE_SO_STATISTICS  = 3,
+        D3D12_QUERY_HEAP_TYPE_VIDEO_DECODE_STATISTICS  = 4,
+        D3D12_QUERY_HEAP_TYPE_COPY_QUEUE_TIMESTAMP = 5
+    }  D3D12_QUERY_HEAP_TYPE;
+
+typedef struct D3D12_QUERY_HEAP_DESC
+    {
+    D3D12_QUERY_HEAP_TYPE Type;
+    UINT Count;
+    UINT NodeMask;
+    }  D3D12_QUERY_HEAP_DESC;
+
+typedef 
+enum D3D12_QUERY_TYPE
+    {
+        D3D12_QUERY_TYPE_OCCLUSION = 0,
+        D3D12_QUERY_TYPE_BINARY_OCCLUSION  = 1,
+        D3D12_QUERY_TYPE_TIMESTAMP = 2,
+        D3D12_QUERY_TYPE_PIPELINE_STATISTICS = 3,
+        D3D12_QUERY_TYPE_SO_STATISTICS_STREAM0 = 4,
+        D3D12_QUERY_TYPE_SO_STATISTICS_STREAM1 = 5,
+        D3D12_QUERY_TYPE_SO_STATISTICS_STREAM2 = 6,
+        D3D12_QUERY_TYPE_SO_STATISTICS_STREAM3 = 7,
+        D3D12_QUERY_TYPE_VIDEO_DECODE_STATISTICS = 8
+    }  D3D12_QUERY_TYPE;
+
+typedef 
+enum D3D12_PREDICATION_OP
+    {
+        D3D12_PREDICATION_OP_EQUAL_ZERO  = 0,
+        D3D12_PREDICATION_OP_NOT_EQUAL_ZERO  = 1
+    }  D3D12_PREDICATION_OP;
+
+typedef struct D3D12_QUERY_DATA_PIPELINE_STATISTICS
+    {
+    UINT64 IAVertices;
+    UINT64 IAPrimitives;
+    UINT64 VSInvocations;
+    UINT64 GSInvocations;
+    UINT64 GSPrimitives;
+    UINT64 CInvocations;
+    UINT64 CPrimitives;
+    UINT64 PSInvocations;
+    UINT64 HSInvocations;
+    UINT64 DSInvocations;
+    UINT64 CSInvocations;
+    }  D3D12_QUERY_DATA_PIPELINE_STATISTICS;
+
+typedef struct D3D12_QUERY_DATA_SO_STATISTICS
+    {
+    UINT64 NumPrimitivesWritten;
+    UINT64 PrimitivesStorageNeeded;
+    }  D3D12_QUERY_DATA_SO_STATISTICS;
+
+typedef struct D3D12_STREAM_OUTPUT_BUFFER_VIEW
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
+    UINT64 SizeInBytes;
+    D3D12_GPU_VIRTUAL_ADDRESS BufferFilledSizeLocation;
+    }  D3D12_STREAM_OUTPUT_BUFFER_VIEW;
+
+typedef struct D3D12_DRAW_ARGUMENTS
+    {
+    UINT VertexCountPerInstance;
+    UINT InstanceCount;
+    UINT StartVertexLocation;
+    UINT StartInstanceLocation;
+    }  D3D12_DRAW_ARGUMENTS;
+
+typedef struct D3D12_DRAW_INDEXED_ARGUMENTS
+    {
+    UINT IndexCountPerInstance;
+    UINT InstanceCount;
+    UINT StartIndexLocation;
+    INT BaseVertexLocation;
+    UINT StartInstanceLocation;
+    }  D3D12_DRAW_INDEXED_ARGUMENTS;
+
+typedef struct D3D12_DISPATCH_ARGUMENTS
+    {
+    UINT ThreadGroupCountX;
+    UINT ThreadGroupCountY;
+    UINT ThreadGroupCountZ;
+    }  D3D12_DISPATCH_ARGUMENTS;
+
+typedef struct D3D12_VERTEX_BUFFER_VIEW
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
+    UINT SizeInBytes;
+    UINT StrideInBytes;
+    }  D3D12_VERTEX_BUFFER_VIEW;
+
+typedef struct D3D12_INDEX_BUFFER_VIEW
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
+    UINT SizeInBytes;
+    DXGI_FORMAT Format;
+    }  D3D12_INDEX_BUFFER_VIEW;
+
+typedef 
+enum D3D12_INDIRECT_ARGUMENT_TYPE
+    {
+        D3D12_INDIRECT_ARGUMENT_TYPE_DRAW  = 0,
+        D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED  = ( D3D12_INDIRECT_ARGUMENT_TYPE_DRAW + 1 ) ,
+        D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH  = ( D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED + 1 ) ,
+        D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW  = ( D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH + 1 ) ,
+        D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW = ( D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW + 1 ) ,
+        D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT  = ( D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW + 1 ) ,
+        D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW  = ( D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT + 1 ) ,
+        D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW  = ( D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW + 1 ) ,
+        D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW = ( D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW + 1 ) 
+    }  D3D12_INDIRECT_ARGUMENT_TYPE;
+
+typedef struct D3D12_INDIRECT_ARGUMENT_DESC
+    {
+    D3D12_INDIRECT_ARGUMENT_TYPE Type;
+    union 
+        {
+        struct 
+            {
+            UINT Slot;
+            }  VertexBuffer;
+        struct 
+            {
+            UINT RootParameterIndex;
+            UINT DestOffsetIn32BitValues;
+            UINT Num32BitValuesToSet;
+            }  Constant;
+        struct 
+            {
+            UINT RootParameterIndex;
+            }  ConstantBufferView;
+        struct 
+            {
+            UINT RootParameterIndex;
+            }  ShaderResourceView;
+        struct 
+            {
+            UINT RootParameterIndex;
+            }  UnorderedAccessView;
+        }  ;
+    }  D3D12_INDIRECT_ARGUMENT_DESC;
+
+typedef struct D3D12_COMMAND_SIGNATURE_DESC
+    {
+    UINT ByteStride;
+    UINT NumArgumentDescs;
+    _Field_size_full_(NumArgumentDescs)  const D3D12_INDIRECT_ARGUMENT_DESC *pArgumentDescs;
+    UINT NodeMask;
+    }  D3D12_COMMAND_SIGNATURE_DESC;
+
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0003_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0003_v0_0_s_ifspec;
+
+#ifndef __ID3D12Pageable_INTERFACE_DEFINED__
+#define __ID3D12Pageable_INTERFACE_DEFINED__
+
+/* interface ID3D12Pageable */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Pageable;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("63ee58fb-1268-4835-86da-f008ce62f0d6")
+    ID3D12Pageable : public ID3D12DeviceChild
+    {
+    public:
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12PageableVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Pageable * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Pageable * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Pageable * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Pageable * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Pageable * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Pageable * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Pageable * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12Pageable * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        END_INTERFACE
+    } ID3D12PageableVtbl;
+
+    interface ID3D12Pageable
+    {
+        CONST_VTBL struct ID3D12PageableVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Pageable_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Pageable_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Pageable_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Pageable_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Pageable_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Pageable_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Pageable_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Pageable_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Pageable_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Heap_INTERFACE_DEFINED__
+#define __ID3D12Heap_INTERFACE_DEFINED__
+
+/* interface ID3D12Heap */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Heap;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6b3b2502-6e51-45b3-90ee-9884265e8df3")
+    ID3D12Heap : public ID3D12Pageable
+    {
+    public:
+        virtual D3D12_HEAP_DESC STDMETHODCALLTYPE GetDesc( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12HeapVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Heap * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Heap * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Heap * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Heap * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Heap * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Heap * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Heap * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12Heap * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_HEAP_DESC ( STDMETHODCALLTYPE *GetDesc )( 
+            ID3D12Heap * This);
+        
+        END_INTERFACE
+    } ID3D12HeapVtbl;
+
+    interface ID3D12Heap
+    {
+        CONST_VTBL struct ID3D12HeapVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Heap_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Heap_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Heap_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Heap_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Heap_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Heap_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Heap_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Heap_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12Heap_GetDesc(This) \
+    ( (This)->lpVtbl -> GetDesc(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+
+
+
+
+#endif   /* __ID3D12Heap_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Resource_INTERFACE_DEFINED__
+#define __ID3D12Resource_INTERFACE_DEFINED__
+
+/* interface ID3D12Resource */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Resource;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("696442be-a72e-4059-bc79-5b5c98040fad")
+    ID3D12Resource : public ID3D12Pageable
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Map( 
+            UINT Subresource,
+            _In_opt_  const D3D12_RANGE *pReadRange,
+            _Outptr_opt_result_bytebuffer_(_Inexpressible_("Dependent on resource"))  void **ppData) = 0;
+        
+        virtual void STDMETHODCALLTYPE Unmap( 
+            UINT Subresource,
+            _In_opt_  const D3D12_RANGE *pWrittenRange) = 0;
+        
+        virtual D3D12_RESOURCE_DESC STDMETHODCALLTYPE GetDesc( void) = 0;
+        
+        virtual D3D12_GPU_VIRTUAL_ADDRESS STDMETHODCALLTYPE GetGPUVirtualAddress( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE WriteToSubresource( 
+            UINT DstSubresource,
+            _In_opt_  const D3D12_BOX *pDstBox,
+            _In_  const void *pSrcData,
+            UINT SrcRowPitch,
+            UINT SrcDepthPitch) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ReadFromSubresource( 
+            _Out_  void *pDstData,
+            UINT DstRowPitch,
+            UINT DstDepthPitch,
+            UINT SrcSubresource,
+            _In_opt_  const D3D12_BOX *pSrcBox) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetHeapProperties( 
+            _Out_opt_  D3D12_HEAP_PROPERTIES *pHeapProperties,
+            _Out_opt_  D3D12_HEAP_FLAGS *pHeapFlags) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12ResourceVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Resource * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Resource * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Resource * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Resource * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Resource * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Resource * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Resource * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12Resource * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *Map )( 
+            ID3D12Resource * This,
+            UINT Subresource,
+            _In_opt_  const D3D12_RANGE *pReadRange,
+            _Outptr_opt_result_bytebuffer_(_Inexpressible_("Dependent on resource"))  void **ppData);
+        
+        void ( STDMETHODCALLTYPE *Unmap )( 
+            ID3D12Resource * This,
+            UINT Subresource,
+            _In_opt_  const D3D12_RANGE *pWrittenRange);
+        
+        D3D12_RESOURCE_DESC ( STDMETHODCALLTYPE *GetDesc )( 
+            ID3D12Resource * This);
+        
+        D3D12_GPU_VIRTUAL_ADDRESS ( STDMETHODCALLTYPE *GetGPUVirtualAddress )( 
+            ID3D12Resource * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *WriteToSubresource )( 
+            ID3D12Resource * This,
+            UINT DstSubresource,
+            _In_opt_  const D3D12_BOX *pDstBox,
+            _In_  const void *pSrcData,
+            UINT SrcRowPitch,
+            UINT SrcDepthPitch);
+        
+        HRESULT ( STDMETHODCALLTYPE *ReadFromSubresource )( 
+            ID3D12Resource * This,
+            _Out_  void *pDstData,
+            UINT DstRowPitch,
+            UINT DstDepthPitch,
+            UINT SrcSubresource,
+            _In_opt_  const D3D12_BOX *pSrcBox);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetHeapProperties )( 
+            ID3D12Resource * This,
+            _Out_opt_  D3D12_HEAP_PROPERTIES *pHeapProperties,
+            _Out_opt_  D3D12_HEAP_FLAGS *pHeapFlags);
+        
+        END_INTERFACE
+    } ID3D12ResourceVtbl;
+
+    interface ID3D12Resource
+    {
+        CONST_VTBL struct ID3D12ResourceVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Resource_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Resource_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Resource_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Resource_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Resource_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Resource_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Resource_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Resource_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12Resource_Map(This,Subresource,pReadRange,ppData) \
+    ( (This)->lpVtbl -> Map(This,Subresource,pReadRange,ppData) ) 
+
+#define ID3D12Resource_Unmap(This,Subresource,pWrittenRange) \
+    ( (This)->lpVtbl -> Unmap(This,Subresource,pWrittenRange) ) 
+
+#define ID3D12Resource_GetDesc(This) \
+    ( (This)->lpVtbl -> GetDesc(This) ) 
+
+#define ID3D12Resource_GetGPUVirtualAddress(This)  \
+    ( (This)->lpVtbl -> GetGPUVirtualAddress(This) ) 
+
+#define ID3D12Resource_WriteToSubresource(This,DstSubresource,pDstBox,pSrcData,SrcRowPitch,SrcDepthPitch)  \
+    ( (This)->lpVtbl -> WriteToSubresource(This,DstSubresource,pDstBox,pSrcData,SrcRowPitch,SrcDepthPitch) ) 
+
+#define ID3D12Resource_ReadFromSubresource(This,pDstData,DstRowPitch,DstDepthPitch,SrcSubresource,pSrcBox) \
+    ( (This)->lpVtbl -> ReadFromSubresource(This,pDstData,DstRowPitch,DstDepthPitch,SrcSubresource,pSrcBox) ) 
+
+#define ID3D12Resource_GetHeapProperties(This,pHeapProperties,pHeapFlags)  \
+    ( (This)->lpVtbl -> GetHeapProperties(This,pHeapProperties,pHeapFlags) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+
+
+
+
+#endif   /* __ID3D12Resource_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12CommandAllocator_INTERFACE_DEFINED__
+#define __ID3D12CommandAllocator_INTERFACE_DEFINED__
+
+/* interface ID3D12CommandAllocator */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12CommandAllocator;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6102dee4-af59-4b09-b999-b44d73f09b24")
+    ID3D12CommandAllocator : public ID3D12Pageable
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12CommandAllocatorVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12CommandAllocator * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12CommandAllocator * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12CommandAllocator * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12CommandAllocator * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12CommandAllocator * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12CommandAllocator * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12CommandAllocator * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12CommandAllocator * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *Reset )( 
+            ID3D12CommandAllocator * This);
+        
+        END_INTERFACE
+    } ID3D12CommandAllocatorVtbl;
+
+    interface ID3D12CommandAllocator
+    {
+        CONST_VTBL struct ID3D12CommandAllocatorVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12CommandAllocator_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12CommandAllocator_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12CommandAllocator_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12CommandAllocator_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12CommandAllocator_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12CommandAllocator_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12CommandAllocator_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12CommandAllocator_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12CommandAllocator_Reset(This) \
+    ( (This)->lpVtbl -> Reset(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12CommandAllocator_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Fence_INTERFACE_DEFINED__
+#define __ID3D12Fence_INTERFACE_DEFINED__
+
+/* interface ID3D12Fence */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Fence;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("0a753dcf-c4d8-4b91-adf6-be5a60d95a76")
+    ID3D12Fence : public ID3D12Pageable
+    {
+    public:
+        virtual UINT64 STDMETHODCALLTYPE GetCompletedValue( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetEventOnCompletion( 
+            UINT64 Value,
+            HANDLE hEvent) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Signal( 
+            UINT64 Value) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12FenceVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Fence * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Fence * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Fence * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Fence * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Fence * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Fence * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Fence * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12Fence * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetCompletedValue )( 
+            ID3D12Fence * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEventOnCompletion )( 
+            ID3D12Fence * This,
+            UINT64 Value,
+            HANDLE hEvent);
+        
+        HRESULT ( STDMETHODCALLTYPE *Signal )( 
+            ID3D12Fence * This,
+            UINT64 Value);
+        
+        END_INTERFACE
+    } ID3D12FenceVtbl;
+
+    interface ID3D12Fence
+    {
+        CONST_VTBL struct ID3D12FenceVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Fence_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Fence_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Fence_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Fence_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Fence_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Fence_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Fence_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Fence_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12Fence_GetCompletedValue(This)  \
+    ( (This)->lpVtbl -> GetCompletedValue(This) ) 
+
+#define ID3D12Fence_SetEventOnCompletion(This,Value,hEvent)  \
+    ( (This)->lpVtbl -> SetEventOnCompletion(This,Value,hEvent) ) 
+
+#define ID3D12Fence_Signal(This,Value) \
+    ( (This)->lpVtbl -> Signal(This,Value) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Fence_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Fence1_INTERFACE_DEFINED__
+#define __ID3D12Fence1_INTERFACE_DEFINED__
+
+/* interface ID3D12Fence1 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Fence1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("433685fe-e22b-4ca0-a8db-b5b4f4dd0e4a")
+    ID3D12Fence1 : public ID3D12Fence
+    {
+    public:
+        virtual D3D12_FENCE_FLAGS STDMETHODCALLTYPE GetCreationFlags( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Fence1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Fence1 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Fence1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Fence1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Fence1 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Fence1 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Fence1 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Fence1 * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12Fence1 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetCompletedValue )( 
+            ID3D12Fence1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEventOnCompletion )( 
+            ID3D12Fence1 * This,
+            UINT64 Value,
+            HANDLE hEvent);
+        
+        HRESULT ( STDMETHODCALLTYPE *Signal )( 
+            ID3D12Fence1 * This,
+            UINT64 Value);
+        
+        D3D12_FENCE_FLAGS ( STDMETHODCALLTYPE *GetCreationFlags )( 
+            ID3D12Fence1 * This);
+        
+        END_INTERFACE
+    } ID3D12Fence1Vtbl;
+
+    interface ID3D12Fence1
+    {
+        CONST_VTBL struct ID3D12Fence1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Fence1_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Fence1_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Fence1_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Fence1_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Fence1_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Fence1_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Fence1_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Fence1_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12Fence1_GetCompletedValue(This) \
+    ( (This)->lpVtbl -> GetCompletedValue(This) ) 
+
+#define ID3D12Fence1_SetEventOnCompletion(This,Value,hEvent) \
+    ( (This)->lpVtbl -> SetEventOnCompletion(This,Value,hEvent) ) 
+
+#define ID3D12Fence1_Signal(This,Value)  \
+    ( (This)->lpVtbl -> Signal(This,Value) ) 
+
+
+#define ID3D12Fence1_GetCreationFlags(This)  \
+    ( (This)->lpVtbl -> GetCreationFlags(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Fence1_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12PipelineState_INTERFACE_DEFINED__
+#define __ID3D12PipelineState_INTERFACE_DEFINED__
+
+/* interface ID3D12PipelineState */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12PipelineState;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("765a30f3-f624-4c6f-a828-ace948622445")
+    ID3D12PipelineState : public ID3D12Pageable
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetCachedBlob( 
+            _COM_Outptr_  ID3DBlob **ppBlob) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12PipelineStateVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12PipelineState * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12PipelineState * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12PipelineState * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12PipelineState * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12PipelineState * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12PipelineState * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12PipelineState * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12PipelineState * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCachedBlob )( 
+            ID3D12PipelineState * This,
+            _COM_Outptr_  ID3DBlob **ppBlob);
+        
+        END_INTERFACE
+    } ID3D12PipelineStateVtbl;
+
+    interface ID3D12PipelineState
+    {
+        CONST_VTBL struct ID3D12PipelineStateVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12PipelineState_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12PipelineState_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12PipelineState_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12PipelineState_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12PipelineState_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12PipelineState_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12PipelineState_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12PipelineState_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12PipelineState_GetCachedBlob(This,ppBlob) \
+    ( (This)->lpVtbl -> GetCachedBlob(This,ppBlob) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12PipelineState_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12DescriptorHeap_INTERFACE_DEFINED__
+#define __ID3D12DescriptorHeap_INTERFACE_DEFINED__
+
+/* interface ID3D12DescriptorHeap */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DescriptorHeap;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("8efb471d-616c-4f49-90f7-127bb763fa51")
+    ID3D12DescriptorHeap : public ID3D12Pageable
+    {
+    public:
+        virtual D3D12_DESCRIPTOR_HEAP_DESC STDMETHODCALLTYPE GetDesc( void) = 0;
+        
+        virtual D3D12_CPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE GetCPUDescriptorHandleForHeapStart( void) = 0;
+        
+        virtual D3D12_GPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE GetGPUDescriptorHandleForHeapStart( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DescriptorHeapVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DescriptorHeap * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DescriptorHeap * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DescriptorHeap * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12DescriptorHeap * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12DescriptorHeap * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12DescriptorHeap * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12DescriptorHeap * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12DescriptorHeap * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_DESCRIPTOR_HEAP_DESC ( STDMETHODCALLTYPE *GetDesc )( 
+            ID3D12DescriptorHeap * This);
+        
+        D3D12_CPU_DESCRIPTOR_HANDLE ( STDMETHODCALLTYPE *GetCPUDescriptorHandleForHeapStart )( 
+            ID3D12DescriptorHeap * This);
+        
+        D3D12_GPU_DESCRIPTOR_HANDLE ( STDMETHODCALLTYPE *GetGPUDescriptorHandleForHeapStart )( 
+            ID3D12DescriptorHeap * This);
+        
+        END_INTERFACE
+    } ID3D12DescriptorHeapVtbl;
+
+    interface ID3D12DescriptorHeap
+    {
+        CONST_VTBL struct ID3D12DescriptorHeapVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DescriptorHeap_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DescriptorHeap_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DescriptorHeap_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DescriptorHeap_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12DescriptorHeap_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12DescriptorHeap_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12DescriptorHeap_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12DescriptorHeap_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12DescriptorHeap_GetDesc(This) \
+    ( (This)->lpVtbl -> GetDesc(This) ) 
+
+#define ID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart(This)  \
+    ( (This)->lpVtbl -> GetCPUDescriptorHandleForHeapStart(This) ) 
+
+#define ID3D12DescriptorHeap_GetGPUDescriptorHandleForHeapStart(This)  \
+    ( (This)->lpVtbl -> GetGPUDescriptorHandleForHeapStart(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif   /* __ID3D12DescriptorHeap_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12QueryHeap_INTERFACE_DEFINED__
+#define __ID3D12QueryHeap_INTERFACE_DEFINED__
+
+/* interface ID3D12QueryHeap */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12QueryHeap;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("0d9658ae-ed45-469e-a61d-970ec583cab4")
+    ID3D12QueryHeap : public ID3D12Pageable
+    {
+    public:
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12QueryHeapVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12QueryHeap * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12QueryHeap * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12QueryHeap * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12QueryHeap * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12QueryHeap * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12QueryHeap * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12QueryHeap * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12QueryHeap * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        END_INTERFACE
+    } ID3D12QueryHeapVtbl;
+
+    interface ID3D12QueryHeap
+    {
+        CONST_VTBL struct ID3D12QueryHeapVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12QueryHeap_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12QueryHeap_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12QueryHeap_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12QueryHeap_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12QueryHeap_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12QueryHeap_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12QueryHeap_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12QueryHeap_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12QueryHeap_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12CommandSignature_INTERFACE_DEFINED__
+#define __ID3D12CommandSignature_INTERFACE_DEFINED__
+
+/* interface ID3D12CommandSignature */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12CommandSignature;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("c36a797c-ec80-4f0a-8985-a7b2475082d1")
+    ID3D12CommandSignature : public ID3D12Pageable
+    {
+    public:
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12CommandSignatureVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12CommandSignature * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12CommandSignature * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12CommandSignature * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12CommandSignature * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12CommandSignature * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12CommandSignature * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12CommandSignature * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12CommandSignature * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        END_INTERFACE
+    } ID3D12CommandSignatureVtbl;
+
+    interface ID3D12CommandSignature
+    {
+        CONST_VTBL struct ID3D12CommandSignatureVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12CommandSignature_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12CommandSignature_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12CommandSignature_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12CommandSignature_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12CommandSignature_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12CommandSignature_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12CommandSignature_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12CommandSignature_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12CommandSignature_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12CommandList_INTERFACE_DEFINED__
+#define __ID3D12CommandList_INTERFACE_DEFINED__
+
+/* interface ID3D12CommandList */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12CommandList;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("7116d91c-e7e4-47ce-b8c6-ec8168f437e5")
+    ID3D12CommandList : public ID3D12DeviceChild
+    {
+    public:
+        virtual D3D12_COMMAND_LIST_TYPE STDMETHODCALLTYPE GetType( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12CommandListVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12CommandList * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12CommandList * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12CommandList * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12CommandList * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12CommandList * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12CommandList * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12CommandList * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12CommandList * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_COMMAND_LIST_TYPE ( STDMETHODCALLTYPE *GetType )( 
+            ID3D12CommandList * This);
+        
+        END_INTERFACE
+    } ID3D12CommandListVtbl;
+
+    interface ID3D12CommandList
+    {
+        CONST_VTBL struct ID3D12CommandListVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12CommandList_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12CommandList_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12CommandList_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12CommandList_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12CommandList_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12CommandList_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12CommandList_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12CommandList_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12CommandList_GetType(This)  \
+    ( (This)->lpVtbl -> GetType(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12CommandList_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12GraphicsCommandList_INTERFACE_DEFINED__
+#define __ID3D12GraphicsCommandList_INTERFACE_DEFINED__
+
+/* interface ID3D12GraphicsCommandList */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12GraphicsCommandList;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("5b160d0f-ac1b-4185-8ba8-b3ae42a5a455")
+    ID3D12GraphicsCommandList : public ID3D12CommandList
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Reset( 
+            _In_  ID3D12CommandAllocator *pAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState) = 0;
+        
+        virtual void STDMETHODCALLTYPE ClearState( 
+            _In_opt_  ID3D12PipelineState *pPipelineState) = 0;
+        
+        virtual void STDMETHODCALLTYPE DrawInstanced( 
+            _In_  UINT VertexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartVertexLocation,
+            _In_  UINT StartInstanceLocation) = 0;
+        
+        virtual void STDMETHODCALLTYPE DrawIndexedInstanced( 
+            _In_  UINT IndexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartIndexLocation,
+            _In_  INT BaseVertexLocation,
+            _In_  UINT StartInstanceLocation) = 0;
+        
+        virtual void STDMETHODCALLTYPE Dispatch( 
+            _In_  UINT ThreadGroupCountX,
+            _In_  UINT ThreadGroupCountY,
+            _In_  UINT ThreadGroupCountZ) = 0;
+        
+        virtual void STDMETHODCALLTYPE CopyBufferRegion( 
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT64 NumBytes) = 0;
+        
+        virtual void STDMETHODCALLTYPE CopyTextureRegion( 
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pDst,
+            UINT DstX,
+            UINT DstY,
+            UINT DstZ,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pSrc,
+            _In_opt_  const D3D12_BOX *pSrcBox) = 0;
+        
+        virtual void STDMETHODCALLTYPE CopyResource( 
+            _In_  ID3D12Resource *pDstResource,
+            _In_  ID3D12Resource *pSrcResource) = 0;
+        
+        virtual void STDMETHODCALLTYPE CopyTiles( 
+            _In_  ID3D12Resource *pTiledResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate,
+            _In_  const D3D12_TILE_REGION_SIZE *pTileRegionSize,
+            _In_  ID3D12Resource *pBuffer,
+            UINT64 BufferStartOffsetInBytes,
+            D3D12_TILE_COPY_FLAGS Flags) = 0;
+        
+        virtual void STDMETHODCALLTYPE ResolveSubresource( 
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_  DXGI_FORMAT Format) = 0;
+        
+        virtual void STDMETHODCALLTYPE IASetPrimitiveTopology( 
+            _In_  D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology) = 0;
+        
+        virtual void STDMETHODCALLTYPE RSSetViewports( 
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumViewports,
+            _In_reads_( NumViewports)  const D3D12_VIEWPORT *pViewports) = 0;
+        
+        virtual void STDMETHODCALLTYPE RSSetScissorRects( 
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumRects,
+            _In_reads_( NumRects)  const D3D12_RECT *pRects) = 0;
+        
+        virtual void STDMETHODCALLTYPE OMSetBlendFactor( 
+            _In_reads_opt_(4)  const FLOAT BlendFactor[ 4 ]) = 0;
+        
+        virtual void STDMETHODCALLTYPE OMSetStencilRef( 
+            _In_  UINT StencilRef) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetPipelineState( 
+            _In_  ID3D12PipelineState *pPipelineState) = 0;
+        
+        virtual void STDMETHODCALLTYPE ResourceBarrier( 
+            _In_  UINT NumBarriers,
+            _In_reads_(NumBarriers)  const D3D12_RESOURCE_BARRIER *pBarriers) = 0;
+        
+        virtual void STDMETHODCALLTYPE ExecuteBundle( 
+            _In_  ID3D12GraphicsCommandList *pCommandList) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetDescriptorHeaps( 
+            _In_  UINT NumDescriptorHeaps,
+            _In_reads_(NumDescriptorHeaps)  ID3D12DescriptorHeap *const *ppDescriptorHeaps) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetComputeRootSignature( 
+            _In_opt_  ID3D12RootSignature *pRootSignature) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetGraphicsRootSignature( 
+            _In_opt_  ID3D12RootSignature *pRootSignature) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetComputeRootDescriptorTable( 
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetGraphicsRootDescriptorTable( 
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetComputeRoot32BitConstant( 
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetGraphicsRoot32BitConstant( 
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetComputeRoot32BitConstants( 
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetGraphicsRoot32BitConstants( 
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetComputeRootConstantBufferView( 
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetGraphicsRootConstantBufferView( 
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetComputeRootShaderResourceView( 
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetGraphicsRootShaderResourceView( 
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetComputeRootUnorderedAccessView( 
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetGraphicsRootUnorderedAccessView( 
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation) = 0;
+        
+        virtual void STDMETHODCALLTYPE IASetIndexBuffer( 
+            _In_opt_  const D3D12_INDEX_BUFFER_VIEW *pView) = 0;
+        
+        virtual void STDMETHODCALLTYPE IASetVertexBuffers( 
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_VERTEX_BUFFER_VIEW *pViews) = 0;
+        
+        virtual void STDMETHODCALLTYPE SOSetTargets( 
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews) = 0;
+        
+        virtual void STDMETHODCALLTYPE OMSetRenderTargets( 
+            _In_  UINT NumRenderTargetDescriptors,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pRenderTargetDescriptors,
+            _In_  BOOL RTsSingleHandleToDescriptorRange,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pDepthStencilDescriptor) = 0;
+        
+        virtual void STDMETHODCALLTYPE ClearDepthStencilView( 
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,
+            _In_  D3D12_CLEAR_FLAGS ClearFlags,
+            _In_  FLOAT Depth,
+            _In_  UINT8 Stencil,
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects) = 0;
+        
+        virtual void STDMETHODCALLTYPE ClearRenderTargetView( 
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,
+            _In_  const FLOAT ColorRGBA[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects) = 0;
+        
+        virtual void STDMETHODCALLTYPE ClearUnorderedAccessViewUint( 
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const UINT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects) = 0;
+        
+        virtual void STDMETHODCALLTYPE ClearUnorderedAccessViewFloat( 
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const FLOAT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects) = 0;
+        
+        virtual void STDMETHODCALLTYPE DiscardResource( 
+            _In_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DISCARD_REGION *pRegion) = 0;
+        
+        virtual void STDMETHODCALLTYPE BeginQuery( 
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index) = 0;
+        
+        virtual void STDMETHODCALLTYPE EndQuery( 
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index) = 0;
+        
+        virtual void STDMETHODCALLTYPE ResolveQueryData( 
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT StartIndex,
+            _In_  UINT NumQueries,
+            _In_  ID3D12Resource *pDestinationBuffer,
+            _In_  UINT64 AlignedDestinationBufferOffset) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetPredication( 
+            _In_opt_  ID3D12Resource *pBuffer,
+            _In_  UINT64 AlignedBufferOffset,
+            _In_  D3D12_PREDICATION_OP Operation) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetMarker( 
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size) = 0;
+        
+        virtual void STDMETHODCALLTYPE BeginEvent( 
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size) = 0;
+        
+        virtual void STDMETHODCALLTYPE EndEvent( void) = 0;
+        
+        virtual void STDMETHODCALLTYPE ExecuteIndirect( 
+            _In_  ID3D12CommandSignature *pCommandSignature,
+            _In_  UINT MaxCommandCount,
+            _In_  ID3D12Resource *pArgumentBuffer,
+            _In_  UINT64 ArgumentBufferOffset,
+            _In_opt_  ID3D12Resource *pCountBuffer,
+            _In_  UINT64 CountBufferOffset) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12GraphicsCommandListVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12GraphicsCommandList * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12GraphicsCommandList * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12GraphicsCommandList * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12GraphicsCommandList * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12GraphicsCommandList * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_COMMAND_LIST_TYPE ( STDMETHODCALLTYPE *GetType )( 
+            ID3D12GraphicsCommandList * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Close )( 
+            ID3D12GraphicsCommandList * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Reset )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12CommandAllocator *pAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState);
+        
+        void ( STDMETHODCALLTYPE *ClearState )( 
+            ID3D12GraphicsCommandList * This,
+            _In_opt_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *DrawInstanced )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT VertexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *DrawIndexedInstanced )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT IndexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartIndexLocation,
+            _In_  INT BaseVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *Dispatch )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT ThreadGroupCountX,
+            _In_  UINT ThreadGroupCountY,
+            _In_  UINT ThreadGroupCountZ);
+        
+        void ( STDMETHODCALLTYPE *CopyBufferRegion )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT64 NumBytes);
+        
+        void ( STDMETHODCALLTYPE *CopyTextureRegion )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pDst,
+            UINT DstX,
+            UINT DstY,
+            UINT DstZ,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pSrc,
+            _In_opt_  const D3D12_BOX *pSrcBox);
+        
+        void ( STDMETHODCALLTYPE *CopyResource )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  ID3D12Resource *pSrcResource);
+        
+        void ( STDMETHODCALLTYPE *CopyTiles )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate,
+            _In_  const D3D12_TILE_REGION_SIZE *pTileRegionSize,
+            _In_  ID3D12Resource *pBuffer,
+            UINT64 BufferStartOffsetInBytes,
+            D3D12_TILE_COPY_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresource )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_  DXGI_FORMAT Format);
+        
+        void ( STDMETHODCALLTYPE *IASetPrimitiveTopology )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology);
+        
+        void ( STDMETHODCALLTYPE *RSSetViewports )( 
+            ID3D12GraphicsCommandList * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumViewports,
+            _In_reads_( NumViewports)  const D3D12_VIEWPORT *pViewports);
+        
+        void ( STDMETHODCALLTYPE *RSSetScissorRects )( 
+            ID3D12GraphicsCommandList * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumRects,
+            _In_reads_( NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *OMSetBlendFactor )( 
+            ID3D12GraphicsCommandList * This,
+            _In_reads_opt_(4)  const FLOAT BlendFactor[ 4 ]);
+        
+        void ( STDMETHODCALLTYPE *OMSetStencilRef )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT StencilRef);
+        
+        void ( STDMETHODCALLTYPE *SetPipelineState )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *ResourceBarrier )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT NumBarriers,
+            _In_reads_(NumBarriers)  const D3D12_RESOURCE_BARRIER *pBarriers);
+        
+        void ( STDMETHODCALLTYPE *ExecuteBundle )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12GraphicsCommandList *pCommandList);
+        
+        void ( STDMETHODCALLTYPE *SetDescriptorHeaps )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT NumDescriptorHeaps,
+            _In_reads_(NumDescriptorHeaps)  ID3D12DescriptorHeap *const *ppDescriptorHeaps);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootSignature )( 
+            ID3D12GraphicsCommandList * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootSignature )( 
+            ID3D12GraphicsCommandList * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootDescriptorTable )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootDescriptorTable )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstant )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstant )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstants )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstants )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootConstantBufferView )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootConstantBufferView )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootShaderResourceView )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootShaderResourceView )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *IASetIndexBuffer )( 
+            ID3D12GraphicsCommandList * This,
+            _In_opt_  const D3D12_INDEX_BUFFER_VIEW *pView);
+        
+        void ( STDMETHODCALLTYPE *IASetVertexBuffers )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_VERTEX_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *SOSetTargets )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *OMSetRenderTargets )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  UINT NumRenderTargetDescriptors,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pRenderTargetDescriptors,
+            _In_  BOOL RTsSingleHandleToDescriptorRange,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pDepthStencilDescriptor);
+        
+        void ( STDMETHODCALLTYPE *ClearDepthStencilView )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,
+            _In_  D3D12_CLEAR_FLAGS ClearFlags,
+            _In_  FLOAT Depth,
+            _In_  UINT8 Stencil,
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearRenderTargetView )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,
+            _In_  const FLOAT ColorRGBA[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewUint )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const UINT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewFloat )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const FLOAT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *DiscardResource )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DISCARD_REGION *pRegion);
+        
+        void ( STDMETHODCALLTYPE *BeginQuery )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *EndQuery )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *ResolveQueryData )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT StartIndex,
+            _In_  UINT NumQueries,
+            _In_  ID3D12Resource *pDestinationBuffer,
+            _In_  UINT64 AlignedDestinationBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *SetPredication )( 
+            ID3D12GraphicsCommandList * This,
+            _In_opt_  ID3D12Resource *pBuffer,
+            _In_  UINT64 AlignedBufferOffset,
+            _In_  D3D12_PREDICATION_OP Operation);
+        
+        void ( STDMETHODCALLTYPE *SetMarker )( 
+            ID3D12GraphicsCommandList * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *BeginEvent )( 
+            ID3D12GraphicsCommandList * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *EndEvent )( 
+            ID3D12GraphicsCommandList * This);
+        
+        void ( STDMETHODCALLTYPE *ExecuteIndirect )( 
+            ID3D12GraphicsCommandList * This,
+            _In_  ID3D12CommandSignature *pCommandSignature,
+            _In_  UINT MaxCommandCount,
+            _In_  ID3D12Resource *pArgumentBuffer,
+            _In_  UINT64 ArgumentBufferOffset,
+            _In_opt_  ID3D12Resource *pCountBuffer,
+            _In_  UINT64 CountBufferOffset);
+        
+        END_INTERFACE
+    } ID3D12GraphicsCommandListVtbl;
+
+    interface ID3D12GraphicsCommandList
+    {
+        CONST_VTBL struct ID3D12GraphicsCommandListVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12GraphicsCommandList_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12GraphicsCommandList_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12GraphicsCommandList_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12GraphicsCommandList_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12GraphicsCommandList_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12GraphicsCommandList_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12GraphicsCommandList_GetType(This)  \
+    ( (This)->lpVtbl -> GetType(This) ) 
+
+
+#define ID3D12GraphicsCommandList_Close(This)  \
+    ( (This)->lpVtbl -> Close(This) ) 
+
+#define ID3D12GraphicsCommandList_Reset(This,pAllocator,pInitialState) \
+    ( (This)->lpVtbl -> Reset(This,pAllocator,pInitialState) ) 
+
+#define ID3D12GraphicsCommandList_ClearState(This,pPipelineState)  \
+    ( (This)->lpVtbl -> ClearState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList_DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation) \
+    ( (This)->lpVtbl -> DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList_DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation) \
+    ( (This)->lpVtbl -> DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList_Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ) \
+    ( (This)->lpVtbl -> Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ) ) 
+
+#define ID3D12GraphicsCommandList_CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes)  \
+    ( (This)->lpVtbl -> CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) ) 
+
+#define ID3D12GraphicsCommandList_CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox) \
+    ( (This)->lpVtbl -> CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox) ) 
+
+#define ID3D12GraphicsCommandList_CopyResource(This,pDstResource,pSrcResource) \
+    ( (This)->lpVtbl -> CopyResource(This,pDstResource,pSrcResource) ) 
+
+#define ID3D12GraphicsCommandList_CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags) \
+    ( (This)->lpVtbl -> CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags) ) 
+
+#define ID3D12GraphicsCommandList_ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format)  \
+    ( (This)->lpVtbl -> ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) ) 
+
+#define ID3D12GraphicsCommandList_IASetPrimitiveTopology(This,PrimitiveTopology) \
+    ( (This)->lpVtbl -> IASetPrimitiveTopology(This,PrimitiveTopology) ) 
+
+#define ID3D12GraphicsCommandList_RSSetViewports(This,NumViewports,pViewports) \
+    ( (This)->lpVtbl -> RSSetViewports(This,NumViewports,pViewports) ) 
+
+#define ID3D12GraphicsCommandList_RSSetScissorRects(This,NumRects,pRects)  \
+    ( (This)->lpVtbl -> RSSetScissorRects(This,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList_OMSetBlendFactor(This,BlendFactor) \
+    ( (This)->lpVtbl -> OMSetBlendFactor(This,BlendFactor) ) 
+
+#define ID3D12GraphicsCommandList_OMSetStencilRef(This,StencilRef) \
+    ( (This)->lpVtbl -> OMSetStencilRef(This,StencilRef) ) 
+
+#define ID3D12GraphicsCommandList_SetPipelineState(This,pPipelineState)  \
+    ( (This)->lpVtbl -> SetPipelineState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList_ResourceBarrier(This,NumBarriers,pBarriers)  \
+    ( (This)->lpVtbl -> ResourceBarrier(This,NumBarriers,pBarriers) ) 
+
+#define ID3D12GraphicsCommandList_ExecuteBundle(This,pCommandList) \
+    ( (This)->lpVtbl -> ExecuteBundle(This,pCommandList) ) 
+
+#define ID3D12GraphicsCommandList_SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps)  \
+    ( (This)->lpVtbl -> SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) ) 
+
+#define ID3D12GraphicsCommandList_SetComputeRootSignature(This,pRootSignature) \
+    ( (This)->lpVtbl -> SetComputeRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList_SetGraphicsRootSignature(This,pRootSignature)  \
+    ( (This)->lpVtbl -> SetGraphicsRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList_SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor)  \
+    ( (This)->lpVtbl -> SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList_SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) \
+    ( (This)->lpVtbl -> SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList_SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList_SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList_SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList_SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList_SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList_IASetIndexBuffer(This,pView) \
+    ( (This)->lpVtbl -> IASetIndexBuffer(This,pView) ) 
+
+#define ID3D12GraphicsCommandList_IASetVertexBuffers(This,StartSlot,NumViews,pViews) \
+    ( (This)->lpVtbl -> IASetVertexBuffers(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList_SOSetTargets(This,StartSlot,NumViews,pViews) \
+    ( (This)->lpVtbl -> SOSetTargets(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList_OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor)  \
+    ( (This)->lpVtbl -> OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) ) 
+
+#define ID3D12GraphicsCommandList_ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList_ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList_ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList_ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList_DiscardResource(This,pResource,pRegion)  \
+    ( (This)->lpVtbl -> DiscardResource(This,pResource,pRegion) ) 
+
+#define ID3D12GraphicsCommandList_BeginQuery(This,pQueryHeap,Type,Index) \
+    ( (This)->lpVtbl -> BeginQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList_EndQuery(This,pQueryHeap,Type,Index) \
+    ( (This)->lpVtbl -> EndQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList_ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset) \
+    ( (This)->lpVtbl -> ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset) ) 
+
+#define ID3D12GraphicsCommandList_SetPredication(This,pBuffer,AlignedBufferOffset,Operation) \
+    ( (This)->lpVtbl -> SetPredication(This,pBuffer,AlignedBufferOffset,Operation) ) 
+
+#define ID3D12GraphicsCommandList_SetMarker(This,Metadata,pData,Size)  \
+    ( (This)->lpVtbl -> SetMarker(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList_BeginEvent(This,Metadata,pData,Size) \
+    ( (This)->lpVtbl -> BeginEvent(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList_EndEvent(This) \
+    ( (This)->lpVtbl -> EndEvent(This) ) 
+
+#define ID3D12GraphicsCommandList_ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset)  \
+    ( (This)->lpVtbl -> ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12GraphicsCommandList_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12GraphicsCommandList1_INTERFACE_DEFINED__
+#define __ID3D12GraphicsCommandList1_INTERFACE_DEFINED__
+
+/* interface ID3D12GraphicsCommandList1 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12GraphicsCommandList1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("553103fb-1fe7-4557-bb38-946d7d0e7ca7")
+    ID3D12GraphicsCommandList1 : public ID3D12GraphicsCommandList
+    {
+    public:
+        virtual void STDMETHODCALLTYPE AtomicCopyBufferUINT( 
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges) = 0;
+        
+        virtual void STDMETHODCALLTYPE AtomicCopyBufferUINT64( 
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges) = 0;
+        
+        virtual void STDMETHODCALLTYPE OMSetDepthBounds( 
+            _In_  FLOAT Min,
+            _In_  FLOAT Max) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetSamplePositions( 
+            _In_  UINT NumSamplesPerPixel,
+            _In_  UINT NumPixels,
+            _In_reads_(NumSamplesPerPixel*NumPixels)  D3D12_SAMPLE_POSITION *pSamplePositions) = 0;
+        
+        virtual void STDMETHODCALLTYPE ResolveSubresourceRegion( 
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  UINT DstX,
+            _In_  UINT DstY,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_opt_  D3D12_RECT *pSrcRect,
+            _In_  DXGI_FORMAT Format,
+            _In_  D3D12_RESOLVE_MODE ResolveMode) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetViewInstanceMask( 
+            _In_  UINT Mask) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12GraphicsCommandList1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12GraphicsCommandList1 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12GraphicsCommandList1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12GraphicsCommandList1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12GraphicsCommandList1 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_COMMAND_LIST_TYPE ( STDMETHODCALLTYPE *GetType )( 
+            ID3D12GraphicsCommandList1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Close )( 
+            ID3D12GraphicsCommandList1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Reset )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12CommandAllocator *pAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState);
+        
+        void ( STDMETHODCALLTYPE *ClearState )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_opt_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *DrawInstanced )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT VertexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *DrawIndexedInstanced )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT IndexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartIndexLocation,
+            _In_  INT BaseVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *Dispatch )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT ThreadGroupCountX,
+            _In_  UINT ThreadGroupCountY,
+            _In_  UINT ThreadGroupCountZ);
+        
+        void ( STDMETHODCALLTYPE *CopyBufferRegion )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT64 NumBytes);
+        
+        void ( STDMETHODCALLTYPE *CopyTextureRegion )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pDst,
+            UINT DstX,
+            UINT DstY,
+            UINT DstZ,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pSrc,
+            _In_opt_  const D3D12_BOX *pSrcBox);
+        
+        void ( STDMETHODCALLTYPE *CopyResource )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  ID3D12Resource *pSrcResource);
+        
+        void ( STDMETHODCALLTYPE *CopyTiles )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate,
+            _In_  const D3D12_TILE_REGION_SIZE *pTileRegionSize,
+            _In_  ID3D12Resource *pBuffer,
+            UINT64 BufferStartOffsetInBytes,
+            D3D12_TILE_COPY_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresource )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_  DXGI_FORMAT Format);
+        
+        void ( STDMETHODCALLTYPE *IASetPrimitiveTopology )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology);
+        
+        void ( STDMETHODCALLTYPE *RSSetViewports )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumViewports,
+            _In_reads_( NumViewports)  const D3D12_VIEWPORT *pViewports);
+        
+        void ( STDMETHODCALLTYPE *RSSetScissorRects )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumRects,
+            _In_reads_( NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *OMSetBlendFactor )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_reads_opt_(4)  const FLOAT BlendFactor[ 4 ]);
+        
+        void ( STDMETHODCALLTYPE *OMSetStencilRef )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT StencilRef);
+        
+        void ( STDMETHODCALLTYPE *SetPipelineState )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *ResourceBarrier )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT NumBarriers,
+            _In_reads_(NumBarriers)  const D3D12_RESOURCE_BARRIER *pBarriers);
+        
+        void ( STDMETHODCALLTYPE *ExecuteBundle )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12GraphicsCommandList *pCommandList);
+        
+        void ( STDMETHODCALLTYPE *SetDescriptorHeaps )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT NumDescriptorHeaps,
+            _In_reads_(NumDescriptorHeaps)  ID3D12DescriptorHeap *const *ppDescriptorHeaps);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootSignature )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootSignature )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootDescriptorTable )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootDescriptorTable )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstant )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstant )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstants )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstants )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootConstantBufferView )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootConstantBufferView )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootShaderResourceView )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootShaderResourceView )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *IASetIndexBuffer )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_opt_  const D3D12_INDEX_BUFFER_VIEW *pView);
+        
+        void ( STDMETHODCALLTYPE *IASetVertexBuffers )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_VERTEX_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *SOSetTargets )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *OMSetRenderTargets )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT NumRenderTargetDescriptors,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pRenderTargetDescriptors,
+            _In_  BOOL RTsSingleHandleToDescriptorRange,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pDepthStencilDescriptor);
+        
+        void ( STDMETHODCALLTYPE *ClearDepthStencilView )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,
+            _In_  D3D12_CLEAR_FLAGS ClearFlags,
+            _In_  FLOAT Depth,
+            _In_  UINT8 Stencil,
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearRenderTargetView )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,
+            _In_  const FLOAT ColorRGBA[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewUint )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const UINT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewFloat )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const FLOAT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *DiscardResource )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DISCARD_REGION *pRegion);
+        
+        void ( STDMETHODCALLTYPE *BeginQuery )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *EndQuery )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *ResolveQueryData )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT StartIndex,
+            _In_  UINT NumQueries,
+            _In_  ID3D12Resource *pDestinationBuffer,
+            _In_  UINT64 AlignedDestinationBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *SetPredication )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_opt_  ID3D12Resource *pBuffer,
+            _In_  UINT64 AlignedBufferOffset,
+            _In_  D3D12_PREDICATION_OP Operation);
+        
+        void ( STDMETHODCALLTYPE *SetMarker )( 
+            ID3D12GraphicsCommandList1 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *BeginEvent )( 
+            ID3D12GraphicsCommandList1 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *EndEvent )( 
+            ID3D12GraphicsCommandList1 * This);
+        
+        void ( STDMETHODCALLTYPE *ExecuteIndirect )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12CommandSignature *pCommandSignature,
+            _In_  UINT MaxCommandCount,
+            _In_  ID3D12Resource *pArgumentBuffer,
+            _In_  UINT64 ArgumentBufferOffset,
+            _In_opt_  ID3D12Resource *pCountBuffer,
+            _In_  UINT64 CountBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT64 )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *OMSetDepthBounds )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  FLOAT Min,
+            _In_  FLOAT Max);
+        
+        void ( STDMETHODCALLTYPE *SetSamplePositions )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT NumSamplesPerPixel,
+            _In_  UINT NumPixels,
+            _In_reads_(NumSamplesPerPixel*NumPixels)  D3D12_SAMPLE_POSITION *pSamplePositions);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresourceRegion )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  UINT DstX,
+            _In_  UINT DstY,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_opt_  D3D12_RECT *pSrcRect,
+            _In_  DXGI_FORMAT Format,
+            _In_  D3D12_RESOLVE_MODE ResolveMode);
+        
+        void ( STDMETHODCALLTYPE *SetViewInstanceMask )( 
+            ID3D12GraphicsCommandList1 * This,
+            _In_  UINT Mask);
+        
+        END_INTERFACE
+    } ID3D12GraphicsCommandList1Vtbl;
+
+    interface ID3D12GraphicsCommandList1
+    {
+        CONST_VTBL struct ID3D12GraphicsCommandList1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12GraphicsCommandList1_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12GraphicsCommandList1_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12GraphicsCommandList1_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12GraphicsCommandList1_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList1_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList1_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12GraphicsCommandList1_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12GraphicsCommandList1_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12GraphicsCommandList1_GetType(This) \
+    ( (This)->lpVtbl -> GetType(This) ) 
+
+
+#define ID3D12GraphicsCommandList1_Close(This) \
+    ( (This)->lpVtbl -> Close(This) ) 
+
+#define ID3D12GraphicsCommandList1_Reset(This,pAllocator,pInitialState)  \
+    ( (This)->lpVtbl -> Reset(This,pAllocator,pInitialState) ) 
+
+#define ID3D12GraphicsCommandList1_ClearState(This,pPipelineState) \
+    ( (This)->lpVtbl -> ClearState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList1_DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList1_DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList1_Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ)  \
+    ( (This)->lpVtbl -> Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ) ) 
+
+#define ID3D12GraphicsCommandList1_CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) \
+    ( (This)->lpVtbl -> CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) ) 
+
+#define ID3D12GraphicsCommandList1_CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox)  \
+    ( (This)->lpVtbl -> CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox) ) 
+
+#define ID3D12GraphicsCommandList1_CopyResource(This,pDstResource,pSrcResource)  \
+    ( (This)->lpVtbl -> CopyResource(This,pDstResource,pSrcResource) ) 
+
+#define ID3D12GraphicsCommandList1_CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags)  \
+    ( (This)->lpVtbl -> CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags) ) 
+
+#define ID3D12GraphicsCommandList1_ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) \
+    ( (This)->lpVtbl -> ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) ) 
+
+#define ID3D12GraphicsCommandList1_IASetPrimitiveTopology(This,PrimitiveTopology)  \
+    ( (This)->lpVtbl -> IASetPrimitiveTopology(This,PrimitiveTopology) ) 
+
+#define ID3D12GraphicsCommandList1_RSSetViewports(This,NumViewports,pViewports)  \
+    ( (This)->lpVtbl -> RSSetViewports(This,NumViewports,pViewports) ) 
+
+#define ID3D12GraphicsCommandList1_RSSetScissorRects(This,NumRects,pRects) \
+    ( (This)->lpVtbl -> RSSetScissorRects(This,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList1_OMSetBlendFactor(This,BlendFactor)  \
+    ( (This)->lpVtbl -> OMSetBlendFactor(This,BlendFactor) ) 
+
+#define ID3D12GraphicsCommandList1_OMSetStencilRef(This,StencilRef)  \
+    ( (This)->lpVtbl -> OMSetStencilRef(This,StencilRef) ) 
+
+#define ID3D12GraphicsCommandList1_SetPipelineState(This,pPipelineState) \
+    ( (This)->lpVtbl -> SetPipelineState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList1_ResourceBarrier(This,NumBarriers,pBarriers) \
+    ( (This)->lpVtbl -> ResourceBarrier(This,NumBarriers,pBarriers) ) 
+
+#define ID3D12GraphicsCommandList1_ExecuteBundle(This,pCommandList)  \
+    ( (This)->lpVtbl -> ExecuteBundle(This,pCommandList) ) 
+
+#define ID3D12GraphicsCommandList1_SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) \
+    ( (This)->lpVtbl -> SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) ) 
+
+#define ID3D12GraphicsCommandList1_SetComputeRootSignature(This,pRootSignature)  \
+    ( (This)->lpVtbl -> SetComputeRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList1_SetGraphicsRootSignature(This,pRootSignature) \
+    ( (This)->lpVtbl -> SetGraphicsRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList1_SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) \
+    ( (This)->lpVtbl -> SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList1_SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor)  \
+    ( (This)->lpVtbl -> SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList1_SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList1_SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList1_SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList1_SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList1_SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList1_SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList1_SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList1_SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList1_SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList1_SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList1_IASetIndexBuffer(This,pView)  \
+    ( (This)->lpVtbl -> IASetIndexBuffer(This,pView) ) 
+
+#define ID3D12GraphicsCommandList1_IASetVertexBuffers(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> IASetVertexBuffers(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList1_SOSetTargets(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> SOSetTargets(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList1_OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) \
+    ( (This)->lpVtbl -> OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) ) 
+
+#define ID3D12GraphicsCommandList1_ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList1_ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList1_ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList1_ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList1_DiscardResource(This,pResource,pRegion) \
+    ( (This)->lpVtbl -> DiscardResource(This,pResource,pRegion) ) 
+
+#define ID3D12GraphicsCommandList1_BeginQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> BeginQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList1_EndQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> EndQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList1_ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset)  \
+    ( (This)->lpVtbl -> ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset) ) 
+
+#define ID3D12GraphicsCommandList1_SetPredication(This,pBuffer,AlignedBufferOffset,Operation)  \
+    ( (This)->lpVtbl -> SetPredication(This,pBuffer,AlignedBufferOffset,Operation) ) 
+
+#define ID3D12GraphicsCommandList1_SetMarker(This,Metadata,pData,Size) \
+    ( (This)->lpVtbl -> SetMarker(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList1_BeginEvent(This,Metadata,pData,Size)  \
+    ( (This)->lpVtbl -> BeginEvent(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList1_EndEvent(This)  \
+    ( (This)->lpVtbl -> EndEvent(This) ) 
+
+#define ID3D12GraphicsCommandList1_ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) \
+    ( (This)->lpVtbl -> ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) ) 
+
+
+#define ID3D12GraphicsCommandList1_AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList1_AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList1_OMSetDepthBounds(This,Min,Max)  \
+    ( (This)->lpVtbl -> OMSetDepthBounds(This,Min,Max) ) 
+
+#define ID3D12GraphicsCommandList1_SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions)  \
+    ( (This)->lpVtbl -> SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions) ) 
+
+#define ID3D12GraphicsCommandList1_ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode)  \
+    ( (This)->lpVtbl -> ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode) ) 
+
+#define ID3D12GraphicsCommandList1_SetViewInstanceMask(This,Mask)  \
+    ( (This)->lpVtbl -> SetViewInstanceMask(This,Mask) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12GraphicsCommandList1_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0018 */
+/* [local] */ 
+
+typedef struct D3D12_WRITEBUFFERIMMEDIATE_PARAMETER
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS Dest;
+    UINT32 Value;
+    }  D3D12_WRITEBUFFERIMMEDIATE_PARAMETER;
+
+typedef 
+enum D3D12_WRITEBUFFERIMMEDIATE_MODE
+    {
+        D3D12_WRITEBUFFERIMMEDIATE_MODE_DEFAULT  = 0,
+        D3D12_WRITEBUFFERIMMEDIATE_MODE_MARKER_IN  = 0x1,
+        D3D12_WRITEBUFFERIMMEDIATE_MODE_MARKER_OUT = 0x2
+    }  D3D12_WRITEBUFFERIMMEDIATE_MODE;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0018_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0018_v0_0_s_ifspec;
+
+#ifndef __ID3D12GraphicsCommandList2_INTERFACE_DEFINED__
+#define __ID3D12GraphicsCommandList2_INTERFACE_DEFINED__
+
+/* interface ID3D12GraphicsCommandList2 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12GraphicsCommandList2;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("38C3E585-FF17-412C-9150-4FC6F9D72A28")
+    ID3D12GraphicsCommandList2 : public ID3D12GraphicsCommandList1
+    {
+    public:
+        virtual void STDMETHODCALLTYPE WriteBufferImmediate( 
+            UINT Count,
+            _In_reads_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *pParams,
+            _In_reads_opt_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_MODE *pModes) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12GraphicsCommandList2Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12GraphicsCommandList2 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12GraphicsCommandList2 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12GraphicsCommandList2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12GraphicsCommandList2 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_COMMAND_LIST_TYPE ( STDMETHODCALLTYPE *GetType )( 
+            ID3D12GraphicsCommandList2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Close )( 
+            ID3D12GraphicsCommandList2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Reset )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12CommandAllocator *pAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState);
+        
+        void ( STDMETHODCALLTYPE *ClearState )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_opt_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *DrawInstanced )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT VertexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *DrawIndexedInstanced )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT IndexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartIndexLocation,
+            _In_  INT BaseVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *Dispatch )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT ThreadGroupCountX,
+            _In_  UINT ThreadGroupCountY,
+            _In_  UINT ThreadGroupCountZ);
+        
+        void ( STDMETHODCALLTYPE *CopyBufferRegion )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT64 NumBytes);
+        
+        void ( STDMETHODCALLTYPE *CopyTextureRegion )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pDst,
+            UINT DstX,
+            UINT DstY,
+            UINT DstZ,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pSrc,
+            _In_opt_  const D3D12_BOX *pSrcBox);
+        
+        void ( STDMETHODCALLTYPE *CopyResource )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  ID3D12Resource *pSrcResource);
+        
+        void ( STDMETHODCALLTYPE *CopyTiles )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate,
+            _In_  const D3D12_TILE_REGION_SIZE *pTileRegionSize,
+            _In_  ID3D12Resource *pBuffer,
+            UINT64 BufferStartOffsetInBytes,
+            D3D12_TILE_COPY_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresource )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_  DXGI_FORMAT Format);
+        
+        void ( STDMETHODCALLTYPE *IASetPrimitiveTopology )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology);
+        
+        void ( STDMETHODCALLTYPE *RSSetViewports )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumViewports,
+            _In_reads_( NumViewports)  const D3D12_VIEWPORT *pViewports);
+        
+        void ( STDMETHODCALLTYPE *RSSetScissorRects )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumRects,
+            _In_reads_( NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *OMSetBlendFactor )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_reads_opt_(4)  const FLOAT BlendFactor[ 4 ]);
+        
+        void ( STDMETHODCALLTYPE *OMSetStencilRef )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT StencilRef);
+        
+        void ( STDMETHODCALLTYPE *SetPipelineState )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *ResourceBarrier )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT NumBarriers,
+            _In_reads_(NumBarriers)  const D3D12_RESOURCE_BARRIER *pBarriers);
+        
+        void ( STDMETHODCALLTYPE *ExecuteBundle )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12GraphicsCommandList *pCommandList);
+        
+        void ( STDMETHODCALLTYPE *SetDescriptorHeaps )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT NumDescriptorHeaps,
+            _In_reads_(NumDescriptorHeaps)  ID3D12DescriptorHeap *const *ppDescriptorHeaps);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootSignature )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootSignature )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootDescriptorTable )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootDescriptorTable )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstant )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstant )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstants )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstants )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootConstantBufferView )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootConstantBufferView )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootShaderResourceView )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootShaderResourceView )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *IASetIndexBuffer )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_opt_  const D3D12_INDEX_BUFFER_VIEW *pView);
+        
+        void ( STDMETHODCALLTYPE *IASetVertexBuffers )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_VERTEX_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *SOSetTargets )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *OMSetRenderTargets )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT NumRenderTargetDescriptors,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pRenderTargetDescriptors,
+            _In_  BOOL RTsSingleHandleToDescriptorRange,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pDepthStencilDescriptor);
+        
+        void ( STDMETHODCALLTYPE *ClearDepthStencilView )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,
+            _In_  D3D12_CLEAR_FLAGS ClearFlags,
+            _In_  FLOAT Depth,
+            _In_  UINT8 Stencil,
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearRenderTargetView )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,
+            _In_  const FLOAT ColorRGBA[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewUint )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const UINT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewFloat )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const FLOAT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *DiscardResource )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DISCARD_REGION *pRegion);
+        
+        void ( STDMETHODCALLTYPE *BeginQuery )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *EndQuery )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *ResolveQueryData )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT StartIndex,
+            _In_  UINT NumQueries,
+            _In_  ID3D12Resource *pDestinationBuffer,
+            _In_  UINT64 AlignedDestinationBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *SetPredication )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_opt_  ID3D12Resource *pBuffer,
+            _In_  UINT64 AlignedBufferOffset,
+            _In_  D3D12_PREDICATION_OP Operation);
+        
+        void ( STDMETHODCALLTYPE *SetMarker )( 
+            ID3D12GraphicsCommandList2 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *BeginEvent )( 
+            ID3D12GraphicsCommandList2 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *EndEvent )( 
+            ID3D12GraphicsCommandList2 * This);
+        
+        void ( STDMETHODCALLTYPE *ExecuteIndirect )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12CommandSignature *pCommandSignature,
+            _In_  UINT MaxCommandCount,
+            _In_  ID3D12Resource *pArgumentBuffer,
+            _In_  UINT64 ArgumentBufferOffset,
+            _In_opt_  ID3D12Resource *pCountBuffer,
+            _In_  UINT64 CountBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT64 )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *OMSetDepthBounds )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  FLOAT Min,
+            _In_  FLOAT Max);
+        
+        void ( STDMETHODCALLTYPE *SetSamplePositions )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT NumSamplesPerPixel,
+            _In_  UINT NumPixels,
+            _In_reads_(NumSamplesPerPixel*NumPixels)  D3D12_SAMPLE_POSITION *pSamplePositions);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresourceRegion )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  UINT DstX,
+            _In_  UINT DstY,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_opt_  D3D12_RECT *pSrcRect,
+            _In_  DXGI_FORMAT Format,
+            _In_  D3D12_RESOLVE_MODE ResolveMode);
+        
+        void ( STDMETHODCALLTYPE *SetViewInstanceMask )( 
+            ID3D12GraphicsCommandList2 * This,
+            _In_  UINT Mask);
+        
+        void ( STDMETHODCALLTYPE *WriteBufferImmediate )( 
+            ID3D12GraphicsCommandList2 * This,
+            UINT Count,
+            _In_reads_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *pParams,
+            _In_reads_opt_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_MODE *pModes);
+        
+        END_INTERFACE
+    } ID3D12GraphicsCommandList2Vtbl;
+
+    interface ID3D12GraphicsCommandList2
+    {
+        CONST_VTBL struct ID3D12GraphicsCommandList2Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12GraphicsCommandList2_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12GraphicsCommandList2_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12GraphicsCommandList2_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12GraphicsCommandList2_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList2_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList2_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12GraphicsCommandList2_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12GraphicsCommandList2_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12GraphicsCommandList2_GetType(This) \
+    ( (This)->lpVtbl -> GetType(This) ) 
+
+
+#define ID3D12GraphicsCommandList2_Close(This) \
+    ( (This)->lpVtbl -> Close(This) ) 
+
+#define ID3D12GraphicsCommandList2_Reset(This,pAllocator,pInitialState)  \
+    ( (This)->lpVtbl -> Reset(This,pAllocator,pInitialState) ) 
+
+#define ID3D12GraphicsCommandList2_ClearState(This,pPipelineState) \
+    ( (This)->lpVtbl -> ClearState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList2_DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList2_DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList2_Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ)  \
+    ( (This)->lpVtbl -> Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ) ) 
+
+#define ID3D12GraphicsCommandList2_CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) \
+    ( (This)->lpVtbl -> CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) ) 
+
+#define ID3D12GraphicsCommandList2_CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox)  \
+    ( (This)->lpVtbl -> CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox) ) 
+
+#define ID3D12GraphicsCommandList2_CopyResource(This,pDstResource,pSrcResource)  \
+    ( (This)->lpVtbl -> CopyResource(This,pDstResource,pSrcResource) ) 
+
+#define ID3D12GraphicsCommandList2_CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags)  \
+    ( (This)->lpVtbl -> CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags) ) 
+
+#define ID3D12GraphicsCommandList2_ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) \
+    ( (This)->lpVtbl -> ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) ) 
+
+#define ID3D12GraphicsCommandList2_IASetPrimitiveTopology(This,PrimitiveTopology)  \
+    ( (This)->lpVtbl -> IASetPrimitiveTopology(This,PrimitiveTopology) ) 
+
+#define ID3D12GraphicsCommandList2_RSSetViewports(This,NumViewports,pViewports)  \
+    ( (This)->lpVtbl -> RSSetViewports(This,NumViewports,pViewports) ) 
+
+#define ID3D12GraphicsCommandList2_RSSetScissorRects(This,NumRects,pRects) \
+    ( (This)->lpVtbl -> RSSetScissorRects(This,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList2_OMSetBlendFactor(This,BlendFactor)  \
+    ( (This)->lpVtbl -> OMSetBlendFactor(This,BlendFactor) ) 
+
+#define ID3D12GraphicsCommandList2_OMSetStencilRef(This,StencilRef)  \
+    ( (This)->lpVtbl -> OMSetStencilRef(This,StencilRef) ) 
+
+#define ID3D12GraphicsCommandList2_SetPipelineState(This,pPipelineState) \
+    ( (This)->lpVtbl -> SetPipelineState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList2_ResourceBarrier(This,NumBarriers,pBarriers) \
+    ( (This)->lpVtbl -> ResourceBarrier(This,NumBarriers,pBarriers) ) 
+
+#define ID3D12GraphicsCommandList2_ExecuteBundle(This,pCommandList)  \
+    ( (This)->lpVtbl -> ExecuteBundle(This,pCommandList) ) 
+
+#define ID3D12GraphicsCommandList2_SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) \
+    ( (This)->lpVtbl -> SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) ) 
+
+#define ID3D12GraphicsCommandList2_SetComputeRootSignature(This,pRootSignature)  \
+    ( (This)->lpVtbl -> SetComputeRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList2_SetGraphicsRootSignature(This,pRootSignature) \
+    ( (This)->lpVtbl -> SetGraphicsRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList2_SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) \
+    ( (This)->lpVtbl -> SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList2_SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor)  \
+    ( (This)->lpVtbl -> SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList2_SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList2_SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList2_SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList2_SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList2_SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList2_SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList2_SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList2_SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList2_SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList2_SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList2_IASetIndexBuffer(This,pView)  \
+    ( (This)->lpVtbl -> IASetIndexBuffer(This,pView) ) 
+
+#define ID3D12GraphicsCommandList2_IASetVertexBuffers(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> IASetVertexBuffers(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList2_SOSetTargets(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> SOSetTargets(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList2_OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) \
+    ( (This)->lpVtbl -> OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) ) 
+
+#define ID3D12GraphicsCommandList2_ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList2_ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList2_ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList2_ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList2_DiscardResource(This,pResource,pRegion) \
+    ( (This)->lpVtbl -> DiscardResource(This,pResource,pRegion) ) 
+
+#define ID3D12GraphicsCommandList2_BeginQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> BeginQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList2_EndQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> EndQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList2_ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset)  \
+    ( (This)->lpVtbl -> ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset) ) 
+
+#define ID3D12GraphicsCommandList2_SetPredication(This,pBuffer,AlignedBufferOffset,Operation)  \
+    ( (This)->lpVtbl -> SetPredication(This,pBuffer,AlignedBufferOffset,Operation) ) 
+
+#define ID3D12GraphicsCommandList2_SetMarker(This,Metadata,pData,Size) \
+    ( (This)->lpVtbl -> SetMarker(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList2_BeginEvent(This,Metadata,pData,Size)  \
+    ( (This)->lpVtbl -> BeginEvent(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList2_EndEvent(This)  \
+    ( (This)->lpVtbl -> EndEvent(This) ) 
+
+#define ID3D12GraphicsCommandList2_ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) \
+    ( (This)->lpVtbl -> ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) ) 
+
+
+#define ID3D12GraphicsCommandList2_AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList2_AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList2_OMSetDepthBounds(This,Min,Max)  \
+    ( (This)->lpVtbl -> OMSetDepthBounds(This,Min,Max) ) 
+
+#define ID3D12GraphicsCommandList2_SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions)  \
+    ( (This)->lpVtbl -> SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions) ) 
+
+#define ID3D12GraphicsCommandList2_ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode)  \
+    ( (This)->lpVtbl -> ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode) ) 
+
+#define ID3D12GraphicsCommandList2_SetViewInstanceMask(This,Mask)  \
+    ( (This)->lpVtbl -> SetViewInstanceMask(This,Mask) ) 
+
+
+#define ID3D12GraphicsCommandList2_WriteBufferImmediate(This,Count,pParams,pModes) \
+    ( (This)->lpVtbl -> WriteBufferImmediate(This,Count,pParams,pModes) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12GraphicsCommandList2_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12CommandQueue_INTERFACE_DEFINED__
+#define __ID3D12CommandQueue_INTERFACE_DEFINED__
+
+/* interface ID3D12CommandQueue */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12CommandQueue;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("0ec870a6-5d7e-4c22-8cfc-5baae07616ed")
+    ID3D12CommandQueue : public ID3D12Pageable
+    {
+    public:
+        virtual void STDMETHODCALLTYPE UpdateTileMappings( 
+            _In_  ID3D12Resource *pResource,
+            UINT NumResourceRegions,
+            _In_reads_opt_(NumResourceRegions)  const D3D12_TILED_RESOURCE_COORDINATE *pResourceRegionStartCoordinates,
+            _In_reads_opt_(NumResourceRegions)  const D3D12_TILE_REGION_SIZE *pResourceRegionSizes,
+            _In_opt_  ID3D12Heap *pHeap,
+            UINT NumRanges,
+            _In_reads_opt_(NumRanges)  const D3D12_TILE_RANGE_FLAGS *pRangeFlags,
+            _In_reads_opt_(NumRanges)  const UINT *pHeapRangeStartOffsets,
+            _In_reads_opt_(NumRanges)  const UINT *pRangeTileCounts,
+            D3D12_TILE_MAPPING_FLAGS Flags) = 0;
+        
+        virtual void STDMETHODCALLTYPE CopyTileMappings( 
+            _In_  ID3D12Resource *pDstResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pDstRegionStartCoordinate,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pSrcRegionStartCoordinate,
+            _In_  const D3D12_TILE_REGION_SIZE *pRegionSize,
+            D3D12_TILE_MAPPING_FLAGS Flags) = 0;
+        
+        virtual void STDMETHODCALLTYPE ExecuteCommandLists( 
+            _In_  UINT NumCommandLists,
+            _In_reads_(NumCommandLists)  ID3D12CommandList *const *ppCommandLists) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetMarker( 
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size) = 0;
+        
+        virtual void STDMETHODCALLTYPE BeginEvent( 
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size) = 0;
+        
+        virtual void STDMETHODCALLTYPE EndEvent( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Signal( 
+            ID3D12Fence *pFence,
+            UINT64 Value) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Wait( 
+            ID3D12Fence *pFence,
+            UINT64 Value) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetTimestampFrequency( 
+            _Out_  UINT64 *pFrequency) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetClockCalibration( 
+            _Out_  UINT64 *pGpuTimestamp,
+            _Out_  UINT64 *pCpuTimestamp) = 0;
+        
+        virtual D3D12_COMMAND_QUEUE_DESC STDMETHODCALLTYPE GetDesc( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12CommandQueueVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12CommandQueue * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12CommandQueue * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12CommandQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12CommandQueue * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12CommandQueue * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12CommandQueue * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12CommandQueue * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12CommandQueue * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        void ( STDMETHODCALLTYPE *UpdateTileMappings )( 
+            ID3D12CommandQueue * This,
+            _In_  ID3D12Resource *pResource,
+            UINT NumResourceRegions,
+            _In_reads_opt_(NumResourceRegions)  const D3D12_TILED_RESOURCE_COORDINATE *pResourceRegionStartCoordinates,
+            _In_reads_opt_(NumResourceRegions)  const D3D12_TILE_REGION_SIZE *pResourceRegionSizes,
+            _In_opt_  ID3D12Heap *pHeap,
+            UINT NumRanges,
+            _In_reads_opt_(NumRanges)  const D3D12_TILE_RANGE_FLAGS *pRangeFlags,
+            _In_reads_opt_(NumRanges)  const UINT *pHeapRangeStartOffsets,
+            _In_reads_opt_(NumRanges)  const UINT *pRangeTileCounts,
+            D3D12_TILE_MAPPING_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *CopyTileMappings )( 
+            ID3D12CommandQueue * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pDstRegionStartCoordinate,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pSrcRegionStartCoordinate,
+            _In_  const D3D12_TILE_REGION_SIZE *pRegionSize,
+            D3D12_TILE_MAPPING_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *ExecuteCommandLists )( 
+            ID3D12CommandQueue * This,
+            _In_  UINT NumCommandLists,
+            _In_reads_(NumCommandLists)  ID3D12CommandList *const *ppCommandLists);
+        
+        void ( STDMETHODCALLTYPE *SetMarker )( 
+            ID3D12CommandQueue * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *BeginEvent )( 
+            ID3D12CommandQueue * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *EndEvent )( 
+            ID3D12CommandQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Signal )( 
+            ID3D12CommandQueue * This,
+            ID3D12Fence *pFence,
+            UINT64 Value);
+        
+        HRESULT ( STDMETHODCALLTYPE *Wait )( 
+            ID3D12CommandQueue * This,
+            ID3D12Fence *pFence,
+            UINT64 Value);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetTimestampFrequency )( 
+            ID3D12CommandQueue * This,
+            _Out_  UINT64 *pFrequency);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetClockCalibration )( 
+            ID3D12CommandQueue * This,
+            _Out_  UINT64 *pGpuTimestamp,
+            _Out_  UINT64 *pCpuTimestamp);
+        
+        D3D12_COMMAND_QUEUE_DESC ( STDMETHODCALLTYPE *GetDesc )( 
+            ID3D12CommandQueue * This);
+        
+        END_INTERFACE
+    } ID3D12CommandQueueVtbl;
+
+    interface ID3D12CommandQueue
+    {
+        CONST_VTBL struct ID3D12CommandQueueVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12CommandQueue_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12CommandQueue_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12CommandQueue_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12CommandQueue_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12CommandQueue_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12CommandQueue_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12CommandQueue_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12CommandQueue_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12CommandQueue_UpdateTileMappings(This,pResource,NumResourceRegions,pResourceRegionStartCoordinates,pResourceRegionSizes,pHeap,NumRanges,pRangeFlags,pHeapRangeStartOffsets,pRangeTileCounts,Flags)  \
+    ( (This)->lpVtbl -> UpdateTileMappings(This,pResource,NumResourceRegions,pResourceRegionStartCoordinates,pResourceRegionSizes,pHeap,NumRanges,pRangeFlags,pHeapRangeStartOffsets,pRangeTileCounts,Flags) ) 
+
+#define ID3D12CommandQueue_CopyTileMappings(This,pDstResource,pDstRegionStartCoordinate,pSrcResource,pSrcRegionStartCoordinate,pRegionSize,Flags)  \
+    ( (This)->lpVtbl -> CopyTileMappings(This,pDstResource,pDstRegionStartCoordinate,pSrcResource,pSrcRegionStartCoordinate,pRegionSize,Flags) ) 
+
+#define ID3D12CommandQueue_ExecuteCommandLists(This,NumCommandLists,ppCommandLists)  \
+    ( (This)->lpVtbl -> ExecuteCommandLists(This,NumCommandLists,ppCommandLists) ) 
+
+#define ID3D12CommandQueue_SetMarker(This,Metadata,pData,Size) \
+    ( (This)->lpVtbl -> SetMarker(This,Metadata,pData,Size) ) 
+
+#define ID3D12CommandQueue_BeginEvent(This,Metadata,pData,Size)  \
+    ( (This)->lpVtbl -> BeginEvent(This,Metadata,pData,Size) ) 
+
+#define ID3D12CommandQueue_EndEvent(This)  \
+    ( (This)->lpVtbl -> EndEvent(This) ) 
+
+#define ID3D12CommandQueue_Signal(This,pFence,Value) \
+    ( (This)->lpVtbl -> Signal(This,pFence,Value) ) 
+
+#define ID3D12CommandQueue_Wait(This,pFence,Value) \
+    ( (This)->lpVtbl -> Wait(This,pFence,Value) ) 
+
+#define ID3D12CommandQueue_GetTimestampFrequency(This,pFrequency)  \
+    ( (This)->lpVtbl -> GetTimestampFrequency(This,pFrequency) ) 
+
+#define ID3D12CommandQueue_GetClockCalibration(This,pGpuTimestamp,pCpuTimestamp) \
+    ( (This)->lpVtbl -> GetClockCalibration(This,pGpuTimestamp,pCpuTimestamp) ) 
+
+#define ID3D12CommandQueue_GetDesc(This) \
+    ( (This)->lpVtbl -> GetDesc(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+
+
+
+
+#endif   /* __ID3D12CommandQueue_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0020 */
+/* [local] */ 
+
+#ifdef __midl
+#ifndef LUID_DEFINED
+#define LUID_DEFINED 1
+typedef struct __LUID
+    {
+    DWORD LowPart;
+    LONG HighPart;
+    }  LUID;
+
+typedef struct __LUID *PLUID;
+
+#endif
+#endif
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0020_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0020_v0_0_s_ifspec;
+
+#ifndef __ID3D12Device_INTERFACE_DEFINED__
+#define __ID3D12Device_INTERFACE_DEFINED__
+
+/* interface ID3D12Device */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Device;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("189819f1-1db6-4b57-be54-1821339b85f7")
+    ID3D12Device : public ID3D12Object
+    {
+    public:
+        virtual UINT STDMETHODCALLTYPE GetNodeCount( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateCommandQueue( 
+            _In_  const D3D12_COMMAND_QUEUE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandQueue) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateCommandAllocator( 
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandAllocator) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateGraphicsPipelineState( 
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateComputePipelineState( 
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateCommandList( 
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  ID3D12CommandAllocator *pCommandAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CheckFeatureSupport( 
+            D3D12_FEATURE Feature,
+            _Inout_updates_bytes_(FeatureSupportDataSize)  void *pFeatureSupportData,
+            UINT FeatureSupportDataSize) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateDescriptorHeap( 
+            _In_  const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap) = 0;
+        
+        virtual UINT STDMETHODCALLTYPE GetDescriptorHandleIncrementSize( 
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateRootSignature( 
+            _In_  UINT nodeMask,
+            _In_reads_(blobLengthInBytes)  const void *pBlobWithRootSignature,
+            _In_  SIZE_T blobLengthInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppvRootSignature) = 0;
+        
+        virtual void STDMETHODCALLTYPE CreateConstantBufferView( 
+            _In_opt_  const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor) = 0;
+        
+        virtual void STDMETHODCALLTYPE CreateShaderResourceView( 
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor) = 0;
+        
+        virtual void STDMETHODCALLTYPE CreateUnorderedAccessView( 
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  ID3D12Resource *pCounterResource,
+            _In_opt_  const D3D12_UNORDERED_ACCESS_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor) = 0;
+        
+        virtual void STDMETHODCALLTYPE CreateRenderTargetView( 
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_RENDER_TARGET_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor) = 0;
+        
+        virtual void STDMETHODCALLTYPE CreateDepthStencilView( 
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor) = 0;
+        
+        virtual void STDMETHODCALLTYPE CreateSampler( 
+            _In_  const D3D12_SAMPLER_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor) = 0;
+        
+        virtual void STDMETHODCALLTYPE CopyDescriptors( 
+            _In_  UINT NumDestDescriptorRanges,
+            _In_reads_(NumDestDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts,
+            _In_reads_opt_(NumDestDescriptorRanges)  const UINT *pDestDescriptorRangeSizes,
+            _In_  UINT NumSrcDescriptorRanges,
+            _In_reads_(NumSrcDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
+            _In_reads_opt_(NumSrcDescriptorRanges)  const UINT *pSrcDescriptorRangeSizes,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType) = 0;
+        
+        virtual void STDMETHODCALLTYPE CopyDescriptorsSimple( 
+            _In_  UINT NumDescriptors,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType) = 0;
+        
+        virtual D3D12_RESOURCE_ALLOCATION_INFO STDMETHODCALLTYPE GetResourceAllocationInfo( 
+            _In_  UINT visibleMask,
+            _In_  UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs) = 0;
+        
+        virtual D3D12_HEAP_PROPERTIES STDMETHODCALLTYPE GetCustomHeapProperties( 
+            _In_  UINT nodeMask,
+            D3D12_HEAP_TYPE heapType) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateCommittedResource( 
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateHeap( 
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreatePlacedResource( 
+            _In_  ID3D12Heap *pHeap,
+            UINT64 HeapOffset,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateReservedResource( 
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateSharedHandle( 
+            _In_  ID3D12DeviceChild *pObject,
+            _In_opt_  const SECURITY_ATTRIBUTES *pAttributes,
+            DWORD Access,
+            _In_opt_  LPCWSTR Name,
+            _Out_  HANDLE *pHandle) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE OpenSharedHandle( 
+            _In_  HANDLE NTHandle,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvObj) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE OpenSharedHandleByName( 
+            _In_  LPCWSTR Name,
+            DWORD Access,
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pNTHandle) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE MakeResident( 
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Evict( 
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateFence( 
+            UINT64 InitialValue,
+            D3D12_FENCE_FLAGS Flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppFence) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDeviceRemovedReason( void) = 0;
+        
+        virtual void STDMETHODCALLTYPE GetCopyableFootprints( 
+            _In_  const D3D12_RESOURCE_DESC *pResourceDesc,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES)  UINT FirstSubresource,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource)  UINT NumSubresources,
+            UINT64 BaseOffset,
+            _Out_writes_opt_(NumSubresources)  D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts,
+            _Out_writes_opt_(NumSubresources)  UINT *pNumRows,
+            _Out_writes_opt_(NumSubresources)  UINT64 *pRowSizeInBytes,
+            _Out_opt_  UINT64 *pTotalBytes) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateQueryHeap( 
+            _In_  const D3D12_QUERY_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetStablePowerState( 
+            BOOL Enable) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateCommandSignature( 
+            _In_  const D3D12_COMMAND_SIGNATURE_DESC *pDesc,
+            _In_opt_  ID3D12RootSignature *pRootSignature,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvCommandSignature) = 0;
+        
+        virtual void STDMETHODCALLTYPE GetResourceTiling( 
+            _In_  ID3D12Resource *pTiledResource,
+            _Out_opt_  UINT *pNumTilesForEntireResource,
+            _Out_opt_  D3D12_PACKED_MIP_INFO *pPackedMipDesc,
+            _Out_opt_  D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips,
+            _Inout_opt_  UINT *pNumSubresourceTilings,
+            _In_  UINT FirstSubresourceTilingToGet,
+            _Out_writes_(*pNumSubresourceTilings)  D3D12_SUBRESOURCE_TILING *pSubresourceTilingsForNonPackedMips) = 0;
+        
+        virtual LUID STDMETHODCALLTYPE GetAdapterLuid( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DeviceVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Device * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Device * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Device * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Device * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Device * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Device * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Device * This,
+            _In_z_  LPCWSTR Name);
+        
+        UINT ( STDMETHODCALLTYPE *GetNodeCount )( 
+            ID3D12Device * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandQueue )( 
+            ID3D12Device * This,
+            _In_  const D3D12_COMMAND_QUEUE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandQueue);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandAllocator )( 
+            ID3D12Device * This,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandAllocator);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateGraphicsPipelineState )( 
+            ID3D12Device * This,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateComputePipelineState )( 
+            ID3D12Device * This,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList )( 
+            ID3D12Device * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  ID3D12CommandAllocator *pCommandAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckFeatureSupport )( 
+            ID3D12Device * This,
+            D3D12_FEATURE Feature,
+            _Inout_updates_bytes_(FeatureSupportDataSize)  void *pFeatureSupportData,
+            UINT FeatureSupportDataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateDescriptorHeap )( 
+            ID3D12Device * This,
+            _In_  const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        UINT ( STDMETHODCALLTYPE *GetDescriptorHandleIncrementSize )( 
+            ID3D12Device * This,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateRootSignature )( 
+            ID3D12Device * This,
+            _In_  UINT nodeMask,
+            _In_reads_(blobLengthInBytes)  const void *pBlobWithRootSignature,
+            _In_  SIZE_T blobLengthInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppvRootSignature);
+        
+        void ( STDMETHODCALLTYPE *CreateConstantBufferView )( 
+            ID3D12Device * This,
+            _In_opt_  const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateShaderResourceView )( 
+            ID3D12Device * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateUnorderedAccessView )( 
+            ID3D12Device * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  ID3D12Resource *pCounterResource,
+            _In_opt_  const D3D12_UNORDERED_ACCESS_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateRenderTargetView )( 
+            ID3D12Device * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_RENDER_TARGET_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateDepthStencilView )( 
+            ID3D12Device * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateSampler )( 
+            ID3D12Device * This,
+            _In_  const D3D12_SAMPLER_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptors )( 
+            ID3D12Device * This,
+            _In_  UINT NumDestDescriptorRanges,
+            _In_reads_(NumDestDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts,
+            _In_reads_opt_(NumDestDescriptorRanges)  const UINT *pDestDescriptorRangeSizes,
+            _In_  UINT NumSrcDescriptorRanges,
+            _In_reads_(NumSrcDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
+            _In_reads_opt_(NumSrcDescriptorRanges)  const UINT *pSrcDescriptorRangeSizes,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptorsSimple )( 
+            ID3D12Device * This,
+            _In_  UINT NumDescriptors,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo )( 
+            ID3D12Device * This,
+            _In_  UINT visibleMask,
+            _In_  UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs);
+        
+        D3D12_HEAP_PROPERTIES ( STDMETHODCALLTYPE *GetCustomHeapProperties )( 
+            ID3D12Device * This,
+            _In_  UINT nodeMask,
+            D3D12_HEAP_TYPE heapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource )( 
+            ID3D12Device * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap )( 
+            ID3D12Device * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePlacedResource )( 
+            ID3D12Device * This,
+            _In_  ID3D12Heap *pHeap,
+            UINT64 HeapOffset,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource )( 
+            ID3D12Device * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSharedHandle )( 
+            ID3D12Device * This,
+            _In_  ID3D12DeviceChild *pObject,
+            _In_opt_  const SECURITY_ATTRIBUTES *pAttributes,
+            DWORD Access,
+            _In_opt_  LPCWSTR Name,
+            _Out_  HANDLE *pHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandle )( 
+            ID3D12Device * This,
+            _In_  HANDLE NTHandle,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvObj);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandleByName )( 
+            ID3D12Device * This,
+            _In_  LPCWSTR Name,
+            DWORD Access,
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pNTHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeResident )( 
+            ID3D12Device * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *Evict )( 
+            ID3D12Device * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateFence )( 
+            ID3D12Device * This,
+            UINT64 InitialValue,
+            D3D12_FENCE_FLAGS Flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppFence);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDeviceRemovedReason )( 
+            ID3D12Device * This);
+        
+        void ( STDMETHODCALLTYPE *GetCopyableFootprints )( 
+            ID3D12Device * This,
+            _In_  const D3D12_RESOURCE_DESC *pResourceDesc,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES)  UINT FirstSubresource,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource)  UINT NumSubresources,
+            UINT64 BaseOffset,
+            _Out_writes_opt_(NumSubresources)  D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts,
+            _Out_writes_opt_(NumSubresources)  UINT *pNumRows,
+            _Out_writes_opt_(NumSubresources)  UINT64 *pRowSizeInBytes,
+            _Out_opt_  UINT64 *pTotalBytes);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateQueryHeap )( 
+            ID3D12Device * This,
+            _In_  const D3D12_QUERY_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetStablePowerState )( 
+            ID3D12Device * This,
+            BOOL Enable);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandSignature )( 
+            ID3D12Device * This,
+            _In_  const D3D12_COMMAND_SIGNATURE_DESC *pDesc,
+            _In_opt_  ID3D12RootSignature *pRootSignature,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvCommandSignature);
+        
+        void ( STDMETHODCALLTYPE *GetResourceTiling )( 
+            ID3D12Device * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _Out_opt_  UINT *pNumTilesForEntireResource,
+            _Out_opt_  D3D12_PACKED_MIP_INFO *pPackedMipDesc,
+            _Out_opt_  D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips,
+            _Inout_opt_  UINT *pNumSubresourceTilings,
+            _In_  UINT FirstSubresourceTilingToGet,
+            _Out_writes_(*pNumSubresourceTilings)  D3D12_SUBRESOURCE_TILING *pSubresourceTilingsForNonPackedMips);
+        
+        LUID ( STDMETHODCALLTYPE *GetAdapterLuid )( 
+            ID3D12Device * This);
+        
+        END_INTERFACE
+    } ID3D12DeviceVtbl;
+
+    interface ID3D12Device
+    {
+        CONST_VTBL struct ID3D12DeviceVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Device_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Device_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Device_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Device_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Device_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Device_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Device_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Device_GetNodeCount(This)  \
+    ( (This)->lpVtbl -> GetNodeCount(This) ) 
+
+#define ID3D12Device_CreateCommandQueue(This,pDesc,riid,ppCommandQueue)  \
+    ( (This)->lpVtbl -> CreateCommandQueue(This,pDesc,riid,ppCommandQueue) ) 
+
+#define ID3D12Device_CreateCommandAllocator(This,type,riid,ppCommandAllocator) \
+    ( (This)->lpVtbl -> CreateCommandAllocator(This,type,riid,ppCommandAllocator) ) 
+
+#define ID3D12Device_CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState)  \
+    ( (This)->lpVtbl -> CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device_CreateComputePipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreateComputePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device_CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList)  \
+    ( (This)->lpVtbl -> CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) ) 
+
+#define ID3D12Device_CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize)  \
+    ( (This)->lpVtbl -> CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) ) 
+
+#define ID3D12Device_CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device_GetDescriptorHandleIncrementSize(This,DescriptorHeapType) \
+    ( (This)->lpVtbl -> GetDescriptorHandleIncrementSize(This,DescriptorHeapType) ) 
+
+#define ID3D12Device_CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature) \
+    ( (This)->lpVtbl -> CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature) ) 
+
+#define ID3D12Device_CreateConstantBufferView(This,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateConstantBufferView(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device_CreateShaderResourceView(This,pResource,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateShaderResourceView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device_CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device_CreateRenderTargetView(This,pResource,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateRenderTargetView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device_CreateDepthStencilView(This,pResource,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateDepthStencilView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device_CreateSampler(This,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateSampler(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device_CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType)  \
+    ( (This)->lpVtbl -> CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) ) 
+
+#define ID3D12Device_CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType) \
+    ( (This)->lpVtbl -> CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType) ) 
+
+#define ID3D12Device_GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs) \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs) ) 
+
+#define ID3D12Device_GetCustomHeapProperties(This,nodeMask,heapType) \
+    ( (This)->lpVtbl -> GetCustomHeapProperties(This,nodeMask,heapType) ) 
+
+#define ID3D12Device_CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource)  \
+    ( (This)->lpVtbl -> CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) ) 
+
+#define ID3D12Device_CreateHeap(This,pDesc,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device_CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource)  \
+    ( (This)->lpVtbl -> CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device_CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device_CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle)  \
+    ( (This)->lpVtbl -> CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) ) 
+
+#define ID3D12Device_OpenSharedHandle(This,NTHandle,riid,ppvObj) \
+    ( (This)->lpVtbl -> OpenSharedHandle(This,NTHandle,riid,ppvObj) ) 
+
+#define ID3D12Device_OpenSharedHandleByName(This,Name,Access,pNTHandle)  \
+    ( (This)->lpVtbl -> OpenSharedHandleByName(This,Name,Access,pNTHandle) ) 
+
+#define ID3D12Device_MakeResident(This,NumObjects,ppObjects) \
+    ( (This)->lpVtbl -> MakeResident(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device_Evict(This,NumObjects,ppObjects)  \
+    ( (This)->lpVtbl -> Evict(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device_CreateFence(This,InitialValue,Flags,riid,ppFence) \
+    ( (This)->lpVtbl -> CreateFence(This,InitialValue,Flags,riid,ppFence) ) 
+
+#define ID3D12Device_GetDeviceRemovedReason(This)  \
+    ( (This)->lpVtbl -> GetDeviceRemovedReason(This) ) 
+
+#define ID3D12Device_GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes) \
+    ( (This)->lpVtbl -> GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes) ) 
+
+#define ID3D12Device_CreateQueryHeap(This,pDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateQueryHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device_SetStablePowerState(This,Enable)  \
+    ( (This)->lpVtbl -> SetStablePowerState(This,Enable) ) 
+
+#define ID3D12Device_CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature)  \
+    ( (This)->lpVtbl -> CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) ) 
+
+#define ID3D12Device_GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips)  \
+    ( (This)->lpVtbl -> GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) ) 
+
+#define ID3D12Device_GetAdapterLuid(This)  \
+    ( (This)->lpVtbl -> GetAdapterLuid(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif   /* __ID3D12Device_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12PipelineLibrary_INTERFACE_DEFINED__
+#define __ID3D12PipelineLibrary_INTERFACE_DEFINED__
+
+/* interface ID3D12PipelineLibrary */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12PipelineLibrary;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("c64226a8-9201-46af-b4cc-53fb9ff7414f")
+    ID3D12PipelineLibrary : public ID3D12DeviceChild
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE StorePipeline( 
+            _In_opt_  LPCWSTR pName,
+            _In_  ID3D12PipelineState *pPipeline) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE LoadGraphicsPipeline( 
+            _In_  LPCWSTR pName,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE LoadComputePipeline( 
+            _In_  LPCWSTR pName,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState) = 0;
+        
+        virtual SIZE_T STDMETHODCALLTYPE GetSerializedSize( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Serialize( 
+            _Out_writes_(DataSizeInBytes)  void *pData,
+            SIZE_T DataSizeInBytes) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12PipelineLibraryVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12PipelineLibrary * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12PipelineLibrary * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12PipelineLibrary * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12PipelineLibrary * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12PipelineLibrary * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12PipelineLibrary * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12PipelineLibrary * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12PipelineLibrary * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *StorePipeline )( 
+            ID3D12PipelineLibrary * This,
+            _In_opt_  LPCWSTR pName,
+            _In_  ID3D12PipelineState *pPipeline);
+        
+        HRESULT ( STDMETHODCALLTYPE *LoadGraphicsPipeline )( 
+            ID3D12PipelineLibrary * This,
+            _In_  LPCWSTR pName,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *LoadComputePipeline )( 
+            ID3D12PipelineLibrary * This,
+            _In_  LPCWSTR pName,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        SIZE_T ( STDMETHODCALLTYPE *GetSerializedSize )( 
+            ID3D12PipelineLibrary * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
+            ID3D12PipelineLibrary * This,
+            _Out_writes_(DataSizeInBytes)  void *pData,
+            SIZE_T DataSizeInBytes);
+        
+        END_INTERFACE
+    } ID3D12PipelineLibraryVtbl;
+
+    interface ID3D12PipelineLibrary
+    {
+        CONST_VTBL struct ID3D12PipelineLibraryVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12PipelineLibrary_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12PipelineLibrary_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12PipelineLibrary_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12PipelineLibrary_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12PipelineLibrary_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12PipelineLibrary_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12PipelineLibrary_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12PipelineLibrary_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12PipelineLibrary_StorePipeline(This,pName,pPipeline)  \
+    ( (This)->lpVtbl -> StorePipeline(This,pName,pPipeline) ) 
+
+#define ID3D12PipelineLibrary_LoadGraphicsPipeline(This,pName,pDesc,riid,ppPipelineState)  \
+    ( (This)->lpVtbl -> LoadGraphicsPipeline(This,pName,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12PipelineLibrary_LoadComputePipeline(This,pName,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> LoadComputePipeline(This,pName,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12PipelineLibrary_GetSerializedSize(This)  \
+    ( (This)->lpVtbl -> GetSerializedSize(This) ) 
+
+#define ID3D12PipelineLibrary_Serialize(This,pData,DataSizeInBytes)  \
+    ( (This)->lpVtbl -> Serialize(This,pData,DataSizeInBytes) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12PipelineLibrary_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12PipelineLibrary1_INTERFACE_DEFINED__
+#define __ID3D12PipelineLibrary1_INTERFACE_DEFINED__
+
+/* interface ID3D12PipelineLibrary1 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12PipelineLibrary1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("80eabf42-2568-4e5e-bd82-c37f86961dc3")
+    ID3D12PipelineLibrary1 : public ID3D12PipelineLibrary
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE LoadPipeline( 
+            _In_  LPCWSTR pName,
+            _In_  const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12PipelineLibrary1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12PipelineLibrary1 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12PipelineLibrary1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12PipelineLibrary1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12PipelineLibrary1 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12PipelineLibrary1 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12PipelineLibrary1 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12PipelineLibrary1 * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12PipelineLibrary1 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *StorePipeline )( 
+            ID3D12PipelineLibrary1 * This,
+            _In_opt_  LPCWSTR pName,
+            _In_  ID3D12PipelineState *pPipeline);
+        
+        HRESULT ( STDMETHODCALLTYPE *LoadGraphicsPipeline )( 
+            ID3D12PipelineLibrary1 * This,
+            _In_  LPCWSTR pName,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *LoadComputePipeline )( 
+            ID3D12PipelineLibrary1 * This,
+            _In_  LPCWSTR pName,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        SIZE_T ( STDMETHODCALLTYPE *GetSerializedSize )( 
+            ID3D12PipelineLibrary1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
+            ID3D12PipelineLibrary1 * This,
+            _Out_writes_(DataSizeInBytes)  void *pData,
+            SIZE_T DataSizeInBytes);
+        
+        HRESULT ( STDMETHODCALLTYPE *LoadPipeline )( 
+            ID3D12PipelineLibrary1 * This,
+            _In_  LPCWSTR pName,
+            _In_  const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        END_INTERFACE
+    } ID3D12PipelineLibrary1Vtbl;
+
+    interface ID3D12PipelineLibrary1
+    {
+        CONST_VTBL struct ID3D12PipelineLibrary1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12PipelineLibrary1_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12PipelineLibrary1_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12PipelineLibrary1_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12PipelineLibrary1_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12PipelineLibrary1_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12PipelineLibrary1_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12PipelineLibrary1_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12PipelineLibrary1_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12PipelineLibrary1_StorePipeline(This,pName,pPipeline) \
+    ( (This)->lpVtbl -> StorePipeline(This,pName,pPipeline) ) 
+
+#define ID3D12PipelineLibrary1_LoadGraphicsPipeline(This,pName,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> LoadGraphicsPipeline(This,pName,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12PipelineLibrary1_LoadComputePipeline(This,pName,pDesc,riid,ppPipelineState)  \
+    ( (This)->lpVtbl -> LoadComputePipeline(This,pName,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12PipelineLibrary1_GetSerializedSize(This) \
+    ( (This)->lpVtbl -> GetSerializedSize(This) ) 
+
+#define ID3D12PipelineLibrary1_Serialize(This,pData,DataSizeInBytes) \
+    ( (This)->lpVtbl -> Serialize(This,pData,DataSizeInBytes) ) 
+
+
+#define ID3D12PipelineLibrary1_LoadPipeline(This,pName,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> LoadPipeline(This,pName,pDesc,riid,ppPipelineState) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12PipelineLibrary1_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0023 */
+/* [local] */ 
+
+typedef 
+enum D3D12_MULTIPLE_FENCE_WAIT_FLAGS
+    {
+        D3D12_MULTIPLE_FENCE_WAIT_FLAG_NONE  = 0,
+        D3D12_MULTIPLE_FENCE_WAIT_FLAG_ANY = 0x1,
+        D3D12_MULTIPLE_FENCE_WAIT_FLAG_ALL = 0
+    }  D3D12_MULTIPLE_FENCE_WAIT_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_MULTIPLE_FENCE_WAIT_FLAGS );
+typedef 
+enum D3D12_RESIDENCY_PRIORITY
+    {
+        D3D12_RESIDENCY_PRIORITY_MINIMUM = 0x28000000,
+        D3D12_RESIDENCY_PRIORITY_LOW = 0x50000000,
+        D3D12_RESIDENCY_PRIORITY_NORMAL  = 0x78000000,
+        D3D12_RESIDENCY_PRIORITY_HIGH  = 0xa0010000,
+        D3D12_RESIDENCY_PRIORITY_MAXIMUM = 0xc8000000
+    }  D3D12_RESIDENCY_PRIORITY;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0023_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0023_v0_0_s_ifspec;
+
+#ifndef __ID3D12Device1_INTERFACE_DEFINED__
+#define __ID3D12Device1_INTERFACE_DEFINED__
+
+/* interface ID3D12Device1 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Device1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("77acce80-638e-4e65-8895-c1f23386863e")
+    ID3D12Device1 : public ID3D12Device
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE CreatePipelineLibrary( 
+            _In_reads_(BlobLength)  const void *pLibraryBlob,
+            SIZE_T BlobLength,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineLibrary) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetEventOnMultipleFenceCompletion( 
+            _In_reads_(NumFences)  ID3D12Fence *const *ppFences,
+            _In_reads_(NumFences)  const UINT64 *pFenceValues,
+            UINT NumFences,
+            D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
+            HANDLE hEvent) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetResidencyPriority( 
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_reads_(NumObjects)  const D3D12_RESIDENCY_PRIORITY *pPriorities) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Device1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Device1 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Device1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Device1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Device1 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Device1 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Device1 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Device1 * This,
+            _In_z_  LPCWSTR Name);
+        
+        UINT ( STDMETHODCALLTYPE *GetNodeCount )( 
+            ID3D12Device1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandQueue )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_COMMAND_QUEUE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandQueue);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandAllocator )( 
+            ID3D12Device1 * This,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandAllocator);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateGraphicsPipelineState )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateComputePipelineState )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList )( 
+            ID3D12Device1 * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  ID3D12CommandAllocator *pCommandAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckFeatureSupport )( 
+            ID3D12Device1 * This,
+            D3D12_FEATURE Feature,
+            _Inout_updates_bytes_(FeatureSupportDataSize)  void *pFeatureSupportData,
+            UINT FeatureSupportDataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateDescriptorHeap )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        UINT ( STDMETHODCALLTYPE *GetDescriptorHandleIncrementSize )( 
+            ID3D12Device1 * This,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateRootSignature )( 
+            ID3D12Device1 * This,
+            _In_  UINT nodeMask,
+            _In_reads_(blobLengthInBytes)  const void *pBlobWithRootSignature,
+            _In_  SIZE_T blobLengthInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppvRootSignature);
+        
+        void ( STDMETHODCALLTYPE *CreateConstantBufferView )( 
+            ID3D12Device1 * This,
+            _In_opt_  const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateShaderResourceView )( 
+            ID3D12Device1 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateUnorderedAccessView )( 
+            ID3D12Device1 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  ID3D12Resource *pCounterResource,
+            _In_opt_  const D3D12_UNORDERED_ACCESS_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateRenderTargetView )( 
+            ID3D12Device1 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_RENDER_TARGET_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateDepthStencilView )( 
+            ID3D12Device1 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateSampler )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_SAMPLER_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptors )( 
+            ID3D12Device1 * This,
+            _In_  UINT NumDestDescriptorRanges,
+            _In_reads_(NumDestDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts,
+            _In_reads_opt_(NumDestDescriptorRanges)  const UINT *pDestDescriptorRangeSizes,
+            _In_  UINT NumSrcDescriptorRanges,
+            _In_reads_(NumSrcDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
+            _In_reads_opt_(NumSrcDescriptorRanges)  const UINT *pSrcDescriptorRangeSizes,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptorsSimple )( 
+            ID3D12Device1 * This,
+            _In_  UINT NumDescriptors,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo )( 
+            ID3D12Device1 * This,
+            _In_  UINT visibleMask,
+            _In_  UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs);
+        
+        D3D12_HEAP_PROPERTIES ( STDMETHODCALLTYPE *GetCustomHeapProperties )( 
+            ID3D12Device1 * This,
+            _In_  UINT nodeMask,
+            D3D12_HEAP_TYPE heapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePlacedResource )( 
+            ID3D12Device1 * This,
+            _In_  ID3D12Heap *pHeap,
+            UINT64 HeapOffset,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSharedHandle )( 
+            ID3D12Device1 * This,
+            _In_  ID3D12DeviceChild *pObject,
+            _In_opt_  const SECURITY_ATTRIBUTES *pAttributes,
+            DWORD Access,
+            _In_opt_  LPCWSTR Name,
+            _Out_  HANDLE *pHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandle )( 
+            ID3D12Device1 * This,
+            _In_  HANDLE NTHandle,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvObj);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandleByName )( 
+            ID3D12Device1 * This,
+            _In_  LPCWSTR Name,
+            DWORD Access,
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pNTHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeResident )( 
+            ID3D12Device1 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *Evict )( 
+            ID3D12Device1 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateFence )( 
+            ID3D12Device1 * This,
+            UINT64 InitialValue,
+            D3D12_FENCE_FLAGS Flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppFence);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDeviceRemovedReason )( 
+            ID3D12Device1 * This);
+        
+        void ( STDMETHODCALLTYPE *GetCopyableFootprints )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_RESOURCE_DESC *pResourceDesc,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES)  UINT FirstSubresource,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource)  UINT NumSubresources,
+            UINT64 BaseOffset,
+            _Out_writes_opt_(NumSubresources)  D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts,
+            _Out_writes_opt_(NumSubresources)  UINT *pNumRows,
+            _Out_writes_opt_(NumSubresources)  UINT64 *pRowSizeInBytes,
+            _Out_opt_  UINT64 *pTotalBytes);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateQueryHeap )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_QUERY_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetStablePowerState )( 
+            ID3D12Device1 * This,
+            BOOL Enable);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandSignature )( 
+            ID3D12Device1 * This,
+            _In_  const D3D12_COMMAND_SIGNATURE_DESC *pDesc,
+            _In_opt_  ID3D12RootSignature *pRootSignature,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvCommandSignature);
+        
+        void ( STDMETHODCALLTYPE *GetResourceTiling )( 
+            ID3D12Device1 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _Out_opt_  UINT *pNumTilesForEntireResource,
+            _Out_opt_  D3D12_PACKED_MIP_INFO *pPackedMipDesc,
+            _Out_opt_  D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips,
+            _Inout_opt_  UINT *pNumSubresourceTilings,
+            _In_  UINT FirstSubresourceTilingToGet,
+            _Out_writes_(*pNumSubresourceTilings)  D3D12_SUBRESOURCE_TILING *pSubresourceTilingsForNonPackedMips);
+        
+        LUID ( STDMETHODCALLTYPE *GetAdapterLuid )( 
+            ID3D12Device1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineLibrary )( 
+            ID3D12Device1 * This,
+            _In_reads_(BlobLength)  const void *pLibraryBlob,
+            SIZE_T BlobLength,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineLibrary);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEventOnMultipleFenceCompletion )( 
+            ID3D12Device1 * This,
+            _In_reads_(NumFences)  ID3D12Fence *const *ppFences,
+            _In_reads_(NumFences)  const UINT64 *pFenceValues,
+            UINT NumFences,
+            D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
+            HANDLE hEvent);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetResidencyPriority )( 
+            ID3D12Device1 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_reads_(NumObjects)  const D3D12_RESIDENCY_PRIORITY *pPriorities);
+        
+        END_INTERFACE
+    } ID3D12Device1Vtbl;
+
+    interface ID3D12Device1
+    {
+        CONST_VTBL struct ID3D12Device1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Device1_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Device1_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Device1_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Device1_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Device1_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Device1_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Device1_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Device1_GetNodeCount(This) \
+    ( (This)->lpVtbl -> GetNodeCount(This) ) 
+
+#define ID3D12Device1_CreateCommandQueue(This,pDesc,riid,ppCommandQueue) \
+    ( (This)->lpVtbl -> CreateCommandQueue(This,pDesc,riid,ppCommandQueue) ) 
+
+#define ID3D12Device1_CreateCommandAllocator(This,type,riid,ppCommandAllocator)  \
+    ( (This)->lpVtbl -> CreateCommandAllocator(This,type,riid,ppCommandAllocator) ) 
+
+#define ID3D12Device1_CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device1_CreateComputePipelineState(This,pDesc,riid,ppPipelineState)  \
+    ( (This)->lpVtbl -> CreateComputePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device1_CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) \
+    ( (This)->lpVtbl -> CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) ) 
+
+#define ID3D12Device1_CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) \
+    ( (This)->lpVtbl -> CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) ) 
+
+#define ID3D12Device1_CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device1_GetDescriptorHandleIncrementSize(This,DescriptorHeapType)  \
+    ( (This)->lpVtbl -> GetDescriptorHandleIncrementSize(This,DescriptorHeapType) ) 
+
+#define ID3D12Device1_CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature)  \
+    ( (This)->lpVtbl -> CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature) ) 
+
+#define ID3D12Device1_CreateConstantBufferView(This,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateConstantBufferView(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device1_CreateShaderResourceView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateShaderResourceView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device1_CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device1_CreateRenderTargetView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateRenderTargetView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device1_CreateDepthStencilView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateDepthStencilView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device1_CreateSampler(This,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateSampler(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device1_CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) \
+    ( (This)->lpVtbl -> CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) ) 
+
+#define ID3D12Device1_CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType)  \
+    ( (This)->lpVtbl -> CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType) ) 
+
+#define ID3D12Device1_GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs)  \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs) ) 
+
+#define ID3D12Device1_GetCustomHeapProperties(This,nodeMask,heapType)  \
+    ( (This)->lpVtbl -> GetCustomHeapProperties(This,nodeMask,heapType) ) 
+
+#define ID3D12Device1_CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) \
+    ( (This)->lpVtbl -> CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) ) 
+
+#define ID3D12Device1_CreateHeap(This,pDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device1_CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device1_CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource)  \
+    ( (This)->lpVtbl -> CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device1_CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) \
+    ( (This)->lpVtbl -> CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) ) 
+
+#define ID3D12Device1_OpenSharedHandle(This,NTHandle,riid,ppvObj)  \
+    ( (This)->lpVtbl -> OpenSharedHandle(This,NTHandle,riid,ppvObj) ) 
+
+#define ID3D12Device1_OpenSharedHandleByName(This,Name,Access,pNTHandle) \
+    ( (This)->lpVtbl -> OpenSharedHandleByName(This,Name,Access,pNTHandle) ) 
+
+#define ID3D12Device1_MakeResident(This,NumObjects,ppObjects)  \
+    ( (This)->lpVtbl -> MakeResident(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device1_Evict(This,NumObjects,ppObjects) \
+    ( (This)->lpVtbl -> Evict(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device1_CreateFence(This,InitialValue,Flags,riid,ppFence)  \
+    ( (This)->lpVtbl -> CreateFence(This,InitialValue,Flags,riid,ppFence) ) 
+
+#define ID3D12Device1_GetDeviceRemovedReason(This) \
+    ( (This)->lpVtbl -> GetDeviceRemovedReason(This) ) 
+
+#define ID3D12Device1_GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes)  \
+    ( (This)->lpVtbl -> GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes) ) 
+
+#define ID3D12Device1_CreateQueryHeap(This,pDesc,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateQueryHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device1_SetStablePowerState(This,Enable) \
+    ( (This)->lpVtbl -> SetStablePowerState(This,Enable) ) 
+
+#define ID3D12Device1_CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) \
+    ( (This)->lpVtbl -> CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) ) 
+
+#define ID3D12Device1_GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) \
+    ( (This)->lpVtbl -> GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) ) 
+
+#define ID3D12Device1_GetAdapterLuid(This) \
+    ( (This)->lpVtbl -> GetAdapterLuid(This) ) 
+
+
+#define ID3D12Device1_CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) \
+    ( (This)->lpVtbl -> CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) ) 
+
+#define ID3D12Device1_SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) \
+    ( (This)->lpVtbl -> SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) ) 
+
+#define ID3D12Device1_SetResidencyPriority(This,NumObjects,ppObjects,pPriorities)  \
+    ( (This)->lpVtbl -> SetResidencyPriority(This,NumObjects,ppObjects,pPriorities) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Device1_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Device2_INTERFACE_DEFINED__
+#define __ID3D12Device2_INTERFACE_DEFINED__
+
+/* interface ID3D12Device2 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Device2;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("30baa41e-b15b-475c-a0bb-1af5c5b64328")
+    ID3D12Device2 : public ID3D12Device1
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE CreatePipelineState( 
+            const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Device2Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Device2 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Device2 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Device2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Device2 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Device2 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Device2 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Device2 * This,
+            _In_z_  LPCWSTR Name);
+        
+        UINT ( STDMETHODCALLTYPE *GetNodeCount )( 
+            ID3D12Device2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandQueue )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_COMMAND_QUEUE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandQueue);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandAllocator )( 
+            ID3D12Device2 * This,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandAllocator);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateGraphicsPipelineState )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateComputePipelineState )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList )( 
+            ID3D12Device2 * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  ID3D12CommandAllocator *pCommandAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckFeatureSupport )( 
+            ID3D12Device2 * This,
+            D3D12_FEATURE Feature,
+            _Inout_updates_bytes_(FeatureSupportDataSize)  void *pFeatureSupportData,
+            UINT FeatureSupportDataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateDescriptorHeap )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        UINT ( STDMETHODCALLTYPE *GetDescriptorHandleIncrementSize )( 
+            ID3D12Device2 * This,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateRootSignature )( 
+            ID3D12Device2 * This,
+            _In_  UINT nodeMask,
+            _In_reads_(blobLengthInBytes)  const void *pBlobWithRootSignature,
+            _In_  SIZE_T blobLengthInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppvRootSignature);
+        
+        void ( STDMETHODCALLTYPE *CreateConstantBufferView )( 
+            ID3D12Device2 * This,
+            _In_opt_  const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateShaderResourceView )( 
+            ID3D12Device2 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateUnorderedAccessView )( 
+            ID3D12Device2 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  ID3D12Resource *pCounterResource,
+            _In_opt_  const D3D12_UNORDERED_ACCESS_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateRenderTargetView )( 
+            ID3D12Device2 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_RENDER_TARGET_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateDepthStencilView )( 
+            ID3D12Device2 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateSampler )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_SAMPLER_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptors )( 
+            ID3D12Device2 * This,
+            _In_  UINT NumDestDescriptorRanges,
+            _In_reads_(NumDestDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts,
+            _In_reads_opt_(NumDestDescriptorRanges)  const UINT *pDestDescriptorRangeSizes,
+            _In_  UINT NumSrcDescriptorRanges,
+            _In_reads_(NumSrcDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
+            _In_reads_opt_(NumSrcDescriptorRanges)  const UINT *pSrcDescriptorRangeSizes,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptorsSimple )( 
+            ID3D12Device2 * This,
+            _In_  UINT NumDescriptors,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo )( 
+            ID3D12Device2 * This,
+            _In_  UINT visibleMask,
+            _In_  UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs);
+        
+        D3D12_HEAP_PROPERTIES ( STDMETHODCALLTYPE *GetCustomHeapProperties )( 
+            ID3D12Device2 * This,
+            _In_  UINT nodeMask,
+            D3D12_HEAP_TYPE heapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePlacedResource )( 
+            ID3D12Device2 * This,
+            _In_  ID3D12Heap *pHeap,
+            UINT64 HeapOffset,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSharedHandle )( 
+            ID3D12Device2 * This,
+            _In_  ID3D12DeviceChild *pObject,
+            _In_opt_  const SECURITY_ATTRIBUTES *pAttributes,
+            DWORD Access,
+            _In_opt_  LPCWSTR Name,
+            _Out_  HANDLE *pHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandle )( 
+            ID3D12Device2 * This,
+            _In_  HANDLE NTHandle,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvObj);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandleByName )( 
+            ID3D12Device2 * This,
+            _In_  LPCWSTR Name,
+            DWORD Access,
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pNTHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeResident )( 
+            ID3D12Device2 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *Evict )( 
+            ID3D12Device2 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateFence )( 
+            ID3D12Device2 * This,
+            UINT64 InitialValue,
+            D3D12_FENCE_FLAGS Flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppFence);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDeviceRemovedReason )( 
+            ID3D12Device2 * This);
+        
+        void ( STDMETHODCALLTYPE *GetCopyableFootprints )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_RESOURCE_DESC *pResourceDesc,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES)  UINT FirstSubresource,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource)  UINT NumSubresources,
+            UINT64 BaseOffset,
+            _Out_writes_opt_(NumSubresources)  D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts,
+            _Out_writes_opt_(NumSubresources)  UINT *pNumRows,
+            _Out_writes_opt_(NumSubresources)  UINT64 *pRowSizeInBytes,
+            _Out_opt_  UINT64 *pTotalBytes);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateQueryHeap )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_QUERY_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetStablePowerState )( 
+            ID3D12Device2 * This,
+            BOOL Enable);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandSignature )( 
+            ID3D12Device2 * This,
+            _In_  const D3D12_COMMAND_SIGNATURE_DESC *pDesc,
+            _In_opt_  ID3D12RootSignature *pRootSignature,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvCommandSignature);
+        
+        void ( STDMETHODCALLTYPE *GetResourceTiling )( 
+            ID3D12Device2 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _Out_opt_  UINT *pNumTilesForEntireResource,
+            _Out_opt_  D3D12_PACKED_MIP_INFO *pPackedMipDesc,
+            _Out_opt_  D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips,
+            _Inout_opt_  UINT *pNumSubresourceTilings,
+            _In_  UINT FirstSubresourceTilingToGet,
+            _Out_writes_(*pNumSubresourceTilings)  D3D12_SUBRESOURCE_TILING *pSubresourceTilingsForNonPackedMips);
+        
+        LUID ( STDMETHODCALLTYPE *GetAdapterLuid )( 
+            ID3D12Device2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineLibrary )( 
+            ID3D12Device2 * This,
+            _In_reads_(BlobLength)  const void *pLibraryBlob,
+            SIZE_T BlobLength,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineLibrary);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEventOnMultipleFenceCompletion )( 
+            ID3D12Device2 * This,
+            _In_reads_(NumFences)  ID3D12Fence *const *ppFences,
+            _In_reads_(NumFences)  const UINT64 *pFenceValues,
+            UINT NumFences,
+            D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
+            HANDLE hEvent);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetResidencyPriority )( 
+            ID3D12Device2 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_reads_(NumObjects)  const D3D12_RESIDENCY_PRIORITY *pPriorities);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineState )( 
+            ID3D12Device2 * This,
+            const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        END_INTERFACE
+    } ID3D12Device2Vtbl;
+
+    interface ID3D12Device2
+    {
+        CONST_VTBL struct ID3D12Device2Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Device2_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Device2_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Device2_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Device2_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Device2_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Device2_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Device2_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Device2_GetNodeCount(This) \
+    ( (This)->lpVtbl -> GetNodeCount(This) ) 
+
+#define ID3D12Device2_CreateCommandQueue(This,pDesc,riid,ppCommandQueue) \
+    ( (This)->lpVtbl -> CreateCommandQueue(This,pDesc,riid,ppCommandQueue) ) 
+
+#define ID3D12Device2_CreateCommandAllocator(This,type,riid,ppCommandAllocator)  \
+    ( (This)->lpVtbl -> CreateCommandAllocator(This,type,riid,ppCommandAllocator) ) 
+
+#define ID3D12Device2_CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device2_CreateComputePipelineState(This,pDesc,riid,ppPipelineState)  \
+    ( (This)->lpVtbl -> CreateComputePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device2_CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) \
+    ( (This)->lpVtbl -> CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) ) 
+
+#define ID3D12Device2_CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) \
+    ( (This)->lpVtbl -> CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) ) 
+
+#define ID3D12Device2_CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device2_GetDescriptorHandleIncrementSize(This,DescriptorHeapType)  \
+    ( (This)->lpVtbl -> GetDescriptorHandleIncrementSize(This,DescriptorHeapType) ) 
+
+#define ID3D12Device2_CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature)  \
+    ( (This)->lpVtbl -> CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature) ) 
+
+#define ID3D12Device2_CreateConstantBufferView(This,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateConstantBufferView(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device2_CreateShaderResourceView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateShaderResourceView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device2_CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device2_CreateRenderTargetView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateRenderTargetView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device2_CreateDepthStencilView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateDepthStencilView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device2_CreateSampler(This,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateSampler(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device2_CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) \
+    ( (This)->lpVtbl -> CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) ) 
+
+#define ID3D12Device2_CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType)  \
+    ( (This)->lpVtbl -> CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType) ) 
+
+#define ID3D12Device2_GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs)  \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs) ) 
+
+#define ID3D12Device2_GetCustomHeapProperties(This,nodeMask,heapType)  \
+    ( (This)->lpVtbl -> GetCustomHeapProperties(This,nodeMask,heapType) ) 
+
+#define ID3D12Device2_CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) \
+    ( (This)->lpVtbl -> CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) ) 
+
+#define ID3D12Device2_CreateHeap(This,pDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device2_CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device2_CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource)  \
+    ( (This)->lpVtbl -> CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device2_CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) \
+    ( (This)->lpVtbl -> CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) ) 
+
+#define ID3D12Device2_OpenSharedHandle(This,NTHandle,riid,ppvObj)  \
+    ( (This)->lpVtbl -> OpenSharedHandle(This,NTHandle,riid,ppvObj) ) 
+
+#define ID3D12Device2_OpenSharedHandleByName(This,Name,Access,pNTHandle) \
+    ( (This)->lpVtbl -> OpenSharedHandleByName(This,Name,Access,pNTHandle) ) 
+
+#define ID3D12Device2_MakeResident(This,NumObjects,ppObjects)  \
+    ( (This)->lpVtbl -> MakeResident(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device2_Evict(This,NumObjects,ppObjects) \
+    ( (This)->lpVtbl -> Evict(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device2_CreateFence(This,InitialValue,Flags,riid,ppFence)  \
+    ( (This)->lpVtbl -> CreateFence(This,InitialValue,Flags,riid,ppFence) ) 
+
+#define ID3D12Device2_GetDeviceRemovedReason(This) \
+    ( (This)->lpVtbl -> GetDeviceRemovedReason(This) ) 
+
+#define ID3D12Device2_GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes)  \
+    ( (This)->lpVtbl -> GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes) ) 
+
+#define ID3D12Device2_CreateQueryHeap(This,pDesc,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateQueryHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device2_SetStablePowerState(This,Enable) \
+    ( (This)->lpVtbl -> SetStablePowerState(This,Enable) ) 
+
+#define ID3D12Device2_CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) \
+    ( (This)->lpVtbl -> CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) ) 
+
+#define ID3D12Device2_GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) \
+    ( (This)->lpVtbl -> GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) ) 
+
+#define ID3D12Device2_GetAdapterLuid(This) \
+    ( (This)->lpVtbl -> GetAdapterLuid(This) ) 
+
+
+#define ID3D12Device2_CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) \
+    ( (This)->lpVtbl -> CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) ) 
+
+#define ID3D12Device2_SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) \
+    ( (This)->lpVtbl -> SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) ) 
+
+#define ID3D12Device2_SetResidencyPriority(This,NumObjects,ppObjects,pPriorities)  \
+    ( (This)->lpVtbl -> SetResidencyPriority(This,NumObjects,ppObjects,pPriorities) ) 
+
+
+#define ID3D12Device2_CreatePipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreatePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Device2_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0025 */
+/* [local] */ 
+
+typedef 
+enum D3D12_RESIDENCY_FLAGS
+    {
+        D3D12_RESIDENCY_FLAG_NONE  = 0,
+        D3D12_RESIDENCY_FLAG_DENY_OVERBUDGET = 0x1
+    }  D3D12_RESIDENCY_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_RESIDENCY_FLAGS );
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0025_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0025_v0_0_s_ifspec;
+
+#ifndef __ID3D12Device3_INTERFACE_DEFINED__
+#define __ID3D12Device3_INTERFACE_DEFINED__
+
+/* interface ID3D12Device3 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Device3;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("81dadc15-2bad-4392-93c5-101345c4aa98")
+    ID3D12Device3 : public ID3D12Device2
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE OpenExistingHeapFromAddress( 
+            _In_  const void *pAddress,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE OpenExistingHeapFromFileMapping( 
+            _In_  HANDLE hFileMapping,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE EnqueueMakeResident( 
+            D3D12_RESIDENCY_FLAGS Flags,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_  ID3D12Fence *pFenceToSignal,
+            UINT64 FenceValueToSignal) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Device3Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Device3 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Device3 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Device3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Device3 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Device3 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Device3 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Device3 * This,
+            _In_z_  LPCWSTR Name);
+        
+        UINT ( STDMETHODCALLTYPE *GetNodeCount )( 
+            ID3D12Device3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandQueue )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_COMMAND_QUEUE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandQueue);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandAllocator )( 
+            ID3D12Device3 * This,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandAllocator);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateGraphicsPipelineState )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateComputePipelineState )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList )( 
+            ID3D12Device3 * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  ID3D12CommandAllocator *pCommandAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckFeatureSupport )( 
+            ID3D12Device3 * This,
+            D3D12_FEATURE Feature,
+            _Inout_updates_bytes_(FeatureSupportDataSize)  void *pFeatureSupportData,
+            UINT FeatureSupportDataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateDescriptorHeap )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        UINT ( STDMETHODCALLTYPE *GetDescriptorHandleIncrementSize )( 
+            ID3D12Device3 * This,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateRootSignature )( 
+            ID3D12Device3 * This,
+            _In_  UINT nodeMask,
+            _In_reads_(blobLengthInBytes)  const void *pBlobWithRootSignature,
+            _In_  SIZE_T blobLengthInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppvRootSignature);
+        
+        void ( STDMETHODCALLTYPE *CreateConstantBufferView )( 
+            ID3D12Device3 * This,
+            _In_opt_  const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateShaderResourceView )( 
+            ID3D12Device3 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateUnorderedAccessView )( 
+            ID3D12Device3 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  ID3D12Resource *pCounterResource,
+            _In_opt_  const D3D12_UNORDERED_ACCESS_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateRenderTargetView )( 
+            ID3D12Device3 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_RENDER_TARGET_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateDepthStencilView )( 
+            ID3D12Device3 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateSampler )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_SAMPLER_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptors )( 
+            ID3D12Device3 * This,
+            _In_  UINT NumDestDescriptorRanges,
+            _In_reads_(NumDestDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts,
+            _In_reads_opt_(NumDestDescriptorRanges)  const UINT *pDestDescriptorRangeSizes,
+            _In_  UINT NumSrcDescriptorRanges,
+            _In_reads_(NumSrcDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
+            _In_reads_opt_(NumSrcDescriptorRanges)  const UINT *pSrcDescriptorRangeSizes,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptorsSimple )( 
+            ID3D12Device3 * This,
+            _In_  UINT NumDescriptors,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo )( 
+            ID3D12Device3 * This,
+            _In_  UINT visibleMask,
+            _In_  UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs);
+        
+        D3D12_HEAP_PROPERTIES ( STDMETHODCALLTYPE *GetCustomHeapProperties )( 
+            ID3D12Device3 * This,
+            _In_  UINT nodeMask,
+            D3D12_HEAP_TYPE heapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePlacedResource )( 
+            ID3D12Device3 * This,
+            _In_  ID3D12Heap *pHeap,
+            UINT64 HeapOffset,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSharedHandle )( 
+            ID3D12Device3 * This,
+            _In_  ID3D12DeviceChild *pObject,
+            _In_opt_  const SECURITY_ATTRIBUTES *pAttributes,
+            DWORD Access,
+            _In_opt_  LPCWSTR Name,
+            _Out_  HANDLE *pHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandle )( 
+            ID3D12Device3 * This,
+            _In_  HANDLE NTHandle,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvObj);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandleByName )( 
+            ID3D12Device3 * This,
+            _In_  LPCWSTR Name,
+            DWORD Access,
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pNTHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeResident )( 
+            ID3D12Device3 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *Evict )( 
+            ID3D12Device3 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateFence )( 
+            ID3D12Device3 * This,
+            UINT64 InitialValue,
+            D3D12_FENCE_FLAGS Flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppFence);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDeviceRemovedReason )( 
+            ID3D12Device3 * This);
+        
+        void ( STDMETHODCALLTYPE *GetCopyableFootprints )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_RESOURCE_DESC *pResourceDesc,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES)  UINT FirstSubresource,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource)  UINT NumSubresources,
+            UINT64 BaseOffset,
+            _Out_writes_opt_(NumSubresources)  D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts,
+            _Out_writes_opt_(NumSubresources)  UINT *pNumRows,
+            _Out_writes_opt_(NumSubresources)  UINT64 *pRowSizeInBytes,
+            _Out_opt_  UINT64 *pTotalBytes);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateQueryHeap )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_QUERY_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetStablePowerState )( 
+            ID3D12Device3 * This,
+            BOOL Enable);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandSignature )( 
+            ID3D12Device3 * This,
+            _In_  const D3D12_COMMAND_SIGNATURE_DESC *pDesc,
+            _In_opt_  ID3D12RootSignature *pRootSignature,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvCommandSignature);
+        
+        void ( STDMETHODCALLTYPE *GetResourceTiling )( 
+            ID3D12Device3 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _Out_opt_  UINT *pNumTilesForEntireResource,
+            _Out_opt_  D3D12_PACKED_MIP_INFO *pPackedMipDesc,
+            _Out_opt_  D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips,
+            _Inout_opt_  UINT *pNumSubresourceTilings,
+            _In_  UINT FirstSubresourceTilingToGet,
+            _Out_writes_(*pNumSubresourceTilings)  D3D12_SUBRESOURCE_TILING *pSubresourceTilingsForNonPackedMips);
+        
+        LUID ( STDMETHODCALLTYPE *GetAdapterLuid )( 
+            ID3D12Device3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineLibrary )( 
+            ID3D12Device3 * This,
+            _In_reads_(BlobLength)  const void *pLibraryBlob,
+            SIZE_T BlobLength,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineLibrary);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEventOnMultipleFenceCompletion )( 
+            ID3D12Device3 * This,
+            _In_reads_(NumFences)  ID3D12Fence *const *ppFences,
+            _In_reads_(NumFences)  const UINT64 *pFenceValues,
+            UINT NumFences,
+            D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
+            HANDLE hEvent);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetResidencyPriority )( 
+            ID3D12Device3 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_reads_(NumObjects)  const D3D12_RESIDENCY_PRIORITY *pPriorities);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineState )( 
+            ID3D12Device3 * This,
+            const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenExistingHeapFromAddress )( 
+            ID3D12Device3 * This,
+            _In_  const void *pAddress,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenExistingHeapFromFileMapping )( 
+            ID3D12Device3 * This,
+            _In_  HANDLE hFileMapping,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnqueueMakeResident )( 
+            ID3D12Device3 * This,
+            D3D12_RESIDENCY_FLAGS Flags,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_  ID3D12Fence *pFenceToSignal,
+            UINT64 FenceValueToSignal);
+        
+        END_INTERFACE
+    } ID3D12Device3Vtbl;
+
+    interface ID3D12Device3
+    {
+        CONST_VTBL struct ID3D12Device3Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Device3_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Device3_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Device3_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Device3_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Device3_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Device3_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Device3_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Device3_GetNodeCount(This) \
+    ( (This)->lpVtbl -> GetNodeCount(This) ) 
+
+#define ID3D12Device3_CreateCommandQueue(This,pDesc,riid,ppCommandQueue) \
+    ( (This)->lpVtbl -> CreateCommandQueue(This,pDesc,riid,ppCommandQueue) ) 
+
+#define ID3D12Device3_CreateCommandAllocator(This,type,riid,ppCommandAllocator)  \
+    ( (This)->lpVtbl -> CreateCommandAllocator(This,type,riid,ppCommandAllocator) ) 
+
+#define ID3D12Device3_CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device3_CreateComputePipelineState(This,pDesc,riid,ppPipelineState)  \
+    ( (This)->lpVtbl -> CreateComputePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device3_CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) \
+    ( (This)->lpVtbl -> CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) ) 
+
+#define ID3D12Device3_CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) \
+    ( (This)->lpVtbl -> CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) ) 
+
+#define ID3D12Device3_CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device3_GetDescriptorHandleIncrementSize(This,DescriptorHeapType)  \
+    ( (This)->lpVtbl -> GetDescriptorHandleIncrementSize(This,DescriptorHeapType) ) 
+
+#define ID3D12Device3_CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature)  \
+    ( (This)->lpVtbl -> CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature) ) 
+
+#define ID3D12Device3_CreateConstantBufferView(This,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateConstantBufferView(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device3_CreateShaderResourceView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateShaderResourceView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device3_CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device3_CreateRenderTargetView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateRenderTargetView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device3_CreateDepthStencilView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateDepthStencilView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device3_CreateSampler(This,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateSampler(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device3_CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) \
+    ( (This)->lpVtbl -> CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) ) 
+
+#define ID3D12Device3_CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType)  \
+    ( (This)->lpVtbl -> CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType) ) 
+
+#define ID3D12Device3_GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs)  \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs) ) 
+
+#define ID3D12Device3_GetCustomHeapProperties(This,nodeMask,heapType)  \
+    ( (This)->lpVtbl -> GetCustomHeapProperties(This,nodeMask,heapType) ) 
+
+#define ID3D12Device3_CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) \
+    ( (This)->lpVtbl -> CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) ) 
+
+#define ID3D12Device3_CreateHeap(This,pDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device3_CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device3_CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource)  \
+    ( (This)->lpVtbl -> CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device3_CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) \
+    ( (This)->lpVtbl -> CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) ) 
+
+#define ID3D12Device3_OpenSharedHandle(This,NTHandle,riid,ppvObj)  \
+    ( (This)->lpVtbl -> OpenSharedHandle(This,NTHandle,riid,ppvObj) ) 
+
+#define ID3D12Device3_OpenSharedHandleByName(This,Name,Access,pNTHandle) \
+    ( (This)->lpVtbl -> OpenSharedHandleByName(This,Name,Access,pNTHandle) ) 
+
+#define ID3D12Device3_MakeResident(This,NumObjects,ppObjects)  \
+    ( (This)->lpVtbl -> MakeResident(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device3_Evict(This,NumObjects,ppObjects) \
+    ( (This)->lpVtbl -> Evict(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device3_CreateFence(This,InitialValue,Flags,riid,ppFence)  \
+    ( (This)->lpVtbl -> CreateFence(This,InitialValue,Flags,riid,ppFence) ) 
+
+#define ID3D12Device3_GetDeviceRemovedReason(This) \
+    ( (This)->lpVtbl -> GetDeviceRemovedReason(This) ) 
+
+#define ID3D12Device3_GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes)  \
+    ( (This)->lpVtbl -> GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes) ) 
+
+#define ID3D12Device3_CreateQueryHeap(This,pDesc,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateQueryHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device3_SetStablePowerState(This,Enable) \
+    ( (This)->lpVtbl -> SetStablePowerState(This,Enable) ) 
+
+#define ID3D12Device3_CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) \
+    ( (This)->lpVtbl -> CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) ) 
+
+#define ID3D12Device3_GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) \
+    ( (This)->lpVtbl -> GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) ) 
+
+#define ID3D12Device3_GetAdapterLuid(This) \
+    ( (This)->lpVtbl -> GetAdapterLuid(This) ) 
+
+
+#define ID3D12Device3_CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) \
+    ( (This)->lpVtbl -> CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) ) 
+
+#define ID3D12Device3_SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) \
+    ( (This)->lpVtbl -> SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) ) 
+
+#define ID3D12Device3_SetResidencyPriority(This,NumObjects,ppObjects,pPriorities)  \
+    ( (This)->lpVtbl -> SetResidencyPriority(This,NumObjects,ppObjects,pPriorities) ) 
+
+
+#define ID3D12Device3_CreatePipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreatePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+
+#define ID3D12Device3_OpenExistingHeapFromAddress(This,pAddress,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> OpenExistingHeapFromAddress(This,pAddress,riid,ppvHeap) ) 
+
+#define ID3D12Device3_OpenExistingHeapFromFileMapping(This,hFileMapping,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> OpenExistingHeapFromFileMapping(This,hFileMapping,riid,ppvHeap) ) 
+
+#define ID3D12Device3_EnqueueMakeResident(This,Flags,NumObjects,ppObjects,pFenceToSignal,FenceValueToSignal) \
+    ( (This)->lpVtbl -> EnqueueMakeResident(This,Flags,NumObjects,ppObjects,pFenceToSignal,FenceValueToSignal) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Device3_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0026 */
+/* [local] */ 
+
+typedef 
+enum D3D12_COMMAND_LIST_FLAGS
+    {
+        D3D12_COMMAND_LIST_FLAG_NONE = 0
+    }  D3D12_COMMAND_LIST_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_COMMAND_LIST_FLAGS );
+typedef 
+enum D3D12_COMMAND_POOL_FLAGS
+    {
+        D3D12_COMMAND_POOL_FLAG_NONE = 0
+    }  D3D12_COMMAND_POOL_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_COMMAND_POOL_FLAGS );
+typedef 
+enum D3D12_COMMAND_RECORDER_FLAGS
+    {
+        D3D12_COMMAND_RECORDER_FLAG_NONE = 0
+    }  D3D12_COMMAND_RECORDER_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_COMMAND_RECORDER_FLAGS );
+typedef 
+enum D3D12_PROTECTED_SESSION_STATUS
+    {
+        D3D12_PROTECTED_SESSION_STATUS_OK  = 0,
+        D3D12_PROTECTED_SESSION_STATUS_INVALID = 1
+    }  D3D12_PROTECTED_SESSION_STATUS;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0026_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0026_v0_0_s_ifspec;
+
+#ifndef __ID3D12ProtectedSession_INTERFACE_DEFINED__
+#define __ID3D12ProtectedSession_INTERFACE_DEFINED__
+
+/* interface ID3D12ProtectedSession */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12ProtectedSession;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("A1533D18-0AC1-4084-85B9-89A96116806B")
+    ID3D12ProtectedSession : public ID3D12DeviceChild
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetStatusFence( 
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppFence) = 0;
+        
+        virtual D3D12_PROTECTED_SESSION_STATUS STDMETHODCALLTYPE GetSessionStatus( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12ProtectedSessionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12ProtectedSession * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12ProtectedSession * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12ProtectedSession * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12ProtectedSession * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12ProtectedSession * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12ProtectedSession * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12ProtectedSession * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12ProtectedSession * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetStatusFence )( 
+            ID3D12ProtectedSession * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppFence);
+        
+        D3D12_PROTECTED_SESSION_STATUS ( STDMETHODCALLTYPE *GetSessionStatus )( 
+            ID3D12ProtectedSession * This);
+        
+        END_INTERFACE
+    } ID3D12ProtectedSessionVtbl;
+
+    interface ID3D12ProtectedSession
+    {
+        CONST_VTBL struct ID3D12ProtectedSessionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12ProtectedSession_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12ProtectedSession_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12ProtectedSession_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12ProtectedSession_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12ProtectedSession_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12ProtectedSession_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12ProtectedSession_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12ProtectedSession_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12ProtectedSession_GetStatusFence(This,riid,ppFence) \
+    ( (This)->lpVtbl -> GetStatusFence(This,riid,ppFence) ) 
+
+#define ID3D12ProtectedSession_GetSessionStatus(This)  \
+    ( (This)->lpVtbl -> GetSessionStatus(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12ProtectedSession_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0027 */
+/* [local] */ 
+
+typedef 
+enum D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS
+    {
+        D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAG_NONE = 0,
+        D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAG_SUPPORTED  = 0x1
+    }  D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS );
+typedef struct D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT
+    {
+    UINT NodeIndex;
+    D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS Support;
+    }  D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT;
+
+typedef 
+enum D3D12_PROTECTED_RESOURCE_SESSION_FLAGS
+    {
+        D3D12_PROTECTED_RESOURCE_SESSION_FLAG_NONE = 0
+    }  D3D12_PROTECTED_RESOURCE_SESSION_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_PROTECTED_RESOURCE_SESSION_FLAGS );
+typedef struct D3D12_PROTECTED_RESOURCE_SESSION_DESC
+    {
+    UINT NodeMask;
+    D3D12_PROTECTED_RESOURCE_SESSION_FLAGS Flags;
+    }  D3D12_PROTECTED_RESOURCE_SESSION_DESC;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0027_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0027_v0_0_s_ifspec;
+
+#ifndef __ID3D12ProtectedResourceSession_INTERFACE_DEFINED__
+#define __ID3D12ProtectedResourceSession_INTERFACE_DEFINED__
+
+/* interface ID3D12ProtectedResourceSession */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12ProtectedResourceSession;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6CD696F4-F289-40CC-8091-5A6C0A099C3D")
+    ID3D12ProtectedResourceSession : public ID3D12ProtectedSession
+    {
+    public:
+        virtual D3D12_PROTECTED_RESOURCE_SESSION_DESC STDMETHODCALLTYPE GetDesc( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12ProtectedResourceSessionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12ProtectedResourceSession * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12ProtectedResourceSession * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12ProtectedResourceSession * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12ProtectedResourceSession * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12ProtectedResourceSession * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12ProtectedResourceSession * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12ProtectedResourceSession * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12ProtectedResourceSession * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetStatusFence )( 
+            ID3D12ProtectedResourceSession * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppFence);
+        
+        D3D12_PROTECTED_SESSION_STATUS ( STDMETHODCALLTYPE *GetSessionStatus )( 
+            ID3D12ProtectedResourceSession * This);
+        
+        D3D12_PROTECTED_RESOURCE_SESSION_DESC ( STDMETHODCALLTYPE *GetDesc )( 
+            ID3D12ProtectedResourceSession * This);
+        
+        END_INTERFACE
+    } ID3D12ProtectedResourceSessionVtbl;
+
+    interface ID3D12ProtectedResourceSession
+    {
+        CONST_VTBL struct ID3D12ProtectedResourceSessionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12ProtectedResourceSession_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12ProtectedResourceSession_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12ProtectedResourceSession_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12ProtectedResourceSession_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12ProtectedResourceSession_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12ProtectedResourceSession_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12ProtectedResourceSession_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12ProtectedResourceSession_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12ProtectedResourceSession_GetStatusFence(This,riid,ppFence) \
+    ( (This)->lpVtbl -> GetStatusFence(This,riid,ppFence) ) 
+
+#define ID3D12ProtectedResourceSession_GetSessionStatus(This)  \
+    ( (This)->lpVtbl -> GetSessionStatus(This) ) 
+
+
+#define ID3D12ProtectedResourceSession_GetDesc(This) \
+    ( (This)->lpVtbl -> GetDesc(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+
+
+
+
+#endif   /* __ID3D12ProtectedResourceSession_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Device4_INTERFACE_DEFINED__
+#define __ID3D12Device4_INTERFACE_DEFINED__
+
+/* interface ID3D12Device4 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Device4;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("e865df17-a9ee-46f9-a463-3098315aa2e5")
+    ID3D12Device4 : public ID3D12Device3
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE CreateCommandList1( 
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  D3D12_COMMAND_LIST_FLAGS flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateProtectedResourceSession( 
+            _In_  const D3D12_PROTECTED_RESOURCE_SESSION_DESC *pDesc,
+            _In_  REFIID riid,
+            _COM_Outptr_  void **ppSession) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateCommittedResource1( 
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateHeap1( 
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateReservedResource1( 
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource) = 0;
+        
+        virtual D3D12_RESOURCE_ALLOCATION_INFO STDMETHODCALLTYPE GetResourceAllocationInfo1( 
+            UINT visibleMask,
+            UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs,
+            _Out_writes_opt_(numResourceDescs)  D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Device4Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Device4 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Device4 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Device4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Device4 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Device4 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Device4 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Device4 * This,
+            _In_z_  LPCWSTR Name);
+        
+        UINT ( STDMETHODCALLTYPE *GetNodeCount )( 
+            ID3D12Device4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandQueue )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_COMMAND_QUEUE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandQueue);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandAllocator )( 
+            ID3D12Device4 * This,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandAllocator);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateGraphicsPipelineState )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateComputePipelineState )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList )( 
+            ID3D12Device4 * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  ID3D12CommandAllocator *pCommandAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckFeatureSupport )( 
+            ID3D12Device4 * This,
+            D3D12_FEATURE Feature,
+            _Inout_updates_bytes_(FeatureSupportDataSize)  void *pFeatureSupportData,
+            UINT FeatureSupportDataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateDescriptorHeap )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        UINT ( STDMETHODCALLTYPE *GetDescriptorHandleIncrementSize )( 
+            ID3D12Device4 * This,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateRootSignature )( 
+            ID3D12Device4 * This,
+            _In_  UINT nodeMask,
+            _In_reads_(blobLengthInBytes)  const void *pBlobWithRootSignature,
+            _In_  SIZE_T blobLengthInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppvRootSignature);
+        
+        void ( STDMETHODCALLTYPE *CreateConstantBufferView )( 
+            ID3D12Device4 * This,
+            _In_opt_  const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateShaderResourceView )( 
+            ID3D12Device4 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateUnorderedAccessView )( 
+            ID3D12Device4 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  ID3D12Resource *pCounterResource,
+            _In_opt_  const D3D12_UNORDERED_ACCESS_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateRenderTargetView )( 
+            ID3D12Device4 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_RENDER_TARGET_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateDepthStencilView )( 
+            ID3D12Device4 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateSampler )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_SAMPLER_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptors )( 
+            ID3D12Device4 * This,
+            _In_  UINT NumDestDescriptorRanges,
+            _In_reads_(NumDestDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts,
+            _In_reads_opt_(NumDestDescriptorRanges)  const UINT *pDestDescriptorRangeSizes,
+            _In_  UINT NumSrcDescriptorRanges,
+            _In_reads_(NumSrcDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
+            _In_reads_opt_(NumSrcDescriptorRanges)  const UINT *pSrcDescriptorRangeSizes,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptorsSimple )( 
+            ID3D12Device4 * This,
+            _In_  UINT NumDescriptors,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo )( 
+            ID3D12Device4 * This,
+            _In_  UINT visibleMask,
+            _In_  UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs);
+        
+        D3D12_HEAP_PROPERTIES ( STDMETHODCALLTYPE *GetCustomHeapProperties )( 
+            ID3D12Device4 * This,
+            _In_  UINT nodeMask,
+            D3D12_HEAP_TYPE heapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePlacedResource )( 
+            ID3D12Device4 * This,
+            _In_  ID3D12Heap *pHeap,
+            UINT64 HeapOffset,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSharedHandle )( 
+            ID3D12Device4 * This,
+            _In_  ID3D12DeviceChild *pObject,
+            _In_opt_  const SECURITY_ATTRIBUTES *pAttributes,
+            DWORD Access,
+            _In_opt_  LPCWSTR Name,
+            _Out_  HANDLE *pHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandle )( 
+            ID3D12Device4 * This,
+            _In_  HANDLE NTHandle,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvObj);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandleByName )( 
+            ID3D12Device4 * This,
+            _In_  LPCWSTR Name,
+            DWORD Access,
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pNTHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeResident )( 
+            ID3D12Device4 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *Evict )( 
+            ID3D12Device4 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateFence )( 
+            ID3D12Device4 * This,
+            UINT64 InitialValue,
+            D3D12_FENCE_FLAGS Flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppFence);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDeviceRemovedReason )( 
+            ID3D12Device4 * This);
+        
+        void ( STDMETHODCALLTYPE *GetCopyableFootprints )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_RESOURCE_DESC *pResourceDesc,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES)  UINT FirstSubresource,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource)  UINT NumSubresources,
+            UINT64 BaseOffset,
+            _Out_writes_opt_(NumSubresources)  D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts,
+            _Out_writes_opt_(NumSubresources)  UINT *pNumRows,
+            _Out_writes_opt_(NumSubresources)  UINT64 *pRowSizeInBytes,
+            _Out_opt_  UINT64 *pTotalBytes);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateQueryHeap )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_QUERY_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetStablePowerState )( 
+            ID3D12Device4 * This,
+            BOOL Enable);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandSignature )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_COMMAND_SIGNATURE_DESC *pDesc,
+            _In_opt_  ID3D12RootSignature *pRootSignature,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvCommandSignature);
+        
+        void ( STDMETHODCALLTYPE *GetResourceTiling )( 
+            ID3D12Device4 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _Out_opt_  UINT *pNumTilesForEntireResource,
+            _Out_opt_  D3D12_PACKED_MIP_INFO *pPackedMipDesc,
+            _Out_opt_  D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips,
+            _Inout_opt_  UINT *pNumSubresourceTilings,
+            _In_  UINT FirstSubresourceTilingToGet,
+            _Out_writes_(*pNumSubresourceTilings)  D3D12_SUBRESOURCE_TILING *pSubresourceTilingsForNonPackedMips);
+        
+        LUID ( STDMETHODCALLTYPE *GetAdapterLuid )( 
+            ID3D12Device4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineLibrary )( 
+            ID3D12Device4 * This,
+            _In_reads_(BlobLength)  const void *pLibraryBlob,
+            SIZE_T BlobLength,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineLibrary);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEventOnMultipleFenceCompletion )( 
+            ID3D12Device4 * This,
+            _In_reads_(NumFences)  ID3D12Fence *const *ppFences,
+            _In_reads_(NumFences)  const UINT64 *pFenceValues,
+            UINT NumFences,
+            D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
+            HANDLE hEvent);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetResidencyPriority )( 
+            ID3D12Device4 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_reads_(NumObjects)  const D3D12_RESIDENCY_PRIORITY *pPriorities);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineState )( 
+            ID3D12Device4 * This,
+            const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenExistingHeapFromAddress )( 
+            ID3D12Device4 * This,
+            _In_  const void *pAddress,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenExistingHeapFromFileMapping )( 
+            ID3D12Device4 * This,
+            _In_  HANDLE hFileMapping,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnqueueMakeResident )( 
+            ID3D12Device4 * This,
+            D3D12_RESIDENCY_FLAGS Flags,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_  ID3D12Fence *pFenceToSignal,
+            UINT64 FenceValueToSignal);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList1 )( 
+            ID3D12Device4 * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  D3D12_COMMAND_LIST_FLAGS flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateProtectedResourceSession )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_PROTECTED_RESOURCE_SESSION_DESC *pDesc,
+            _In_  REFIID riid,
+            _COM_Outptr_  void **ppSession);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource1 )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap1 )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource1 )( 
+            ID3D12Device4 * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo1 )( 
+            ID3D12Device4 * This,
+            UINT visibleMask,
+            UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs,
+            _Out_writes_opt_(numResourceDescs)  D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1);
+        
+        END_INTERFACE
+    } ID3D12Device4Vtbl;
+
+    interface ID3D12Device4
+    {
+        CONST_VTBL struct ID3D12Device4Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Device4_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Device4_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Device4_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Device4_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Device4_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Device4_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Device4_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Device4_GetNodeCount(This) \
+    ( (This)->lpVtbl -> GetNodeCount(This) ) 
+
+#define ID3D12Device4_CreateCommandQueue(This,pDesc,riid,ppCommandQueue) \
+    ( (This)->lpVtbl -> CreateCommandQueue(This,pDesc,riid,ppCommandQueue) ) 
+
+#define ID3D12Device4_CreateCommandAllocator(This,type,riid,ppCommandAllocator)  \
+    ( (This)->lpVtbl -> CreateCommandAllocator(This,type,riid,ppCommandAllocator) ) 
+
+#define ID3D12Device4_CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device4_CreateComputePipelineState(This,pDesc,riid,ppPipelineState)  \
+    ( (This)->lpVtbl -> CreateComputePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device4_CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) \
+    ( (This)->lpVtbl -> CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) ) 
+
+#define ID3D12Device4_CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) \
+    ( (This)->lpVtbl -> CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) ) 
+
+#define ID3D12Device4_CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device4_GetDescriptorHandleIncrementSize(This,DescriptorHeapType)  \
+    ( (This)->lpVtbl -> GetDescriptorHandleIncrementSize(This,DescriptorHeapType) ) 
+
+#define ID3D12Device4_CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature)  \
+    ( (This)->lpVtbl -> CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature) ) 
+
+#define ID3D12Device4_CreateConstantBufferView(This,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateConstantBufferView(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device4_CreateShaderResourceView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateShaderResourceView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device4_CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device4_CreateRenderTargetView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateRenderTargetView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device4_CreateDepthStencilView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateDepthStencilView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device4_CreateSampler(This,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateSampler(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device4_CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) \
+    ( (This)->lpVtbl -> CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) ) 
+
+#define ID3D12Device4_CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType)  \
+    ( (This)->lpVtbl -> CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType) ) 
+
+#define ID3D12Device4_GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs)  \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs) ) 
+
+#define ID3D12Device4_GetCustomHeapProperties(This,nodeMask,heapType)  \
+    ( (This)->lpVtbl -> GetCustomHeapProperties(This,nodeMask,heapType) ) 
+
+#define ID3D12Device4_CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) \
+    ( (This)->lpVtbl -> CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) ) 
+
+#define ID3D12Device4_CreateHeap(This,pDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device4_CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device4_CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource)  \
+    ( (This)->lpVtbl -> CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device4_CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) \
+    ( (This)->lpVtbl -> CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) ) 
+
+#define ID3D12Device4_OpenSharedHandle(This,NTHandle,riid,ppvObj)  \
+    ( (This)->lpVtbl -> OpenSharedHandle(This,NTHandle,riid,ppvObj) ) 
+
+#define ID3D12Device4_OpenSharedHandleByName(This,Name,Access,pNTHandle) \
+    ( (This)->lpVtbl -> OpenSharedHandleByName(This,Name,Access,pNTHandle) ) 
+
+#define ID3D12Device4_MakeResident(This,NumObjects,ppObjects)  \
+    ( (This)->lpVtbl -> MakeResident(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device4_Evict(This,NumObjects,ppObjects) \
+    ( (This)->lpVtbl -> Evict(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device4_CreateFence(This,InitialValue,Flags,riid,ppFence)  \
+    ( (This)->lpVtbl -> CreateFence(This,InitialValue,Flags,riid,ppFence) ) 
+
+#define ID3D12Device4_GetDeviceRemovedReason(This) \
+    ( (This)->lpVtbl -> GetDeviceRemovedReason(This) ) 
+
+#define ID3D12Device4_GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes)  \
+    ( (This)->lpVtbl -> GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes) ) 
+
+#define ID3D12Device4_CreateQueryHeap(This,pDesc,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateQueryHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device4_SetStablePowerState(This,Enable) \
+    ( (This)->lpVtbl -> SetStablePowerState(This,Enable) ) 
+
+#define ID3D12Device4_CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) \
+    ( (This)->lpVtbl -> CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) ) 
+
+#define ID3D12Device4_GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) \
+    ( (This)->lpVtbl -> GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) ) 
+
+#define ID3D12Device4_GetAdapterLuid(This) \
+    ( (This)->lpVtbl -> GetAdapterLuid(This) ) 
+
+
+#define ID3D12Device4_CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) \
+    ( (This)->lpVtbl -> CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) ) 
+
+#define ID3D12Device4_SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) \
+    ( (This)->lpVtbl -> SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) ) 
+
+#define ID3D12Device4_SetResidencyPriority(This,NumObjects,ppObjects,pPriorities)  \
+    ( (This)->lpVtbl -> SetResidencyPriority(This,NumObjects,ppObjects,pPriorities) ) 
+
+
+#define ID3D12Device4_CreatePipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreatePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+
+#define ID3D12Device4_OpenExistingHeapFromAddress(This,pAddress,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> OpenExistingHeapFromAddress(This,pAddress,riid,ppvHeap) ) 
+
+#define ID3D12Device4_OpenExistingHeapFromFileMapping(This,hFileMapping,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> OpenExistingHeapFromFileMapping(This,hFileMapping,riid,ppvHeap) ) 
+
+#define ID3D12Device4_EnqueueMakeResident(This,Flags,NumObjects,ppObjects,pFenceToSignal,FenceValueToSignal) \
+    ( (This)->lpVtbl -> EnqueueMakeResident(This,Flags,NumObjects,ppObjects,pFenceToSignal,FenceValueToSignal) ) 
+
+
+#define ID3D12Device4_CreateCommandList1(This,nodeMask,type,flags,riid,ppCommandList)  \
+    ( (This)->lpVtbl -> CreateCommandList1(This,nodeMask,type,flags,riid,ppCommandList) ) 
+
+#define ID3D12Device4_CreateProtectedResourceSession(This,pDesc,riid,ppSession)  \
+    ( (This)->lpVtbl -> CreateProtectedResourceSession(This,pDesc,riid,ppSession) ) 
+
+#define ID3D12Device4_CreateCommittedResource1(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,pProtectedSession,riidResource,ppvResource)  \
+    ( (This)->lpVtbl -> CreateCommittedResource1(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,pProtectedSession,riidResource,ppvResource) ) 
+
+#define ID3D12Device4_CreateHeap1(This,pDesc,pProtectedSession,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateHeap1(This,pDesc,pProtectedSession,riid,ppvHeap) ) 
+
+#define ID3D12Device4_CreateReservedResource1(This,pDesc,InitialState,pOptimizedClearValue,pProtectedSession,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreateReservedResource1(This,pDesc,InitialState,pOptimizedClearValue,pProtectedSession,riid,ppvResource) ) 
+
+#define ID3D12Device4_GetResourceAllocationInfo1(This,visibleMask,numResourceDescs,pResourceDescs,pResourceAllocationInfo1)  \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo1(This,visibleMask,numResourceDescs,pResourceDescs,pResourceAllocationInfo1) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+
+
+
+
+#endif   /* __ID3D12Device4_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0029 */
+/* [local] */ 
+
+typedef 
+enum D3D12_LIFETIME_STATE
+    {
+        D3D12_LIFETIME_STATE_IN_USE  = 0,
+        D3D12_LIFETIME_STATE_NOT_IN_USE  = ( D3D12_LIFETIME_STATE_IN_USE + 1 ) 
+    }  D3D12_LIFETIME_STATE;
+
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0029_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0029_v0_0_s_ifspec;
+
+#ifndef __ID3D12LifetimeOwner_INTERFACE_DEFINED__
+#define __ID3D12LifetimeOwner_INTERFACE_DEFINED__
+
+/* interface ID3D12LifetimeOwner */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12LifetimeOwner;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("e667af9f-cd56-4f46-83ce-032e595d70a8")
+    ID3D12LifetimeOwner : public IUnknown
+    {
+    public:
+        virtual void STDMETHODCALLTYPE LifetimeStateUpdated( 
+            D3D12_LIFETIME_STATE NewState) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12LifetimeOwnerVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12LifetimeOwner * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12LifetimeOwner * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12LifetimeOwner * This);
+        
+        void ( STDMETHODCALLTYPE *LifetimeStateUpdated )( 
+            ID3D12LifetimeOwner * This,
+            D3D12_LIFETIME_STATE NewState);
+        
+        END_INTERFACE
+    } ID3D12LifetimeOwnerVtbl;
+
+    interface ID3D12LifetimeOwner
+    {
+        CONST_VTBL struct ID3D12LifetimeOwnerVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12LifetimeOwner_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12LifetimeOwner_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12LifetimeOwner_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12LifetimeOwner_LifetimeStateUpdated(This,NewState)  \
+    ( (This)->lpVtbl -> LifetimeStateUpdated(This,NewState) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12LifetimeOwner_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12SwapChainAssistant_INTERFACE_DEFINED__
+#define __ID3D12SwapChainAssistant_INTERFACE_DEFINED__
+
+/* interface ID3D12SwapChainAssistant */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12SwapChainAssistant;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("f1df64b6-57fd-49cd-8807-c0eb88b45c8f")
+    ID3D12SwapChainAssistant : public IUnknown
+    {
+    public:
+        virtual LUID STDMETHODCALLTYPE GetLUID( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetSwapChainObject( 
+            REFIID riid,
+            _COM_Outptr_  void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetCurrentResourceAndCommandQueue( 
+            REFIID riidResource,
+            _COM_Outptr_  void **ppvResource,
+            REFIID riidQueue,
+            _COM_Outptr_  void **ppvQueue) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE InsertImplicitSync( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12SwapChainAssistantVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12SwapChainAssistant * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12SwapChainAssistant * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12SwapChainAssistant * This);
+        
+        LUID ( STDMETHODCALLTYPE *GetLUID )( 
+            ID3D12SwapChainAssistant * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSwapChainObject )( 
+            ID3D12SwapChainAssistant * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCurrentResourceAndCommandQueue )( 
+            ID3D12SwapChainAssistant * This,
+            REFIID riidResource,
+            _COM_Outptr_  void **ppvResource,
+            REFIID riidQueue,
+            _COM_Outptr_  void **ppvQueue);
+        
+        HRESULT ( STDMETHODCALLTYPE *InsertImplicitSync )( 
+            ID3D12SwapChainAssistant * This);
+        
+        END_INTERFACE
+    } ID3D12SwapChainAssistantVtbl;
+
+    interface ID3D12SwapChainAssistant
+    {
+        CONST_VTBL struct ID3D12SwapChainAssistantVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12SwapChainAssistant_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12SwapChainAssistant_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12SwapChainAssistant_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12SwapChainAssistant_GetLUID(This) \
+    ( (This)->lpVtbl -> GetLUID(This) ) 
+
+#define ID3D12SwapChainAssistant_GetSwapChainObject(This,riid,ppv) \
+    ( (This)->lpVtbl -> GetSwapChainObject(This,riid,ppv) ) 
+
+#define ID3D12SwapChainAssistant_GetCurrentResourceAndCommandQueue(This,riidResource,ppvResource,riidQueue,ppvQueue) \
+    ( (This)->lpVtbl -> GetCurrentResourceAndCommandQueue(This,riidResource,ppvResource,riidQueue,ppvQueue) ) 
+
+#define ID3D12SwapChainAssistant_InsertImplicitSync(This)  \
+    ( (This)->lpVtbl -> InsertImplicitSync(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+
+
+
+
+#endif   /* __ID3D12SwapChainAssistant_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12LifetimeTracker_INTERFACE_DEFINED__
+#define __ID3D12LifetimeTracker_INTERFACE_DEFINED__
+
+/* interface ID3D12LifetimeTracker */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12LifetimeTracker;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("3fd03d36-4eb1-424a-a582-494ecb8ba813")
+    ID3D12LifetimeTracker : public ID3D12DeviceChild
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE DestroyOwnedObject( 
+            _In_  ID3D12DeviceChild *pObject) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12LifetimeTrackerVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12LifetimeTracker * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12LifetimeTracker * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12LifetimeTracker * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12LifetimeTracker * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12LifetimeTracker * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12LifetimeTracker * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12LifetimeTracker * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12LifetimeTracker * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *DestroyOwnedObject )( 
+            ID3D12LifetimeTracker * This,
+            _In_  ID3D12DeviceChild *pObject);
+        
+        END_INTERFACE
+    } ID3D12LifetimeTrackerVtbl;
+
+    interface ID3D12LifetimeTracker
+    {
+        CONST_VTBL struct ID3D12LifetimeTrackerVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12LifetimeTracker_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12LifetimeTracker_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12LifetimeTracker_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12LifetimeTracker_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12LifetimeTracker_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12LifetimeTracker_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12LifetimeTracker_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12LifetimeTracker_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12LifetimeTracker_DestroyOwnedObject(This,pObject) \
+    ( (This)->lpVtbl -> DestroyOwnedObject(This,pObject) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12LifetimeTracker_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0032 */
+/* [local] */ 
+
+typedef 
+enum D3D12_META_COMMAND_PARAMETER_TYPE
+    {
+        D3D12_META_COMMAND_PARAMETER_TYPE_FLOAT  = 0,
+        D3D12_META_COMMAND_PARAMETER_TYPE_UINT64 = 1,
+        D3D12_META_COMMAND_PARAMETER_TYPE_GPU_VIRTUAL_ADDRESS  = 2,
+        D3D12_META_COMMAND_PARAMETER_TYPE_CPU_DESCRIPTOR_HANDLE_HEAP_TYPE_CBV_SRV_UAV  = 3,
+        D3D12_META_COMMAND_PARAMETER_TYPE_GPU_DESCRIPTOR_HANDLE_HEAP_TYPE_CBV_SRV_UAV  = 4
+    }  D3D12_META_COMMAND_PARAMETER_TYPE;
+
+typedef 
+enum D3D12_META_COMMAND_PARAMETER_FLAGS
+    {
+        D3D12_META_COMMAND_PARAMETER_FLAG_INPUT  = 0x1,
+        D3D12_META_COMMAND_PARAMETER_FLAG_OUTPUT = 0x2
+    }  D3D12_META_COMMAND_PARAMETER_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_META_COMMAND_PARAMETER_FLAGS );
+typedef 
+enum D3D12_META_COMMAND_PARAMETER_STAGE
+    {
+        D3D12_META_COMMAND_PARAMETER_STAGE_CREATION  = 0,
+        D3D12_META_COMMAND_PARAMETER_STAGE_INITIALIZATION  = 1,
+        D3D12_META_COMMAND_PARAMETER_STAGE_EXECUTION = 2
+    }  D3D12_META_COMMAND_PARAMETER_STAGE;
+
+typedef struct D3D12_META_COMMAND_PARAMETER_DESC
+    {
+    LPCWSTR Name;
+    D3D12_META_COMMAND_PARAMETER_TYPE Type;
+    D3D12_META_COMMAND_PARAMETER_FLAGS Flags;
+    D3D12_RESOURCE_STATES RequiredResourceState;
+    UINT StructureOffset;
+    }  D3D12_META_COMMAND_PARAMETER_DESC;
+
+typedef 
+enum D3D12_GRAPHICS_STATES
+    {
+        D3D12_GRAPHICS_STATE_NONE  = 0,
+        D3D12_GRAPHICS_STATE_IA_VERTEX_BUFFERS = ( 1 << 0 ) ,
+        D3D12_GRAPHICS_STATE_IA_INDEX_BUFFER = ( 1 << 1 ) ,
+        D3D12_GRAPHICS_STATE_IA_PRIMITIVE_TOPOLOGY = ( 1 << 2 ) ,
+        D3D12_GRAPHICS_STATE_DESCRIPTOR_HEAP = ( 1 << 3 ) ,
+        D3D12_GRAPHICS_STATE_GRAPHICS_ROOT_SIGNATURE = ( 1 << 4 ) ,
+        D3D12_GRAPHICS_STATE_COMPUTE_ROOT_SIGNATURE  = ( 1 << 5 ) ,
+        D3D12_GRAPHICS_STATE_RS_VIEWPORTS  = ( 1 << 6 ) ,
+        D3D12_GRAPHICS_STATE_RS_SCISSOR_RECTS  = ( 1 << 7 ) ,
+        D3D12_GRAPHICS_STATE_PREDICATION = ( 1 << 8 ) ,
+        D3D12_GRAPHICS_STATE_OM_RENDER_TARGETS = ( 1 << 9 ) ,
+        D3D12_GRAPHICS_STATE_OM_STENCIL_REF  = ( 1 << 10 ) ,
+        D3D12_GRAPHICS_STATE_OM_BLEND_FACTOR = ( 1 << 11 ) ,
+        D3D12_GRAPHICS_STATE_PIPELINE_STATE  = ( 1 << 12 ) ,
+        D3D12_GRAPHICS_STATE_SO_TARGETS  = ( 1 << 13 ) ,
+        D3D12_GRAPHICS_STATE_OM_DEPTH_BOUNDS = ( 1 << 14 ) ,
+        D3D12_GRAPHICS_STATE_SAMPLE_POSITIONS  = ( 1 << 15 ) ,
+        D3D12_GRAPHICS_STATE_VIEW_INSTANCE_MASK  = ( 1 << 16 ) 
+    }  D3D12_GRAPHICS_STATES;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_GRAPHICS_STATES );
+typedef struct D3D12_META_COMMAND_DESC
+    {
+    GUID Id;
+    LPCWSTR Name;
+    D3D12_GRAPHICS_STATES InitializationDirtyState;
+    D3D12_GRAPHICS_STATES ExecutionDirtyState;
+    }  D3D12_META_COMMAND_DESC;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0032_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0032_v0_0_s_ifspec;
+
+#ifndef __ID3D12StateObject_INTERFACE_DEFINED__
+#define __ID3D12StateObject_INTERFACE_DEFINED__
+
+/* interface ID3D12StateObject */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12StateObject;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("47016943-fca8-4594-93ea-af258b55346d")
+    ID3D12StateObject : public ID3D12Pageable
+    {
+    public:
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12StateObjectVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12StateObject * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12StateObject * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12StateObject * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12StateObject * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12StateObject * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12StateObject * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12StateObject * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12StateObject * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        END_INTERFACE
+    } ID3D12StateObjectVtbl;
+
+    interface ID3D12StateObject
+    {
+        CONST_VTBL struct ID3D12StateObjectVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12StateObject_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12StateObject_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12StateObject_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12StateObject_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12StateObject_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12StateObject_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12StateObject_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12StateObject_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12StateObject_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12StateObjectProperties_INTERFACE_DEFINED__
+#define __ID3D12StateObjectProperties_INTERFACE_DEFINED__
+
+/* interface ID3D12StateObjectProperties */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12StateObjectProperties;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("de5fa827-9bf9-4f26-89ff-d7f56fde3860")
+    ID3D12StateObjectProperties : public IUnknown
+    {
+    public:
+        virtual void *STDMETHODCALLTYPE GetShaderIdentifier( 
+            _In_  LPCWSTR pExportName) = 0;
+        
+        virtual UINT64 STDMETHODCALLTYPE GetShaderStackSize( 
+            _In_  LPCWSTR pExportName) = 0;
+        
+        virtual UINT64 STDMETHODCALLTYPE GetPipelineStackSize( void) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetPipelineStackSize( 
+            UINT64 PipelineStackSizeInBytes) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12StateObjectPropertiesVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12StateObjectProperties * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12StateObjectProperties * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12StateObjectProperties * This);
+        
+        void *( STDMETHODCALLTYPE *GetShaderIdentifier )( 
+            ID3D12StateObjectProperties * This,
+            _In_  LPCWSTR pExportName);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetShaderStackSize )( 
+            ID3D12StateObjectProperties * This,
+            _In_  LPCWSTR pExportName);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetPipelineStackSize )( 
+            ID3D12StateObjectProperties * This);
+        
+        void ( STDMETHODCALLTYPE *SetPipelineStackSize )( 
+            ID3D12StateObjectProperties * This,
+            UINT64 PipelineStackSizeInBytes);
+        
+        END_INTERFACE
+    } ID3D12StateObjectPropertiesVtbl;
+
+    interface ID3D12StateObjectProperties
+    {
+        CONST_VTBL struct ID3D12StateObjectPropertiesVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12StateObjectProperties_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12StateObjectProperties_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12StateObjectProperties_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12StateObjectProperties_GetShaderIdentifier(This,pExportName)  \
+    ( (This)->lpVtbl -> GetShaderIdentifier(This,pExportName) ) 
+
+#define ID3D12StateObjectProperties_GetShaderStackSize(This,pExportName) \
+    ( (This)->lpVtbl -> GetShaderStackSize(This,pExportName) ) 
+
+#define ID3D12StateObjectProperties_GetPipelineStackSize(This) \
+    ( (This)->lpVtbl -> GetPipelineStackSize(This) ) 
+
+#define ID3D12StateObjectProperties_SetPipelineStackSize(This,PipelineStackSizeInBytes)  \
+    ( (This)->lpVtbl -> SetPipelineStackSize(This,PipelineStackSizeInBytes) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12StateObjectProperties_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0034 */
+/* [local] */ 
+
+typedef 
+enum D3D12_STATE_SUBOBJECT_TYPE
+    {
+        D3D12_STATE_SUBOBJECT_TYPE_STATE_OBJECT_CONFIG = 0,
+        D3D12_STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE = 1,
+        D3D12_STATE_SUBOBJECT_TYPE_LOCAL_ROOT_SIGNATURE  = 2,
+        D3D12_STATE_SUBOBJECT_TYPE_NODE_MASK = 3,
+        D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY  = 5,
+        D3D12_STATE_SUBOBJECT_TYPE_EXISTING_COLLECTION = 6,
+        D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION  = 7,
+        D3D12_STATE_SUBOBJECT_TYPE_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION = 8,
+        D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG  = 9,
+        D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG  = 10,
+        D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP = 11,
+        D3D12_STATE_SUBOBJECT_TYPE_MAX_VALID = ( D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP + 1 ) 
+    }  D3D12_STATE_SUBOBJECT_TYPE;
+
+typedef struct D3D12_STATE_SUBOBJECT
+    {
+    D3D12_STATE_SUBOBJECT_TYPE Type;
+    const void *pDesc;
+    }  D3D12_STATE_SUBOBJECT;
+
+typedef 
+enum D3D12_STATE_OBJECT_FLAGS
+    {
+        D3D12_STATE_OBJECT_FLAG_NONE = 0,
+        D3D12_STATE_OBJECT_FLAG_ALLOW_LOCAL_DEPENDENCIES_ON_EXTERNAL_DEFINITIONS = 0x1,
+        D3D12_STATE_OBJECT_FLAG_ALLOW_EXTERNAL_DEPENDENCIES_ON_LOCAL_DEFINITIONS = 0x2
+    }  D3D12_STATE_OBJECT_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_STATE_OBJECT_FLAGS );
+typedef struct D3D12_STATE_OBJECT_CONFIG
+    {
+    D3D12_STATE_OBJECT_FLAGS Flags;
+    }  D3D12_STATE_OBJECT_CONFIG;
+
+typedef struct D3D12_GLOBAL_ROOT_SIGNATURE
+    {
+    ID3D12RootSignature *pGlobalRootSignature;
+    }  D3D12_GLOBAL_ROOT_SIGNATURE;
+
+typedef struct D3D12_LOCAL_ROOT_SIGNATURE
+    {
+    ID3D12RootSignature *pLocalRootSignature;
+    }  D3D12_LOCAL_ROOT_SIGNATURE;
+
+typedef struct D3D12_NODE_MASK
+    {
+    UINT NodeMask;
+    }  D3D12_NODE_MASK;
+
+typedef 
+enum D3D12_EXPORT_FLAGS
+    {
+        D3D12_EXPORT_FLAG_NONE = 0
+    }  D3D12_EXPORT_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_EXPORT_FLAGS );
+typedef struct D3D12_EXPORT_DESC
+    {
+    LPCWSTR Name;
+    _In_opt_  LPCWSTR ExportToRename;
+    D3D12_EXPORT_FLAGS Flags;
+    }  D3D12_EXPORT_DESC;
+
+typedef struct D3D12_DXIL_LIBRARY_DESC
+    {
+    D3D12_SHADER_BYTECODE DXILLibrary;
+    UINT NumExports;
+    _In_reads_(NumExports)  D3D12_EXPORT_DESC *pExports;
+    }  D3D12_DXIL_LIBRARY_DESC;
+
+typedef struct D3D12_EXISTING_COLLECTION_DESC
+    {
+    ID3D12StateObject *pExistingCollection;
+    UINT NumExports;
+    _In_reads_(NumExports)  D3D12_EXPORT_DESC *pExports;
+    }  D3D12_EXISTING_COLLECTION_DESC;
+
+typedef struct D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION
+    {
+    const D3D12_STATE_SUBOBJECT *pSubobjectToAssociate;
+    UINT NumExports;
+    _In_reads_(NumExports)  LPCWSTR *pExports;
+    }  D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
+
+typedef struct D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION
+    {
+    LPCWSTR SubobjectToAssociate;
+    UINT NumExports;
+    _In_reads_(NumExports)  LPCWSTR *pExports;
+    }  D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
+
+typedef 
+enum D3D12_HIT_GROUP_TYPE
+    {
+        D3D12_HIT_GROUP_TYPE_TRIANGLES = 0,
+        D3D12_HIT_GROUP_TYPE_PROCEDURAL_PRIMITIVE  = 0x1
+    }  D3D12_HIT_GROUP_TYPE;
+
+typedef struct D3D12_HIT_GROUP_DESC
+    {
+    LPCWSTR HitGroupExport;
+    D3D12_HIT_GROUP_TYPE Type;
+    _In_opt_  LPCWSTR AnyHitShaderImport;
+    _In_opt_  LPCWSTR ClosestHitShaderImport;
+    _In_opt_  LPCWSTR IntersectionShaderImport;
+    }  D3D12_HIT_GROUP_DESC;
+
+typedef struct D3D12_RAYTRACING_SHADER_CONFIG
+    {
+    UINT MaxPayloadSizeInBytes;
+    UINT MaxAttributeSizeInBytes;
+    }  D3D12_RAYTRACING_SHADER_CONFIG;
+
+typedef struct D3D12_RAYTRACING_PIPELINE_CONFIG
+    {
+    UINT MaxTraceRecursionDepth;
+    }  D3D12_RAYTRACING_PIPELINE_CONFIG;
+
+typedef 
+enum D3D12_STATE_OBJECT_TYPE
+    {
+        D3D12_STATE_OBJECT_TYPE_COLLECTION = 0,
+        D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE  = 3
+    }  D3D12_STATE_OBJECT_TYPE;
+
+typedef struct D3D12_STATE_OBJECT_DESC
+    {
+    D3D12_STATE_OBJECT_TYPE Type;
+    UINT NumSubobjects;
+    _In_reads_(NumSubobjects)  const D3D12_STATE_SUBOBJECT *pSubobjects;
+    }  D3D12_STATE_OBJECT_DESC;
+
+typedef 
+enum D3D12_RAYTRACING_GEOMETRY_FLAGS
+    {
+        D3D12_RAYTRACING_GEOMETRY_FLAG_NONE  = 0,
+        D3D12_RAYTRACING_GEOMETRY_FLAG_OPAQUE  = 0x1,
+        D3D12_RAYTRACING_GEOMETRY_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION  = 0x2
+    }  D3D12_RAYTRACING_GEOMETRY_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_RAYTRACING_GEOMETRY_FLAGS );
+typedef 
+enum D3D12_RAYTRACING_GEOMETRY_TYPE
+    {
+        D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES = 0,
+        D3D12_RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS  = ( D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES + 1 ) 
+    }  D3D12_RAYTRACING_GEOMETRY_TYPE;
+
+typedef 
+enum D3D12_RAYTRACING_INSTANCE_FLAGS
+    {
+        D3D12_RAYTRACING_INSTANCE_FLAG_NONE  = 0,
+        D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_CULL_DISABLE = 0x1,
+        D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_FRONT_COUNTERCLOCKWISE = 0x2,
+        D3D12_RAYTRACING_INSTANCE_FLAG_FORCE_OPAQUE  = 0x4,
+        D3D12_RAYTRACING_INSTANCE_FLAG_FORCE_NON_OPAQUE  = 0x8
+    }  D3D12_RAYTRACING_INSTANCE_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_RAYTRACING_INSTANCE_FLAGS );
+typedef struct D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS StartAddress;
+    UINT64 StrideInBytes;
+    }  D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE;
+
+typedef struct D3D12_GPU_VIRTUAL_ADDRESS_RANGE
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS StartAddress;
+    UINT64 SizeInBytes;
+    }  D3D12_GPU_VIRTUAL_ADDRESS_RANGE;
+
+typedef struct D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS StartAddress;
+    UINT64 SizeInBytes;
+    UINT64 StrideInBytes;
+    }  D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE;
+
+typedef struct D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS Transform3x4;
+    DXGI_FORMAT IndexFormat;
+    DXGI_FORMAT VertexFormat;
+    UINT IndexCount;
+    UINT VertexCount;
+    D3D12_GPU_VIRTUAL_ADDRESS IndexBuffer;
+    D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE VertexBuffer;
+    }  D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC;
+
+typedef struct D3D12_RAYTRACING_AABB
+    {
+    FLOAT MinX;
+    FLOAT MinY;
+    FLOAT MinZ;
+    FLOAT MaxX;
+    FLOAT MaxY;
+    FLOAT MaxZ;
+    }  D3D12_RAYTRACING_AABB;
+
+typedef struct D3D12_RAYTRACING_GEOMETRY_AABBS_DESC
+    {
+    UINT64 AABBCount;
+    D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE AABBs;
+    }  D3D12_RAYTRACING_GEOMETRY_AABBS_DESC;
+
+typedef 
+enum D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS
+    {
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_NONE  = 0,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE  = 0x1,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_COMPACTION  = 0x2,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE = 0x4,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_BUILD = 0x8,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_MINIMIZE_MEMORY = 0x10,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE  = 0x20
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS );
+typedef 
+enum D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE
+    {
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_CLONE  = 0,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_COMPACT  = 0x1,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_VISUALIZATION_DECODE_FOR_TOOLS = 0x2,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_SERIALIZE  = 0x3,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_DESERIALIZE  = 0x4
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE;
+
+typedef 
+enum D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE
+    {
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL = 0,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL  = 0x1
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE;
+
+typedef 
+enum D3D12_ELEMENTS_LAYOUT
+    {
+        D3D12_ELEMENTS_LAYOUT_ARRAY  = 0,
+        D3D12_ELEMENTS_LAYOUT_ARRAY_OF_POINTERS  = 0x1
+    }  D3D12_ELEMENTS_LAYOUT;
+
+typedef 
+enum D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE
+    {
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE  = 0,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION = 0x1,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION = 0x2,
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE  = 0x3
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE;
+
+typedef struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS DestBuffer;
+    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE InfoType;
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC;
+
+typedef struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC
+    {
+    UINT64 CompactedSizeInBytes;
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC;
+
+typedef struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC
+    {
+    UINT64 DecodedSizeInBytes;
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC;
+
+typedef struct D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER
+    {
+    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE Type;
+    UINT NumDescs;
+    }  D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER;
+
+// Regarding D3D12_BUILD_RAY_TRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER above,
+// depending on Type field, NumDescs above is followed by either:
+//       D3D12_RAY_TRACING_INSTANCE_DESC InstanceDescs[NumDescs]
+//    or D3D12_RAY_TRACING_GEOMETRY_DESC GeometryDescs[NumDescs].
+// There is 4 bytes of padding between GeometryDesc structs in the array so alignment is natural when viewed by CPU.
+
+typedef struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC
+    {
+    UINT64 SerializedSizeInBytes;
+    UINT64 NumBottomLevelAccelerationStructurePointers;
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC;
+
+typedef struct D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER
+    {
+    GUID DriverOpaqueGUID;
+    BYTE DriverOpaqueVersioningData[ 16 ];
+    }  D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER;
+
+typedef 
+enum D3D12_SERIALIZED_DATA_TYPE
+    {
+        D3D12_SERIALIZED_DATA_RAYTRACING_ACCELERATION_STRUCTURE  = 0
+    }  D3D12_SERIALIZED_DATA_TYPE;
+
+typedef 
+enum D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS
+    {
+        D3D12_DRIVER_MATCHING_IDENTIFIER_COMPATIBLE_WITH_DEVICE  = 0,
+        D3D12_DRIVER_MATCHING_IDENTIFIER_UNSUPPORTED_TYPE  = 0x1,
+        D3D12_DRIVER_MATCHING_IDENTIFIER_UNRECOGNIZED  = 0x2,
+        D3D12_DRIVER_MATCHING_IDENTIFIER_INCOMPATIBLE_VERSION  = 0x3,
+        D3D12_DRIVER_MATCHING_IDENTIFIER_INCOMPATIBLE_TYPE = 0x4
+    }  D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS;
+
+typedef struct D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER
+    {
+    D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER DriverMatchingIdentifier;
+    UINT64 SerializedSizeInBytesIncludingHeader;
+    UINT64 DeserializedSizeInBytes;
+    UINT64 NumBottomLevelAccelerationStructurePointersAfterHeader;
+    }  D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER;
+
+typedef struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC
+    {
+    UINT64 CurrentSizeInBytes;
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC;
+
+typedef struct D3D12_RAYTRACING_INSTANCE_DESC
+    {
+    FLOAT Transform[ 3 ][ 4 ];
+    UINT InstanceID  : 24;
+    UINT InstanceMask  : 8;
+    UINT InstanceContributionToHitGroupIndex : 24;
+    UINT Flags : 8;
+    D3D12_GPU_VIRTUAL_ADDRESS AccelerationStructure;
+    }  D3D12_RAYTRACING_INSTANCE_DESC;
+
+typedef struct D3D12_RAYTRACING_GEOMETRY_DESC
+    {
+    D3D12_RAYTRACING_GEOMETRY_TYPE Type;
+    D3D12_RAYTRACING_GEOMETRY_FLAGS Flags;
+    union 
+        {
+        D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC Triangles;
+        D3D12_RAYTRACING_GEOMETRY_AABBS_DESC AABBs;
+        }  ;
+    }  D3D12_RAYTRACING_GEOMETRY_DESC;
+
+typedef struct D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS
+    {
+    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE Type;
+    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS Flags;
+    UINT NumDescs;
+    D3D12_ELEMENTS_LAYOUT DescsLayout;
+    union 
+        {
+        D3D12_GPU_VIRTUAL_ADDRESS InstanceDescs;
+        const D3D12_RAYTRACING_GEOMETRY_DESC *pGeometryDescs;
+        const D3D12_RAYTRACING_GEOMETRY_DESC *const *ppGeometryDescs;
+        }  ;
+    }  D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS;
+
+typedef struct D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData;
+    D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS Inputs;
+    _In_opt_  D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData;
+    D3D12_GPU_VIRTUAL_ADDRESS ScratchAccelerationStructureData;
+    }  D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC;
+
+typedef struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO
+    {
+    UINT64 ResultDataMaxSizeInBytes;
+    UINT64 ScratchDataSizeInBytes;
+    UINT64 UpdateScratchDataSizeInBytes;
+    }  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO;
+
+typedef 
+enum D3D12_RAY_FLAGS
+    {
+        D3D12_RAY_FLAG_NONE  = 0,
+        D3D12_RAY_FLAG_FORCE_OPAQUE  = 0x1,
+        D3D12_RAY_FLAG_FORCE_NON_OPAQUE  = 0x2,
+        D3D12_RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH = 0x4,
+        D3D12_RAY_FLAG_SKIP_CLOSEST_HIT_SHADER = 0x8,
+        D3D12_RAY_FLAG_CULL_BACK_FACING_TRIANGLES  = 0x10,
+        D3D12_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES = 0x20,
+        D3D12_RAY_FLAG_CULL_OPAQUE = 0x40,
+        D3D12_RAY_FLAG_CULL_NON_OPAQUE = 0x80
+    }  D3D12_RAY_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_RAY_FLAGS );
+typedef 
+enum D3D12_HIT_KIND
+    {
+        D3D12_HIT_KIND_TRIANGLE_FRONT_FACE = 0xfe,
+        D3D12_HIT_KIND_TRIANGLE_BACK_FACE  = 0xff
+    }  D3D12_HIT_KIND;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0034_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0034_v0_0_s_ifspec;
+
+#ifndef __ID3D12Device5_INTERFACE_DEFINED__
+#define __ID3D12Device5_INTERFACE_DEFINED__
+
+/* interface ID3D12Device5 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Device5;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("8b4f173b-2fea-4b80-8f58-4307191ab95d")
+    ID3D12Device5 : public ID3D12Device4
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE CreateLifetimeTracker( 
+            _In_  ID3D12LifetimeOwner *pOwner,
+            REFIID riid,
+            _COM_Outptr_  void **ppvTracker) = 0;
+        
+        virtual void STDMETHODCALLTYPE RemoveDevice( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE EnumerateMetaCommands( 
+            _Inout_  UINT *pNumMetaCommands,
+            _Out_writes_opt_(*pNumMetaCommands)  D3D12_META_COMMAND_DESC *pDescs) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE EnumerateMetaCommandParameters( 
+            _In_  REFGUID CommandId,
+            _In_  D3D12_META_COMMAND_PARAMETER_STAGE Stage,
+            _Out_opt_  UINT *pTotalStructureSizeInBytes,
+            _Inout_  UINT *pParameterCount,
+            _Out_writes_opt_(*pParameterCount)  D3D12_META_COMMAND_PARAMETER_DESC *pParameterDescs) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateMetaCommand( 
+            _In_  REFGUID CommandId,
+            _In_  UINT NodeMask,
+            _In_reads_bytes_opt_(CreationParametersDataSizeInBytes)  const void *pCreationParametersData,
+            _In_  SIZE_T CreationParametersDataSizeInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppMetaCommand) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateStateObject( 
+            const D3D12_STATE_OBJECT_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppStateObject) = 0;
+        
+        virtual void STDMETHODCALLTYPE GetRaytracingAccelerationStructurePrebuildInfo( 
+            _In_  const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS *pDesc,
+            _Out_  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO *pInfo) = 0;
+        
+        virtual D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS STDMETHODCALLTYPE CheckDriverMatchingIdentifier( 
+            _In_  D3D12_SERIALIZED_DATA_TYPE SerializedDataType,
+            _In_  const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER *pIdentifierToCheck) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Device5Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Device5 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Device5 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Device5 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Device5 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Device5 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Device5 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Device5 * This,
+            _In_z_  LPCWSTR Name);
+        
+        UINT ( STDMETHODCALLTYPE *GetNodeCount )( 
+            ID3D12Device5 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandQueue )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_COMMAND_QUEUE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandQueue);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandAllocator )( 
+            ID3D12Device5 * This,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandAllocator);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateGraphicsPipelineState )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateComputePipelineState )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList )( 
+            ID3D12Device5 * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  ID3D12CommandAllocator *pCommandAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckFeatureSupport )( 
+            ID3D12Device5 * This,
+            D3D12_FEATURE Feature,
+            _Inout_updates_bytes_(FeatureSupportDataSize)  void *pFeatureSupportData,
+            UINT FeatureSupportDataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateDescriptorHeap )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        UINT ( STDMETHODCALLTYPE *GetDescriptorHandleIncrementSize )( 
+            ID3D12Device5 * This,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateRootSignature )( 
+            ID3D12Device5 * This,
+            _In_  UINT nodeMask,
+            _In_reads_(blobLengthInBytes)  const void *pBlobWithRootSignature,
+            _In_  SIZE_T blobLengthInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppvRootSignature);
+        
+        void ( STDMETHODCALLTYPE *CreateConstantBufferView )( 
+            ID3D12Device5 * This,
+            _In_opt_  const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateShaderResourceView )( 
+            ID3D12Device5 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateUnorderedAccessView )( 
+            ID3D12Device5 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  ID3D12Resource *pCounterResource,
+            _In_opt_  const D3D12_UNORDERED_ACCESS_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateRenderTargetView )( 
+            ID3D12Device5 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_RENDER_TARGET_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateDepthStencilView )( 
+            ID3D12Device5 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateSampler )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_SAMPLER_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptors )( 
+            ID3D12Device5 * This,
+            _In_  UINT NumDestDescriptorRanges,
+            _In_reads_(NumDestDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts,
+            _In_reads_opt_(NumDestDescriptorRanges)  const UINT *pDestDescriptorRangeSizes,
+            _In_  UINT NumSrcDescriptorRanges,
+            _In_reads_(NumSrcDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
+            _In_reads_opt_(NumSrcDescriptorRanges)  const UINT *pSrcDescriptorRangeSizes,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptorsSimple )( 
+            ID3D12Device5 * This,
+            _In_  UINT NumDescriptors,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo )( 
+            ID3D12Device5 * This,
+            _In_  UINT visibleMask,
+            _In_  UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs);
+        
+        D3D12_HEAP_PROPERTIES ( STDMETHODCALLTYPE *GetCustomHeapProperties )( 
+            ID3D12Device5 * This,
+            _In_  UINT nodeMask,
+            D3D12_HEAP_TYPE heapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePlacedResource )( 
+            ID3D12Device5 * This,
+            _In_  ID3D12Heap *pHeap,
+            UINT64 HeapOffset,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSharedHandle )( 
+            ID3D12Device5 * This,
+            _In_  ID3D12DeviceChild *pObject,
+            _In_opt_  const SECURITY_ATTRIBUTES *pAttributes,
+            DWORD Access,
+            _In_opt_  LPCWSTR Name,
+            _Out_  HANDLE *pHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandle )( 
+            ID3D12Device5 * This,
+            _In_  HANDLE NTHandle,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvObj);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandleByName )( 
+            ID3D12Device5 * This,
+            _In_  LPCWSTR Name,
+            DWORD Access,
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pNTHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeResident )( 
+            ID3D12Device5 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *Evict )( 
+            ID3D12Device5 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateFence )( 
+            ID3D12Device5 * This,
+            UINT64 InitialValue,
+            D3D12_FENCE_FLAGS Flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppFence);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDeviceRemovedReason )( 
+            ID3D12Device5 * This);
+        
+        void ( STDMETHODCALLTYPE *GetCopyableFootprints )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_RESOURCE_DESC *pResourceDesc,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES)  UINT FirstSubresource,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource)  UINT NumSubresources,
+            UINT64 BaseOffset,
+            _Out_writes_opt_(NumSubresources)  D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts,
+            _Out_writes_opt_(NumSubresources)  UINT *pNumRows,
+            _Out_writes_opt_(NumSubresources)  UINT64 *pRowSizeInBytes,
+            _Out_opt_  UINT64 *pTotalBytes);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateQueryHeap )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_QUERY_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetStablePowerState )( 
+            ID3D12Device5 * This,
+            BOOL Enable);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandSignature )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_COMMAND_SIGNATURE_DESC *pDesc,
+            _In_opt_  ID3D12RootSignature *pRootSignature,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvCommandSignature);
+        
+        void ( STDMETHODCALLTYPE *GetResourceTiling )( 
+            ID3D12Device5 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _Out_opt_  UINT *pNumTilesForEntireResource,
+            _Out_opt_  D3D12_PACKED_MIP_INFO *pPackedMipDesc,
+            _Out_opt_  D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips,
+            _Inout_opt_  UINT *pNumSubresourceTilings,
+            _In_  UINT FirstSubresourceTilingToGet,
+            _Out_writes_(*pNumSubresourceTilings)  D3D12_SUBRESOURCE_TILING *pSubresourceTilingsForNonPackedMips);
+        
+        LUID ( STDMETHODCALLTYPE *GetAdapterLuid )( 
+            ID3D12Device5 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineLibrary )( 
+            ID3D12Device5 * This,
+            _In_reads_(BlobLength)  const void *pLibraryBlob,
+            SIZE_T BlobLength,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineLibrary);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEventOnMultipleFenceCompletion )( 
+            ID3D12Device5 * This,
+            _In_reads_(NumFences)  ID3D12Fence *const *ppFences,
+            _In_reads_(NumFences)  const UINT64 *pFenceValues,
+            UINT NumFences,
+            D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
+            HANDLE hEvent);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetResidencyPriority )( 
+            ID3D12Device5 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_reads_(NumObjects)  const D3D12_RESIDENCY_PRIORITY *pPriorities);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineState )( 
+            ID3D12Device5 * This,
+            const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenExistingHeapFromAddress )( 
+            ID3D12Device5 * This,
+            _In_  const void *pAddress,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenExistingHeapFromFileMapping )( 
+            ID3D12Device5 * This,
+            _In_  HANDLE hFileMapping,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnqueueMakeResident )( 
+            ID3D12Device5 * This,
+            D3D12_RESIDENCY_FLAGS Flags,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_  ID3D12Fence *pFenceToSignal,
+            UINT64 FenceValueToSignal);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList1 )( 
+            ID3D12Device5 * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  D3D12_COMMAND_LIST_FLAGS flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateProtectedResourceSession )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_PROTECTED_RESOURCE_SESSION_DESC *pDesc,
+            _In_  REFIID riid,
+            _COM_Outptr_  void **ppSession);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource1 )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap1 )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource1 )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo1 )( 
+            ID3D12Device5 * This,
+            UINT visibleMask,
+            UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs,
+            _Out_writes_opt_(numResourceDescs)  D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateLifetimeTracker )( 
+            ID3D12Device5 * This,
+            _In_  ID3D12LifetimeOwner *pOwner,
+            REFIID riid,
+            _COM_Outptr_  void **ppvTracker);
+        
+        void ( STDMETHODCALLTYPE *RemoveDevice )( 
+            ID3D12Device5 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumerateMetaCommands )( 
+            ID3D12Device5 * This,
+            _Inout_  UINT *pNumMetaCommands,
+            _Out_writes_opt_(*pNumMetaCommands)  D3D12_META_COMMAND_DESC *pDescs);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumerateMetaCommandParameters )( 
+            ID3D12Device5 * This,
+            _In_  REFGUID CommandId,
+            _In_  D3D12_META_COMMAND_PARAMETER_STAGE Stage,
+            _Out_opt_  UINT *pTotalStructureSizeInBytes,
+            _Inout_  UINT *pParameterCount,
+            _Out_writes_opt_(*pParameterCount)  D3D12_META_COMMAND_PARAMETER_DESC *pParameterDescs);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateMetaCommand )( 
+            ID3D12Device5 * This,
+            _In_  REFGUID CommandId,
+            _In_  UINT NodeMask,
+            _In_reads_bytes_opt_(CreationParametersDataSizeInBytes)  const void *pCreationParametersData,
+            _In_  SIZE_T CreationParametersDataSizeInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppMetaCommand);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateStateObject )( 
+            ID3D12Device5 * This,
+            const D3D12_STATE_OBJECT_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppStateObject);
+        
+        void ( STDMETHODCALLTYPE *GetRaytracingAccelerationStructurePrebuildInfo )( 
+            ID3D12Device5 * This,
+            _In_  const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS *pDesc,
+            _Out_  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO *pInfo);
+        
+        D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS ( STDMETHODCALLTYPE *CheckDriverMatchingIdentifier )( 
+            ID3D12Device5 * This,
+            _In_  D3D12_SERIALIZED_DATA_TYPE SerializedDataType,
+            _In_  const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER *pIdentifierToCheck);
+        
+        END_INTERFACE
+    } ID3D12Device5Vtbl;
+
+    interface ID3D12Device5
+    {
+        CONST_VTBL struct ID3D12Device5Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Device5_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Device5_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Device5_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Device5_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Device5_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Device5_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Device5_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Device5_GetNodeCount(This) \
+    ( (This)->lpVtbl -> GetNodeCount(This) ) 
+
+#define ID3D12Device5_CreateCommandQueue(This,pDesc,riid,ppCommandQueue) \
+    ( (This)->lpVtbl -> CreateCommandQueue(This,pDesc,riid,ppCommandQueue) ) 
+
+#define ID3D12Device5_CreateCommandAllocator(This,type,riid,ppCommandAllocator)  \
+    ( (This)->lpVtbl -> CreateCommandAllocator(This,type,riid,ppCommandAllocator) ) 
+
+#define ID3D12Device5_CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device5_CreateComputePipelineState(This,pDesc,riid,ppPipelineState)  \
+    ( (This)->lpVtbl -> CreateComputePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device5_CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) \
+    ( (This)->lpVtbl -> CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) ) 
+
+#define ID3D12Device5_CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) \
+    ( (This)->lpVtbl -> CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) ) 
+
+#define ID3D12Device5_CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device5_GetDescriptorHandleIncrementSize(This,DescriptorHeapType)  \
+    ( (This)->lpVtbl -> GetDescriptorHandleIncrementSize(This,DescriptorHeapType) ) 
+
+#define ID3D12Device5_CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature)  \
+    ( (This)->lpVtbl -> CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature) ) 
+
+#define ID3D12Device5_CreateConstantBufferView(This,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateConstantBufferView(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device5_CreateShaderResourceView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateShaderResourceView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device5_CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device5_CreateRenderTargetView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateRenderTargetView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device5_CreateDepthStencilView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateDepthStencilView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device5_CreateSampler(This,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateSampler(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device5_CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) \
+    ( (This)->lpVtbl -> CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) ) 
+
+#define ID3D12Device5_CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType)  \
+    ( (This)->lpVtbl -> CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType) ) 
+
+#define ID3D12Device5_GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs)  \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs) ) 
+
+#define ID3D12Device5_GetCustomHeapProperties(This,nodeMask,heapType)  \
+    ( (This)->lpVtbl -> GetCustomHeapProperties(This,nodeMask,heapType) ) 
+
+#define ID3D12Device5_CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) \
+    ( (This)->lpVtbl -> CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) ) 
+
+#define ID3D12Device5_CreateHeap(This,pDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device5_CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device5_CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource)  \
+    ( (This)->lpVtbl -> CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device5_CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) \
+    ( (This)->lpVtbl -> CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) ) 
+
+#define ID3D12Device5_OpenSharedHandle(This,NTHandle,riid,ppvObj)  \
+    ( (This)->lpVtbl -> OpenSharedHandle(This,NTHandle,riid,ppvObj) ) 
+
+#define ID3D12Device5_OpenSharedHandleByName(This,Name,Access,pNTHandle) \
+    ( (This)->lpVtbl -> OpenSharedHandleByName(This,Name,Access,pNTHandle) ) 
+
+#define ID3D12Device5_MakeResident(This,NumObjects,ppObjects)  \
+    ( (This)->lpVtbl -> MakeResident(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device5_Evict(This,NumObjects,ppObjects) \
+    ( (This)->lpVtbl -> Evict(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device5_CreateFence(This,InitialValue,Flags,riid,ppFence)  \
+    ( (This)->lpVtbl -> CreateFence(This,InitialValue,Flags,riid,ppFence) ) 
+
+#define ID3D12Device5_GetDeviceRemovedReason(This) \
+    ( (This)->lpVtbl -> GetDeviceRemovedReason(This) ) 
+
+#define ID3D12Device5_GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes)  \
+    ( (This)->lpVtbl -> GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes) ) 
+
+#define ID3D12Device5_CreateQueryHeap(This,pDesc,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateQueryHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device5_SetStablePowerState(This,Enable) \
+    ( (This)->lpVtbl -> SetStablePowerState(This,Enable) ) 
+
+#define ID3D12Device5_CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) \
+    ( (This)->lpVtbl -> CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) ) 
+
+#define ID3D12Device5_GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) \
+    ( (This)->lpVtbl -> GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) ) 
+
+#define ID3D12Device5_GetAdapterLuid(This) \
+    ( (This)->lpVtbl -> GetAdapterLuid(This) ) 
+
+
+#define ID3D12Device5_CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) \
+    ( (This)->lpVtbl -> CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) ) 
+
+#define ID3D12Device5_SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) \
+    ( (This)->lpVtbl -> SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) ) 
+
+#define ID3D12Device5_SetResidencyPriority(This,NumObjects,ppObjects,pPriorities)  \
+    ( (This)->lpVtbl -> SetResidencyPriority(This,NumObjects,ppObjects,pPriorities) ) 
+
+
+#define ID3D12Device5_CreatePipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreatePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+
+#define ID3D12Device5_OpenExistingHeapFromAddress(This,pAddress,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> OpenExistingHeapFromAddress(This,pAddress,riid,ppvHeap) ) 
+
+#define ID3D12Device5_OpenExistingHeapFromFileMapping(This,hFileMapping,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> OpenExistingHeapFromFileMapping(This,hFileMapping,riid,ppvHeap) ) 
+
+#define ID3D12Device5_EnqueueMakeResident(This,Flags,NumObjects,ppObjects,pFenceToSignal,FenceValueToSignal) \
+    ( (This)->lpVtbl -> EnqueueMakeResident(This,Flags,NumObjects,ppObjects,pFenceToSignal,FenceValueToSignal) ) 
+
+
+#define ID3D12Device5_CreateCommandList1(This,nodeMask,type,flags,riid,ppCommandList)  \
+    ( (This)->lpVtbl -> CreateCommandList1(This,nodeMask,type,flags,riid,ppCommandList) ) 
+
+#define ID3D12Device5_CreateProtectedResourceSession(This,pDesc,riid,ppSession)  \
+    ( (This)->lpVtbl -> CreateProtectedResourceSession(This,pDesc,riid,ppSession) ) 
+
+#define ID3D12Device5_CreateCommittedResource1(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,pProtectedSession,riidResource,ppvResource)  \
+    ( (This)->lpVtbl -> CreateCommittedResource1(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,pProtectedSession,riidResource,ppvResource) ) 
+
+#define ID3D12Device5_CreateHeap1(This,pDesc,pProtectedSession,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateHeap1(This,pDesc,pProtectedSession,riid,ppvHeap) ) 
+
+#define ID3D12Device5_CreateReservedResource1(This,pDesc,InitialState,pOptimizedClearValue,pProtectedSession,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreateReservedResource1(This,pDesc,InitialState,pOptimizedClearValue,pProtectedSession,riid,ppvResource) ) 
+
+#define ID3D12Device5_GetResourceAllocationInfo1(This,visibleMask,numResourceDescs,pResourceDescs,pResourceAllocationInfo1)  \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo1(This,visibleMask,numResourceDescs,pResourceDescs,pResourceAllocationInfo1) ) 
+
+
+#define ID3D12Device5_CreateLifetimeTracker(This,pOwner,riid,ppvTracker) \
+    ( (This)->lpVtbl -> CreateLifetimeTracker(This,pOwner,riid,ppvTracker) ) 
+
+#define ID3D12Device5_RemoveDevice(This) \
+    ( (This)->lpVtbl -> RemoveDevice(This) ) 
+
+#define ID3D12Device5_EnumerateMetaCommands(This,pNumMetaCommands,pDescs)  \
+    ( (This)->lpVtbl -> EnumerateMetaCommands(This,pNumMetaCommands,pDescs) ) 
+
+#define ID3D12Device5_EnumerateMetaCommandParameters(This,CommandId,Stage,pTotalStructureSizeInBytes,pParameterCount,pParameterDescs)  \
+    ( (This)->lpVtbl -> EnumerateMetaCommandParameters(This,CommandId,Stage,pTotalStructureSizeInBytes,pParameterCount,pParameterDescs) ) 
+
+#define ID3D12Device5_CreateMetaCommand(This,CommandId,NodeMask,pCreationParametersData,CreationParametersDataSizeInBytes,riid,ppMetaCommand)  \
+    ( (This)->lpVtbl -> CreateMetaCommand(This,CommandId,NodeMask,pCreationParametersData,CreationParametersDataSizeInBytes,riid,ppMetaCommand) ) 
+
+#define ID3D12Device5_CreateStateObject(This,pDesc,riid,ppStateObject) \
+    ( (This)->lpVtbl -> CreateStateObject(This,pDesc,riid,ppStateObject) ) 
+
+#define ID3D12Device5_GetRaytracingAccelerationStructurePrebuildInfo(This,pDesc,pInfo) \
+    ( (This)->lpVtbl -> GetRaytracingAccelerationStructurePrebuildInfo(This,pDesc,pInfo) ) 
+
+#define ID3D12Device5_CheckDriverMatchingIdentifier(This,SerializedDataType,pIdentifierToCheck)  \
+    ( (This)->lpVtbl -> CheckDriverMatchingIdentifier(This,SerializedDataType,pIdentifierToCheck) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Device5_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0035 */
+/* [local] */ 
+
+typedef 
+enum D3D12_AUTO_BREADCRUMB_OP
+    {
+        D3D12_AUTO_BREADCRUMB_OP_SETMARKER = 0,
+        D3D12_AUTO_BREADCRUMB_OP_BEGINEVENT  = 1,
+        D3D12_AUTO_BREADCRUMB_OP_ENDEVENT  = 2,
+        D3D12_AUTO_BREADCRUMB_OP_DRAWINSTANCED = 3,
+        D3D12_AUTO_BREADCRUMB_OP_DRAWINDEXEDINSTANCED  = 4,
+        D3D12_AUTO_BREADCRUMB_OP_EXECUTEINDIRECT = 5,
+        D3D12_AUTO_BREADCRUMB_OP_DISPATCH  = 6,
+        D3D12_AUTO_BREADCRUMB_OP_COPYBUFFERREGION  = 7,
+        D3D12_AUTO_BREADCRUMB_OP_COPYTEXTUREREGION = 8,
+        D3D12_AUTO_BREADCRUMB_OP_COPYRESOURCE  = 9,
+        D3D12_AUTO_BREADCRUMB_OP_COPYTILES = 10,
+        D3D12_AUTO_BREADCRUMB_OP_RESOLVESUBRESOURCE  = 11,
+        D3D12_AUTO_BREADCRUMB_OP_CLEARRENDERTARGETVIEW = 12,
+        D3D12_AUTO_BREADCRUMB_OP_CLEARUNORDEREDACCESSVIEW  = 13,
+        D3D12_AUTO_BREADCRUMB_OP_CLEARDEPTHSTENCILVIEW = 14,
+        D3D12_AUTO_BREADCRUMB_OP_RESOURCEBARRIER = 15,
+        D3D12_AUTO_BREADCRUMB_OP_EXECUTEBUNDLE = 16,
+        D3D12_AUTO_BREADCRUMB_OP_PRESENT = 17,
+        D3D12_AUTO_BREADCRUMB_OP_RESOLVEQUERYDATA  = 18,
+        D3D12_AUTO_BREADCRUMB_OP_BEGINSUBMISSION = 19,
+        D3D12_AUTO_BREADCRUMB_OP_ENDSUBMISSION = 20,
+        D3D12_AUTO_BREADCRUMB_OP_DECODEFRAME = 21,
+        D3D12_AUTO_BREADCRUMB_OP_PROCESSFRAMES = 22,
+        D3D12_AUTO_BREADCRUMB_OP_ATOMICCOPYBUFFERUINT  = 23,
+        D3D12_AUTO_BREADCRUMB_OP_ATOMICCOPYBUFFERUINT64  = 24,
+        D3D12_AUTO_BREADCRUMB_OP_RESOLVESUBRESOURCEREGION  = 25,
+        D3D12_AUTO_BREADCRUMB_OP_WRITEBUFFERIMMEDIATE  = 26,
+        D3D12_AUTO_BREADCRUMB_OP_DECODEFRAME1  = 27,
+        D3D12_AUTO_BREADCRUMB_OP_SETPROTECTEDRESOURCESESSION = 28,
+        D3D12_AUTO_BREADCRUMB_OP_DECODEFRAME2  = 29,
+        D3D12_AUTO_BREADCRUMB_OP_PROCESSFRAMES1  = 30,
+        D3D12_AUTO_BREADCRUMB_OP_BUILDRAYTRACINGACCELERATIONSTRUCTURE  = 31,
+        D3D12_AUTO_BREADCRUMB_OP_EMITRAYTRACINGACCELERATIONSTRUCTUREPOSTBUILDINFO  = 32,
+        D3D12_AUTO_BREADCRUMB_OP_COPYRAYTRACINGACCELERATIONSTRUCTURE = 33,
+        D3D12_AUTO_BREADCRUMB_OP_DISPATCHRAYS  = 34,
+        D3D12_AUTO_BREADCRUMB_OP_INITIALIZEMETACOMMAND = 35,
+        D3D12_AUTO_BREADCRUMB_OP_EXECUTEMETACOMMAND  = 36,
+        D3D12_AUTO_BREADCRUMB_OP_ESTIMATEMOTION  = 37,
+        D3D12_AUTO_BREADCRUMB_OP_RESOLVEMOTIONVECTORHEAP = 38,
+        D3D12_AUTO_BREADCRUMB_OP_SETPIPELINESTATE1 = 39,
+        D3D12_AUTO_BREADCRUMB_OP_INITIALIZEEXTENSIONCOMMAND  = 40,
+        D3D12_AUTO_BREADCRUMB_OP_EXECUTEEXTENSIONCOMMAND = 41
+    }  D3D12_AUTO_BREADCRUMB_OP;
+
+typedef struct D3D12_AUTO_BREADCRUMB_NODE
+    {
+    const char *pCommandListDebugNameA;
+    const wchar_t *pCommandListDebugNameW;
+    const char *pCommandQueueDebugNameA;
+    const wchar_t *pCommandQueueDebugNameW;
+    ID3D12GraphicsCommandList *pCommandList;
+    ID3D12CommandQueue *pCommandQueue;
+    UINT32 BreadcrumbCount;
+    const UINT32 *pLastBreadcrumbValue;
+    const D3D12_AUTO_BREADCRUMB_OP *pCommandHistory;
+    const struct D3D12_AUTO_BREADCRUMB_NODE *pNext;
+    }  D3D12_AUTO_BREADCRUMB_NODE;
+
+typedef 
+enum D3D12_DRED_VERSION
+    {
+        D3D12_DRED_VERSION_1_0 = 0x1,
+        D3D12_DRED_VERSION_1_1 = 0x2
+    }  D3D12_DRED_VERSION;
+
+typedef 
+enum D3D12_DRED_FLAGS
+    {
+        D3D12_DRED_FLAG_NONE = 0,
+        D3D12_DRED_FLAG_FORCE_ENABLE = 1,
+        D3D12_DRED_FLAG_DISABLE_AUTOBREADCRUMBS  = 2
+    }  D3D12_DRED_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_DRED_FLAGS );
+typedef 
+enum D3D12_DRED_ENABLEMENT
+    {
+        D3D12_DRED_ENABLEMENT_SYSTEM_CONTROLLED  = 0,
+        D3D12_DRED_ENABLEMENT_FORCED_OFF = 1,
+        D3D12_DRED_ENABLEMENT_FORCED_ON  = 2
+    }  D3D12_DRED_ENABLEMENT;
+
+typedef struct D3D12_DEVICE_REMOVED_EXTENDED_DATA
+    {
+    _In_  D3D12_DRED_FLAGS Flags;
+    _Out_  D3D12_AUTO_BREADCRUMB_NODE *pHeadAutoBreadcrumbNode;
+    }  D3D12_DEVICE_REMOVED_EXTENDED_DATA;
+
+typedef 
+enum D3D12_DRED_ALLOCATION_TYPE
+    {
+        D3D12_DRED_ALLOCATION_TYPE_COMMAND_QUEUE = 19,
+        D3D12_DRED_ALLOCATION_TYPE_COMMAND_ALLOCATOR = 20,
+        D3D12_DRED_ALLOCATION_TYPE_PIPELINE_STATE  = 21,
+        D3D12_DRED_ALLOCATION_TYPE_COMMAND_LIST  = 22,
+        D3D12_DRED_ALLOCATION_TYPE_FENCE = 23,
+        D3D12_DRED_ALLOCATION_TYPE_DESCRIPTOR_HEAP = 24,
+        D3D12_DRED_ALLOCATION_TYPE_HEAP  = 25,
+        D3D12_DRED_ALLOCATION_TYPE_QUERY_HEAP  = 27,
+        D3D12_DRED_ALLOCATION_TYPE_COMMAND_SIGNATURE = 28,
+        D3D12_DRED_ALLOCATION_TYPE_PIPELINE_LIBRARY  = 29,
+        D3D12_DRED_ALLOCATION_TYPE_VIDEO_DECODER = 30,
+        D3D12_DRED_ALLOCATION_TYPE_VIDEO_PROCESSOR = 32,
+        D3D12_DRED_ALLOCATION_TYPE_RESOURCE  = 34,
+        D3D12_DRED_ALLOCATION_TYPE_PASS  = 35,
+        D3D12_DRED_ALLOCATION_TYPE_CRYPTOSESSION = 36,
+        D3D12_DRED_ALLOCATION_TYPE_CRYPTOSESSIONPOLICY = 37,
+        D3D12_DRED_ALLOCATION_TYPE_PROTECTEDRESOURCESESSION  = 38,
+        D3D12_DRED_ALLOCATION_TYPE_VIDEO_DECODER_HEAP  = 39,
+        D3D12_DRED_ALLOCATION_TYPE_COMMAND_POOL  = 40,
+        D3D12_DRED_ALLOCATION_TYPE_COMMAND_RECORDER  = 41,
+        D3D12_DRED_ALLOCATION_TYPE_STATE_OBJECT  = 42,
+        D3D12_DRED_ALLOCATION_TYPE_METACOMMAND = 43,
+        D3D12_DRED_ALLOCATION_TYPE_SCHEDULINGGROUP = 44,
+        D3D12_DRED_ALLOCATION_TYPE_VIDEO_MOTION_ESTIMATOR  = 45,
+        D3D12_DRED_ALLOCATION_TYPE_VIDEO_MOTION_VECTOR_HEAP  = 46,
+        D3D12_DRED_ALLOCATION_TYPE_VIDEO_EXTENSION_COMMAND = 47,
+        D3D12_DRED_ALLOCATION_TYPE_INVALID = 0xffffffff
+    }  D3D12_DRED_ALLOCATION_TYPE;
+
+typedef struct D3D12_DRED_ALLOCATION_NODE
+    {
+    const char *ObjectNameA;
+    const wchar_t *ObjectNameW;
+    D3D12_DRED_ALLOCATION_TYPE AllocationType;
+    const struct D3D12_DRED_ALLOCATION_NODE *pNext;
+    }  D3D12_DRED_ALLOCATION_NODE;
+
+typedef struct D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT
+    {
+    _Out_  const D3D12_AUTO_BREADCRUMB_NODE *pHeadAutoBreadcrumbNode;
+    }  D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT;
+
+typedef struct D3D12_DRED_PAGE_FAULT_OUTPUT
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS PageFaultVA;
+    _Out_  const D3D12_DRED_ALLOCATION_NODE *pHeadExistingAllocationNode;
+    _Out_  const D3D12_DRED_ALLOCATION_NODE *pHeadRecentFreedAllocationNode;
+    }  D3D12_DRED_PAGE_FAULT_OUTPUT;
+
+typedef struct D3D12_DEVICE_REMOVED_EXTENDED_DATA1
+    {
+    HRESULT DeviceRemovedReason;
+    D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT AutoBreadcrumbsOutput;
+    D3D12_DRED_PAGE_FAULT_OUTPUT PageFaultOutput;
+    }  D3D12_DEVICE_REMOVED_EXTENDED_DATA1;
+
+typedef struct D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA
+    {
+    D3D12_DRED_VERSION Version;
+    union 
+        {
+        D3D12_DEVICE_REMOVED_EXTENDED_DATA Dred_1_0;
+        D3D12_DEVICE_REMOVED_EXTENDED_DATA1 Dred_1_1;
+        }  ;
+    }  D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0035_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0035_v0_0_s_ifspec;
+
+#ifndef __ID3D12DeviceRemovedExtendedDataSettings_INTERFACE_DEFINED__
+#define __ID3D12DeviceRemovedExtendedDataSettings_INTERFACE_DEFINED__
+
+/* interface ID3D12DeviceRemovedExtendedDataSettings */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DeviceRemovedExtendedDataSettings;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("82BC481C-6B9B-4030-AEDB-7EE3D1DF1E63")
+    ID3D12DeviceRemovedExtendedDataSettings : public IUnknown
+    {
+    public:
+        virtual void STDMETHODCALLTYPE SetAutoBreadcrumbsEnablement( 
+            D3D12_DRED_ENABLEMENT __MIDL__ID3D12DeviceRemovedExtendedDataSettings0000) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetPageFaultEnablement( 
+            D3D12_DRED_ENABLEMENT __MIDL__ID3D12DeviceRemovedExtendedDataSettings0001) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetWatsonDumpEnablement( 
+            D3D12_DRED_ENABLEMENT __MIDL__ID3D12DeviceRemovedExtendedDataSettings0002) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DeviceRemovedExtendedDataSettingsVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DeviceRemovedExtendedDataSettings * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DeviceRemovedExtendedDataSettings * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DeviceRemovedExtendedDataSettings * This);
+        
+        void ( STDMETHODCALLTYPE *SetAutoBreadcrumbsEnablement )( 
+            ID3D12DeviceRemovedExtendedDataSettings * This,
+            D3D12_DRED_ENABLEMENT __MIDL__ID3D12DeviceRemovedExtendedDataSettings0000);
+        
+        void ( STDMETHODCALLTYPE *SetPageFaultEnablement )( 
+            ID3D12DeviceRemovedExtendedDataSettings * This,
+            D3D12_DRED_ENABLEMENT __MIDL__ID3D12DeviceRemovedExtendedDataSettings0001);
+        
+        void ( STDMETHODCALLTYPE *SetWatsonDumpEnablement )( 
+            ID3D12DeviceRemovedExtendedDataSettings * This,
+            D3D12_DRED_ENABLEMENT __MIDL__ID3D12DeviceRemovedExtendedDataSettings0002);
+        
+        END_INTERFACE
+    } ID3D12DeviceRemovedExtendedDataSettingsVtbl;
+
+    interface ID3D12DeviceRemovedExtendedDataSettings
+    {
+        CONST_VTBL struct ID3D12DeviceRemovedExtendedDataSettingsVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DeviceRemovedExtendedDataSettings_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DeviceRemovedExtendedDataSettings_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DeviceRemovedExtendedDataSettings_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DeviceRemovedExtendedDataSettings_SetAutoBreadcrumbsEnablement(This,__MIDL__ID3D12DeviceRemovedExtendedDataSettings0000) \
+    ( (This)->lpVtbl -> SetAutoBreadcrumbsEnablement(This,__MIDL__ID3D12DeviceRemovedExtendedDataSettings0000) ) 
+
+#define ID3D12DeviceRemovedExtendedDataSettings_SetPageFaultEnablement(This,__MIDL__ID3D12DeviceRemovedExtendedDataSettings0001) \
+    ( (This)->lpVtbl -> SetPageFaultEnablement(This,__MIDL__ID3D12DeviceRemovedExtendedDataSettings0001) ) 
+
+#define ID3D12DeviceRemovedExtendedDataSettings_SetWatsonDumpEnablement(This,__MIDL__ID3D12DeviceRemovedExtendedDataSettings0002)  \
+    ( (This)->lpVtbl -> SetWatsonDumpEnablement(This,__MIDL__ID3D12DeviceRemovedExtendedDataSettings0002) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DeviceRemovedExtendedDataSettings_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12DeviceRemovedExtendedData_INTERFACE_DEFINED__
+#define __ID3D12DeviceRemovedExtendedData_INTERFACE_DEFINED__
+
+/* interface ID3D12DeviceRemovedExtendedData */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DeviceRemovedExtendedData;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("98931D33-5AE8-4791-AA3C-1A73A2934E71")
+    ID3D12DeviceRemovedExtendedData : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetAutoBreadcrumbsOutput( 
+            D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT *pOutput) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetPageFaultAllocationOutput( 
+            D3D12_DRED_PAGE_FAULT_OUTPUT *pOutput) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DeviceRemovedExtendedDataVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DeviceRemovedExtendedData * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DeviceRemovedExtendedData * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DeviceRemovedExtendedData * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAutoBreadcrumbsOutput )( 
+            ID3D12DeviceRemovedExtendedData * This,
+            D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT *pOutput);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPageFaultAllocationOutput )( 
+            ID3D12DeviceRemovedExtendedData * This,
+            D3D12_DRED_PAGE_FAULT_OUTPUT *pOutput);
+        
+        END_INTERFACE
+    } ID3D12DeviceRemovedExtendedDataVtbl;
+
+    interface ID3D12DeviceRemovedExtendedData
+    {
+        CONST_VTBL struct ID3D12DeviceRemovedExtendedDataVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DeviceRemovedExtendedData_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DeviceRemovedExtendedData_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DeviceRemovedExtendedData_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DeviceRemovedExtendedData_GetAutoBreadcrumbsOutput(This,pOutput) \
+    ( (This)->lpVtbl -> GetAutoBreadcrumbsOutput(This,pOutput) ) 
+
+#define ID3D12DeviceRemovedExtendedData_GetPageFaultAllocationOutput(This,pOutput) \
+    ( (This)->lpVtbl -> GetPageFaultAllocationOutput(This,pOutput) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DeviceRemovedExtendedData_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0037 */
+/* [local] */ 
+
+typedef 
+enum D3D12_BACKGROUND_PROCESSING_MODE
+    {
+        D3D12_BACKGROUND_PROCESSING_MODE_ALLOWED = 0,
+        D3D12_BACKGROUND_PROCESSING_MODE_ALLOW_INTRUSIVE_MEASUREMENTS  = ( D3D12_BACKGROUND_PROCESSING_MODE_ALLOWED + 1 ) ,
+        D3D12_BACKGROUND_PROCESSING_MODE_DISABLE_BACKGROUND_WORK = ( D3D12_BACKGROUND_PROCESSING_MODE_ALLOW_INTRUSIVE_MEASUREMENTS + 1 ) ,
+        D3D12_BACKGROUND_PROCESSING_MODE_DISABLE_PROFILING_BY_SYSTEM = ( D3D12_BACKGROUND_PROCESSING_MODE_DISABLE_BACKGROUND_WORK + 1 ) 
+    }  D3D12_BACKGROUND_PROCESSING_MODE;
+
+typedef 
+enum D3D12_MEASUREMENTS_ACTION
+    {
+        D3D12_MEASUREMENTS_ACTION_KEEP_ALL = 0,
+        D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS = ( D3D12_MEASUREMENTS_ACTION_KEEP_ALL + 1 ) ,
+        D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS_HIGH_PRIORITY = ( D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS + 1 ) ,
+        D3D12_MEASUREMENTS_ACTION_DISCARD_PREVIOUS = ( D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS_HIGH_PRIORITY + 1 ) 
+    }  D3D12_MEASUREMENTS_ACTION;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0037_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0037_v0_0_s_ifspec;
+
+#ifndef __ID3D12Device6_INTERFACE_DEFINED__
+#define __ID3D12Device6_INTERFACE_DEFINED__
+
+/* interface ID3D12Device6 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Device6;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("c70b221b-40e4-4a17-89af-025a0727a6dc")
+    ID3D12Device6 : public ID3D12Device5
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetBackgroundProcessingMode( 
+            D3D12_BACKGROUND_PROCESSING_MODE Mode,
+            D3D12_MEASUREMENTS_ACTION MeasurementsAction,
+            _In_opt_  HANDLE hEventToSignalUponCompletion,
+            _Out_opt_  BOOL *pbFurtherMeasurementsDesired) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Device6Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Device6 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Device6 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Device6 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Device6 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Device6 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Device6 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Device6 * This,
+            _In_z_  LPCWSTR Name);
+        
+        UINT ( STDMETHODCALLTYPE *GetNodeCount )( 
+            ID3D12Device6 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandQueue )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_COMMAND_QUEUE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandQueue);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandAllocator )( 
+            ID3D12Device6 * This,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandAllocator);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateGraphicsPipelineState )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateComputePipelineState )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList )( 
+            ID3D12Device6 * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  ID3D12CommandAllocator *pCommandAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckFeatureSupport )( 
+            ID3D12Device6 * This,
+            D3D12_FEATURE Feature,
+            _Inout_updates_bytes_(FeatureSupportDataSize)  void *pFeatureSupportData,
+            UINT FeatureSupportDataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateDescriptorHeap )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        UINT ( STDMETHODCALLTYPE *GetDescriptorHandleIncrementSize )( 
+            ID3D12Device6 * This,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateRootSignature )( 
+            ID3D12Device6 * This,
+            _In_  UINT nodeMask,
+            _In_reads_(blobLengthInBytes)  const void *pBlobWithRootSignature,
+            _In_  SIZE_T blobLengthInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppvRootSignature);
+        
+        void ( STDMETHODCALLTYPE *CreateConstantBufferView )( 
+            ID3D12Device6 * This,
+            _In_opt_  const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateShaderResourceView )( 
+            ID3D12Device6 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateUnorderedAccessView )( 
+            ID3D12Device6 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  ID3D12Resource *pCounterResource,
+            _In_opt_  const D3D12_UNORDERED_ACCESS_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateRenderTargetView )( 
+            ID3D12Device6 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_RENDER_TARGET_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateDepthStencilView )( 
+            ID3D12Device6 * This,
+            _In_opt_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CreateSampler )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_SAMPLER_DESC *pDesc,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptors )( 
+            ID3D12Device6 * This,
+            _In_  UINT NumDestDescriptorRanges,
+            _In_reads_(NumDestDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts,
+            _In_reads_opt_(NumDestDescriptorRanges)  const UINT *pDestDescriptorRangeSizes,
+            _In_  UINT NumSrcDescriptorRanges,
+            _In_reads_(NumSrcDescriptorRanges)  const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
+            _In_reads_opt_(NumSrcDescriptorRanges)  const UINT *pSrcDescriptorRangeSizes,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        void ( STDMETHODCALLTYPE *CopyDescriptorsSimple )( 
+            ID3D12Device6 * This,
+            _In_  UINT NumDescriptors,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
+            _In_  D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo )( 
+            ID3D12Device6 * This,
+            _In_  UINT visibleMask,
+            _In_  UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs);
+        
+        D3D12_HEAP_PROPERTIES ( STDMETHODCALLTYPE *GetCustomHeapProperties )( 
+            ID3D12Device6 * This,
+            _In_  UINT nodeMask,
+            D3D12_HEAP_TYPE heapType);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePlacedResource )( 
+            ID3D12Device6 * This,
+            _In_  ID3D12Heap *pHeap,
+            UINT64 HeapOffset,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSharedHandle )( 
+            ID3D12Device6 * This,
+            _In_  ID3D12DeviceChild *pObject,
+            _In_opt_  const SECURITY_ATTRIBUTES *pAttributes,
+            DWORD Access,
+            _In_opt_  LPCWSTR Name,
+            _Out_  HANDLE *pHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandle )( 
+            ID3D12Device6 * This,
+            _In_  HANDLE NTHandle,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvObj);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenSharedHandleByName )( 
+            ID3D12Device6 * This,
+            _In_  LPCWSTR Name,
+            DWORD Access,
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pNTHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeResident )( 
+            ID3D12Device6 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *Evict )( 
+            ID3D12Device6 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateFence )( 
+            ID3D12Device6 * This,
+            UINT64 InitialValue,
+            D3D12_FENCE_FLAGS Flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppFence);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDeviceRemovedReason )( 
+            ID3D12Device6 * This);
+        
+        void ( STDMETHODCALLTYPE *GetCopyableFootprints )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_RESOURCE_DESC *pResourceDesc,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES)  UINT FirstSubresource,
+            _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource)  UINT NumSubresources,
+            UINT64 BaseOffset,
+            _Out_writes_opt_(NumSubresources)  D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts,
+            _Out_writes_opt_(NumSubresources)  UINT *pNumRows,
+            _Out_writes_opt_(NumSubresources)  UINT64 *pRowSizeInBytes,
+            _Out_opt_  UINT64 *pTotalBytes);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateQueryHeap )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_QUERY_HEAP_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetStablePowerState )( 
+            ID3D12Device6 * This,
+            BOOL Enable);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandSignature )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_COMMAND_SIGNATURE_DESC *pDesc,
+            _In_opt_  ID3D12RootSignature *pRootSignature,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvCommandSignature);
+        
+        void ( STDMETHODCALLTYPE *GetResourceTiling )( 
+            ID3D12Device6 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _Out_opt_  UINT *pNumTilesForEntireResource,
+            _Out_opt_  D3D12_PACKED_MIP_INFO *pPackedMipDesc,
+            _Out_opt_  D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips,
+            _Inout_opt_  UINT *pNumSubresourceTilings,
+            _In_  UINT FirstSubresourceTilingToGet,
+            _Out_writes_(*pNumSubresourceTilings)  D3D12_SUBRESOURCE_TILING *pSubresourceTilingsForNonPackedMips);
+        
+        LUID ( STDMETHODCALLTYPE *GetAdapterLuid )( 
+            ID3D12Device6 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineLibrary )( 
+            ID3D12Device6 * This,
+            _In_reads_(BlobLength)  const void *pLibraryBlob,
+            SIZE_T BlobLength,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineLibrary);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEventOnMultipleFenceCompletion )( 
+            ID3D12Device6 * This,
+            _In_reads_(NumFences)  ID3D12Fence *const *ppFences,
+            _In_reads_(NumFences)  const UINT64 *pFenceValues,
+            UINT NumFences,
+            D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
+            HANDLE hEvent);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetResidencyPriority )( 
+            ID3D12Device6 * This,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_reads_(NumObjects)  const D3D12_RESIDENCY_PRIORITY *pPriorities);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreatePipelineState )( 
+            ID3D12Device6 * This,
+            const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppPipelineState);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenExistingHeapFromAddress )( 
+            ID3D12Device6 * This,
+            _In_  const void *pAddress,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *OpenExistingHeapFromFileMapping )( 
+            ID3D12Device6 * This,
+            _In_  HANDLE hFileMapping,
+            REFIID riid,
+            _COM_Outptr_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnqueueMakeResident )( 
+            ID3D12Device6 * This,
+            D3D12_RESIDENCY_FLAGS Flags,
+            UINT NumObjects,
+            _In_reads_(NumObjects)  ID3D12Pageable *const *ppObjects,
+            _In_  ID3D12Fence *pFenceToSignal,
+            UINT64 FenceValueToSignal);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommandList1 )( 
+            ID3D12Device6 * This,
+            _In_  UINT nodeMask,
+            _In_  D3D12_COMMAND_LIST_TYPE type,
+            _In_  D3D12_COMMAND_LIST_FLAGS flags,
+            REFIID riid,
+            _COM_Outptr_  void **ppCommandList);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateProtectedResourceSession )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_PROTECTED_RESOURCE_SESSION_DESC *pDesc,
+            _In_  REFIID riid,
+            _COM_Outptr_  void **ppSession);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateCommittedResource1 )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_HEAP_PROPERTIES *pHeapProperties,
+            D3D12_HEAP_FLAGS HeapFlags,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialResourceState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riidResource,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateHeap1 )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_HEAP_DESC *pDesc,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvHeap);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateReservedResource1 )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_RESOURCE_DESC *pDesc,
+            D3D12_RESOURCE_STATES InitialState,
+            _In_opt_  const D3D12_CLEAR_VALUE *pOptimizedClearValue,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedSession,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvResource);
+        
+        D3D12_RESOURCE_ALLOCATION_INFO ( STDMETHODCALLTYPE *GetResourceAllocationInfo1 )( 
+            ID3D12Device6 * This,
+            UINT visibleMask,
+            UINT numResourceDescs,
+            _In_reads_(numResourceDescs)  const D3D12_RESOURCE_DESC *pResourceDescs,
+            _Out_writes_opt_(numResourceDescs)  D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateLifetimeTracker )( 
+            ID3D12Device6 * This,
+            _In_  ID3D12LifetimeOwner *pOwner,
+            REFIID riid,
+            _COM_Outptr_  void **ppvTracker);
+        
+        void ( STDMETHODCALLTYPE *RemoveDevice )( 
+            ID3D12Device6 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumerateMetaCommands )( 
+            ID3D12Device6 * This,
+            _Inout_  UINT *pNumMetaCommands,
+            _Out_writes_opt_(*pNumMetaCommands)  D3D12_META_COMMAND_DESC *pDescs);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumerateMetaCommandParameters )( 
+            ID3D12Device6 * This,
+            _In_  REFGUID CommandId,
+            _In_  D3D12_META_COMMAND_PARAMETER_STAGE Stage,
+            _Out_opt_  UINT *pTotalStructureSizeInBytes,
+            _Inout_  UINT *pParameterCount,
+            _Out_writes_opt_(*pParameterCount)  D3D12_META_COMMAND_PARAMETER_DESC *pParameterDescs);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateMetaCommand )( 
+            ID3D12Device6 * This,
+            _In_  REFGUID CommandId,
+            _In_  UINT NodeMask,
+            _In_reads_bytes_opt_(CreationParametersDataSizeInBytes)  const void *pCreationParametersData,
+            _In_  SIZE_T CreationParametersDataSizeInBytes,
+            REFIID riid,
+            _COM_Outptr_  void **ppMetaCommand);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateStateObject )( 
+            ID3D12Device6 * This,
+            const D3D12_STATE_OBJECT_DESC *pDesc,
+            REFIID riid,
+            _COM_Outptr_  void **ppStateObject);
+        
+        void ( STDMETHODCALLTYPE *GetRaytracingAccelerationStructurePrebuildInfo )( 
+            ID3D12Device6 * This,
+            _In_  const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS *pDesc,
+            _Out_  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO *pInfo);
+        
+        D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS ( STDMETHODCALLTYPE *CheckDriverMatchingIdentifier )( 
+            ID3D12Device6 * This,
+            _In_  D3D12_SERIALIZED_DATA_TYPE SerializedDataType,
+            _In_  const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER *pIdentifierToCheck);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetBackgroundProcessingMode )( 
+            ID3D12Device6 * This,
+            D3D12_BACKGROUND_PROCESSING_MODE Mode,
+            D3D12_MEASUREMENTS_ACTION MeasurementsAction,
+            _In_opt_  HANDLE hEventToSignalUponCompletion,
+            _Out_opt_  BOOL *pbFurtherMeasurementsDesired);
+        
+        END_INTERFACE
+    } ID3D12Device6Vtbl;
+
+    interface ID3D12Device6
+    {
+        CONST_VTBL struct ID3D12Device6Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Device6_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Device6_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Device6_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Device6_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Device6_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Device6_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Device6_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Device6_GetNodeCount(This) \
+    ( (This)->lpVtbl -> GetNodeCount(This) ) 
+
+#define ID3D12Device6_CreateCommandQueue(This,pDesc,riid,ppCommandQueue) \
+    ( (This)->lpVtbl -> CreateCommandQueue(This,pDesc,riid,ppCommandQueue) ) 
+
+#define ID3D12Device6_CreateCommandAllocator(This,type,riid,ppCommandAllocator)  \
+    ( (This)->lpVtbl -> CreateCommandAllocator(This,type,riid,ppCommandAllocator) ) 
+
+#define ID3D12Device6_CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreateGraphicsPipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device6_CreateComputePipelineState(This,pDesc,riid,ppPipelineState)  \
+    ( (This)->lpVtbl -> CreateComputePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+#define ID3D12Device6_CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) \
+    ( (This)->lpVtbl -> CreateCommandList(This,nodeMask,type,pCommandAllocator,pInitialState,riid,ppCommandList) ) 
+
+#define ID3D12Device6_CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) \
+    ( (This)->lpVtbl -> CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) ) 
+
+#define ID3D12Device6_CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateDescriptorHeap(This,pDescriptorHeapDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device6_GetDescriptorHandleIncrementSize(This,DescriptorHeapType)  \
+    ( (This)->lpVtbl -> GetDescriptorHandleIncrementSize(This,DescriptorHeapType) ) 
+
+#define ID3D12Device6_CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature)  \
+    ( (This)->lpVtbl -> CreateRootSignature(This,nodeMask,pBlobWithRootSignature,blobLengthInBytes,riid,ppvRootSignature) ) 
+
+#define ID3D12Device6_CreateConstantBufferView(This,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateConstantBufferView(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device6_CreateShaderResourceView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateShaderResourceView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device6_CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateUnorderedAccessView(This,pResource,pCounterResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device6_CreateRenderTargetView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateRenderTargetView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device6_CreateDepthStencilView(This,pResource,pDesc,DestDescriptor)  \
+    ( (This)->lpVtbl -> CreateDepthStencilView(This,pResource,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device6_CreateSampler(This,pDesc,DestDescriptor) \
+    ( (This)->lpVtbl -> CreateSampler(This,pDesc,DestDescriptor) ) 
+
+#define ID3D12Device6_CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) \
+    ( (This)->lpVtbl -> CopyDescriptors(This,NumDestDescriptorRanges,pDestDescriptorRangeStarts,pDestDescriptorRangeSizes,NumSrcDescriptorRanges,pSrcDescriptorRangeStarts,pSrcDescriptorRangeSizes,DescriptorHeapsType) ) 
+
+#define ID3D12Device6_CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType)  \
+    ( (This)->lpVtbl -> CopyDescriptorsSimple(This,NumDescriptors,DestDescriptorRangeStart,SrcDescriptorRangeStart,DescriptorHeapsType) ) 
+
+#define ID3D12Device6_GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs)  \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo(This,visibleMask,numResourceDescs,pResourceDescs) ) 
+
+#define ID3D12Device6_GetCustomHeapProperties(This,nodeMask,heapType)  \
+    ( (This)->lpVtbl -> GetCustomHeapProperties(This,nodeMask,heapType) ) 
+
+#define ID3D12Device6_CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) \
+    ( (This)->lpVtbl -> CreateCommittedResource(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,riidResource,ppvResource) ) 
+
+#define ID3D12Device6_CreateHeap(This,pDesc,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> CreateHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device6_CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreatePlacedResource(This,pHeap,HeapOffset,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device6_CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource)  \
+    ( (This)->lpVtbl -> CreateReservedResource(This,pDesc,InitialState,pOptimizedClearValue,riid,ppvResource) ) 
+
+#define ID3D12Device6_CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) \
+    ( (This)->lpVtbl -> CreateSharedHandle(This,pObject,pAttributes,Access,Name,pHandle) ) 
+
+#define ID3D12Device6_OpenSharedHandle(This,NTHandle,riid,ppvObj)  \
+    ( (This)->lpVtbl -> OpenSharedHandle(This,NTHandle,riid,ppvObj) ) 
+
+#define ID3D12Device6_OpenSharedHandleByName(This,Name,Access,pNTHandle) \
+    ( (This)->lpVtbl -> OpenSharedHandleByName(This,Name,Access,pNTHandle) ) 
+
+#define ID3D12Device6_MakeResident(This,NumObjects,ppObjects)  \
+    ( (This)->lpVtbl -> MakeResident(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device6_Evict(This,NumObjects,ppObjects) \
+    ( (This)->lpVtbl -> Evict(This,NumObjects,ppObjects) ) 
+
+#define ID3D12Device6_CreateFence(This,InitialValue,Flags,riid,ppFence)  \
+    ( (This)->lpVtbl -> CreateFence(This,InitialValue,Flags,riid,ppFence) ) 
+
+#define ID3D12Device6_GetDeviceRemovedReason(This) \
+    ( (This)->lpVtbl -> GetDeviceRemovedReason(This) ) 
+
+#define ID3D12Device6_GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes)  \
+    ( (This)->lpVtbl -> GetCopyableFootprints(This,pResourceDesc,FirstSubresource,NumSubresources,BaseOffset,pLayouts,pNumRows,pRowSizeInBytes,pTotalBytes) ) 
+
+#define ID3D12Device6_CreateQueryHeap(This,pDesc,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateQueryHeap(This,pDesc,riid,ppvHeap) ) 
+
+#define ID3D12Device6_SetStablePowerState(This,Enable) \
+    ( (This)->lpVtbl -> SetStablePowerState(This,Enable) ) 
+
+#define ID3D12Device6_CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) \
+    ( (This)->lpVtbl -> CreateCommandSignature(This,pDesc,pRootSignature,riid,ppvCommandSignature) ) 
+
+#define ID3D12Device6_GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) \
+    ( (This)->lpVtbl -> GetResourceTiling(This,pTiledResource,pNumTilesForEntireResource,pPackedMipDesc,pStandardTileShapeForNonPackedMips,pNumSubresourceTilings,FirstSubresourceTilingToGet,pSubresourceTilingsForNonPackedMips) ) 
+
+#define ID3D12Device6_GetAdapterLuid(This) \
+    ( (This)->lpVtbl -> GetAdapterLuid(This) ) 
+
+
+#define ID3D12Device6_CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) \
+    ( (This)->lpVtbl -> CreatePipelineLibrary(This,pLibraryBlob,BlobLength,riid,ppPipelineLibrary) ) 
+
+#define ID3D12Device6_SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) \
+    ( (This)->lpVtbl -> SetEventOnMultipleFenceCompletion(This,ppFences,pFenceValues,NumFences,Flags,hEvent) ) 
+
+#define ID3D12Device6_SetResidencyPriority(This,NumObjects,ppObjects,pPriorities)  \
+    ( (This)->lpVtbl -> SetResidencyPriority(This,NumObjects,ppObjects,pPriorities) ) 
+
+
+#define ID3D12Device6_CreatePipelineState(This,pDesc,riid,ppPipelineState) \
+    ( (This)->lpVtbl -> CreatePipelineState(This,pDesc,riid,ppPipelineState) ) 
+
+
+#define ID3D12Device6_OpenExistingHeapFromAddress(This,pAddress,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> OpenExistingHeapFromAddress(This,pAddress,riid,ppvHeap) ) 
+
+#define ID3D12Device6_OpenExistingHeapFromFileMapping(This,hFileMapping,riid,ppvHeap)  \
+    ( (This)->lpVtbl -> OpenExistingHeapFromFileMapping(This,hFileMapping,riid,ppvHeap) ) 
+
+#define ID3D12Device6_EnqueueMakeResident(This,Flags,NumObjects,ppObjects,pFenceToSignal,FenceValueToSignal) \
+    ( (This)->lpVtbl -> EnqueueMakeResident(This,Flags,NumObjects,ppObjects,pFenceToSignal,FenceValueToSignal) ) 
+
+
+#define ID3D12Device6_CreateCommandList1(This,nodeMask,type,flags,riid,ppCommandList)  \
+    ( (This)->lpVtbl -> CreateCommandList1(This,nodeMask,type,flags,riid,ppCommandList) ) 
+
+#define ID3D12Device6_CreateProtectedResourceSession(This,pDesc,riid,ppSession)  \
+    ( (This)->lpVtbl -> CreateProtectedResourceSession(This,pDesc,riid,ppSession) ) 
+
+#define ID3D12Device6_CreateCommittedResource1(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,pProtectedSession,riidResource,ppvResource)  \
+    ( (This)->lpVtbl -> CreateCommittedResource1(This,pHeapProperties,HeapFlags,pDesc,InitialResourceState,pOptimizedClearValue,pProtectedSession,riidResource,ppvResource) ) 
+
+#define ID3D12Device6_CreateHeap1(This,pDesc,pProtectedSession,riid,ppvHeap) \
+    ( (This)->lpVtbl -> CreateHeap1(This,pDesc,pProtectedSession,riid,ppvHeap) ) 
+
+#define ID3D12Device6_CreateReservedResource1(This,pDesc,InitialState,pOptimizedClearValue,pProtectedSession,riid,ppvResource) \
+    ( (This)->lpVtbl -> CreateReservedResource1(This,pDesc,InitialState,pOptimizedClearValue,pProtectedSession,riid,ppvResource) ) 
+
+#define ID3D12Device6_GetResourceAllocationInfo1(This,visibleMask,numResourceDescs,pResourceDescs,pResourceAllocationInfo1)  \
+    ( (This)->lpVtbl -> GetResourceAllocationInfo1(This,visibleMask,numResourceDescs,pResourceDescs,pResourceAllocationInfo1) ) 
+
+
+#define ID3D12Device6_CreateLifetimeTracker(This,pOwner,riid,ppvTracker) \
+    ( (This)->lpVtbl -> CreateLifetimeTracker(This,pOwner,riid,ppvTracker) ) 
+
+#define ID3D12Device6_RemoveDevice(This) \
+    ( (This)->lpVtbl -> RemoveDevice(This) ) 
+
+#define ID3D12Device6_EnumerateMetaCommands(This,pNumMetaCommands,pDescs)  \
+    ( (This)->lpVtbl -> EnumerateMetaCommands(This,pNumMetaCommands,pDescs) ) 
+
+#define ID3D12Device6_EnumerateMetaCommandParameters(This,CommandId,Stage,pTotalStructureSizeInBytes,pParameterCount,pParameterDescs)  \
+    ( (This)->lpVtbl -> EnumerateMetaCommandParameters(This,CommandId,Stage,pTotalStructureSizeInBytes,pParameterCount,pParameterDescs) ) 
+
+#define ID3D12Device6_CreateMetaCommand(This,CommandId,NodeMask,pCreationParametersData,CreationParametersDataSizeInBytes,riid,ppMetaCommand)  \
+    ( (This)->lpVtbl -> CreateMetaCommand(This,CommandId,NodeMask,pCreationParametersData,CreationParametersDataSizeInBytes,riid,ppMetaCommand) ) 
+
+#define ID3D12Device6_CreateStateObject(This,pDesc,riid,ppStateObject) \
+    ( (This)->lpVtbl -> CreateStateObject(This,pDesc,riid,ppStateObject) ) 
+
+#define ID3D12Device6_GetRaytracingAccelerationStructurePrebuildInfo(This,pDesc,pInfo) \
+    ( (This)->lpVtbl -> GetRaytracingAccelerationStructurePrebuildInfo(This,pDesc,pInfo) ) 
+
+#define ID3D12Device6_CheckDriverMatchingIdentifier(This,SerializedDataType,pIdentifierToCheck)  \
+    ( (This)->lpVtbl -> CheckDriverMatchingIdentifier(This,SerializedDataType,pIdentifierToCheck) ) 
+
+
+#define ID3D12Device6_SetBackgroundProcessingMode(This,Mode,MeasurementsAction,hEventToSignalUponCompletion,pbFurtherMeasurementsDesired)  \
+    ( (This)->lpVtbl -> SetBackgroundProcessingMode(This,Mode,MeasurementsAction,hEventToSignalUponCompletion,pbFurtherMeasurementsDesired) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Device6_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Resource1_INTERFACE_DEFINED__
+#define __ID3D12Resource1_INTERFACE_DEFINED__
+
+/* interface ID3D12Resource1 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Resource1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("9D5E227A-4430-4161-88B3-3ECA6BB16E19")
+    ID3D12Resource1 : public ID3D12Resource
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetProtectedResourceSession( 
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppProtectedSession) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Resource1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Resource1 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Resource1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Resource1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Resource1 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Resource1 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Resource1 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Resource1 * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12Resource1 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *Map )( 
+            ID3D12Resource1 * This,
+            UINT Subresource,
+            _In_opt_  const D3D12_RANGE *pReadRange,
+            _Outptr_opt_result_bytebuffer_(_Inexpressible_("Dependent on resource"))  void **ppData);
+        
+        void ( STDMETHODCALLTYPE *Unmap )( 
+            ID3D12Resource1 * This,
+            UINT Subresource,
+            _In_opt_  const D3D12_RANGE *pWrittenRange);
+        
+        D3D12_RESOURCE_DESC ( STDMETHODCALLTYPE *GetDesc )( 
+            ID3D12Resource1 * This);
+        
+        D3D12_GPU_VIRTUAL_ADDRESS ( STDMETHODCALLTYPE *GetGPUVirtualAddress )( 
+            ID3D12Resource1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *WriteToSubresource )( 
+            ID3D12Resource1 * This,
+            UINT DstSubresource,
+            _In_opt_  const D3D12_BOX *pDstBox,
+            _In_  const void *pSrcData,
+            UINT SrcRowPitch,
+            UINT SrcDepthPitch);
+        
+        HRESULT ( STDMETHODCALLTYPE *ReadFromSubresource )( 
+            ID3D12Resource1 * This,
+            _Out_  void *pDstData,
+            UINT DstRowPitch,
+            UINT DstDepthPitch,
+            UINT SrcSubresource,
+            _In_opt_  const D3D12_BOX *pSrcBox);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetHeapProperties )( 
+            ID3D12Resource1 * This,
+            _Out_opt_  D3D12_HEAP_PROPERTIES *pHeapProperties,
+            _Out_opt_  D3D12_HEAP_FLAGS *pHeapFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetProtectedResourceSession )( 
+            ID3D12Resource1 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppProtectedSession);
+        
+        END_INTERFACE
+    } ID3D12Resource1Vtbl;
+
+    interface ID3D12Resource1
+    {
+        CONST_VTBL struct ID3D12Resource1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Resource1_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Resource1_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Resource1_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Resource1_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Resource1_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Resource1_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Resource1_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Resource1_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12Resource1_Map(This,Subresource,pReadRange,ppData)  \
+    ( (This)->lpVtbl -> Map(This,Subresource,pReadRange,ppData) ) 
+
+#define ID3D12Resource1_Unmap(This,Subresource,pWrittenRange)  \
+    ( (This)->lpVtbl -> Unmap(This,Subresource,pWrittenRange) ) 
+
+#define ID3D12Resource1_GetDesc(This)  \
+    ( (This)->lpVtbl -> GetDesc(This) ) 
+
+#define ID3D12Resource1_GetGPUVirtualAddress(This) \
+    ( (This)->lpVtbl -> GetGPUVirtualAddress(This) ) 
+
+#define ID3D12Resource1_WriteToSubresource(This,DstSubresource,pDstBox,pSrcData,SrcRowPitch,SrcDepthPitch) \
+    ( (This)->lpVtbl -> WriteToSubresource(This,DstSubresource,pDstBox,pSrcData,SrcRowPitch,SrcDepthPitch) ) 
+
+#define ID3D12Resource1_ReadFromSubresource(This,pDstData,DstRowPitch,DstDepthPitch,SrcSubresource,pSrcBox)  \
+    ( (This)->lpVtbl -> ReadFromSubresource(This,pDstData,DstRowPitch,DstDepthPitch,SrcSubresource,pSrcBox) ) 
+
+#define ID3D12Resource1_GetHeapProperties(This,pHeapProperties,pHeapFlags) \
+    ( (This)->lpVtbl -> GetHeapProperties(This,pHeapProperties,pHeapFlags) ) 
+
+
+#define ID3D12Resource1_GetProtectedResourceSession(This,riid,ppProtectedSession)  \
+    ( (This)->lpVtbl -> GetProtectedResourceSession(This,riid,ppProtectedSession) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Resource1_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Heap1_INTERFACE_DEFINED__
+#define __ID3D12Heap1_INTERFACE_DEFINED__
+
+/* interface ID3D12Heap1 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Heap1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("572F7389-2168-49E3-9693-D6DF5871BF6D")
+    ID3D12Heap1 : public ID3D12Heap
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetProtectedResourceSession( 
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppProtectedSession) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Heap1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Heap1 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Heap1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Heap1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12Heap1 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12Heap1 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12Heap1 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12Heap1 * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12Heap1 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_HEAP_DESC ( STDMETHODCALLTYPE *GetDesc )( 
+            ID3D12Heap1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetProtectedResourceSession )( 
+            ID3D12Heap1 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppProtectedSession);
+        
+        END_INTERFACE
+    } ID3D12Heap1Vtbl;
+
+    interface ID3D12Heap1
+    {
+        CONST_VTBL struct ID3D12Heap1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Heap1_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Heap1_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Heap1_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Heap1_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12Heap1_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12Heap1_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12Heap1_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12Heap1_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12Heap1_GetDesc(This)  \
+    ( (This)->lpVtbl -> GetDesc(This) ) 
+
+
+#define ID3D12Heap1_GetProtectedResourceSession(This,riid,ppProtectedSession)  \
+    ( (This)->lpVtbl -> GetProtectedResourceSession(This,riid,ppProtectedSession) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Heap1_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12GraphicsCommandList3_INTERFACE_DEFINED__
+#define __ID3D12GraphicsCommandList3_INTERFACE_DEFINED__
+
+/* interface ID3D12GraphicsCommandList3 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12GraphicsCommandList3;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6FDA83A7-B84C-4E38-9AC8-C7BD22016B3D")
+    ID3D12GraphicsCommandList3 : public ID3D12GraphicsCommandList2
+    {
+    public:
+        virtual void STDMETHODCALLTYPE SetProtectedResourceSession( 
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedResourceSession) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12GraphicsCommandList3Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12GraphicsCommandList3 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12GraphicsCommandList3 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12GraphicsCommandList3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12GraphicsCommandList3 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_COMMAND_LIST_TYPE ( STDMETHODCALLTYPE *GetType )( 
+            ID3D12GraphicsCommandList3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Close )( 
+            ID3D12GraphicsCommandList3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Reset )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12CommandAllocator *pAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState);
+        
+        void ( STDMETHODCALLTYPE *ClearState )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_opt_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *DrawInstanced )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT VertexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *DrawIndexedInstanced )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT IndexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartIndexLocation,
+            _In_  INT BaseVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *Dispatch )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT ThreadGroupCountX,
+            _In_  UINT ThreadGroupCountY,
+            _In_  UINT ThreadGroupCountZ);
+        
+        void ( STDMETHODCALLTYPE *CopyBufferRegion )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT64 NumBytes);
+        
+        void ( STDMETHODCALLTYPE *CopyTextureRegion )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pDst,
+            UINT DstX,
+            UINT DstY,
+            UINT DstZ,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pSrc,
+            _In_opt_  const D3D12_BOX *pSrcBox);
+        
+        void ( STDMETHODCALLTYPE *CopyResource )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  ID3D12Resource *pSrcResource);
+        
+        void ( STDMETHODCALLTYPE *CopyTiles )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate,
+            _In_  const D3D12_TILE_REGION_SIZE *pTileRegionSize,
+            _In_  ID3D12Resource *pBuffer,
+            UINT64 BufferStartOffsetInBytes,
+            D3D12_TILE_COPY_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresource )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_  DXGI_FORMAT Format);
+        
+        void ( STDMETHODCALLTYPE *IASetPrimitiveTopology )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology);
+        
+        void ( STDMETHODCALLTYPE *RSSetViewports )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumViewports,
+            _In_reads_( NumViewports)  const D3D12_VIEWPORT *pViewports);
+        
+        void ( STDMETHODCALLTYPE *RSSetScissorRects )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumRects,
+            _In_reads_( NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *OMSetBlendFactor )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_reads_opt_(4)  const FLOAT BlendFactor[ 4 ]);
+        
+        void ( STDMETHODCALLTYPE *OMSetStencilRef )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT StencilRef);
+        
+        void ( STDMETHODCALLTYPE *SetPipelineState )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *ResourceBarrier )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT NumBarriers,
+            _In_reads_(NumBarriers)  const D3D12_RESOURCE_BARRIER *pBarriers);
+        
+        void ( STDMETHODCALLTYPE *ExecuteBundle )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12GraphicsCommandList *pCommandList);
+        
+        void ( STDMETHODCALLTYPE *SetDescriptorHeaps )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT NumDescriptorHeaps,
+            _In_reads_(NumDescriptorHeaps)  ID3D12DescriptorHeap *const *ppDescriptorHeaps);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootSignature )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootSignature )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootDescriptorTable )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootDescriptorTable )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstant )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstant )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstants )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstants )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootConstantBufferView )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootConstantBufferView )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootShaderResourceView )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootShaderResourceView )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *IASetIndexBuffer )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_opt_  const D3D12_INDEX_BUFFER_VIEW *pView);
+        
+        void ( STDMETHODCALLTYPE *IASetVertexBuffers )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_VERTEX_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *SOSetTargets )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *OMSetRenderTargets )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT NumRenderTargetDescriptors,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pRenderTargetDescriptors,
+            _In_  BOOL RTsSingleHandleToDescriptorRange,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pDepthStencilDescriptor);
+        
+        void ( STDMETHODCALLTYPE *ClearDepthStencilView )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,
+            _In_  D3D12_CLEAR_FLAGS ClearFlags,
+            _In_  FLOAT Depth,
+            _In_  UINT8 Stencil,
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearRenderTargetView )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,
+            _In_  const FLOAT ColorRGBA[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewUint )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const UINT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewFloat )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const FLOAT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *DiscardResource )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DISCARD_REGION *pRegion);
+        
+        void ( STDMETHODCALLTYPE *BeginQuery )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *EndQuery )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *ResolveQueryData )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT StartIndex,
+            _In_  UINT NumQueries,
+            _In_  ID3D12Resource *pDestinationBuffer,
+            _In_  UINT64 AlignedDestinationBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *SetPredication )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_opt_  ID3D12Resource *pBuffer,
+            _In_  UINT64 AlignedBufferOffset,
+            _In_  D3D12_PREDICATION_OP Operation);
+        
+        void ( STDMETHODCALLTYPE *SetMarker )( 
+            ID3D12GraphicsCommandList3 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *BeginEvent )( 
+            ID3D12GraphicsCommandList3 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *EndEvent )( 
+            ID3D12GraphicsCommandList3 * This);
+        
+        void ( STDMETHODCALLTYPE *ExecuteIndirect )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12CommandSignature *pCommandSignature,
+            _In_  UINT MaxCommandCount,
+            _In_  ID3D12Resource *pArgumentBuffer,
+            _In_  UINT64 ArgumentBufferOffset,
+            _In_opt_  ID3D12Resource *pCountBuffer,
+            _In_  UINT64 CountBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT64 )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *OMSetDepthBounds )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  FLOAT Min,
+            _In_  FLOAT Max);
+        
+        void ( STDMETHODCALLTYPE *SetSamplePositions )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT NumSamplesPerPixel,
+            _In_  UINT NumPixels,
+            _In_reads_(NumSamplesPerPixel*NumPixels)  D3D12_SAMPLE_POSITION *pSamplePositions);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresourceRegion )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  UINT DstX,
+            _In_  UINT DstY,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_opt_  D3D12_RECT *pSrcRect,
+            _In_  DXGI_FORMAT Format,
+            _In_  D3D12_RESOLVE_MODE ResolveMode);
+        
+        void ( STDMETHODCALLTYPE *SetViewInstanceMask )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_  UINT Mask);
+        
+        void ( STDMETHODCALLTYPE *WriteBufferImmediate )( 
+            ID3D12GraphicsCommandList3 * This,
+            UINT Count,
+            _In_reads_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *pParams,
+            _In_reads_opt_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_MODE *pModes);
+        
+        void ( STDMETHODCALLTYPE *SetProtectedResourceSession )( 
+            ID3D12GraphicsCommandList3 * This,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedResourceSession);
+        
+        END_INTERFACE
+    } ID3D12GraphicsCommandList3Vtbl;
+
+    interface ID3D12GraphicsCommandList3
+    {
+        CONST_VTBL struct ID3D12GraphicsCommandList3Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12GraphicsCommandList3_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12GraphicsCommandList3_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12GraphicsCommandList3_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12GraphicsCommandList3_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList3_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList3_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12GraphicsCommandList3_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12GraphicsCommandList3_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12GraphicsCommandList3_GetType(This) \
+    ( (This)->lpVtbl -> GetType(This) ) 
+
+
+#define ID3D12GraphicsCommandList3_Close(This) \
+    ( (This)->lpVtbl -> Close(This) ) 
+
+#define ID3D12GraphicsCommandList3_Reset(This,pAllocator,pInitialState)  \
+    ( (This)->lpVtbl -> Reset(This,pAllocator,pInitialState) ) 
+
+#define ID3D12GraphicsCommandList3_ClearState(This,pPipelineState) \
+    ( (This)->lpVtbl -> ClearState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList3_DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList3_DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList3_Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ)  \
+    ( (This)->lpVtbl -> Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ) ) 
+
+#define ID3D12GraphicsCommandList3_CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) \
+    ( (This)->lpVtbl -> CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) ) 
+
+#define ID3D12GraphicsCommandList3_CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox)  \
+    ( (This)->lpVtbl -> CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox) ) 
+
+#define ID3D12GraphicsCommandList3_CopyResource(This,pDstResource,pSrcResource)  \
+    ( (This)->lpVtbl -> CopyResource(This,pDstResource,pSrcResource) ) 
+
+#define ID3D12GraphicsCommandList3_CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags)  \
+    ( (This)->lpVtbl -> CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags) ) 
+
+#define ID3D12GraphicsCommandList3_ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) \
+    ( (This)->lpVtbl -> ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) ) 
+
+#define ID3D12GraphicsCommandList3_IASetPrimitiveTopology(This,PrimitiveTopology)  \
+    ( (This)->lpVtbl -> IASetPrimitiveTopology(This,PrimitiveTopology) ) 
+
+#define ID3D12GraphicsCommandList3_RSSetViewports(This,NumViewports,pViewports)  \
+    ( (This)->lpVtbl -> RSSetViewports(This,NumViewports,pViewports) ) 
+
+#define ID3D12GraphicsCommandList3_RSSetScissorRects(This,NumRects,pRects) \
+    ( (This)->lpVtbl -> RSSetScissorRects(This,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList3_OMSetBlendFactor(This,BlendFactor)  \
+    ( (This)->lpVtbl -> OMSetBlendFactor(This,BlendFactor) ) 
+
+#define ID3D12GraphicsCommandList3_OMSetStencilRef(This,StencilRef)  \
+    ( (This)->lpVtbl -> OMSetStencilRef(This,StencilRef) ) 
+
+#define ID3D12GraphicsCommandList3_SetPipelineState(This,pPipelineState) \
+    ( (This)->lpVtbl -> SetPipelineState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList3_ResourceBarrier(This,NumBarriers,pBarriers) \
+    ( (This)->lpVtbl -> ResourceBarrier(This,NumBarriers,pBarriers) ) 
+
+#define ID3D12GraphicsCommandList3_ExecuteBundle(This,pCommandList)  \
+    ( (This)->lpVtbl -> ExecuteBundle(This,pCommandList) ) 
+
+#define ID3D12GraphicsCommandList3_SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) \
+    ( (This)->lpVtbl -> SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) ) 
+
+#define ID3D12GraphicsCommandList3_SetComputeRootSignature(This,pRootSignature)  \
+    ( (This)->lpVtbl -> SetComputeRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList3_SetGraphicsRootSignature(This,pRootSignature) \
+    ( (This)->lpVtbl -> SetGraphicsRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList3_SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) \
+    ( (This)->lpVtbl -> SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList3_SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor)  \
+    ( (This)->lpVtbl -> SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList3_SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList3_SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList3_SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList3_SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList3_SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList3_SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList3_SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList3_SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList3_SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList3_SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList3_IASetIndexBuffer(This,pView)  \
+    ( (This)->lpVtbl -> IASetIndexBuffer(This,pView) ) 
+
+#define ID3D12GraphicsCommandList3_IASetVertexBuffers(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> IASetVertexBuffers(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList3_SOSetTargets(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> SOSetTargets(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList3_OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) \
+    ( (This)->lpVtbl -> OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) ) 
+
+#define ID3D12GraphicsCommandList3_ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList3_ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList3_ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList3_ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList3_DiscardResource(This,pResource,pRegion) \
+    ( (This)->lpVtbl -> DiscardResource(This,pResource,pRegion) ) 
+
+#define ID3D12GraphicsCommandList3_BeginQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> BeginQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList3_EndQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> EndQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList3_ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset)  \
+    ( (This)->lpVtbl -> ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset) ) 
+
+#define ID3D12GraphicsCommandList3_SetPredication(This,pBuffer,AlignedBufferOffset,Operation)  \
+    ( (This)->lpVtbl -> SetPredication(This,pBuffer,AlignedBufferOffset,Operation) ) 
+
+#define ID3D12GraphicsCommandList3_SetMarker(This,Metadata,pData,Size) \
+    ( (This)->lpVtbl -> SetMarker(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList3_BeginEvent(This,Metadata,pData,Size)  \
+    ( (This)->lpVtbl -> BeginEvent(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList3_EndEvent(This)  \
+    ( (This)->lpVtbl -> EndEvent(This) ) 
+
+#define ID3D12GraphicsCommandList3_ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) \
+    ( (This)->lpVtbl -> ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) ) 
+
+
+#define ID3D12GraphicsCommandList3_AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList3_AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList3_OMSetDepthBounds(This,Min,Max)  \
+    ( (This)->lpVtbl -> OMSetDepthBounds(This,Min,Max) ) 
+
+#define ID3D12GraphicsCommandList3_SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions)  \
+    ( (This)->lpVtbl -> SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions) ) 
+
+#define ID3D12GraphicsCommandList3_ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode)  \
+    ( (This)->lpVtbl -> ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode) ) 
+
+#define ID3D12GraphicsCommandList3_SetViewInstanceMask(This,Mask)  \
+    ( (This)->lpVtbl -> SetViewInstanceMask(This,Mask) ) 
+
+
+#define ID3D12GraphicsCommandList3_WriteBufferImmediate(This,Count,pParams,pModes) \
+    ( (This)->lpVtbl -> WriteBufferImmediate(This,Count,pParams,pModes) ) 
+
+
+#define ID3D12GraphicsCommandList3_SetProtectedResourceSession(This,pProtectedResourceSession) \
+    ( (This)->lpVtbl -> SetProtectedResourceSession(This,pProtectedResourceSession) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12GraphicsCommandList3_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0041 */
+/* [local] */ 
+
+typedef 
+enum D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE
+    {
+        D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_DISCARD  = 0,
+        D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_PRESERVE = ( D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_DISCARD + 1 ) ,
+        D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR  = ( D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_PRESERVE + 1 ) ,
+        D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_NO_ACCESS  = ( D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR + 1 ) 
+    }  D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE;
+
+typedef struct D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS
+    {
+    D3D12_CLEAR_VALUE ClearValue;
+    }  D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS;
+
+typedef struct D3D12_RENDER_PASS_BEGINNING_ACCESS
+    {
+    D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE Type;
+    union 
+        {
+        D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS Clear;
+        }  ;
+    }  D3D12_RENDER_PASS_BEGINNING_ACCESS;
+
+typedef 
+enum D3D12_RENDER_PASS_ENDING_ACCESS_TYPE
+    {
+        D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_DISCARD = 0,
+        D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE  = ( D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_DISCARD + 1 ) ,
+        D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_RESOLVE = ( D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE + 1 ) ,
+        D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_NO_ACCESS = ( D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_RESOLVE + 1 ) 
+    }  D3D12_RENDER_PASS_ENDING_ACCESS_TYPE;
+
+typedef struct D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS
+    {
+    UINT SrcSubresource;
+    UINT DstSubresource;
+    UINT DstX;
+    UINT DstY;
+    D3D12_RECT SrcRect;
+    }  D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS;
+
+typedef struct D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS
+    {
+    ID3D12Resource *pSrcResource;
+    ID3D12Resource *pDstResource;
+    UINT SubresourceCount;
+    _Field_size_full_(SubresourceCount)  const D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS *pSubresourceParameters;
+    DXGI_FORMAT Format;
+    D3D12_RESOLVE_MODE ResolveMode;
+    BOOL PreserveResolveSource;
+    }  D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS;
+
+typedef struct D3D12_RENDER_PASS_ENDING_ACCESS
+    {
+    D3D12_RENDER_PASS_ENDING_ACCESS_TYPE Type;
+    union 
+        {
+        D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS Resolve;
+        }  ;
+    }  D3D12_RENDER_PASS_ENDING_ACCESS;
+
+typedef struct D3D12_RENDER_PASS_RENDER_TARGET_DESC
+    {
+    D3D12_CPU_DESCRIPTOR_HANDLE cpuDescriptor;
+    D3D12_RENDER_PASS_BEGINNING_ACCESS BeginningAccess;
+    D3D12_RENDER_PASS_ENDING_ACCESS EndingAccess;
+    }  D3D12_RENDER_PASS_RENDER_TARGET_DESC;
+
+typedef struct D3D12_RENDER_PASS_DEPTH_STENCIL_DESC
+    {
+    D3D12_CPU_DESCRIPTOR_HANDLE cpuDescriptor;
+    D3D12_RENDER_PASS_BEGINNING_ACCESS DepthBeginningAccess;
+    D3D12_RENDER_PASS_BEGINNING_ACCESS StencilBeginningAccess;
+    D3D12_RENDER_PASS_ENDING_ACCESS DepthEndingAccess;
+    D3D12_RENDER_PASS_ENDING_ACCESS StencilEndingAccess;
+    }  D3D12_RENDER_PASS_DEPTH_STENCIL_DESC;
+
+typedef 
+enum D3D12_RENDER_PASS_FLAGS
+    {
+        D3D12_RENDER_PASS_FLAG_NONE  = 0,
+        D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES  = 0x1,
+        D3D12_RENDER_PASS_FLAG_SUSPENDING_PASS = 0x2,
+        D3D12_RENDER_PASS_FLAG_RESUMING_PASS = 0x4
+    }  D3D12_RENDER_PASS_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS( D3D12_RENDER_PASS_FLAGS );
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0041_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0041_v0_0_s_ifspec;
+
+#ifndef __ID3D12MetaCommand_INTERFACE_DEFINED__
+#define __ID3D12MetaCommand_INTERFACE_DEFINED__
+
+/* interface ID3D12MetaCommand */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12MetaCommand;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("DBB84C27-36CE-4FC9-B801-F048C46AC570")
+    ID3D12MetaCommand : public ID3D12Pageable
+    {
+    public:
+        virtual UINT64 STDMETHODCALLTYPE GetRequiredParameterResourceSize( 
+            _In_  D3D12_META_COMMAND_PARAMETER_STAGE Stage,
+            _In_  UINT ParameterIndex) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12MetaCommandVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12MetaCommand * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12MetaCommand * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12MetaCommand * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12MetaCommand * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12MetaCommand * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12MetaCommand * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12MetaCommand * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12MetaCommand * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetRequiredParameterResourceSize )( 
+            ID3D12MetaCommand * This,
+            _In_  D3D12_META_COMMAND_PARAMETER_STAGE Stage,
+            _In_  UINT ParameterIndex);
+        
+        END_INTERFACE
+    } ID3D12MetaCommandVtbl;
+
+    interface ID3D12MetaCommand
+    {
+        CONST_VTBL struct ID3D12MetaCommandVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12MetaCommand_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12MetaCommand_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12MetaCommand_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12MetaCommand_GetPrivateData(This,guid,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12MetaCommand_SetPrivateData(This,guid,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12MetaCommand_SetPrivateDataInterface(This,guid,pData) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12MetaCommand_SetName(This,Name) \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12MetaCommand_GetDevice(This,riid,ppvDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+
+#define ID3D12MetaCommand_GetRequiredParameterResourceSize(This,Stage,ParameterIndex)  \
+    ( (This)->lpVtbl -> GetRequiredParameterResourceSize(This,Stage,ParameterIndex) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12MetaCommand_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0042 */
+/* [local] */ 
+
+typedef struct D3D12_DISPATCH_RAYS_DESC
+    {
+    D3D12_GPU_VIRTUAL_ADDRESS_RANGE RayGenerationShaderRecord;
+    D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE MissShaderTable;
+    D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE HitGroupTable;
+    D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE CallableShaderTable;
+    UINT Width;
+    UINT Height;
+    UINT Depth;
+    }  D3D12_DISPATCH_RAYS_DESC;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0042_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0042_v0_0_s_ifspec;
+
+#ifndef __ID3D12GraphicsCommandList4_INTERFACE_DEFINED__
+#define __ID3D12GraphicsCommandList4_INTERFACE_DEFINED__
+
+/* interface ID3D12GraphicsCommandList4 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12GraphicsCommandList4;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("8754318e-d3a9-4541-98cf-645b50dc4874")
+    ID3D12GraphicsCommandList4 : public ID3D12GraphicsCommandList3
+    {
+    public:
+        virtual void STDMETHODCALLTYPE BeginRenderPass( 
+            _In_  UINT NumRenderTargets,
+            _In_reads_opt_(NumRenderTargets)  const D3D12_RENDER_PASS_RENDER_TARGET_DESC *pRenderTargets,
+            _In_opt_  const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC *pDepthStencil,
+            D3D12_RENDER_PASS_FLAGS Flags) = 0;
+        
+        virtual void STDMETHODCALLTYPE EndRenderPass( void) = 0;
+        
+        virtual void STDMETHODCALLTYPE InitializeMetaCommand( 
+            _In_  ID3D12MetaCommand *pMetaCommand,
+            _In_reads_bytes_opt_(InitializationParametersDataSizeInBytes)  const void *pInitializationParametersData,
+            _In_  SIZE_T InitializationParametersDataSizeInBytes) = 0;
+        
+        virtual void STDMETHODCALLTYPE ExecuteMetaCommand( 
+            _In_  ID3D12MetaCommand *pMetaCommand,
+            _In_reads_bytes_opt_(ExecutionParametersDataSizeInBytes)  const void *pExecutionParametersData,
+            _In_  SIZE_T ExecutionParametersDataSizeInBytes) = 0;
+        
+        virtual void STDMETHODCALLTYPE BuildRaytracingAccelerationStructure( 
+            _In_  const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC *pDesc,
+            _In_  UINT NumPostbuildInfoDescs,
+            _In_reads_opt_(NumPostbuildInfoDescs)  const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pPostbuildInfoDescs) = 0;
+        
+        virtual void STDMETHODCALLTYPE EmitRaytracingAccelerationStructurePostbuildInfo( 
+            _In_  const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pDesc,
+            _In_  UINT NumSourceAccelerationStructures,
+            _In_reads_( NumSourceAccelerationStructures )  const D3D12_GPU_VIRTUAL_ADDRESS *pSourceAccelerationStructureData) = 0;
+        
+        virtual void STDMETHODCALLTYPE CopyRaytracingAccelerationStructure( 
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData,
+            _In_  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetPipelineState1( 
+            _In_  ID3D12StateObject *pStateObject) = 0;
+        
+        virtual void STDMETHODCALLTYPE DispatchRays( 
+            _In_  const D3D12_DISPATCH_RAYS_DESC *pDesc) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12GraphicsCommandList4Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12GraphicsCommandList4 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12GraphicsCommandList4 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12GraphicsCommandList4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12GraphicsCommandList4 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_COMMAND_LIST_TYPE ( STDMETHODCALLTYPE *GetType )( 
+            ID3D12GraphicsCommandList4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Close )( 
+            ID3D12GraphicsCommandList4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Reset )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12CommandAllocator *pAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState);
+        
+        void ( STDMETHODCALLTYPE *ClearState )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_opt_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *DrawInstanced )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT VertexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *DrawIndexedInstanced )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT IndexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartIndexLocation,
+            _In_  INT BaseVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *Dispatch )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT ThreadGroupCountX,
+            _In_  UINT ThreadGroupCountY,
+            _In_  UINT ThreadGroupCountZ);
+        
+        void ( STDMETHODCALLTYPE *CopyBufferRegion )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT64 NumBytes);
+        
+        void ( STDMETHODCALLTYPE *CopyTextureRegion )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pDst,
+            UINT DstX,
+            UINT DstY,
+            UINT DstZ,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pSrc,
+            _In_opt_  const D3D12_BOX *pSrcBox);
+        
+        void ( STDMETHODCALLTYPE *CopyResource )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  ID3D12Resource *pSrcResource);
+        
+        void ( STDMETHODCALLTYPE *CopyTiles )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate,
+            _In_  const D3D12_TILE_REGION_SIZE *pTileRegionSize,
+            _In_  ID3D12Resource *pBuffer,
+            UINT64 BufferStartOffsetInBytes,
+            D3D12_TILE_COPY_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresource )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_  DXGI_FORMAT Format);
+        
+        void ( STDMETHODCALLTYPE *IASetPrimitiveTopology )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology);
+        
+        void ( STDMETHODCALLTYPE *RSSetViewports )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumViewports,
+            _In_reads_( NumViewports)  const D3D12_VIEWPORT *pViewports);
+        
+        void ( STDMETHODCALLTYPE *RSSetScissorRects )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumRects,
+            _In_reads_( NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *OMSetBlendFactor )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_reads_opt_(4)  const FLOAT BlendFactor[ 4 ]);
+        
+        void ( STDMETHODCALLTYPE *OMSetStencilRef )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT StencilRef);
+        
+        void ( STDMETHODCALLTYPE *SetPipelineState )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *ResourceBarrier )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT NumBarriers,
+            _In_reads_(NumBarriers)  const D3D12_RESOURCE_BARRIER *pBarriers);
+        
+        void ( STDMETHODCALLTYPE *ExecuteBundle )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12GraphicsCommandList *pCommandList);
+        
+        void ( STDMETHODCALLTYPE *SetDescriptorHeaps )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT NumDescriptorHeaps,
+            _In_reads_(NumDescriptorHeaps)  ID3D12DescriptorHeap *const *ppDescriptorHeaps);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootSignature )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootSignature )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootDescriptorTable )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootDescriptorTable )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstant )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstant )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstants )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstants )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootConstantBufferView )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootConstantBufferView )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootShaderResourceView )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootShaderResourceView )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *IASetIndexBuffer )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_opt_  const D3D12_INDEX_BUFFER_VIEW *pView);
+        
+        void ( STDMETHODCALLTYPE *IASetVertexBuffers )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_VERTEX_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *SOSetTargets )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *OMSetRenderTargets )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT NumRenderTargetDescriptors,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pRenderTargetDescriptors,
+            _In_  BOOL RTsSingleHandleToDescriptorRange,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pDepthStencilDescriptor);
+        
+        void ( STDMETHODCALLTYPE *ClearDepthStencilView )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,
+            _In_  D3D12_CLEAR_FLAGS ClearFlags,
+            _In_  FLOAT Depth,
+            _In_  UINT8 Stencil,
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearRenderTargetView )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,
+            _In_  const FLOAT ColorRGBA[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewUint )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const UINT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewFloat )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const FLOAT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *DiscardResource )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DISCARD_REGION *pRegion);
+        
+        void ( STDMETHODCALLTYPE *BeginQuery )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *EndQuery )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *ResolveQueryData )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT StartIndex,
+            _In_  UINT NumQueries,
+            _In_  ID3D12Resource *pDestinationBuffer,
+            _In_  UINT64 AlignedDestinationBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *SetPredication )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_opt_  ID3D12Resource *pBuffer,
+            _In_  UINT64 AlignedBufferOffset,
+            _In_  D3D12_PREDICATION_OP Operation);
+        
+        void ( STDMETHODCALLTYPE *SetMarker )( 
+            ID3D12GraphicsCommandList4 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *BeginEvent )( 
+            ID3D12GraphicsCommandList4 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *EndEvent )( 
+            ID3D12GraphicsCommandList4 * This);
+        
+        void ( STDMETHODCALLTYPE *ExecuteIndirect )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12CommandSignature *pCommandSignature,
+            _In_  UINT MaxCommandCount,
+            _In_  ID3D12Resource *pArgumentBuffer,
+            _In_  UINT64 ArgumentBufferOffset,
+            _In_opt_  ID3D12Resource *pCountBuffer,
+            _In_  UINT64 CountBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT64 )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *OMSetDepthBounds )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  FLOAT Min,
+            _In_  FLOAT Max);
+        
+        void ( STDMETHODCALLTYPE *SetSamplePositions )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT NumSamplesPerPixel,
+            _In_  UINT NumPixels,
+            _In_reads_(NumSamplesPerPixel*NumPixels)  D3D12_SAMPLE_POSITION *pSamplePositions);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresourceRegion )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  UINT DstX,
+            _In_  UINT DstY,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_opt_  D3D12_RECT *pSrcRect,
+            _In_  DXGI_FORMAT Format,
+            _In_  D3D12_RESOLVE_MODE ResolveMode);
+        
+        void ( STDMETHODCALLTYPE *SetViewInstanceMask )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT Mask);
+        
+        void ( STDMETHODCALLTYPE *WriteBufferImmediate )( 
+            ID3D12GraphicsCommandList4 * This,
+            UINT Count,
+            _In_reads_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *pParams,
+            _In_reads_opt_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_MODE *pModes);
+        
+        void ( STDMETHODCALLTYPE *SetProtectedResourceSession )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedResourceSession);
+        
+        void ( STDMETHODCALLTYPE *BeginRenderPass )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  UINT NumRenderTargets,
+            _In_reads_opt_(NumRenderTargets)  const D3D12_RENDER_PASS_RENDER_TARGET_DESC *pRenderTargets,
+            _In_opt_  const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC *pDepthStencil,
+            D3D12_RENDER_PASS_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *EndRenderPass )( 
+            ID3D12GraphicsCommandList4 * This);
+        
+        void ( STDMETHODCALLTYPE *InitializeMetaCommand )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12MetaCommand *pMetaCommand,
+            _In_reads_bytes_opt_(InitializationParametersDataSizeInBytes)  const void *pInitializationParametersData,
+            _In_  SIZE_T InitializationParametersDataSizeInBytes);
+        
+        void ( STDMETHODCALLTYPE *ExecuteMetaCommand )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12MetaCommand *pMetaCommand,
+            _In_reads_bytes_opt_(ExecutionParametersDataSizeInBytes)  const void *pExecutionParametersData,
+            _In_  SIZE_T ExecutionParametersDataSizeInBytes);
+        
+        void ( STDMETHODCALLTYPE *BuildRaytracingAccelerationStructure )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC *pDesc,
+            _In_  UINT NumPostbuildInfoDescs,
+            _In_reads_opt_(NumPostbuildInfoDescs)  const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pPostbuildInfoDescs);
+        
+        void ( STDMETHODCALLTYPE *EmitRaytracingAccelerationStructurePostbuildInfo )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pDesc,
+            _In_  UINT NumSourceAccelerationStructures,
+            _In_reads_( NumSourceAccelerationStructures )  const D3D12_GPU_VIRTUAL_ADDRESS *pSourceAccelerationStructureData);
+        
+        void ( STDMETHODCALLTYPE *CopyRaytracingAccelerationStructure )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData,
+            _In_  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode);
+        
+        void ( STDMETHODCALLTYPE *SetPipelineState1 )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  ID3D12StateObject *pStateObject);
+        
+        void ( STDMETHODCALLTYPE *DispatchRays )( 
+            ID3D12GraphicsCommandList4 * This,
+            _In_  const D3D12_DISPATCH_RAYS_DESC *pDesc);
+        
+        END_INTERFACE
+    } ID3D12GraphicsCommandList4Vtbl;
+
+    interface ID3D12GraphicsCommandList4
+    {
+        CONST_VTBL struct ID3D12GraphicsCommandList4Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12GraphicsCommandList4_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12GraphicsCommandList4_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12GraphicsCommandList4_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12GraphicsCommandList4_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList4_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList4_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12GraphicsCommandList4_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12GraphicsCommandList4_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12GraphicsCommandList4_GetType(This) \
+    ( (This)->lpVtbl -> GetType(This) ) 
+
+
+#define ID3D12GraphicsCommandList4_Close(This) \
+    ( (This)->lpVtbl -> Close(This) ) 
+
+#define ID3D12GraphicsCommandList4_Reset(This,pAllocator,pInitialState)  \
+    ( (This)->lpVtbl -> Reset(This,pAllocator,pInitialState) ) 
+
+#define ID3D12GraphicsCommandList4_ClearState(This,pPipelineState) \
+    ( (This)->lpVtbl -> ClearState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList4_DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList4_DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList4_Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ)  \
+    ( (This)->lpVtbl -> Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ) ) 
+
+#define ID3D12GraphicsCommandList4_CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) \
+    ( (This)->lpVtbl -> CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) ) 
+
+#define ID3D12GraphicsCommandList4_CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox)  \
+    ( (This)->lpVtbl -> CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox) ) 
+
+#define ID3D12GraphicsCommandList4_CopyResource(This,pDstResource,pSrcResource)  \
+    ( (This)->lpVtbl -> CopyResource(This,pDstResource,pSrcResource) ) 
+
+#define ID3D12GraphicsCommandList4_CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags)  \
+    ( (This)->lpVtbl -> CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags) ) 
+
+#define ID3D12GraphicsCommandList4_ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) \
+    ( (This)->lpVtbl -> ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) ) 
+
+#define ID3D12GraphicsCommandList4_IASetPrimitiveTopology(This,PrimitiveTopology)  \
+    ( (This)->lpVtbl -> IASetPrimitiveTopology(This,PrimitiveTopology) ) 
+
+#define ID3D12GraphicsCommandList4_RSSetViewports(This,NumViewports,pViewports)  \
+    ( (This)->lpVtbl -> RSSetViewports(This,NumViewports,pViewports) ) 
+
+#define ID3D12GraphicsCommandList4_RSSetScissorRects(This,NumRects,pRects) \
+    ( (This)->lpVtbl -> RSSetScissorRects(This,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList4_OMSetBlendFactor(This,BlendFactor)  \
+    ( (This)->lpVtbl -> OMSetBlendFactor(This,BlendFactor) ) 
+
+#define ID3D12GraphicsCommandList4_OMSetStencilRef(This,StencilRef)  \
+    ( (This)->lpVtbl -> OMSetStencilRef(This,StencilRef) ) 
+
+#define ID3D12GraphicsCommandList4_SetPipelineState(This,pPipelineState) \
+    ( (This)->lpVtbl -> SetPipelineState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList4_ResourceBarrier(This,NumBarriers,pBarriers) \
+    ( (This)->lpVtbl -> ResourceBarrier(This,NumBarriers,pBarriers) ) 
+
+#define ID3D12GraphicsCommandList4_ExecuteBundle(This,pCommandList)  \
+    ( (This)->lpVtbl -> ExecuteBundle(This,pCommandList) ) 
+
+#define ID3D12GraphicsCommandList4_SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) \
+    ( (This)->lpVtbl -> SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) ) 
+
+#define ID3D12GraphicsCommandList4_SetComputeRootSignature(This,pRootSignature)  \
+    ( (This)->lpVtbl -> SetComputeRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList4_SetGraphicsRootSignature(This,pRootSignature) \
+    ( (This)->lpVtbl -> SetGraphicsRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList4_SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) \
+    ( (This)->lpVtbl -> SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList4_SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor)  \
+    ( (This)->lpVtbl -> SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList4_SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList4_SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList4_SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList4_SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList4_SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList4_SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList4_SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList4_SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList4_SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList4_SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList4_IASetIndexBuffer(This,pView)  \
+    ( (This)->lpVtbl -> IASetIndexBuffer(This,pView) ) 
+
+#define ID3D12GraphicsCommandList4_IASetVertexBuffers(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> IASetVertexBuffers(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList4_SOSetTargets(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> SOSetTargets(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList4_OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) \
+    ( (This)->lpVtbl -> OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) ) 
+
+#define ID3D12GraphicsCommandList4_ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList4_ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList4_ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList4_ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList4_DiscardResource(This,pResource,pRegion) \
+    ( (This)->lpVtbl -> DiscardResource(This,pResource,pRegion) ) 
+
+#define ID3D12GraphicsCommandList4_BeginQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> BeginQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList4_EndQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> EndQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList4_ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset)  \
+    ( (This)->lpVtbl -> ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset) ) 
+
+#define ID3D12GraphicsCommandList4_SetPredication(This,pBuffer,AlignedBufferOffset,Operation)  \
+    ( (This)->lpVtbl -> SetPredication(This,pBuffer,AlignedBufferOffset,Operation) ) 
+
+#define ID3D12GraphicsCommandList4_SetMarker(This,Metadata,pData,Size) \
+    ( (This)->lpVtbl -> SetMarker(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList4_BeginEvent(This,Metadata,pData,Size)  \
+    ( (This)->lpVtbl -> BeginEvent(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList4_EndEvent(This)  \
+    ( (This)->lpVtbl -> EndEvent(This) ) 
+
+#define ID3D12GraphicsCommandList4_ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) \
+    ( (This)->lpVtbl -> ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) ) 
+
+
+#define ID3D12GraphicsCommandList4_AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList4_AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList4_OMSetDepthBounds(This,Min,Max)  \
+    ( (This)->lpVtbl -> OMSetDepthBounds(This,Min,Max) ) 
+
+#define ID3D12GraphicsCommandList4_SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions)  \
+    ( (This)->lpVtbl -> SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions) ) 
+
+#define ID3D12GraphicsCommandList4_ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode)  \
+    ( (This)->lpVtbl -> ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode) ) 
+
+#define ID3D12GraphicsCommandList4_SetViewInstanceMask(This,Mask)  \
+    ( (This)->lpVtbl -> SetViewInstanceMask(This,Mask) ) 
+
+
+#define ID3D12GraphicsCommandList4_WriteBufferImmediate(This,Count,pParams,pModes) \
+    ( (This)->lpVtbl -> WriteBufferImmediate(This,Count,pParams,pModes) ) 
+
+
+#define ID3D12GraphicsCommandList4_SetProtectedResourceSession(This,pProtectedResourceSession) \
+    ( (This)->lpVtbl -> SetProtectedResourceSession(This,pProtectedResourceSession) ) 
+
+
+#define ID3D12GraphicsCommandList4_BeginRenderPass(This,NumRenderTargets,pRenderTargets,pDepthStencil,Flags) \
+    ( (This)->lpVtbl -> BeginRenderPass(This,NumRenderTargets,pRenderTargets,pDepthStencil,Flags) ) 
+
+#define ID3D12GraphicsCommandList4_EndRenderPass(This) \
+    ( (This)->lpVtbl -> EndRenderPass(This) ) 
+
+#define ID3D12GraphicsCommandList4_InitializeMetaCommand(This,pMetaCommand,pInitializationParametersData,InitializationParametersDataSizeInBytes)  \
+    ( (This)->lpVtbl -> InitializeMetaCommand(This,pMetaCommand,pInitializationParametersData,InitializationParametersDataSizeInBytes) ) 
+
+#define ID3D12GraphicsCommandList4_ExecuteMetaCommand(This,pMetaCommand,pExecutionParametersData,ExecutionParametersDataSizeInBytes) \
+    ( (This)->lpVtbl -> ExecuteMetaCommand(This,pMetaCommand,pExecutionParametersData,ExecutionParametersDataSizeInBytes) ) 
+
+#define ID3D12GraphicsCommandList4_BuildRaytracingAccelerationStructure(This,pDesc,NumPostbuildInfoDescs,pPostbuildInfoDescs)  \
+    ( (This)->lpVtbl -> BuildRaytracingAccelerationStructure(This,pDesc,NumPostbuildInfoDescs,pPostbuildInfoDescs) ) 
+
+#define ID3D12GraphicsCommandList4_EmitRaytracingAccelerationStructurePostbuildInfo(This,pDesc,NumSourceAccelerationStructures,pSourceAccelerationStructureData) \
+    ( (This)->lpVtbl -> EmitRaytracingAccelerationStructurePostbuildInfo(This,pDesc,NumSourceAccelerationStructures,pSourceAccelerationStructureData) ) 
+
+#define ID3D12GraphicsCommandList4_CopyRaytracingAccelerationStructure(This,DestAccelerationStructureData,SourceAccelerationStructureData,Mode)  \
+    ( (This)->lpVtbl -> CopyRaytracingAccelerationStructure(This,DestAccelerationStructureData,SourceAccelerationStructureData,Mode) ) 
+
+#define ID3D12GraphicsCommandList4_SetPipelineState1(This,pStateObject)  \
+    ( (This)->lpVtbl -> SetPipelineState1(This,pStateObject) ) 
+
+#define ID3D12GraphicsCommandList4_DispatchRays(This,pDesc)  \
+    ( (This)->lpVtbl -> DispatchRays(This,pDesc) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12GraphicsCommandList4_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Tools_INTERFACE_DEFINED__
+#define __ID3D12Tools_INTERFACE_DEFINED__
+
+/* interface ID3D12Tools */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Tools;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("7071e1f0-e84b-4b33-974f-12fa49de65c5")
+    ID3D12Tools : public IUnknown
+    {
+    public:
+        virtual void STDMETHODCALLTYPE EnableShaderInstrumentation( 
+            BOOL bEnable) = 0;
+        
+        virtual BOOL STDMETHODCALLTYPE ShaderInstrumentationEnabled( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12ToolsVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Tools * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Tools * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Tools * This);
+        
+        void ( STDMETHODCALLTYPE *EnableShaderInstrumentation )( 
+            ID3D12Tools * This,
+            BOOL bEnable);
+        
+        BOOL ( STDMETHODCALLTYPE *ShaderInstrumentationEnabled )( 
+            ID3D12Tools * This);
+        
+        END_INTERFACE
+    } ID3D12ToolsVtbl;
+
+    interface ID3D12Tools
+    {
+        CONST_VTBL struct ID3D12ToolsVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Tools_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Tools_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Tools_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Tools_EnableShaderInstrumentation(This,bEnable)  \
+    ( (This)->lpVtbl -> EnableShaderInstrumentation(This,bEnable) ) 
+
+#define ID3D12Tools_ShaderInstrumentationEnabled(This) \
+    ( (This)->lpVtbl -> ShaderInstrumentationEnabled(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Tools_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0044 */
+/* [local] */ 
+
+typedef struct D3D12_SUBRESOURCE_DATA
+    {
+    const void *pData;
+    LONG_PTR RowPitch;
+    LONG_PTR SlicePitch;
+    }  D3D12_SUBRESOURCE_DATA;
+
+typedef struct D3D12_MEMCPY_DEST
+    {
+    void *pData;
+    SIZE_T RowPitch;
+    SIZE_T SlicePitch;
+    }  D3D12_MEMCPY_DEST;
+
+#if !defined( D3D12_IGNORE_SDK_LAYERS ) 
+#include "d3d12sdklayers.h" 
+#endif 
+
+///////////////////////////////////////////////////////////////////////////
+// D3D12CreateDevice
+// ------------------
+//
+// pAdapter
+//      If NULL, D3D12CreateDevice will choose the primary adapter.
+//      If non-NULL, D3D12CreateDevice will use the provided adapter.
+// MinimumFeatureLevel
+//      The minimum feature level required for successful device creation.
+// riid
+//      The interface IID of the device to be returned. Expected: ID3D12Device.
+// ppDevice
+//      Pointer to returned interface. May be NULL.
+//
+// Return Values
+//  Any of those documented for 
+//          CreateDXGIFactory1
+//          IDXGIFactory::EnumAdapters
+//          D3D12CreateDevice
+//
+///////////////////////////////////////////////////////////////////////////
+typedef HRESULT (WINAPI* PFN_D3D12_CREATE_DEVICE)( _In_opt_ IUnknown*, 
+    D3D_FEATURE_LEVEL, 
+    _In_ REFIID, _COM_Outptr_opt_ void** );
+
+HRESULT WINAPI D3D12CreateDevice(
+    _In_opt_ IUnknown* pAdapter,
+    D3D_FEATURE_LEVEL MinimumFeatureLevel,
+    _In_ REFIID riid, // Expected: ID3D12Device
+    _COM_Outptr_opt_ void** ppDevice );
+
+
+typedef HRESULT (WINAPI* PFN_D3D12_GET_DEBUG_INTERFACE)( _In_ REFIID, _COM_Outptr_opt_ void** );
+
+HRESULT WINAPI D3D12GetDebugInterface( _In_ REFIID riid, _COM_Outptr_opt_ void** ppvDebug );
+
+// --------------------------------------------------------------------------------------------------------------------------------
+// D3D12EnableExperimentalFeatures
+//
+// Pass in a list of feature GUIDs to be enabled together.
+// 
+// If a particular feature requires some configuration information on enablement, it will have
+// a configuration struct that can be passed alongside the GUID.
+// 
+// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via
+// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface
+// for manipulating the feature.  This allows for control that might not cleanly be expressed by just 
+// the configuration struct that D3D12EnableExperimentalFeatures provides.
+//
+// If this method is called and a change to existing feature enablement is made, 
+// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one
+// singleton device for a process.  Removing the devices when configuration changes prevents
+// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.
+//
+// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.
+// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed
+// in are known to be incompatible with each other, or other errors.
+// Returns S_OK otherwise.
+//
+// --------------------------------------------------------------------------------------------------------------------------------
+HRESULT WINAPI D3D12EnableExperimentalFeatures(
+    UINT                                    NumFeatures,
+    __in_ecount(NumFeatures) const IID*     pIIDs,
+    __in_ecount_opt(NumFeatures) void*      pConfigurationStructs,
+    __in_ecount_opt(NumFeatures) UINT*      pConfigurationStructSizes);
+
+// --------------------------------------------------------------------------------------------------------------------------------
+// Experimental Feature: D3D12ExperimentalShaderModels
+//
+// Use with D3D12EnableExperimentalFeatures to enable experimental shader model support,
+// meaning shader models that haven't been finalized for use in retail.
+//
+// Enabling D3D12ExperimentalShaderModels needs no configuration struct, pass NULL in the pConfigurationStructs array.
+//
+// --------------------------------------------------------------------------------------------------------------------------------
+static const UUID D3D12ExperimentalShaderModels = { /* 76f5573e-f13a-40f5-b297-81ce9e18933f */
+    0x76f5573e,
+    0xf13a,
+    0x40f5,
+    { 0xb2, 0x97, 0x81, 0xce, 0x9e, 0x18, 0x93, 0x3f }
+};
+// --------------------------------------------------------------------------------------------------------------------------------
+// Experimental Feature: D3D12TiledResourceTier4
+//
+// Use with D3D12EnableExperimentalFeatures to enable tiled resource tier 4 support,
+// meaning texture tile data-inheritance is allowed.
+//
+// Enabling D3D12TiledResourceTier4 needs no configuration struct, pass NULL in the pConfigurationStructs array.
+//
+// --------------------------------------------------------------------------------------------------------------------------------
+static const UUID D3D12TiledResourceTier4 = { /* c9c4725f-a81a-4f56-8c5b-c51039d694fb */
+    0xc9c4725f,
+    0xa81a,
+    0x4f56,
+    { 0x8c, 0x5b, 0xc5, 0x10, 0x39, 0xd6, 0x94, 0xfb }
+};
+// --------------------------------------------------------------------------------------------------------------------------------
+// Experimental Feature: D3D12MetaCommand
+//
+// Use with D3D12EnableExperimentalFeatures to enable the D3D12 Meta Command.
+//
+// Enabling D3D12MetaCommand needs no configuration struct, pass NULL in the pConfigurationStructs array.
+//
+// --------------------------------------------------------------------------------------------------------------------------------
+static const UUID D3D12MetaCommand = { /* C734C97E-8077-48C8-9FDC-D9D1DD31DD77 */
+    0xc734c97e,
+    0x8077,
+    0x48c8,
+    { 0x9f, 0xdc, 0xd9, 0xd1, 0xdd, 0x31, 0xdd, 0x77 }
+};
+// --------------------------------------------------------------------------------------------------------------------------------
+// Experimental Feature: D3D12ComputeOnlyDevices
+//
+// Use with D3D12EnableExperimentalFeatures to enable compute only devices (D3D_FEATURE_LEVEL_1_0_CORE).
+//
+// Enabling D3D12ComputeOnlyDevices needs no configuration struct, pass NULL in the pConfigurationStructs array.
+//
+// --------------------------------------------------------------------------------------------------------------------------------
+static const UUID D3D12ComputeOnlyDevices = { /* 50f7ab08-4b6d-4e14-89a5-5d16cd272594 */
+    0x50f7ab08,
+    0x4b6d,
+    0x4e14,
+    {0x89, 0xa5, 0x5d, 0x16, 0xcd, 0x27, 0x25, 0x94}
+};
+typedef 
+enum D3D12_AXIS_SHADING_RATE
+    {
+        D3D12_AXIS_SHADING_RATE_1X = 0,
+        D3D12_AXIS_SHADING_RATE_2X = 0x1,
+        D3D12_AXIS_SHADING_RATE_4X = 0x2
+    }  D3D12_AXIS_SHADING_RATE;
+
+#define D3D12_SHADING_RATE_X_AXIS_SHIFT 2
+#define D3D12_SHADING_RATE_VALID_MASK 3
+#define D3D12_MAKE_COARSE_SHADING_RATE(x,y) ((x) << D3D12_SHADING_RATE_X_AXIS_SHIFT | (y))
+#define D3D12_GET_COARSE_SHADING_RATE_X_AXIS(x) (((x) >> D3D12_SHADING_RATE_X_AXIS_SHIFT) & D3D12_SHADING_RATE_VALID_MASK)
+#define D3D12_GET_COARSE_SHADING_RATE_Y_AXIS(y) ((y) & D3D12_SHADING_RATE_VALID_MASK)
+typedef 
+enum D3D12_SHADING_RATE
+    {
+        D3D12_SHADING_RATE_1X1 = 0,
+        D3D12_SHADING_RATE_1X2 = 0x1,
+        D3D12_SHADING_RATE_2X1 = 0x4,
+        D3D12_SHADING_RATE_2X2 = 0x5,
+        D3D12_SHADING_RATE_2X4 = 0x6,
+        D3D12_SHADING_RATE_4X2 = 0x9,
+        D3D12_SHADING_RATE_4X4 = 0xa
+    }  D3D12_SHADING_RATE;
+
+typedef 
+enum D3D12_SHADING_RATE_COMBINER
+    {
+        D3D12_SHADING_RATE_COMBINER_PASSTHROUGH  = 0,
+        D3D12_SHADING_RATE_COMBINER_OVERRIDE = 1,
+        D3D12_SHADING_RATE_COMBINER_MIN  = 2,
+        D3D12_SHADING_RATE_COMBINER_MAX  = 3,
+        D3D12_SHADING_RATE_COMBINER_SUM  = 4
+    }  D3D12_SHADING_RATE_COMBINER;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0044_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0044_v0_0_s_ifspec;
+
+#ifndef __ID3D12GraphicsCommandList5_INTERFACE_DEFINED__
+#define __ID3D12GraphicsCommandList5_INTERFACE_DEFINED__
+
+/* interface ID3D12GraphicsCommandList5 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12GraphicsCommandList5;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("55050859-4024-474c-87f5-6472eaee44ea")
+    ID3D12GraphicsCommandList5 : public ID3D12GraphicsCommandList4
+    {
+    public:
+        virtual void STDMETHODCALLTYPE RSSetShadingRate( 
+            _In_  D3D12_SHADING_RATE baseShadingRate,
+            _In_reads_opt_(D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT)  const D3D12_SHADING_RATE_COMBINER *combiners) = 0;
+        
+        virtual void STDMETHODCALLTYPE RSSetShadingRateImage( 
+            _In_opt_  ID3D12Resource *shadingRateImage) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12GraphicsCommandList5Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12GraphicsCommandList5 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12GraphicsCommandList5 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12GraphicsCommandList5 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  REFGUID guid,
+            _Inout_  UINT *pDataSize,
+            _Out_writes_bytes_opt_( *pDataSize )  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  REFGUID guid,
+            _In_  UINT DataSize,
+            _In_reads_bytes_opt_( DataSize )  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  REFGUID guid,
+            _In_opt_  const IUnknown *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetName )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_z_  LPCWSTR Name);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            ID3D12GraphicsCommandList5 * This,
+            REFIID riid,
+            _COM_Outptr_opt_  void **ppvDevice);
+        
+        D3D12_COMMAND_LIST_TYPE ( STDMETHODCALLTYPE *GetType )( 
+            ID3D12GraphicsCommandList5 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Close )( 
+            ID3D12GraphicsCommandList5 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Reset )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12CommandAllocator *pAllocator,
+            _In_opt_  ID3D12PipelineState *pInitialState);
+        
+        void ( STDMETHODCALLTYPE *ClearState )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_opt_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *DrawInstanced )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT VertexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *DrawIndexedInstanced )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT IndexCountPerInstance,
+            _In_  UINT InstanceCount,
+            _In_  UINT StartIndexLocation,
+            _In_  INT BaseVertexLocation,
+            _In_  UINT StartInstanceLocation);
+        
+        void ( STDMETHODCALLTYPE *Dispatch )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT ThreadGroupCountX,
+            _In_  UINT ThreadGroupCountY,
+            _In_  UINT ThreadGroupCountZ);
+        
+        void ( STDMETHODCALLTYPE *CopyBufferRegion )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT64 NumBytes);
+        
+        void ( STDMETHODCALLTYPE *CopyTextureRegion )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pDst,
+            UINT DstX,
+            UINT DstY,
+            UINT DstZ,
+            _In_  const D3D12_TEXTURE_COPY_LOCATION *pSrc,
+            _In_opt_  const D3D12_BOX *pSrcBox);
+        
+        void ( STDMETHODCALLTYPE *CopyResource )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  ID3D12Resource *pSrcResource);
+        
+        void ( STDMETHODCALLTYPE *CopyTiles )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12Resource *pTiledResource,
+            _In_  const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate,
+            _In_  const D3D12_TILE_REGION_SIZE *pTileRegionSize,
+            _In_  ID3D12Resource *pBuffer,
+            UINT64 BufferStartOffsetInBytes,
+            D3D12_TILE_COPY_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresource )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_  DXGI_FORMAT Format);
+        
+        void ( STDMETHODCALLTYPE *IASetPrimitiveTopology )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology);
+        
+        void ( STDMETHODCALLTYPE *RSSetViewports )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumViewports,
+            _In_reads_( NumViewports)  const D3D12_VIEWPORT *pViewports);
+        
+        void ( STDMETHODCALLTYPE *RSSetScissorRects )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_range_(0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  UINT NumRects,
+            _In_reads_( NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *OMSetBlendFactor )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_reads_opt_(4)  const FLOAT BlendFactor[ 4 ]);
+        
+        void ( STDMETHODCALLTYPE *OMSetStencilRef )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT StencilRef);
+        
+        void ( STDMETHODCALLTYPE *SetPipelineState )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12PipelineState *pPipelineState);
+        
+        void ( STDMETHODCALLTYPE *ResourceBarrier )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT NumBarriers,
+            _In_reads_(NumBarriers)  const D3D12_RESOURCE_BARRIER *pBarriers);
+        
+        void ( STDMETHODCALLTYPE *ExecuteBundle )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12GraphicsCommandList *pCommandList);
+        
+        void ( STDMETHODCALLTYPE *SetDescriptorHeaps )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT NumDescriptorHeaps,
+            _In_reads_(NumDescriptorHeaps)  ID3D12DescriptorHeap *const *ppDescriptorHeaps);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootSignature )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootSignature )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_opt_  ID3D12RootSignature *pRootSignature);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootDescriptorTable )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootDescriptorTable )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstant )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstant )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT SrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRoot32BitConstants )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRoot32BitConstants )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  UINT Num32BitValuesToSet,
+            _In_reads_(Num32BitValuesToSet*sizeof(UINT))  const void *pSrcData,
+            _In_  UINT DestOffsetIn32BitValues);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootConstantBufferView )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootConstantBufferView )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootShaderResourceView )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootShaderResourceView )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetComputeRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *SetGraphicsRootUnorderedAccessView )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT RootParameterIndex,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);
+        
+        void ( STDMETHODCALLTYPE *IASetIndexBuffer )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_opt_  const D3D12_INDEX_BUFFER_VIEW *pView);
+        
+        void ( STDMETHODCALLTYPE *IASetVertexBuffers )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_VERTEX_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *SOSetTargets )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT StartSlot,
+            _In_  UINT NumViews,
+            _In_reads_opt_(NumViews)  const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews);
+        
+        void ( STDMETHODCALLTYPE *OMSetRenderTargets )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT NumRenderTargetDescriptors,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pRenderTargetDescriptors,
+            _In_  BOOL RTsSingleHandleToDescriptorRange,
+            _In_opt_  const D3D12_CPU_DESCRIPTOR_HANDLE *pDepthStencilDescriptor);
+        
+        void ( STDMETHODCALLTYPE *ClearDepthStencilView )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,
+            _In_  D3D12_CLEAR_FLAGS ClearFlags,
+            _In_  FLOAT Depth,
+            _In_  UINT8 Stencil,
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearRenderTargetView )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,
+            _In_  const FLOAT ColorRGBA[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewUint )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const UINT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *ClearUnorderedAccessViewFloat )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
+            _In_  D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
+            _In_  ID3D12Resource *pResource,
+            _In_  const FLOAT Values[ 4 ],
+            _In_  UINT NumRects,
+            _In_reads_(NumRects)  const D3D12_RECT *pRects);
+        
+        void ( STDMETHODCALLTYPE *DiscardResource )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12Resource *pResource,
+            _In_opt_  const D3D12_DISCARD_REGION *pRegion);
+        
+        void ( STDMETHODCALLTYPE *BeginQuery )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *EndQuery )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT Index);
+        
+        void ( STDMETHODCALLTYPE *ResolveQueryData )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12QueryHeap *pQueryHeap,
+            _In_  D3D12_QUERY_TYPE Type,
+            _In_  UINT StartIndex,
+            _In_  UINT NumQueries,
+            _In_  ID3D12Resource *pDestinationBuffer,
+            _In_  UINT64 AlignedDestinationBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *SetPredication )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_opt_  ID3D12Resource *pBuffer,
+            _In_  UINT64 AlignedBufferOffset,
+            _In_  D3D12_PREDICATION_OP Operation);
+        
+        void ( STDMETHODCALLTYPE *SetMarker )( 
+            ID3D12GraphicsCommandList5 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *BeginEvent )( 
+            ID3D12GraphicsCommandList5 * This,
+            UINT Metadata,
+            _In_reads_bytes_opt_(Size)  const void *pData,
+            UINT Size);
+        
+        void ( STDMETHODCALLTYPE *EndEvent )( 
+            ID3D12GraphicsCommandList5 * This);
+        
+        void ( STDMETHODCALLTYPE *ExecuteIndirect )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12CommandSignature *pCommandSignature,
+            _In_  UINT MaxCommandCount,
+            _In_  ID3D12Resource *pArgumentBuffer,
+            _In_  UINT64 ArgumentBufferOffset,
+            _In_opt_  ID3D12Resource *pCountBuffer,
+            _In_  UINT64 CountBufferOffset);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *AtomicCopyBufferUINT64 )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12Resource *pDstBuffer,
+            UINT64 DstOffset,
+            _In_  ID3D12Resource *pSrcBuffer,
+            UINT64 SrcOffset,
+            UINT Dependencies,
+            _In_reads_(Dependencies)  ID3D12Resource *const *ppDependentResources,
+            _In_reads_(Dependencies)  const D3D12_SUBRESOURCE_RANGE_UINT64 *pDependentSubresourceRanges);
+        
+        void ( STDMETHODCALLTYPE *OMSetDepthBounds )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  FLOAT Min,
+            _In_  FLOAT Max);
+        
+        void ( STDMETHODCALLTYPE *SetSamplePositions )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT NumSamplesPerPixel,
+            _In_  UINT NumPixels,
+            _In_reads_(NumSamplesPerPixel*NumPixels)  D3D12_SAMPLE_POSITION *pSamplePositions);
+        
+        void ( STDMETHODCALLTYPE *ResolveSubresourceRegion )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12Resource *pDstResource,
+            _In_  UINT DstSubresource,
+            _In_  UINT DstX,
+            _In_  UINT DstY,
+            _In_  ID3D12Resource *pSrcResource,
+            _In_  UINT SrcSubresource,
+            _In_opt_  D3D12_RECT *pSrcRect,
+            _In_  DXGI_FORMAT Format,
+            _In_  D3D12_RESOLVE_MODE ResolveMode);
+        
+        void ( STDMETHODCALLTYPE *SetViewInstanceMask )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT Mask);
+        
+        void ( STDMETHODCALLTYPE *WriteBufferImmediate )( 
+            ID3D12GraphicsCommandList5 * This,
+            UINT Count,
+            _In_reads_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *pParams,
+            _In_reads_opt_(Count)  const D3D12_WRITEBUFFERIMMEDIATE_MODE *pModes);
+        
+        void ( STDMETHODCALLTYPE *SetProtectedResourceSession )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_opt_  ID3D12ProtectedResourceSession *pProtectedResourceSession);
+        
+        void ( STDMETHODCALLTYPE *BeginRenderPass )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  UINT NumRenderTargets,
+            _In_reads_opt_(NumRenderTargets)  const D3D12_RENDER_PASS_RENDER_TARGET_DESC *pRenderTargets,
+            _In_opt_  const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC *pDepthStencil,
+            D3D12_RENDER_PASS_FLAGS Flags);
+        
+        void ( STDMETHODCALLTYPE *EndRenderPass )( 
+            ID3D12GraphicsCommandList5 * This);
+        
+        void ( STDMETHODCALLTYPE *InitializeMetaCommand )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12MetaCommand *pMetaCommand,
+            _In_reads_bytes_opt_(InitializationParametersDataSizeInBytes)  const void *pInitializationParametersData,
+            _In_  SIZE_T InitializationParametersDataSizeInBytes);
+        
+        void ( STDMETHODCALLTYPE *ExecuteMetaCommand )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12MetaCommand *pMetaCommand,
+            _In_reads_bytes_opt_(ExecutionParametersDataSizeInBytes)  const void *pExecutionParametersData,
+            _In_  SIZE_T ExecutionParametersDataSizeInBytes);
+        
+        void ( STDMETHODCALLTYPE *BuildRaytracingAccelerationStructure )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC *pDesc,
+            _In_  UINT NumPostbuildInfoDescs,
+            _In_reads_opt_(NumPostbuildInfoDescs)  const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pPostbuildInfoDescs);
+        
+        void ( STDMETHODCALLTYPE *EmitRaytracingAccelerationStructurePostbuildInfo )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pDesc,
+            _In_  UINT NumSourceAccelerationStructures,
+            _In_reads_( NumSourceAccelerationStructures )  const D3D12_GPU_VIRTUAL_ADDRESS *pSourceAccelerationStructureData);
+        
+        void ( STDMETHODCALLTYPE *CopyRaytracingAccelerationStructure )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData,
+            _In_  D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData,
+            _In_  D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode);
+        
+        void ( STDMETHODCALLTYPE *SetPipelineState1 )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  ID3D12StateObject *pStateObject);
+        
+        void ( STDMETHODCALLTYPE *DispatchRays )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  const D3D12_DISPATCH_RAYS_DESC *pDesc);
+        
+        void ( STDMETHODCALLTYPE *RSSetShadingRate )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_  D3D12_SHADING_RATE baseShadingRate,
+            _In_reads_opt_(D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT)  const D3D12_SHADING_RATE_COMBINER *combiners);
+        
+        void ( STDMETHODCALLTYPE *RSSetShadingRateImage )( 
+            ID3D12GraphicsCommandList5 * This,
+            _In_opt_  ID3D12Resource *shadingRateImage);
+        
+        END_INTERFACE
+    } ID3D12GraphicsCommandList5Vtbl;
+
+    interface ID3D12GraphicsCommandList5
+    {
+        CONST_VTBL struct ID3D12GraphicsCommandList5Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12GraphicsCommandList5_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12GraphicsCommandList5_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12GraphicsCommandList5_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12GraphicsCommandList5_GetPrivateData(This,guid,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,guid,pDataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList5_SetPrivateData(This,guid,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,guid,DataSize,pData) ) 
+
+#define ID3D12GraphicsCommandList5_SetPrivateDataInterface(This,guid,pData)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,guid,pData) ) 
+
+#define ID3D12GraphicsCommandList5_SetName(This,Name)  \
+    ( (This)->lpVtbl -> SetName(This,Name) ) 
+
+
+#define ID3D12GraphicsCommandList5_GetDevice(This,riid,ppvDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppvDevice) ) 
+
+
+#define ID3D12GraphicsCommandList5_GetType(This) \
+    ( (This)->lpVtbl -> GetType(This) ) 
+
+
+#define ID3D12GraphicsCommandList5_Close(This) \
+    ( (This)->lpVtbl -> Close(This) ) 
+
+#define ID3D12GraphicsCommandList5_Reset(This,pAllocator,pInitialState)  \
+    ( (This)->lpVtbl -> Reset(This,pAllocator,pInitialState) ) 
+
+#define ID3D12GraphicsCommandList5_ClearState(This,pPipelineState) \
+    ( (This)->lpVtbl -> ClearState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList5_DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawInstanced(This,VertexCountPerInstance,InstanceCount,StartVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList5_DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation)  \
+    ( (This)->lpVtbl -> DrawIndexedInstanced(This,IndexCountPerInstance,InstanceCount,StartIndexLocation,BaseVertexLocation,StartInstanceLocation) ) 
+
+#define ID3D12GraphicsCommandList5_Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ)  \
+    ( (This)->lpVtbl -> Dispatch(This,ThreadGroupCountX,ThreadGroupCountY,ThreadGroupCountZ) ) 
+
+#define ID3D12GraphicsCommandList5_CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) \
+    ( (This)->lpVtbl -> CopyBufferRegion(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,NumBytes) ) 
+
+#define ID3D12GraphicsCommandList5_CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox)  \
+    ( (This)->lpVtbl -> CopyTextureRegion(This,pDst,DstX,DstY,DstZ,pSrc,pSrcBox) ) 
+
+#define ID3D12GraphicsCommandList5_CopyResource(This,pDstResource,pSrcResource)  \
+    ( (This)->lpVtbl -> CopyResource(This,pDstResource,pSrcResource) ) 
+
+#define ID3D12GraphicsCommandList5_CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags)  \
+    ( (This)->lpVtbl -> CopyTiles(This,pTiledResource,pTileRegionStartCoordinate,pTileRegionSize,pBuffer,BufferStartOffsetInBytes,Flags) ) 
+
+#define ID3D12GraphicsCommandList5_ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) \
+    ( (This)->lpVtbl -> ResolveSubresource(This,pDstResource,DstSubresource,pSrcResource,SrcSubresource,Format) ) 
+
+#define ID3D12GraphicsCommandList5_IASetPrimitiveTopology(This,PrimitiveTopology)  \
+    ( (This)->lpVtbl -> IASetPrimitiveTopology(This,PrimitiveTopology) ) 
+
+#define ID3D12GraphicsCommandList5_RSSetViewports(This,NumViewports,pViewports)  \
+    ( (This)->lpVtbl -> RSSetViewports(This,NumViewports,pViewports) ) 
+
+#define ID3D12GraphicsCommandList5_RSSetScissorRects(This,NumRects,pRects) \
+    ( (This)->lpVtbl -> RSSetScissorRects(This,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList5_OMSetBlendFactor(This,BlendFactor)  \
+    ( (This)->lpVtbl -> OMSetBlendFactor(This,BlendFactor) ) 
+
+#define ID3D12GraphicsCommandList5_OMSetStencilRef(This,StencilRef)  \
+    ( (This)->lpVtbl -> OMSetStencilRef(This,StencilRef) ) 
+
+#define ID3D12GraphicsCommandList5_SetPipelineState(This,pPipelineState) \
+    ( (This)->lpVtbl -> SetPipelineState(This,pPipelineState) ) 
+
+#define ID3D12GraphicsCommandList5_ResourceBarrier(This,NumBarriers,pBarriers) \
+    ( (This)->lpVtbl -> ResourceBarrier(This,NumBarriers,pBarriers) ) 
+
+#define ID3D12GraphicsCommandList5_ExecuteBundle(This,pCommandList)  \
+    ( (This)->lpVtbl -> ExecuteBundle(This,pCommandList) ) 
+
+#define ID3D12GraphicsCommandList5_SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) \
+    ( (This)->lpVtbl -> SetDescriptorHeaps(This,NumDescriptorHeaps,ppDescriptorHeaps) ) 
+
+#define ID3D12GraphicsCommandList5_SetComputeRootSignature(This,pRootSignature)  \
+    ( (This)->lpVtbl -> SetComputeRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList5_SetGraphicsRootSignature(This,pRootSignature) \
+    ( (This)->lpVtbl -> SetGraphicsRootSignature(This,pRootSignature) ) 
+
+#define ID3D12GraphicsCommandList5_SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) \
+    ( (This)->lpVtbl -> SetComputeRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList5_SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor)  \
+    ( (This)->lpVtbl -> SetGraphicsRootDescriptorTable(This,RootParameterIndex,BaseDescriptor) ) 
+
+#define ID3D12GraphicsCommandList5_SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList5_SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstant(This,RootParameterIndex,SrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList5_SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues)  \
+    ( (This)->lpVtbl -> SetComputeRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList5_SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) \
+    ( (This)->lpVtbl -> SetGraphicsRoot32BitConstants(This,RootParameterIndex,Num32BitValuesToSet,pSrcData,DestOffsetIn32BitValues) ) 
+
+#define ID3D12GraphicsCommandList5_SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList5_SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootConstantBufferView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList5_SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetComputeRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList5_SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetGraphicsRootShaderResourceView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList5_SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) \
+    ( (This)->lpVtbl -> SetComputeRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList5_SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation)  \
+    ( (This)->lpVtbl -> SetGraphicsRootUnorderedAccessView(This,RootParameterIndex,BufferLocation) ) 
+
+#define ID3D12GraphicsCommandList5_IASetIndexBuffer(This,pView)  \
+    ( (This)->lpVtbl -> IASetIndexBuffer(This,pView) ) 
+
+#define ID3D12GraphicsCommandList5_IASetVertexBuffers(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> IASetVertexBuffers(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList5_SOSetTargets(This,StartSlot,NumViews,pViews)  \
+    ( (This)->lpVtbl -> SOSetTargets(This,StartSlot,NumViews,pViews) ) 
+
+#define ID3D12GraphicsCommandList5_OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) \
+    ( (This)->lpVtbl -> OMSetRenderTargets(This,NumRenderTargetDescriptors,pRenderTargetDescriptors,RTsSingleHandleToDescriptorRange,pDepthStencilDescriptor) ) 
+
+#define ID3D12GraphicsCommandList5_ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearDepthStencilView(This,DepthStencilView,ClearFlags,Depth,Stencil,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList5_ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearRenderTargetView(This,RenderTargetView,ColorRGBA,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList5_ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects)  \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewUint(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList5_ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) \
+    ( (This)->lpVtbl -> ClearUnorderedAccessViewFloat(This,ViewGPUHandleInCurrentHeap,ViewCPUHandle,pResource,Values,NumRects,pRects) ) 
+
+#define ID3D12GraphicsCommandList5_DiscardResource(This,pResource,pRegion) \
+    ( (This)->lpVtbl -> DiscardResource(This,pResource,pRegion) ) 
+
+#define ID3D12GraphicsCommandList5_BeginQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> BeginQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList5_EndQuery(This,pQueryHeap,Type,Index)  \
+    ( (This)->lpVtbl -> EndQuery(This,pQueryHeap,Type,Index) ) 
+
+#define ID3D12GraphicsCommandList5_ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset)  \
+    ( (This)->lpVtbl -> ResolveQueryData(This,pQueryHeap,Type,StartIndex,NumQueries,pDestinationBuffer,AlignedDestinationBufferOffset) ) 
+
+#define ID3D12GraphicsCommandList5_SetPredication(This,pBuffer,AlignedBufferOffset,Operation)  \
+    ( (This)->lpVtbl -> SetPredication(This,pBuffer,AlignedBufferOffset,Operation) ) 
+
+#define ID3D12GraphicsCommandList5_SetMarker(This,Metadata,pData,Size) \
+    ( (This)->lpVtbl -> SetMarker(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList5_BeginEvent(This,Metadata,pData,Size)  \
+    ( (This)->lpVtbl -> BeginEvent(This,Metadata,pData,Size) ) 
+
+#define ID3D12GraphicsCommandList5_EndEvent(This)  \
+    ( (This)->lpVtbl -> EndEvent(This) ) 
+
+#define ID3D12GraphicsCommandList5_ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) \
+    ( (This)->lpVtbl -> ExecuteIndirect(This,pCommandSignature,MaxCommandCount,pArgumentBuffer,ArgumentBufferOffset,pCountBuffer,CountBufferOffset) ) 
+
+
+#define ID3D12GraphicsCommandList5_AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList5_AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges)  \
+    ( (This)->lpVtbl -> AtomicCopyBufferUINT64(This,pDstBuffer,DstOffset,pSrcBuffer,SrcOffset,Dependencies,ppDependentResources,pDependentSubresourceRanges) ) 
+
+#define ID3D12GraphicsCommandList5_OMSetDepthBounds(This,Min,Max)  \
+    ( (This)->lpVtbl -> OMSetDepthBounds(This,Min,Max) ) 
+
+#define ID3D12GraphicsCommandList5_SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions)  \
+    ( (This)->lpVtbl -> SetSamplePositions(This,NumSamplesPerPixel,NumPixels,pSamplePositions) ) 
+
+#define ID3D12GraphicsCommandList5_ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode)  \
+    ( (This)->lpVtbl -> ResolveSubresourceRegion(This,pDstResource,DstSubresource,DstX,DstY,pSrcResource,SrcSubresource,pSrcRect,Format,ResolveMode) ) 
+
+#define ID3D12GraphicsCommandList5_SetViewInstanceMask(This,Mask)  \
+    ( (This)->lpVtbl -> SetViewInstanceMask(This,Mask) ) 
+
+
+#define ID3D12GraphicsCommandList5_WriteBufferImmediate(This,Count,pParams,pModes) \
+    ( (This)->lpVtbl -> WriteBufferImmediate(This,Count,pParams,pModes) ) 
+
+
+#define ID3D12GraphicsCommandList5_SetProtectedResourceSession(This,pProtectedResourceSession) \
+    ( (This)->lpVtbl -> SetProtectedResourceSession(This,pProtectedResourceSession) ) 
+
+
+#define ID3D12GraphicsCommandList5_BeginRenderPass(This,NumRenderTargets,pRenderTargets,pDepthStencil,Flags) \
+    ( (This)->lpVtbl -> BeginRenderPass(This,NumRenderTargets,pRenderTargets,pDepthStencil,Flags) ) 
+
+#define ID3D12GraphicsCommandList5_EndRenderPass(This) \
+    ( (This)->lpVtbl -> EndRenderPass(This) ) 
+
+#define ID3D12GraphicsCommandList5_InitializeMetaCommand(This,pMetaCommand,pInitializationParametersData,InitializationParametersDataSizeInBytes)  \
+    ( (This)->lpVtbl -> InitializeMetaCommand(This,pMetaCommand,pInitializationParametersData,InitializationParametersDataSizeInBytes) ) 
+
+#define ID3D12GraphicsCommandList5_ExecuteMetaCommand(This,pMetaCommand,pExecutionParametersData,ExecutionParametersDataSizeInBytes) \
+    ( (This)->lpVtbl -> ExecuteMetaCommand(This,pMetaCommand,pExecutionParametersData,ExecutionParametersDataSizeInBytes) ) 
+
+#define ID3D12GraphicsCommandList5_BuildRaytracingAccelerationStructure(This,pDesc,NumPostbuildInfoDescs,pPostbuildInfoDescs)  \
+    ( (This)->lpVtbl -> BuildRaytracingAccelerationStructure(This,pDesc,NumPostbuildInfoDescs,pPostbuildInfoDescs) ) 
+
+#define ID3D12GraphicsCommandList5_EmitRaytracingAccelerationStructurePostbuildInfo(This,pDesc,NumSourceAccelerationStructures,pSourceAccelerationStructureData) \
+    ( (This)->lpVtbl -> EmitRaytracingAccelerationStructurePostbuildInfo(This,pDesc,NumSourceAccelerationStructures,pSourceAccelerationStructureData) ) 
+
+#define ID3D12GraphicsCommandList5_CopyRaytracingAccelerationStructure(This,DestAccelerationStructureData,SourceAccelerationStructureData,Mode)  \
+    ( (This)->lpVtbl -> CopyRaytracingAccelerationStructure(This,DestAccelerationStructureData,SourceAccelerationStructureData,Mode) ) 
+
+#define ID3D12GraphicsCommandList5_SetPipelineState1(This,pStateObject)  \
+    ( (This)->lpVtbl -> SetPipelineState1(This,pStateObject) ) 
+
+#define ID3D12GraphicsCommandList5_DispatchRays(This,pDesc)  \
+    ( (This)->lpVtbl -> DispatchRays(This,pDesc) ) 
+
+
+#define ID3D12GraphicsCommandList5_RSSetShadingRate(This,baseShadingRate,combiners)  \
+    ( (This)->lpVtbl -> RSSetShadingRate(This,baseShadingRate,combiners) ) 
+
+#define ID3D12GraphicsCommandList5_RSSetShadingRateImage(This,shadingRateImage)  \
+    ( (This)->lpVtbl -> RSSetShadingRateImage(This,shadingRateImage) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12GraphicsCommandList5_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12_0000_0045 */
+/* [local] */ 
+
+#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_GAMES) */
+#pragma endregion
+DEFINE_GUID(IID_ID3D12Object,0xc4fec28f,0x7966,0x4e95,0x9f,0x94,0xf4,0x31,0xcb,0x56,0xc3,0xb8);
+DEFINE_GUID(IID_ID3D12DeviceChild,0x905db94b,0xa00c,0x4140,0x9d,0xf5,0x2b,0x64,0xca,0x9e,0xa3,0x57);
+DEFINE_GUID(IID_ID3D12RootSignature,0xc54a6b66,0x72df,0x4ee8,0x8b,0xe5,0xa9,0x46,0xa1,0x42,0x92,0x14);
+DEFINE_GUID(IID_ID3D12RootSignatureDeserializer,0x34AB647B,0x3CC8,0x46AC,0x84,0x1B,0xC0,0x96,0x56,0x45,0xC0,0x46);
+DEFINE_GUID(IID_ID3D12VersionedRootSignatureDeserializer,0x7F91CE67,0x090C,0x4BB7,0xB7,0x8E,0xED,0x8F,0xF2,0xE3,0x1D,0xA0);
+DEFINE_GUID(IID_ID3D12Pageable,0x63ee58fb,0x1268,0x4835,0x86,0xda,0xf0,0x08,0xce,0x62,0xf0,0xd6);
+DEFINE_GUID(IID_ID3D12Heap,0x6b3b2502,0x6e51,0x45b3,0x90,0xee,0x98,0x84,0x26,0x5e,0x8d,0xf3);
+DEFINE_GUID(IID_ID3D12Resource,0x696442be,0xa72e,0x4059,0xbc,0x79,0x5b,0x5c,0x98,0x04,0x0f,0xad);
+DEFINE_GUID(IID_ID3D12CommandAllocator,0x6102dee4,0xaf59,0x4b09,0xb9,0x99,0xb4,0x4d,0x73,0xf0,0x9b,0x24);
+DEFINE_GUID(IID_ID3D12Fence,0x0a753dcf,0xc4d8,0x4b91,0xad,0xf6,0xbe,0x5a,0x60,0xd9,0x5a,0x76);
+DEFINE_GUID(IID_ID3D12Fence1,0x433685fe,0xe22b,0x4ca0,0xa8,0xdb,0xb5,0xb4,0xf4,0xdd,0x0e,0x4a);
+DEFINE_GUID(IID_ID3D12PipelineState,0x765a30f3,0xf624,0x4c6f,0xa8,0x28,0xac,0xe9,0x48,0x62,0x24,0x45);
+DEFINE_GUID(IID_ID3D12DescriptorHeap,0x8efb471d,0x616c,0x4f49,0x90,0xf7,0x12,0x7b,0xb7,0x63,0xfa,0x51);
+DEFINE_GUID(IID_ID3D12QueryHeap,0x0d9658ae,0xed45,0x469e,0xa6,0x1d,0x97,0x0e,0xc5,0x83,0xca,0xb4);
+DEFINE_GUID(IID_ID3D12CommandSignature,0xc36a797c,0xec80,0x4f0a,0x89,0x85,0xa7,0xb2,0x47,0x50,0x82,0xd1);
+DEFINE_GUID(IID_ID3D12CommandList,0x7116d91c,0xe7e4,0x47ce,0xb8,0xc6,0xec,0x81,0x68,0xf4,0x37,0xe5);
+DEFINE_GUID(IID_ID3D12GraphicsCommandList,0x5b160d0f,0xac1b,0x4185,0x8b,0xa8,0xb3,0xae,0x42,0xa5,0xa4,0x55);
+DEFINE_GUID(IID_ID3D12GraphicsCommandList1,0x553103fb,0x1fe7,0x4557,0xbb,0x38,0x94,0x6d,0x7d,0x0e,0x7c,0xa7);
+DEFINE_GUID(IID_ID3D12GraphicsCommandList2,0x38C3E585,0xFF17,0x412C,0x91,0x50,0x4F,0xC6,0xF9,0xD7,0x2A,0x28);
+DEFINE_GUID(IID_ID3D12CommandQueue,0x0ec870a6,0x5d7e,0x4c22,0x8c,0xfc,0x5b,0xaa,0xe0,0x76,0x16,0xed);
+DEFINE_GUID(IID_ID3D12Device,0x189819f1,0x1db6,0x4b57,0xbe,0x54,0x18,0x21,0x33,0x9b,0x85,0xf7);
+DEFINE_GUID(IID_ID3D12PipelineLibrary,0xc64226a8,0x9201,0x46af,0xb4,0xcc,0x53,0xfb,0x9f,0xf7,0x41,0x4f);
+DEFINE_GUID(IID_ID3D12PipelineLibrary1,0x80eabf42,0x2568,0x4e5e,0xbd,0x82,0xc3,0x7f,0x86,0x96,0x1d,0xc3);
+DEFINE_GUID(IID_ID3D12Device1,0x77acce80,0x638e,0x4e65,0x88,0x95,0xc1,0xf2,0x33,0x86,0x86,0x3e);
+DEFINE_GUID(IID_ID3D12Device2,0x30baa41e,0xb15b,0x475c,0xa0,0xbb,0x1a,0xf5,0xc5,0xb6,0x43,0x28);
+DEFINE_GUID(IID_ID3D12Device3,0x81dadc15,0x2bad,0x4392,0x93,0xc5,0x10,0x13,0x45,0xc4,0xaa,0x98);
+DEFINE_GUID(IID_ID3D12ProtectedSession,0xA1533D18,0x0AC1,0x4084,0x85,0xB9,0x89,0xA9,0x61,0x16,0x80,0x6B);
+DEFINE_GUID(IID_ID3D12ProtectedResourceSession,0x6CD696F4,0xF289,0x40CC,0x80,0x91,0x5A,0x6C,0x0A,0x09,0x9C,0x3D);
+DEFINE_GUID(IID_ID3D12Device4,0xe865df17,0xa9ee,0x46f9,0xa4,0x63,0x30,0x98,0x31,0x5a,0xa2,0xe5);
+DEFINE_GUID(IID_ID3D12LifetimeOwner,0xe667af9f,0xcd56,0x4f46,0x83,0xce,0x03,0x2e,0x59,0x5d,0x70,0xa8);
+DEFINE_GUID(IID_ID3D12SwapChainAssistant,0xf1df64b6,0x57fd,0x49cd,0x88,0x07,0xc0,0xeb,0x88,0xb4,0x5c,0x8f);
+DEFINE_GUID(IID_ID3D12LifetimeTracker,0x3fd03d36,0x4eb1,0x424a,0xa5,0x82,0x49,0x4e,0xcb,0x8b,0xa8,0x13);
+DEFINE_GUID(IID_ID3D12StateObject,0x47016943,0xfca8,0x4594,0x93,0xea,0xaf,0x25,0x8b,0x55,0x34,0x6d);
+DEFINE_GUID(IID_ID3D12StateObjectProperties,0xde5fa827,0x9bf9,0x4f26,0x89,0xff,0xd7,0xf5,0x6f,0xde,0x38,0x60);
+DEFINE_GUID(IID_ID3D12Device5,0x8b4f173b,0x2fea,0x4b80,0x8f,0x58,0x43,0x07,0x19,0x1a,0xb9,0x5d);
+DEFINE_GUID(IID_ID3D12DeviceRemovedExtendedDataSettings,0x82BC481C,0x6B9B,0x4030,0xAE,0xDB,0x7E,0xE3,0xD1,0xDF,0x1E,0x63);
+DEFINE_GUID(IID_ID3D12DeviceRemovedExtendedData,0x98931D33,0x5AE8,0x4791,0xAA,0x3C,0x1A,0x73,0xA2,0x93,0x4E,0x71);
+DEFINE_GUID(IID_ID3D12Device6,0xc70b221b,0x40e4,0x4a17,0x89,0xaf,0x02,0x5a,0x07,0x27,0xa6,0xdc);
+DEFINE_GUID(IID_ID3D12Resource1,0x9D5E227A,0x4430,0x4161,0x88,0xB3,0x3E,0xCA,0x6B,0xB1,0x6E,0x19);
+DEFINE_GUID(IID_ID3D12Heap1,0x572F7389,0x2168,0x49E3,0x96,0x93,0xD6,0xDF,0x58,0x71,0xBF,0x6D);
+DEFINE_GUID(IID_ID3D12GraphicsCommandList3,0x6FDA83A7,0xB84C,0x4E38,0x9A,0xC8,0xC7,0xBD,0x22,0x01,0x6B,0x3D);
+DEFINE_GUID(IID_ID3D12MetaCommand,0xDBB84C27,0x36CE,0x4FC9,0xB8,0x01,0xF0,0x48,0xC4,0x6A,0xC5,0x70);
+DEFINE_GUID(IID_ID3D12GraphicsCommandList4,0x8754318e,0xd3a9,0x4541,0x98,0xcf,0x64,0x5b,0x50,0xdc,0x48,0x74);
+DEFINE_GUID(IID_ID3D12Tools,0x7071e1f0,0xe84b,0x4b33,0x97,0x4f,0x12,0xfa,0x49,0xde,0x65,0xc5);
+DEFINE_GUID(IID_ID3D12GraphicsCommandList5,0x55050859,0x4024,0x474c,0x87,0xf5,0x64,0x72,0xea,0xee,0x44,0xea);
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0045_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12_0000_0045_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/pc/gfx/dxsdk/d3d12sdklayers.h b/src/pc/gfx/dxsdk/d3d12sdklayers.h
new file mode 100644
index 0000000..93c9358
--- /dev/null
+++ b/src/pc/gfx/dxsdk/d3d12sdklayers.h
@@ -0,0 +1,3230 @@
+/*-------------------------------------------------------------------------------------
+ *
+ * Copyright (c) Microsoft Corporation
+ *
+ *-------------------------------------------------------------------------------------*/
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 8.01.0622 */
+
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 500
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif /* __RPCNDR_H_VERSION__ */
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __d3d12sdklayers_h__
+#define __d3d12sdklayers_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __ID3D12Debug_FWD_DEFINED__
+#define __ID3D12Debug_FWD_DEFINED__
+typedef interface ID3D12Debug ID3D12Debug;
+
+#endif   /* __ID3D12Debug_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Debug1_FWD_DEFINED__
+#define __ID3D12Debug1_FWD_DEFINED__
+typedef interface ID3D12Debug1 ID3D12Debug1;
+
+#endif   /* __ID3D12Debug1_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Debug2_FWD_DEFINED__
+#define __ID3D12Debug2_FWD_DEFINED__
+typedef interface ID3D12Debug2 ID3D12Debug2;
+
+#endif   /* __ID3D12Debug2_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12Debug3_FWD_DEFINED__
+#define __ID3D12Debug3_FWD_DEFINED__
+typedef interface ID3D12Debug3 ID3D12Debug3;
+
+#endif   /* __ID3D12Debug3_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DebugDevice1_FWD_DEFINED__
+#define __ID3D12DebugDevice1_FWD_DEFINED__
+typedef interface ID3D12DebugDevice1 ID3D12DebugDevice1;
+
+#endif   /* __ID3D12DebugDevice1_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DebugDevice_FWD_DEFINED__
+#define __ID3D12DebugDevice_FWD_DEFINED__
+typedef interface ID3D12DebugDevice ID3D12DebugDevice;
+
+#endif   /* __ID3D12DebugDevice_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DebugDevice2_FWD_DEFINED__
+#define __ID3D12DebugDevice2_FWD_DEFINED__
+typedef interface ID3D12DebugDevice2 ID3D12DebugDevice2;
+
+#endif   /* __ID3D12DebugDevice2_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DebugCommandQueue_FWD_DEFINED__
+#define __ID3D12DebugCommandQueue_FWD_DEFINED__
+typedef interface ID3D12DebugCommandQueue ID3D12DebugCommandQueue;
+
+#endif   /* __ID3D12DebugCommandQueue_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DebugCommandList1_FWD_DEFINED__
+#define __ID3D12DebugCommandList1_FWD_DEFINED__
+typedef interface ID3D12DebugCommandList1 ID3D12DebugCommandList1;
+
+#endif   /* __ID3D12DebugCommandList1_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DebugCommandList_FWD_DEFINED__
+#define __ID3D12DebugCommandList_FWD_DEFINED__
+typedef interface ID3D12DebugCommandList ID3D12DebugCommandList;
+
+#endif   /* __ID3D12DebugCommandList_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12DebugCommandList2_FWD_DEFINED__
+#define __ID3D12DebugCommandList2_FWD_DEFINED__
+typedef interface ID3D12DebugCommandList2 ID3D12DebugCommandList2;
+
+#endif   /* __ID3D12DebugCommandList2_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12SharingContract_FWD_DEFINED__
+#define __ID3D12SharingContract_FWD_DEFINED__
+typedef interface ID3D12SharingContract ID3D12SharingContract;
+
+#endif   /* __ID3D12SharingContract_FWD_DEFINED__ */
+
+
+#ifndef __ID3D12InfoQueue_FWD_DEFINED__
+#define __ID3D12InfoQueue_FWD_DEFINED__
+typedef interface ID3D12InfoQueue ID3D12InfoQueue;
+
+#endif   /* __ID3D12InfoQueue_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "oaidl.h"
+#include "ocidl.h"
+#include "d3d12.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_d3d12sdklayers_0000_0000 */
+/* [local] */ 
+
+#include <winapifamily.h>
+#pragma region App Family
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_GAMES)
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0000_v0_0_s_ifspec;
+
+#ifndef __ID3D12Debug_INTERFACE_DEFINED__
+#define __ID3D12Debug_INTERFACE_DEFINED__
+
+/* interface ID3D12Debug */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Debug;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("344488b7-6846-474b-b989-f027448245e0")
+    ID3D12Debug : public IUnknown
+    {
+    public:
+        virtual void STDMETHODCALLTYPE EnableDebugLayer( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DebugVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Debug * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Debug * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Debug * This);
+        
+        void ( STDMETHODCALLTYPE *EnableDebugLayer )( 
+            ID3D12Debug * This);
+        
+        END_INTERFACE
+    } ID3D12DebugVtbl;
+
+    interface ID3D12Debug
+    {
+        CONST_VTBL struct ID3D12DebugVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Debug_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Debug_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Debug_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Debug_EnableDebugLayer(This) \
+    ( (This)->lpVtbl -> EnableDebugLayer(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Debug_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12sdklayers_0000_0001 */
+/* [local] */ 
+
+typedef 
+enum D3D12_GPU_BASED_VALIDATION_FLAGS
+    {
+        D3D12_GPU_BASED_VALIDATION_FLAGS_NONE  = 0,
+        D3D12_GPU_BASED_VALIDATION_FLAGS_DISABLE_STATE_TRACKING  = 0x1
+    }  D3D12_GPU_BASED_VALIDATION_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS(D3D12_GPU_BASED_VALIDATION_FLAGS)
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0001_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0001_v0_0_s_ifspec;
+
+#ifndef __ID3D12Debug1_INTERFACE_DEFINED__
+#define __ID3D12Debug1_INTERFACE_DEFINED__
+
+/* interface ID3D12Debug1 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Debug1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("affaa4ca-63fe-4d8e-b8ad-159000af4304")
+    ID3D12Debug1 : public IUnknown
+    {
+    public:
+        virtual void STDMETHODCALLTYPE EnableDebugLayer( void) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetEnableGPUBasedValidation( 
+            BOOL Enable) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetEnableSynchronizedCommandQueueValidation( 
+            BOOL Enable) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Debug1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Debug1 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Debug1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Debug1 * This);
+        
+        void ( STDMETHODCALLTYPE *EnableDebugLayer )( 
+            ID3D12Debug1 * This);
+        
+        void ( STDMETHODCALLTYPE *SetEnableGPUBasedValidation )( 
+            ID3D12Debug1 * This,
+            BOOL Enable);
+        
+        void ( STDMETHODCALLTYPE *SetEnableSynchronizedCommandQueueValidation )( 
+            ID3D12Debug1 * This,
+            BOOL Enable);
+        
+        END_INTERFACE
+    } ID3D12Debug1Vtbl;
+
+    interface ID3D12Debug1
+    {
+        CONST_VTBL struct ID3D12Debug1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Debug1_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Debug1_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Debug1_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Debug1_EnableDebugLayer(This)  \
+    ( (This)->lpVtbl -> EnableDebugLayer(This) ) 
+
+#define ID3D12Debug1_SetEnableGPUBasedValidation(This,Enable)  \
+    ( (This)->lpVtbl -> SetEnableGPUBasedValidation(This,Enable) ) 
+
+#define ID3D12Debug1_SetEnableSynchronizedCommandQueueValidation(This,Enable)  \
+    ( (This)->lpVtbl -> SetEnableSynchronizedCommandQueueValidation(This,Enable) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Debug1_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Debug2_INTERFACE_DEFINED__
+#define __ID3D12Debug2_INTERFACE_DEFINED__
+
+/* interface ID3D12Debug2 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Debug2;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("93a665c4-a3b2-4e5d-b692-a26ae14e3374")
+    ID3D12Debug2 : public IUnknown
+    {
+    public:
+        virtual void STDMETHODCALLTYPE SetGPUBasedValidationFlags( 
+            D3D12_GPU_BASED_VALIDATION_FLAGS Flags) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Debug2Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Debug2 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Debug2 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Debug2 * This);
+        
+        void ( STDMETHODCALLTYPE *SetGPUBasedValidationFlags )( 
+            ID3D12Debug2 * This,
+            D3D12_GPU_BASED_VALIDATION_FLAGS Flags);
+        
+        END_INTERFACE
+    } ID3D12Debug2Vtbl;
+
+    interface ID3D12Debug2
+    {
+        CONST_VTBL struct ID3D12Debug2Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Debug2_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Debug2_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Debug2_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Debug2_SetGPUBasedValidationFlags(This,Flags)  \
+    ( (This)->lpVtbl -> SetGPUBasedValidationFlags(This,Flags) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Debug2_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12Debug3_INTERFACE_DEFINED__
+#define __ID3D12Debug3_INTERFACE_DEFINED__
+
+/* interface ID3D12Debug3 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12Debug3;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("5cf4e58f-f671-4ff1-a542-3686e3d153d1")
+    ID3D12Debug3 : public ID3D12Debug
+    {
+    public:
+        virtual void STDMETHODCALLTYPE SetEnableGPUBasedValidation( 
+            BOOL Enable) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetEnableSynchronizedCommandQueueValidation( 
+            BOOL Enable) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetGPUBasedValidationFlags( 
+            D3D12_GPU_BASED_VALIDATION_FLAGS Flags) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12Debug3Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12Debug3 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12Debug3 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12Debug3 * This);
+        
+        void ( STDMETHODCALLTYPE *EnableDebugLayer )( 
+            ID3D12Debug3 * This);
+        
+        void ( STDMETHODCALLTYPE *SetEnableGPUBasedValidation )( 
+            ID3D12Debug3 * This,
+            BOOL Enable);
+        
+        void ( STDMETHODCALLTYPE *SetEnableSynchronizedCommandQueueValidation )( 
+            ID3D12Debug3 * This,
+            BOOL Enable);
+        
+        void ( STDMETHODCALLTYPE *SetGPUBasedValidationFlags )( 
+            ID3D12Debug3 * This,
+            D3D12_GPU_BASED_VALIDATION_FLAGS Flags);
+        
+        END_INTERFACE
+    } ID3D12Debug3Vtbl;
+
+    interface ID3D12Debug3
+    {
+        CONST_VTBL struct ID3D12Debug3Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12Debug3_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12Debug3_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12Debug3_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12Debug3_EnableDebugLayer(This)  \
+    ( (This)->lpVtbl -> EnableDebugLayer(This) ) 
+
+
+#define ID3D12Debug3_SetEnableGPUBasedValidation(This,Enable)  \
+    ( (This)->lpVtbl -> SetEnableGPUBasedValidation(This,Enable) ) 
+
+#define ID3D12Debug3_SetEnableSynchronizedCommandQueueValidation(This,Enable)  \
+    ( (This)->lpVtbl -> SetEnableSynchronizedCommandQueueValidation(This,Enable) ) 
+
+#define ID3D12Debug3_SetGPUBasedValidationFlags(This,Flags)  \
+    ( (This)->lpVtbl -> SetGPUBasedValidationFlags(This,Flags) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12Debug3_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12sdklayers_0000_0004 */
+/* [local] */ 
+
+typedef 
+enum D3D12_RLDO_FLAGS
+    {
+        D3D12_RLDO_NONE  = 0,
+        D3D12_RLDO_SUMMARY = 0x1,
+        D3D12_RLDO_DETAIL  = 0x2,
+        D3D12_RLDO_IGNORE_INTERNAL = 0x4
+    }  D3D12_RLDO_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS(D3D12_RLDO_FLAGS)
+typedef 
+enum D3D12_DEBUG_DEVICE_PARAMETER_TYPE
+    {
+        D3D12_DEBUG_DEVICE_PARAMETER_FEATURE_FLAGS = 0,
+        D3D12_DEBUG_DEVICE_PARAMETER_GPU_BASED_VALIDATION_SETTINGS = ( D3D12_DEBUG_DEVICE_PARAMETER_FEATURE_FLAGS + 1 ) ,
+        D3D12_DEBUG_DEVICE_PARAMETER_GPU_SLOWDOWN_PERFORMANCE_FACTOR = ( D3D12_DEBUG_DEVICE_PARAMETER_GPU_BASED_VALIDATION_SETTINGS + 1 ) 
+    }  D3D12_DEBUG_DEVICE_PARAMETER_TYPE;
+
+typedef 
+enum D3D12_DEBUG_FEATURE
+    {
+        D3D12_DEBUG_FEATURE_NONE = 0,
+        D3D12_DEBUG_FEATURE_ALLOW_BEHAVIOR_CHANGING_DEBUG_AIDS = 0x1,
+        D3D12_DEBUG_FEATURE_CONSERVATIVE_RESOURCE_STATE_TRACKING = 0x2,
+        D3D12_DEBUG_FEATURE_DISABLE_VIRTUALIZED_BUNDLES_VALIDATION = 0x4,
+        D3D12_DEBUG_FEATURE_EMULATE_WINDOWS7 = 0x8
+    }  D3D12_DEBUG_FEATURE;
+
+DEFINE_ENUM_FLAG_OPERATORS(D3D12_DEBUG_FEATURE)
+typedef 
+enum D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE
+    {
+        D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_NONE  = 0,
+        D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_STATE_TRACKING_ONLY = ( D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_NONE + 1 ) ,
+        D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_UNGUARDED_VALIDATION  = ( D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_STATE_TRACKING_ONLY + 1 ) ,
+        D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_GUARDED_VALIDATION  = ( D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_UNGUARDED_VALIDATION + 1 ) ,
+        NUM_D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODES  = ( D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_GUARDED_VALIDATION + 1 ) 
+    }  D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE;
+
+typedef 
+enum D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS
+    {
+        D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAG_NONE = 0,
+        D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAG_FRONT_LOAD_CREATE_TRACKING_ONLY_SHADERS  = 0x1,
+        D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAG_FRONT_LOAD_CREATE_UNGUARDED_VALIDATION_SHADERS = 0x2,
+        D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAG_FRONT_LOAD_CREATE_GUARDED_VALIDATION_SHADERS = 0x4,
+        D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS_VALID_MASK  = 0x7
+    }  D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS;
+
+DEFINE_ENUM_FLAG_OPERATORS(D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS)
+typedef struct D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS
+    {
+    UINT MaxMessagesPerCommandList;
+    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE DefaultShaderPatchMode;
+    D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS PipelineStateCreateFlags;
+    }  D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS;
+
+typedef struct D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR
+    {
+    FLOAT SlowdownFactor;
+    }  D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0004_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0004_v0_0_s_ifspec;
+
+#ifndef __ID3D12DebugDevice1_INTERFACE_DEFINED__
+#define __ID3D12DebugDevice1_INTERFACE_DEFINED__
+
+/* interface ID3D12DebugDevice1 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DebugDevice1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("a9b71770-d099-4a65-a698-3dee10020f88")
+    ID3D12DebugDevice1 : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetDebugParameter( 
+            D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
+            _In_reads_bytes_(DataSize)  const void *pData,
+            UINT DataSize) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDebugParameter( 
+            D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
+            _Out_writes_bytes_(DataSize)  void *pData,
+            UINT DataSize) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ReportLiveDeviceObjects( 
+            D3D12_RLDO_FLAGS Flags) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DebugDevice1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DebugDevice1 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DebugDevice1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DebugDevice1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetDebugParameter )( 
+            ID3D12DebugDevice1 * This,
+            D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
+            _In_reads_bytes_(DataSize)  const void *pData,
+            UINT DataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDebugParameter )( 
+            ID3D12DebugDevice1 * This,
+            D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
+            _Out_writes_bytes_(DataSize)  void *pData,
+            UINT DataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *ReportLiveDeviceObjects )( 
+            ID3D12DebugDevice1 * This,
+            D3D12_RLDO_FLAGS Flags);
+        
+        END_INTERFACE
+    } ID3D12DebugDevice1Vtbl;
+
+    interface ID3D12DebugDevice1
+    {
+        CONST_VTBL struct ID3D12DebugDevice1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DebugDevice1_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DebugDevice1_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DebugDevice1_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DebugDevice1_SetDebugParameter(This,Type,pData,DataSize) \
+    ( (This)->lpVtbl -> SetDebugParameter(This,Type,pData,DataSize) ) 
+
+#define ID3D12DebugDevice1_GetDebugParameter(This,Type,pData,DataSize) \
+    ( (This)->lpVtbl -> GetDebugParameter(This,Type,pData,DataSize) ) 
+
+#define ID3D12DebugDevice1_ReportLiveDeviceObjects(This,Flags) \
+    ( (This)->lpVtbl -> ReportLiveDeviceObjects(This,Flags) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DebugDevice1_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12DebugDevice_INTERFACE_DEFINED__
+#define __ID3D12DebugDevice_INTERFACE_DEFINED__
+
+/* interface ID3D12DebugDevice */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DebugDevice;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("3febd6dd-4973-4787-8194-e45f9e28923e")
+    ID3D12DebugDevice : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetFeatureMask( 
+            D3D12_DEBUG_FEATURE Mask) = 0;
+        
+        virtual D3D12_DEBUG_FEATURE STDMETHODCALLTYPE GetFeatureMask( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ReportLiveDeviceObjects( 
+            D3D12_RLDO_FLAGS Flags) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DebugDeviceVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DebugDevice * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DebugDevice * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DebugDevice * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetFeatureMask )( 
+            ID3D12DebugDevice * This,
+            D3D12_DEBUG_FEATURE Mask);
+        
+        D3D12_DEBUG_FEATURE ( STDMETHODCALLTYPE *GetFeatureMask )( 
+            ID3D12DebugDevice * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *ReportLiveDeviceObjects )( 
+            ID3D12DebugDevice * This,
+            D3D12_RLDO_FLAGS Flags);
+        
+        END_INTERFACE
+    } ID3D12DebugDeviceVtbl;
+
+    interface ID3D12DebugDevice
+    {
+        CONST_VTBL struct ID3D12DebugDeviceVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DebugDevice_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DebugDevice_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DebugDevice_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DebugDevice_SetFeatureMask(This,Mask)  \
+    ( (This)->lpVtbl -> SetFeatureMask(This,Mask) ) 
+
+#define ID3D12DebugDevice_GetFeatureMask(This) \
+    ( (This)->lpVtbl -> GetFeatureMask(This) ) 
+
+#define ID3D12DebugDevice_ReportLiveDeviceObjects(This,Flags)  \
+    ( (This)->lpVtbl -> ReportLiveDeviceObjects(This,Flags) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DebugDevice_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12DebugDevice2_INTERFACE_DEFINED__
+#define __ID3D12DebugDevice2_INTERFACE_DEFINED__
+
+/* interface ID3D12DebugDevice2 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DebugDevice2;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("60eccbc1-378d-4df1-894c-f8ac5ce4d7dd")
+    ID3D12DebugDevice2 : public ID3D12DebugDevice
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetDebugParameter( 
+            D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
+            _In_reads_bytes_(DataSize)  const void *pData,
+            UINT DataSize) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDebugParameter( 
+            D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
+            _Out_writes_bytes_(DataSize)  void *pData,
+            UINT DataSize) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DebugDevice2Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DebugDevice2 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DebugDevice2 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DebugDevice2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetFeatureMask )( 
+            ID3D12DebugDevice2 * This,
+            D3D12_DEBUG_FEATURE Mask);
+        
+        D3D12_DEBUG_FEATURE ( STDMETHODCALLTYPE *GetFeatureMask )( 
+            ID3D12DebugDevice2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *ReportLiveDeviceObjects )( 
+            ID3D12DebugDevice2 * This,
+            D3D12_RLDO_FLAGS Flags);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetDebugParameter )( 
+            ID3D12DebugDevice2 * This,
+            D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
+            _In_reads_bytes_(DataSize)  const void *pData,
+            UINT DataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDebugParameter )( 
+            ID3D12DebugDevice2 * This,
+            D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
+            _Out_writes_bytes_(DataSize)  void *pData,
+            UINT DataSize);
+        
+        END_INTERFACE
+    } ID3D12DebugDevice2Vtbl;
+
+    interface ID3D12DebugDevice2
+    {
+        CONST_VTBL struct ID3D12DebugDevice2Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DebugDevice2_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DebugDevice2_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DebugDevice2_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DebugDevice2_SetFeatureMask(This,Mask) \
+    ( (This)->lpVtbl -> SetFeatureMask(This,Mask) ) 
+
+#define ID3D12DebugDevice2_GetFeatureMask(This)  \
+    ( (This)->lpVtbl -> GetFeatureMask(This) ) 
+
+#define ID3D12DebugDevice2_ReportLiveDeviceObjects(This,Flags) \
+    ( (This)->lpVtbl -> ReportLiveDeviceObjects(This,Flags) ) 
+
+
+#define ID3D12DebugDevice2_SetDebugParameter(This,Type,pData,DataSize) \
+    ( (This)->lpVtbl -> SetDebugParameter(This,Type,pData,DataSize) ) 
+
+#define ID3D12DebugDevice2_GetDebugParameter(This,Type,pData,DataSize) \
+    ( (This)->lpVtbl -> GetDebugParameter(This,Type,pData,DataSize) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DebugDevice2_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12sdklayers_0000_0007 */
+/* [local] */ 
+
+DEFINE_GUID(DXGI_DEBUG_D3D12, 0xcf59a98c, 0xa950, 0x4326, 0x91, 0xef, 0x9b, 0xba, 0xa1, 0x7b, 0xfd, 0x95);
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0007_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0007_v0_0_s_ifspec;
+
+#ifndef __ID3D12DebugCommandQueue_INTERFACE_DEFINED__
+#define __ID3D12DebugCommandQueue_INTERFACE_DEFINED__
+
+/* interface ID3D12DebugCommandQueue */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DebugCommandQueue;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("09e0bf36-54ac-484f-8847-4baeeab6053a")
+    ID3D12DebugCommandQueue : public IUnknown
+    {
+    public:
+        virtual BOOL STDMETHODCALLTYPE AssertResourceState( 
+            _In_  ID3D12Resource *pResource,
+            UINT Subresource,
+            UINT State) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DebugCommandQueueVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DebugCommandQueue * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DebugCommandQueue * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DebugCommandQueue * This);
+        
+        BOOL ( STDMETHODCALLTYPE *AssertResourceState )( 
+            ID3D12DebugCommandQueue * This,
+            _In_  ID3D12Resource *pResource,
+            UINT Subresource,
+            UINT State);
+        
+        END_INTERFACE
+    } ID3D12DebugCommandQueueVtbl;
+
+    interface ID3D12DebugCommandQueue
+    {
+        CONST_VTBL struct ID3D12DebugCommandQueueVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DebugCommandQueue_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DebugCommandQueue_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DebugCommandQueue_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DebugCommandQueue_AssertResourceState(This,pResource,Subresource,State)  \
+    ( (This)->lpVtbl -> AssertResourceState(This,pResource,Subresource,State) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DebugCommandQueue_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12sdklayers_0000_0008 */
+/* [local] */ 
+
+typedef 
+enum D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE
+    {
+        D3D12_DEBUG_COMMAND_LIST_PARAMETER_GPU_BASED_VALIDATION_SETTINGS = 0
+    }  D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE;
+
+typedef struct D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS
+    {
+    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE ShaderPatchMode;
+    }  D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0008_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0008_v0_0_s_ifspec;
+
+#ifndef __ID3D12DebugCommandList1_INTERFACE_DEFINED__
+#define __ID3D12DebugCommandList1_INTERFACE_DEFINED__
+
+/* interface ID3D12DebugCommandList1 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DebugCommandList1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("102ca951-311b-4b01-b11f-ecb83e061b37")
+    ID3D12DebugCommandList1 : public IUnknown
+    {
+    public:
+        virtual BOOL STDMETHODCALLTYPE AssertResourceState( 
+            _In_  ID3D12Resource *pResource,
+            UINT Subresource,
+            UINT State) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetDebugParameter( 
+            D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
+            _In_reads_bytes_(DataSize)  const void *pData,
+            UINT DataSize) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDebugParameter( 
+            D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
+            _Out_writes_bytes_(DataSize)  void *pData,
+            UINT DataSize) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DebugCommandList1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DebugCommandList1 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DebugCommandList1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DebugCommandList1 * This);
+        
+        BOOL ( STDMETHODCALLTYPE *AssertResourceState )( 
+            ID3D12DebugCommandList1 * This,
+            _In_  ID3D12Resource *pResource,
+            UINT Subresource,
+            UINT State);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetDebugParameter )( 
+            ID3D12DebugCommandList1 * This,
+            D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
+            _In_reads_bytes_(DataSize)  const void *pData,
+            UINT DataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDebugParameter )( 
+            ID3D12DebugCommandList1 * This,
+            D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
+            _Out_writes_bytes_(DataSize)  void *pData,
+            UINT DataSize);
+        
+        END_INTERFACE
+    } ID3D12DebugCommandList1Vtbl;
+
+    interface ID3D12DebugCommandList1
+    {
+        CONST_VTBL struct ID3D12DebugCommandList1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DebugCommandList1_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DebugCommandList1_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DebugCommandList1_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DebugCommandList1_AssertResourceState(This,pResource,Subresource,State)  \
+    ( (This)->lpVtbl -> AssertResourceState(This,pResource,Subresource,State) ) 
+
+#define ID3D12DebugCommandList1_SetDebugParameter(This,Type,pData,DataSize)  \
+    ( (This)->lpVtbl -> SetDebugParameter(This,Type,pData,DataSize) ) 
+
+#define ID3D12DebugCommandList1_GetDebugParameter(This,Type,pData,DataSize)  \
+    ( (This)->lpVtbl -> GetDebugParameter(This,Type,pData,DataSize) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DebugCommandList1_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12DebugCommandList_INTERFACE_DEFINED__
+#define __ID3D12DebugCommandList_INTERFACE_DEFINED__
+
+/* interface ID3D12DebugCommandList */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DebugCommandList;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("09e0bf36-54ac-484f-8847-4baeeab6053f")
+    ID3D12DebugCommandList : public IUnknown
+    {
+    public:
+        virtual BOOL STDMETHODCALLTYPE AssertResourceState( 
+            _In_  ID3D12Resource *pResource,
+            UINT Subresource,
+            UINT State) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetFeatureMask( 
+            D3D12_DEBUG_FEATURE Mask) = 0;
+        
+        virtual D3D12_DEBUG_FEATURE STDMETHODCALLTYPE GetFeatureMask( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DebugCommandListVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DebugCommandList * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DebugCommandList * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DebugCommandList * This);
+        
+        BOOL ( STDMETHODCALLTYPE *AssertResourceState )( 
+            ID3D12DebugCommandList * This,
+            _In_  ID3D12Resource *pResource,
+            UINT Subresource,
+            UINT State);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetFeatureMask )( 
+            ID3D12DebugCommandList * This,
+            D3D12_DEBUG_FEATURE Mask);
+        
+        D3D12_DEBUG_FEATURE ( STDMETHODCALLTYPE *GetFeatureMask )( 
+            ID3D12DebugCommandList * This);
+        
+        END_INTERFACE
+    } ID3D12DebugCommandListVtbl;
+
+    interface ID3D12DebugCommandList
+    {
+        CONST_VTBL struct ID3D12DebugCommandListVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DebugCommandList_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DebugCommandList_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DebugCommandList_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DebugCommandList_AssertResourceState(This,pResource,Subresource,State) \
+    ( (This)->lpVtbl -> AssertResourceState(This,pResource,Subresource,State) ) 
+
+#define ID3D12DebugCommandList_SetFeatureMask(This,Mask) \
+    ( (This)->lpVtbl -> SetFeatureMask(This,Mask) ) 
+
+#define ID3D12DebugCommandList_GetFeatureMask(This)  \
+    ( (This)->lpVtbl -> GetFeatureMask(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DebugCommandList_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12DebugCommandList2_INTERFACE_DEFINED__
+#define __ID3D12DebugCommandList2_INTERFACE_DEFINED__
+
+/* interface ID3D12DebugCommandList2 */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12DebugCommandList2;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("aeb575cf-4e06-48be-ba3b-c450fc96652e")
+    ID3D12DebugCommandList2 : public ID3D12DebugCommandList
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetDebugParameter( 
+            D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
+            _In_reads_bytes_(DataSize)  const void *pData,
+            UINT DataSize) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDebugParameter( 
+            D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
+            _Out_writes_bytes_(DataSize)  void *pData,
+            UINT DataSize) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12DebugCommandList2Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12DebugCommandList2 * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12DebugCommandList2 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12DebugCommandList2 * This);
+        
+        BOOL ( STDMETHODCALLTYPE *AssertResourceState )( 
+            ID3D12DebugCommandList2 * This,
+            _In_  ID3D12Resource *pResource,
+            UINT Subresource,
+            UINT State);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetFeatureMask )( 
+            ID3D12DebugCommandList2 * This,
+            D3D12_DEBUG_FEATURE Mask);
+        
+        D3D12_DEBUG_FEATURE ( STDMETHODCALLTYPE *GetFeatureMask )( 
+            ID3D12DebugCommandList2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetDebugParameter )( 
+            ID3D12DebugCommandList2 * This,
+            D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
+            _In_reads_bytes_(DataSize)  const void *pData,
+            UINT DataSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDebugParameter )( 
+            ID3D12DebugCommandList2 * This,
+            D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
+            _Out_writes_bytes_(DataSize)  void *pData,
+            UINT DataSize);
+        
+        END_INTERFACE
+    } ID3D12DebugCommandList2Vtbl;
+
+    interface ID3D12DebugCommandList2
+    {
+        CONST_VTBL struct ID3D12DebugCommandList2Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12DebugCommandList2_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12DebugCommandList2_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12DebugCommandList2_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12DebugCommandList2_AssertResourceState(This,pResource,Subresource,State)  \
+    ( (This)->lpVtbl -> AssertResourceState(This,pResource,Subresource,State) ) 
+
+#define ID3D12DebugCommandList2_SetFeatureMask(This,Mask)  \
+    ( (This)->lpVtbl -> SetFeatureMask(This,Mask) ) 
+
+#define ID3D12DebugCommandList2_GetFeatureMask(This) \
+    ( (This)->lpVtbl -> GetFeatureMask(This) ) 
+
+
+#define ID3D12DebugCommandList2_SetDebugParameter(This,Type,pData,DataSize)  \
+    ( (This)->lpVtbl -> SetDebugParameter(This,Type,pData,DataSize) ) 
+
+#define ID3D12DebugCommandList2_GetDebugParameter(This,Type,pData,DataSize)  \
+    ( (This)->lpVtbl -> GetDebugParameter(This,Type,pData,DataSize) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12DebugCommandList2_INTERFACE_DEFINED__ */
+
+
+#ifndef __ID3D12SharingContract_INTERFACE_DEFINED__
+#define __ID3D12SharingContract_INTERFACE_DEFINED__
+
+/* interface ID3D12SharingContract */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12SharingContract;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("0adf7d52-929c-4e61-addb-ffed30de66ef")
+    ID3D12SharingContract : public IUnknown
+    {
+    public:
+        virtual void STDMETHODCALLTYPE Present( 
+            _In_  ID3D12Resource *pResource,
+            UINT Subresource,
+            _In_  HWND window) = 0;
+        
+        virtual void STDMETHODCALLTYPE SharedFenceSignal( 
+            _In_  ID3D12Fence *pFence,
+            UINT64 FenceValue) = 0;
+        
+        virtual void STDMETHODCALLTYPE BeginCapturableWork( 
+            _In_  REFGUID guid) = 0;
+        
+        virtual void STDMETHODCALLTYPE EndCapturableWork( 
+            _In_  REFGUID guid) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12SharingContractVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12SharingContract * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12SharingContract * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12SharingContract * This);
+        
+        void ( STDMETHODCALLTYPE *Present )( 
+            ID3D12SharingContract * This,
+            _In_  ID3D12Resource *pResource,
+            UINT Subresource,
+            _In_  HWND window);
+        
+        void ( STDMETHODCALLTYPE *SharedFenceSignal )( 
+            ID3D12SharingContract * This,
+            _In_  ID3D12Fence *pFence,
+            UINT64 FenceValue);
+        
+        void ( STDMETHODCALLTYPE *BeginCapturableWork )( 
+            ID3D12SharingContract * This,
+            _In_  REFGUID guid);
+        
+        void ( STDMETHODCALLTYPE *EndCapturableWork )( 
+            ID3D12SharingContract * This,
+            _In_  REFGUID guid);
+        
+        END_INTERFACE
+    } ID3D12SharingContractVtbl;
+
+    interface ID3D12SharingContract
+    {
+        CONST_VTBL struct ID3D12SharingContractVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12SharingContract_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12SharingContract_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12SharingContract_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12SharingContract_Present(This,pResource,Subresource,window) \
+    ( (This)->lpVtbl -> Present(This,pResource,Subresource,window) ) 
+
+#define ID3D12SharingContract_SharedFenceSignal(This,pFence,FenceValue)  \
+    ( (This)->lpVtbl -> SharedFenceSignal(This,pFence,FenceValue) ) 
+
+#define ID3D12SharingContract_BeginCapturableWork(This,guid) \
+    ( (This)->lpVtbl -> BeginCapturableWork(This,guid) ) 
+
+#define ID3D12SharingContract_EndCapturableWork(This,guid) \
+    ( (This)->lpVtbl -> EndCapturableWork(This,guid) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12SharingContract_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12sdklayers_0000_0012 */
+/* [local] */ 
+
+typedef 
+enum D3D12_MESSAGE_CATEGORY
+    {
+        D3D12_MESSAGE_CATEGORY_APPLICATION_DEFINED = 0,
+        D3D12_MESSAGE_CATEGORY_MISCELLANEOUS = ( D3D12_MESSAGE_CATEGORY_APPLICATION_DEFINED + 1 ) ,
+        D3D12_MESSAGE_CATEGORY_INITIALIZATION  = ( D3D12_MESSAGE_CATEGORY_MISCELLANEOUS + 1 ) ,
+        D3D12_MESSAGE_CATEGORY_CLEANUP = ( D3D12_MESSAGE_CATEGORY_INITIALIZATION + 1 ) ,
+        D3D12_MESSAGE_CATEGORY_COMPILATION = ( D3D12_MESSAGE_CATEGORY_CLEANUP + 1 ) ,
+        D3D12_MESSAGE_CATEGORY_STATE_CREATION  = ( D3D12_MESSAGE_CATEGORY_COMPILATION + 1 ) ,
+        D3D12_MESSAGE_CATEGORY_STATE_SETTING = ( D3D12_MESSAGE_CATEGORY_STATE_CREATION + 1 ) ,
+        D3D12_MESSAGE_CATEGORY_STATE_GETTING = ( D3D12_MESSAGE_CATEGORY_STATE_SETTING + 1 ) ,
+        D3D12_MESSAGE_CATEGORY_RESOURCE_MANIPULATION = ( D3D12_MESSAGE_CATEGORY_STATE_GETTING + 1 ) ,
+        D3D12_MESSAGE_CATEGORY_EXECUTION = ( D3D12_MESSAGE_CATEGORY_RESOURCE_MANIPULATION + 1 ) ,
+        D3D12_MESSAGE_CATEGORY_SHADER  = ( D3D12_MESSAGE_CATEGORY_EXECUTION + 1 ) 
+    }  D3D12_MESSAGE_CATEGORY;
+
+typedef 
+enum D3D12_MESSAGE_SEVERITY
+    {
+        D3D12_MESSAGE_SEVERITY_CORRUPTION  = 0,
+        D3D12_MESSAGE_SEVERITY_ERROR = ( D3D12_MESSAGE_SEVERITY_CORRUPTION + 1 ) ,
+        D3D12_MESSAGE_SEVERITY_WARNING = ( D3D12_MESSAGE_SEVERITY_ERROR + 1 ) ,
+        D3D12_MESSAGE_SEVERITY_INFO  = ( D3D12_MESSAGE_SEVERITY_WARNING + 1 ) ,
+        D3D12_MESSAGE_SEVERITY_MESSAGE = ( D3D12_MESSAGE_SEVERITY_INFO + 1 ) 
+    }  D3D12_MESSAGE_SEVERITY;
+
+typedef 
+enum D3D12_MESSAGE_ID
+    {
+        D3D12_MESSAGE_ID_UNKNOWN = 0,
+        D3D12_MESSAGE_ID_STRING_FROM_APPLICATION = ( D3D12_MESSAGE_ID_UNKNOWN + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_THIS  = ( D3D12_MESSAGE_ID_STRING_FROM_APPLICATION + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER1  = ( D3D12_MESSAGE_ID_CORRUPTED_THIS + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER2  = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER1 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER3  = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER2 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER4  = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER3 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER5  = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER4 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER6  = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER5 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER7  = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER6 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER8  = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER7 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER9  = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER8 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER10 = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER9 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER11 = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER10 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER12 = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER11 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER13 = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER12 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER14 = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER13 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_PARAMETER15 = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER14 + 1 ) ,
+        D3D12_MESSAGE_ID_CORRUPTED_MULTITHREADING  = ( D3D12_MESSAGE_ID_CORRUPTED_PARAMETER15 + 1 ) ,
+        D3D12_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY = ( D3D12_MESSAGE_ID_CORRUPTED_MULTITHREADING + 1 ) ,
+        D3D12_MESSAGE_ID_GETPRIVATEDATA_MOREDATA = ( D3D12_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA  = ( D3D12_MESSAGE_ID_GETPRIVATEDATA_MOREDATA + 1 ) ,
+        D3D12_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN  = ( D3D12_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA + 1 ) ,
+        D3D12_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS = ( D3D12_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN + 1 ) ,
+        D3D12_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS = ( D3D12_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY  = ( D3D12_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT = ( D3D12_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC  = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT  = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDVIDEOPLANESLICE = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDPLANESLICE  = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDVIDEOPLANESLICE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS  = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDPLANESLICE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE  = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN  = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT  = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC  = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT  = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDVIDEOPLANESLICE = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDPLANESLICE  = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDVIDEOPLANESLICE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS  = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDPLANESLICE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE  = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN  = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT  = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE  = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT  = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC  = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT  = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY  = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE  = ( D3D12_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE  = ( D3D12_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY  = ( D3D12_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE = ( D3D12_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE = ( D3D12_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE = ( D3D12_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE = ( D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP = ( D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS = ( D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC  = ( D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK = ( D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND = ( D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP = ( D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA = ( D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA  = ( D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA  = ( D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK = ( D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC = ( D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER  = ( D3D12_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU  = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV  = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW  = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS  = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC  = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD  = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD  = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED = ( D3D12_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED  = ( D3D12_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT = ( D3D12_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR = ( D3D12_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH = ( D3D12_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH = ( D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID = ( D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH + 1 ) ,
+        D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE  = ( D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE  = ( D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE = ( D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE + 1 ) ,
+        D3D12_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE = ( D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE + 1 ) ,
+        D3D12_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX = ( D3D12_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE = ( D3D12_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID = ( D3D12_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID = ( D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID  = ( D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID  = ( D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID  = ( D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE = ( D3D12_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS = ( D3D12_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED  = ( D3D12_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN = ( D3D12_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED  = ( D3D12_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE  = ( D3D12_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE  = ( D3D12_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS  = ( D3D12_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED = ( D3D12_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN  = ( D3D12_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE  = ( D3D12_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED = ( D3D12_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE  = ( D3D12_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE  = ( D3D12_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS  = ( D3D12_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED = ( D3D12_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN  = ( D3D12_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE  = ( D3D12_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED = ( D3D12_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE  = ( D3D12_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE  = ( D3D12_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS  = ( D3D12_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED = ( D3D12_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN  = ( D3D12_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE  = ( D3D12_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED = ( D3D12_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED  = ( D3D12_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED = ( D3D12_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED + 1 ) ,
+        D3D12_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS  = ( D3D12_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED + 1 ) ,
+        D3D12_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN  = ( D3D12_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN = ( D3D12_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE = ( D3D12_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_REF_THREADING_MODE  = ( D3D12_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE + 1 ) ,
+        D3D12_MESSAGE_ID_REF_UMDRIVER_EXCEPTION  = ( D3D12_MESSAGE_ID_REF_THREADING_MODE + 1 ) ,
+        D3D12_MESSAGE_ID_REF_KMDRIVER_EXCEPTION  = ( D3D12_MESSAGE_ID_REF_UMDRIVER_EXCEPTION + 1 ) ,
+        D3D12_MESSAGE_ID_REF_HARDWARE_EXCEPTION  = ( D3D12_MESSAGE_ID_REF_KMDRIVER_EXCEPTION + 1 ) ,
+        D3D12_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE = ( D3D12_MESSAGE_ID_REF_HARDWARE_EXCEPTION + 1 ) ,
+        D3D12_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER  = ( D3D12_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE + 1 ) ,
+        D3D12_MESSAGE_ID_REF_OUT_OF_MEMORY = ( D3D12_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER + 1 ) ,
+        D3D12_MESSAGE_ID_REF_INFO  = ( D3D12_MESSAGE_ID_REF_OUT_OF_MEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW  = ( D3D12_MESSAGE_ID_REF_INFO + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW = ( D3D12_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW = ( D3D12_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW  = ( D3D12_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW = ( D3D12_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET = ( D3D12_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX = ( D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE = ( D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK  = ( D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE = ( D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS  = ( D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_ROOT_SIGNATURE_NOT_SET  = ( D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_ROOT_SIGNATURE_MISMATCH = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_ROOT_SIGNATURE_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_NOT_SET = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_ROOT_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INPUTLAYOUT_NOT_SET = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_CONSTANT_BUFFER_NOT_SET = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INPUTLAYOUT_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_CONSTANT_BUFFER_TOO_SMALL = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_CONSTANT_BUFFER_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_SAMPLER_NOT_SET = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_CONSTANT_BUFFER_TOO_SMALL + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_SHADERRESOURCEVIEW_NOT_SET  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_SAMPLER_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VIEW_DIMENSION_MISMATCH = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_SHADERRESOURCEVIEW_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VIEW_DIMENSION_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_TOO_SMALL = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_BUFFER_NOT_SET  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_TOO_SMALL + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_BUFFER_FORMAT_INVALID = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_BUFFER_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_BUFFER_TOO_SMALL  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_BUFFER_FORMAT_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_GS_INPUT_PRIMITIVE_MISMATCH = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_BUFFER_TOO_SMALL + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_RETURN_TYPE_MISMATCH = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_GS_INPUT_PRIMITIVE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_POSITION_NOT_PRESENT  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_RETURN_TYPE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_OUTPUT_STREAM_NOT_SET = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_POSITION_NOT_PRESENT + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_BOUND_RESOURCE_MAPPED = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_OUTPUT_STREAM_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INVALID_PRIMITIVETOPOLOGY = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_BOUND_RESOURCE_MAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_OFFSET_UNALIGNED = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INVALID_PRIMITIVETOPOLOGY + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_STRIDE_UNALIGNED = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_OFFSET_UNALIGNED + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_OFFSET_UNALIGNED  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_STRIDE_UNALIGNED + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_OFFSET_UNALIGNED + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_SO_STRIDE_LARGER_THAN_BUFFER  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_SO_STRIDE_LARGER_THAN_BUFFER + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT  = ( D3D12_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT = ( D3D12_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN = ( D3D12_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN  = ( D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN = ( D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET  = ( D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC + 1 ) ,
+        D3D12_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW  = ( D3D12_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS  = ( D3D12_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH  = ( D3D12_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH = ( D3D12_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY = ( D3D12_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH = ( D3D12_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN = ( D3D12_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE  = ( D3D12_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT  = ( D3D12_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_OBJECT_SUMMARY = ( D3D12_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_BUFFER = ( D3D12_MESSAGE_ID_LIVE_OBJECT_SUMMARY + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_TEXTURE1D  = ( D3D12_MESSAGE_ID_LIVE_BUFFER + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_TEXTURE2D  = ( D3D12_MESSAGE_ID_LIVE_TEXTURE1D + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_TEXTURE3D  = ( D3D12_MESSAGE_ID_LIVE_TEXTURE2D + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW = ( D3D12_MESSAGE_ID_LIVE_TEXTURE3D + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_RENDERTARGETVIEW = ( D3D12_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW = ( D3D12_MESSAGE_ID_LIVE_RENDERTARGETVIEW + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_VERTEXSHADER = ( D3D12_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_GEOMETRYSHADER = ( D3D12_MESSAGE_ID_LIVE_VERTEXSHADER + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_PIXELSHADER  = ( D3D12_MESSAGE_ID_LIVE_GEOMETRYSHADER + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_INPUTLAYOUT  = ( D3D12_MESSAGE_ID_LIVE_PIXELSHADER + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_SAMPLER  = ( D3D12_MESSAGE_ID_LIVE_INPUTLAYOUT + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_BLENDSTATE = ( D3D12_MESSAGE_ID_LIVE_SAMPLER + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE  = ( D3D12_MESSAGE_ID_LIVE_BLENDSTATE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_RASTERIZERSTATE  = ( D3D12_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_QUERY  = ( D3D12_MESSAGE_ID_LIVE_RASTERIZERSTATE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_PREDICATE  = ( D3D12_MESSAGE_ID_LIVE_QUERY + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_COUNTER  = ( D3D12_MESSAGE_ID_LIVE_PREDICATE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_DEVICE = ( D3D12_MESSAGE_ID_LIVE_COUNTER + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_SWAPCHAIN  = ( D3D12_MESSAGE_ID_LIVE_DEVICE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFLAGS = ( D3D12_MESSAGE_ID_LIVE_SWAPCHAIN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDCLASSLINKAGE  = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDCLASSLINKAGE  = ( D3D12_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDCLASSLINKAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTREAMS  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDCLASSLINKAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAMTORASTERIZER  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTREAMS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTREAMS  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAMTORASTERIZER + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCLASSLINKAGE  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTREAMS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIXELSHADER_INVALIDCLASSLINKAGE = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCLASSLINKAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAM  = ( D3D12_MESSAGE_ID_CREATEPIXELSHADER_INVALIDCLASSLINKAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDENTRIES  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAM + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTRIDES  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDENTRIES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTRIDES  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTRIDES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDCALL  = ( D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTRIDES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHULLSHADER_OUTOFMEMORY  = ( D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDCALL + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERBYTECODE  = ( D3D12_MESSAGE_ID_CREATEHULLSHADER_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERTYPE  = ( D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERBYTECODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDCLASSLINKAGE  = ( D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCALL  = ( D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDCLASSLINKAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDOMAINSHADER_OUTOFMEMORY  = ( D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCALL + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERBYTECODE  = ( D3D12_MESSAGE_ID_CREATEDOMAINSHADER_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERTYPE  = ( D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERBYTECODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCLASSLINKAGE  = ( D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_HS_XOR_DS_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCLASSLINKAGE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAWINDIRECT_INVALID_ARG_BUFFER  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_HS_XOR_DS_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_UNALIGNED  = ( D3D12_MESSAGE_ID_DEVICE_DRAWINDIRECT_INVALID_ARG_BUFFER + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_OVERFLOW = ( D3D12_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_UNALIGNED + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_MAP_INVALIDMAPTYPE = ( D3D12_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_OVERFLOW + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_MAP_INVALIDSUBRESOURCE = ( D3D12_MESSAGE_ID_RESOURCE_MAP_INVALIDMAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_MAP_INVALIDFLAGS = ( D3D12_MESSAGE_ID_RESOURCE_MAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_MAP_ALREADYMAPPED  = ( D3D12_MESSAGE_ID_RESOURCE_MAP_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_MAP_DEVICEREMOVED_RETURN = ( D3D12_MESSAGE_ID_RESOURCE_MAP_ALREADYMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_MAP_OUTOFMEMORY_RETURN = ( D3D12_MESSAGE_ID_RESOURCE_MAP_DEVICEREMOVED_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_MAP_WITHOUT_INITIAL_DISCARD  = ( D3D12_MESSAGE_ID_RESOURCE_MAP_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_UNMAP_INVALIDSUBRESOURCE = ( D3D12_MESSAGE_ID_RESOURCE_MAP_WITHOUT_INITIAL_DISCARD + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_UNMAP_NOTMAPPED  = ( D3D12_MESSAGE_ID_RESOURCE_UNMAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_RASTERIZING_CONTROL_POINTS  = ( D3D12_MESSAGE_ID_RESOURCE_UNMAP_NOTMAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_RASTERIZING_CONTROL_POINTS + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_HS_DS_SIGNATURE_MISMATCH  = ( D3D12_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH = ( D3D12_MESSAGE_ID_DEVICE_DRAW_HS_DS_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_HS_DS_CONTROL_POINT_COUNT_MISMATCH  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_HS_DS_TESSELLATOR_DOMAIN_MISMATCH = ( D3D12_MESSAGE_ID_DEVICE_DRAW_HS_DS_CONTROL_POINT_COUNT_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_UNRECOGNIZED_FEATURE = ( D3D12_MESSAGE_ID_DEVICE_DRAW_HS_DS_TESSELLATOR_DOMAIN_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_MISMATCHED_DATA_SIZE = ( D3D12_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_UNRECOGNIZED_FEATURE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_INVALIDARG_RETURN  = ( D3D12_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_MISMATCHED_DATA_SIZE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCALL = ( D3D12_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATECOMPUTESHADER_OUTOFMEMORY = ( D3D12_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCALL + 1 ) ,
+        D3D12_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERBYTECODE = ( D3D12_MESSAGE_ID_CREATECOMPUTESHADER_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCLASSLINKAGE = ( D3D12_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERBYTECODE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_VIEWS_EMPTY = ( D3D12_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCLASSLINKAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CSSETCONSTANTBUFFERS_INVALIDBUFFER  = ( D3D12_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_VIEWS_EMPTY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_BUFFERS_EMPTY = ( D3D12_MESSAGE_ID_CSSETCONSTANTBUFFERS_INVALIDBUFFER + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CSSETSAMPLERS_SAMPLERS_EMPTY = ( D3D12_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CSGETSHADERRESOURCES_VIEWS_EMPTY = ( D3D12_MESSAGE_ID_DEVICE_CSSETSAMPLERS_SAMPLERS_EMPTY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CSGETCONSTANTBUFFERS_BUFFERS_EMPTY = ( D3D12_MESSAGE_ID_DEVICE_CSGETSHADERRESOURCES_VIEWS_EMPTY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CSGETSAMPLERS_SAMPLERS_EMPTY = ( D3D12_MESSAGE_ID_DEVICE_CSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEFLOATOPSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CSGETSAMPLERS_SAMPLERS_EMPTY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEFLOATOPSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEFLOATOPSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEFLOATOPSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEFLOATOPSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEFLOATOPSNOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEFLOATOPSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEFLOATOPSNOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBUFFER_INVALIDSTRUCTURESTRIDE = ( D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFLAGS = ( D3D12_MESSAGE_ID_CREATEBUFFER_INVALIDSTRUCTURESTRIDE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDRESOURCE = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDESC = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFORMAT = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDVIDEOPLANESLICE  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDPLANESLICE = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDVIDEOPLANESLICE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDIMENSIONS = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDPLANESLICE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_UNRECOGNIZEDFORMAT  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDIMENSIONS + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_OVERLAPPING_OLD_SLOTS  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_UNRECOGNIZEDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_NO_OP  = ( D3D12_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_OVERLAPPING_OLD_SLOTS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDARG_RETURN = ( D3D12_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_NO_OP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_OUTOFMEMORY_RETURN  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_DENORMFLUSH  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSS_VIEWS_EMPTY  = ( D3D12_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_DENORMFLUSH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CSGETUNORDEREDACCESSS_VIEWS_EMPTY  = ( D3D12_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSS_VIEWS_EMPTY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFLAGS  = ( D3D12_MESSAGE_ID_DEVICE_CSGETUNORDEREDACCESSS_VIEWS_EMPTY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_INVALID_ARG_BUFFER  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_UNALIGNED  = ( D3D12_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_INVALID_ARG_BUFFER + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_OVERFLOW = ( D3D12_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_UNALIGNED + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DEPTH_READONLY  = ( D3D12_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_OVERFLOW + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_STENCIL_READONLY  = ( D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DEPTH_READONLY + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKFEATURESUPPORT_FORMAT_DEPRECATED = ( D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_STENCIL_READONLY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RETURN_TYPE_MISMATCH = ( D3D12_MESSAGE_ID_CHECKFEATURESUPPORT_FORMAT_DEPRECATED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET  = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RETURN_TYPE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_UNORDEREDACCESSVIEW_RENDERTARGETVIEW_OVERLAP  = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_DIMENSION_MISMATCH = ( D3D12_MESSAGE_ID_DEVICE_DRAW_UNORDEREDACCESSVIEW_RENDERTARGETVIEW_OVERLAP + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_APPEND_UNSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_DIMENSION_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMICS_UNSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_APPEND_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_STRUCTURE_STRIDE_MISMATCH  = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMICS_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_BUFFER_TYPE_MISMATCH = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_STRUCTURE_STRIDE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RAW_UNSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_BUFFER_TYPE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_LD_UNSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RAW_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_STORE_UNSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_LD_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_ADD_UNSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_STORE_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_BITWISE_OPS_UNSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_ADD_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_CMPSTORE_CMPEXCHANGE_UNSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_BITWISE_OPS_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_EXCHANGE_UNSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_CMPSTORE_CMPEXCHANGE_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_SIGNED_MINMAX_UNSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_EXCHANGE_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_UNSIGNED_MINMAX_UNSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_SIGNED_MINMAX_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DISPATCH_BOUND_RESOURCE_MAPPED = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_UNSIGNED_MINMAX_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_OVERFLOW = ( D3D12_MESSAGE_ID_DEVICE_DISPATCH_BOUND_RESOURCE_MAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_ZERO = ( D3D12_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_OVERFLOW + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_STRUCTURE_STRIDE_MISMATCH = ( D3D12_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_ZERO + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_BUFFER_TYPE_MISMATCH  = ( D3D12_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_STRUCTURE_STRIDE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_RAW_UNSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_BUFFER_TYPE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DISPATCH_UNSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_RAW_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_UNSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_DISPATCH_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDOFFSET  = ( D3D12_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_COPYSTRUCTURECOUNT_LARGEOFFSET  = ( D3D12_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDOFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDDESTINATIONSTATE  = ( D3D12_MESSAGE_ID_COPYSTRUCTURECOUNT_LARGEOFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDSOURCESTATE = ( D3D12_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDDESTINATIONSTATE + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_NOT_SUPPORTED = ( D3D12_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDSOURCESTATE + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWFLOAT_INVALIDFORMAT = ( D3D12_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_COUNTER_UNSUPPORTED  = ( D3D12_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWFLOAT_INVALIDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_PIXEL_SHADER_WITHOUT_RTV_OR_DSV = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_COUNTER_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_SHADER_ABORT  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_PIXEL_SHADER_WITHOUT_RTV_OR_DSV + 1 ) ,
+        D3D12_MESSAGE_ID_SHADER_MESSAGE  = ( D3D12_MESSAGE_ID_SHADER_ABORT + 1 ) ,
+        D3D12_MESSAGE_ID_SHADER_ERROR  = ( D3D12_MESSAGE_ID_SHADER_MESSAGE + 1 ) ,
+        D3D12_MESSAGE_ID_OFFERRESOURCES_INVALIDRESOURCE  = ( D3D12_MESSAGE_ID_SHADER_ERROR + 1 ) ,
+        D3D12_MESSAGE_ID_ENQUEUESETEVENT_INVALIDARG_RETURN = ( D3D12_MESSAGE_ID_OFFERRESOURCES_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_ENQUEUESETEVENT_OUTOFMEMORY_RETURN  = ( D3D12_MESSAGE_ID_ENQUEUESETEVENT_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_ENQUEUESETEVENT_ACCESSDENIED_RETURN = ( D3D12_MESSAGE_ID_ENQUEUESETEVENT_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFORCEDSAMPLECOUNT  = ( D3D12_MESSAGE_ID_ENQUEUESETEVENT_ACCESSDENIED_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_FORCED_SAMPLE_COUNT  = ( D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFORCEDSAMPLECOUNT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDLOGICOPS  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_FORCED_SAMPLE_COUNT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARRAYWITHDECODER  = ( D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDLOGICOPS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDARRAYWITHDECODER = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARRAYWITHDECODER + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARRAYWITHDECODER  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDARRAYWITHDECODER + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_LOCKEDOUT_INTERFACE  = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARRAYWITHDECODER + 1 ) ,
+        D3D12_MESSAGE_ID_OFFERRESOURCES_INVALIDPRIORITY  = ( D3D12_MESSAGE_ID_DEVICE_LOCKEDOUT_INTERFACE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDVIEW  = ( D3D12_MESSAGE_ID_OFFERRESOURCES_INVALIDPRIORITY + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEEXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDVIEW + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_SHADEREXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEEXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_SHADEREXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEEXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_SHADEREXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEEXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_SHADEREXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEEXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_SHADEREXTENSIONSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEEXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_SHADEREXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_SHADEREXTENSIONSNOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEEXTENSIONSNOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_SHADEREXTENSIONSNOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_MINPRECISION  = ( D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_SHADEREXTENSIONSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_UAVSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_SHADER_LINKAGE_MINPRECISION + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_UAVSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_UAVSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_UAVSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_UAVSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_UAVSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_UAVSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UAVSNOTSUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_UAVSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_UAVSNOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UAVSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_UAVSNOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_UAVSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_INVALIDOFFSET  = ( D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_UAVSNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_TOOMANYVIEWS = ( D3D12_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_INVALIDOFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_NOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_TOOMANYVIEWS + 1 ) ,
+        D3D12_MESSAGE_ID_SWAPDEVICECONTEXTSTATE_NOTSUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_NOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_UPDATESUBRESOURCE_PREFERUPDATESUBRESOURCE1  = ( D3D12_MESSAGE_ID_SWAPDEVICECONTEXTSTATE_NOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_GETDC_INACCESSIBLE  = ( D3D12_MESSAGE_ID_UPDATESUBRESOURCE_PREFERUPDATESUBRESOURCE1 + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDRECT  = ( D3D12_MESSAGE_ID_GETDC_INACCESSIBLE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_SAMPLE_MASK_IGNORED_ON_FL9  = ( D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDRECT + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE1_NOT_SUPPORTED  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_SAMPLE_MASK_IGNORED_ON_FL9 + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BY_NAME_NOT_SUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE1_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_ENQUEUESETEVENT_NOT_SUPPORTED = ( D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BY_NAME_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_OFFERRELEASE_NOT_SUPPORTED  = ( D3D12_MESSAGE_ID_ENQUEUESETEVENT_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_OFFERRESOURCES_INACCESSIBLE = ( D3D12_MESSAGE_ID_OFFERRELEASE_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDMSAA = ( D3D12_MESSAGE_ID_OFFERRESOURCES_INACCESSIBLE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDMSAA  = ( D3D12_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDMSAA + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDSOURCERECT  = ( D3D12_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDMSAA + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_EMPTYRECT  = ( D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDSOURCERECT + 1 ) ,
+        D3D12_MESSAGE_ID_UPDATESUBRESOURCE_EMPTYDESTBOX  = ( D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_EMPTYRECT + 1 ) ,
+        D3D12_MESSAGE_ID_COPYSUBRESOURCEREGION_EMPTYSOURCEBOX  = ( D3D12_MESSAGE_ID_UPDATESUBRESOURCE_EMPTYDESTBOX + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_LOGIC_OPS = ( D3D12_MESSAGE_ID_COPYSUBRESOURCEREGION_EMPTYSOURCEBOX + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_DEPTHSTENCILVIEW_NOT_SET  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_LOGIC_OPS + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_DEPTHSTENCILVIEW_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET_DUE_TO_FLIP_PRESENT  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET_DUE_TO_FLIP_PRESENT  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET_DUE_TO_FLIP_PRESENT + 1 ) ,
+        D3D12_MESSAGE_ID_GETDATAFORNEWHARDWAREKEY_NULLPARAM  = ( D3D12_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET_DUE_TO_FLIP_PRESENT + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKCRYPTOSESSIONSTATUS_NULLPARAM  = ( D3D12_MESSAGE_ID_GETDATAFORNEWHARDWAREKEY_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_SETEVENTONHARDWARECONTENTPROTECTIONTILT_NULLPARAM = ( D3D12_MESSAGE_ID_CHECKCRYPTOSESSIONSTATUS_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_GETVIDEODECODERCAPS_NULLPARAM = ( D3D12_MESSAGE_ID_SETEVENTONHARDWARECONTENTPROTECTIONTILT_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_GETVIDEODECODERCAPS_ZEROWIDTHHEIGHT = ( D3D12_MESSAGE_ID_GETVIDEODECODERCAPS_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_NULLPARAM = ( D3D12_MESSAGE_ID_GETVIDEODECODERCAPS_ZEROWIDTHHEIGHT + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_INVALIDCOLORSPACE = ( D3D12_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_ZEROWIDTHHEIGHT = ( D3D12_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_INVALIDCOLORSPACE + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEODECODERENABLEDOWNSAMPLING_NULLPARAM  = ( D3D12_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_ZEROWIDTHHEIGHT + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEODECODERENABLEDOWNSAMPLING_UNSUPPORTED  = ( D3D12_MESSAGE_ID_VIDEODECODERENABLEDOWNSAMPLING_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEODECODERUPDATEDOWNSAMPLING_NULLPARAM  = ( D3D12_MESSAGE_ID_VIDEODECODERENABLEDOWNSAMPLING_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEODECODERUPDATEDOWNSAMPLING_UNSUPPORTED  = ( D3D12_MESSAGE_ID_VIDEODECODERUPDATEDOWNSAMPLING_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKVIDEOPROCESSORFORMATCONVERSION_NULLPARAM = ( D3D12_MESSAGE_ID_VIDEODECODERUPDATEDOWNSAMPLING_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCOLORSPACE1_NULLPARAM  = ( D3D12_MESSAGE_ID_CHECKVIDEOPROCESSORFORMATCONVERSION_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTCOLORSPACE1_NULLPARAM  = ( D3D12_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCOLORSPACE1_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE1_NULLPARAM  = ( D3D12_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTCOLORSPACE1_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE1_INVALIDSTREAM  = ( D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE1_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_NULLPARAM = ( D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE1_INVALIDSTREAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_INVALIDSTREAM = ( D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_UNSUPPORTED = ( D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_INVALIDSTREAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE1_NULLPARAM  = ( D3D12_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORGETSTREAMMIRROR_NULLPARAM = ( D3D12_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE1_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_NULLPARAM = ( D3D12_MESSAGE_ID_VIDEOPROCESSORGETSTREAMMIRROR_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_INVALIDCOLORSPACE = ( D3D12_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_ZEROWIDTHHEIGHT = ( D3D12_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_INVALIDCOLORSPACE + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTSHADERUSAGE_NULLPARAM  = ( D3D12_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_ZEROWIDTHHEIGHT + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTSHADERUSAGE_NULLPARAM  = ( D3D12_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTSHADERUSAGE_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_NULLPARAM  = ( D3D12_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTSHADERUSAGE_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDSTREAMCOUNT = ( D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_NULLPARAM + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_TARGETRECT = ( D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDSTREAMCOUNT + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDSOURCERECT  = ( D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_TARGETRECT + 1 ) ,
+        D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDDESTRECT  = ( D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDSOURCERECT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEBUFFER_INVALIDUSAGE = ( D3D12_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDDESTRECT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATETEXTURE1D_INVALIDUSAGE  = ( D3D12_MESSAGE_ID_CREATEBUFFER_INVALIDUSAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATETEXTURE2D_INVALIDUSAGE  = ( D3D12_MESSAGE_ID_CREATETEXTURE1D_INVALIDUSAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_LEVEL9_STEPRATE_NOT_1 = ( D3D12_MESSAGE_ID_CREATETEXTURE2D_INVALIDUSAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_LEVEL9_INSTANCING_NOT_SUPPORTED = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_LEVEL9_STEPRATE_NOT_1 + 1 ) ,
+        D3D12_MESSAGE_ID_UPDATETILEMAPPINGS_INVALID_PARAMETER  = ( D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_LEVEL9_INSTANCING_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTILEMAPPINGS_INVALID_PARAMETER  = ( D3D12_MESSAGE_ID_UPDATETILEMAPPINGS_INVALID_PARAMETER + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTILES_INVALID_PARAMETER = ( D3D12_MESSAGE_ID_COPYTILEMAPPINGS_INVALID_PARAMETER + 1 ) ,
+        D3D12_MESSAGE_ID_NULL_TILE_MAPPING_ACCESS_WARNING  = ( D3D12_MESSAGE_ID_COPYTILES_INVALID_PARAMETER + 1 ) ,
+        D3D12_MESSAGE_ID_NULL_TILE_MAPPING_ACCESS_ERROR  = ( D3D12_MESSAGE_ID_NULL_TILE_MAPPING_ACCESS_WARNING + 1 ) ,
+        D3D12_MESSAGE_ID_DIRTY_TILE_MAPPING_ACCESS = ( D3D12_MESSAGE_ID_NULL_TILE_MAPPING_ACCESS_ERROR + 1 ) ,
+        D3D12_MESSAGE_ID_DUPLICATE_TILE_MAPPINGS_IN_COVERED_AREA = ( D3D12_MESSAGE_ID_DIRTY_TILE_MAPPING_ACCESS + 1 ) ,
+        D3D12_MESSAGE_ID_TILE_MAPPINGS_IN_COVERED_AREA_DUPLICATED_OUTSIDE  = ( D3D12_MESSAGE_ID_DUPLICATE_TILE_MAPPINGS_IN_COVERED_AREA + 1 ) ,
+        D3D12_MESSAGE_ID_TILE_MAPPINGS_SHARED_BETWEEN_INCOMPATIBLE_RESOURCES = ( D3D12_MESSAGE_ID_TILE_MAPPINGS_IN_COVERED_AREA_DUPLICATED_OUTSIDE + 1 ) ,
+        D3D12_MESSAGE_ID_TILE_MAPPINGS_SHARED_BETWEEN_INPUT_AND_OUTPUT = ( D3D12_MESSAGE_ID_TILE_MAPPINGS_SHARED_BETWEEN_INCOMPATIBLE_RESOURCES + 1 ) ,
+        D3D12_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_INVALIDFLAGS  = ( D3D12_MESSAGE_ID_TILE_MAPPINGS_SHARED_BETWEEN_INPUT_AND_OUTPUT + 1 ) ,
+        D3D12_MESSAGE_ID_GETRESOURCETILING_NONTILED_RESOURCE = ( D3D12_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_NEED_TO_CALL_TILEDRESOURCEBARRIER = ( D3D12_MESSAGE_ID_GETRESOURCETILING_NONTILED_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEVICE_INVALIDARGS  = ( D3D12_MESSAGE_ID_NEED_TO_CALL_TILEDRESOURCEBARRIER + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEVICE_WARNING  = ( D3D12_MESSAGE_ID_CREATEDEVICE_INVALIDARGS + 1 ) ,
+        D3D12_MESSAGE_ID_TILED_RESOURCE_TIER_1_BUFFER_TEXTURE_MISMATCH = ( D3D12_MESSAGE_ID_CREATEDEVICE_WARNING + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_CRYPTOSESSION  = ( D3D12_MESSAGE_ID_TILED_RESOURCE_TIER_1_BUFFER_TEXTURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_AUTHENTICATEDCHANNEL = ( D3D12_MESSAGE_ID_CREATE_CRYPTOSESSION + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_CRYPTOSESSION  = ( D3D12_MESSAGE_ID_CREATE_AUTHENTICATEDCHANNEL + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_AUTHENTICATEDCHANNEL = ( D3D12_MESSAGE_ID_LIVE_CRYPTOSESSION + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_CRYPTOSESSION = ( D3D12_MESSAGE_ID_LIVE_AUTHENTICATEDCHANNEL + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_AUTHENTICATEDCHANNEL  = ( D3D12_MESSAGE_ID_DESTROY_CRYPTOSESSION + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_INVALID_SUBRESOURCE = ( D3D12_MESSAGE_ID_DESTROY_AUTHENTICATEDCHANNEL + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_INVALID_TYPE  = ( D3D12_MESSAGE_ID_MAP_INVALID_SUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_UNSUPPORTED_TYPE  = ( D3D12_MESSAGE_ID_MAP_INVALID_TYPE + 1 ) ,
+        D3D12_MESSAGE_ID_UNMAP_INVALID_SUBRESOURCE = ( D3D12_MESSAGE_ID_MAP_UNSUPPORTED_TYPE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_TYPE = ( D3D12_MESSAGE_ID_UNMAP_INVALID_SUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_NULL_POINTER = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_TYPE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_SUBRESOURCE  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_NULL_POINTER + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_RESERVED_BITS  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_SUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISSING_BIND_FLAGS = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_RESERVED_BITS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_MISC_FLAGS = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISSING_BIND_FLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_MATCHING_STATES  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_MISC_FLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMBINATION  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_MATCHING_STATES + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_BEFORE_AFTER_MISMATCH  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMBINATION + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_RESOURCE = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_BEFORE_AFTER_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_SAMPLE_COUNT = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_FLAGS  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_SAMPLE_COUNT + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMBINED_FLAGS = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_FLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_FLAGS_FOR_FORMAT = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMBINED_FLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_SPLIT_BARRIER  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_FLAGS_FOR_FORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_UNMATCHED_END  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_SPLIT_BARRIER + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_UNMATCHED_BEGIN  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_UNMATCHED_END + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_FLAG = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_UNMATCHED_BEGIN + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMMAND_LIST_TYPE  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_FLAG + 1 ) ,
+        D3D12_MESSAGE_ID_INVALID_SUBRESOURCE_STATE = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMMAND_LIST_TYPE + 1 ) ,
+        D3D12_MESSAGE_ID_INEFFICIENT_PRESENT = ( D3D12_MESSAGE_ID_INVALID_SUBRESOURCE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_CONTENTION  = ( D3D12_MESSAGE_ID_INEFFICIENT_PRESENT + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_RESET = ( D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_CONTENTION + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_RESET_BUNDLE  = ( D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_RESET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_CANNOT_RESET  = ( D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_RESET_BUNDLE + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_OPEN = ( D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_CANNOT_RESET + 1 ) ,
+        D3D12_MESSAGE_ID_QUERY_STATE_MISMATCH  = ( D3D12_MESSAGE_ID_COMMAND_LIST_OPEN + 1 ) ,
+        D3D12_MESSAGE_ID_INVALID_BUNDLE_API  = ( D3D12_MESSAGE_ID_QUERY_STATE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_CLOSED = ( D3D12_MESSAGE_ID_INVALID_BUNDLE_API + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_CLOSED_WITH_INVALID_RESOURCE = ( D3D12_MESSAGE_ID_COMMAND_LIST_CLOSED + 1 ) ,
+        D3D12_MESSAGE_ID_WRONG_COMMAND_ALLOCATOR_TYPE  = ( D3D12_MESSAGE_ID_COMMAND_LIST_CLOSED_WITH_INVALID_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_INVALID_INDIRECT_ARGUMENT_BUFFER  = ( D3D12_MESSAGE_ID_WRONG_COMMAND_ALLOCATOR_TYPE + 1 ) ,
+        D3D12_MESSAGE_ID_COMPUTE_AND_GRAPHICS_PIPELINE = ( D3D12_MESSAGE_ID_INVALID_INDIRECT_ARGUMENT_BUFFER + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_SYNC  = ( D3D12_MESSAGE_ID_COMPUTE_AND_GRAPHICS_PIPELINE + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_SYNC = ( D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_SYNC + 1 ) ,
+        D3D12_MESSAGE_ID_SET_DESCRIPTOR_HEAP_INVALID = ( D3D12_MESSAGE_ID_COMMAND_LIST_SYNC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_QUEUE_IMAGE_NOT_SUPPORTED  = ( D3D12_MESSAGE_ID_SET_DESCRIPTOR_HEAP_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_ALLOCATOR_IMAGE_NOT_SUPPORTED  = ( D3D12_MESSAGE_ID_CREATE_QUEUE_IMAGE_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_COMMANDQUEUE = ( D3D12_MESSAGE_ID_CREATE_COMMAND_ALLOCATOR_IMAGE_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_COMMANDALLOCATOR = ( D3D12_MESSAGE_ID_CREATE_COMMANDQUEUE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_PIPELINESTATE  = ( D3D12_MESSAGE_ID_CREATE_COMMANDALLOCATOR + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_COMMANDLIST12  = ( D3D12_MESSAGE_ID_CREATE_PIPELINESTATE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_IMAGECOMMANDLIST = ( D3D12_MESSAGE_ID_CREATE_COMMANDLIST12 + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_RESOURCE = ( D3D12_MESSAGE_ID_CREATE_IMAGECOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_DESCRIPTORHEAP = ( D3D12_MESSAGE_ID_CREATE_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_ROOTSIGNATURE  = ( D3D12_MESSAGE_ID_CREATE_DESCRIPTORHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_LIBRARY  = ( D3D12_MESSAGE_ID_CREATE_ROOTSIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_HEAP = ( D3D12_MESSAGE_ID_CREATE_LIBRARY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_MONITOREDFENCE = ( D3D12_MESSAGE_ID_CREATE_HEAP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_QUERYHEAP  = ( D3D12_MESSAGE_ID_CREATE_MONITOREDFENCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_COMMANDSIGNATURE = ( D3D12_MESSAGE_ID_CREATE_QUERYHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_COMMANDQUEUE = ( D3D12_MESSAGE_ID_CREATE_COMMANDSIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_COMMANDALLOCATOR = ( D3D12_MESSAGE_ID_LIVE_COMMANDQUEUE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_PIPELINESTATE  = ( D3D12_MESSAGE_ID_LIVE_COMMANDALLOCATOR + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_COMMANDLIST12  = ( D3D12_MESSAGE_ID_LIVE_PIPELINESTATE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_IMAGECOMMANDLIST = ( D3D12_MESSAGE_ID_LIVE_COMMANDLIST12 + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_RESOURCE = ( D3D12_MESSAGE_ID_LIVE_IMAGECOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_DESCRIPTORHEAP = ( D3D12_MESSAGE_ID_LIVE_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_ROOTSIGNATURE  = ( D3D12_MESSAGE_ID_LIVE_DESCRIPTORHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_LIBRARY  = ( D3D12_MESSAGE_ID_LIVE_ROOTSIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_HEAP = ( D3D12_MESSAGE_ID_LIVE_LIBRARY + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_MONITOREDFENCE = ( D3D12_MESSAGE_ID_LIVE_HEAP + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_QUERYHEAP  = ( D3D12_MESSAGE_ID_LIVE_MONITOREDFENCE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_COMMANDSIGNATURE = ( D3D12_MESSAGE_ID_LIVE_QUERYHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_COMMANDQUEUE  = ( D3D12_MESSAGE_ID_LIVE_COMMANDSIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_COMMANDALLOCATOR  = ( D3D12_MESSAGE_ID_DESTROY_COMMANDQUEUE + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_PIPELINESTATE = ( D3D12_MESSAGE_ID_DESTROY_COMMANDALLOCATOR + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_COMMANDLIST12 = ( D3D12_MESSAGE_ID_DESTROY_PIPELINESTATE + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_IMAGECOMMANDLIST  = ( D3D12_MESSAGE_ID_DESTROY_COMMANDLIST12 + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_RESOURCE  = ( D3D12_MESSAGE_ID_DESTROY_IMAGECOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_DESCRIPTORHEAP  = ( D3D12_MESSAGE_ID_DESTROY_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_ROOTSIGNATURE = ( D3D12_MESSAGE_ID_DESTROY_DESCRIPTORHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_LIBRARY = ( D3D12_MESSAGE_ID_DESTROY_ROOTSIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_HEAP  = ( D3D12_MESSAGE_ID_DESTROY_LIBRARY + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_MONITOREDFENCE  = ( D3D12_MESSAGE_ID_DESTROY_HEAP + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_QUERYHEAP = ( D3D12_MESSAGE_ID_DESTROY_MONITOREDFENCE + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_COMMANDSIGNATURE  = ( D3D12_MESSAGE_ID_DESTROY_QUERYHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDHEAPTYPE = ( D3D12_MESSAGE_ID_DESTROY_COMMANDSIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDDIMENSIONS  = ( D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDHEAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDMISCFLAGS  = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDDIMENSIONS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDMISCFLAGS = ( D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDMISCFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_LARGEALLOCATION  = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDMISCFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_SMALLALLOCATION  = ( D3D12_MESSAGE_ID_CREATERESOURCE_LARGEALLOCATION + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDARG_RETURN  = ( D3D12_MESSAGE_ID_CREATERESOURCE_SMALLALLOCATION + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_OUTOFMEMORY_RETURN = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDDESC  = ( D3D12_MESSAGE_ID_CREATERESOURCE_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDINITIALSTATE  = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDDESC + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_HAS_PENDING_INITIAL_DATA = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDINITIALSTATE + 1 ) ,
+        D3D12_MESSAGE_ID_POSSIBLY_INVALID_SUBRESOURCE_STATE  = ( D3D12_MESSAGE_ID_RESOURCE_HAS_PENDING_INITIAL_DATA + 1 ) ,
+        D3D12_MESSAGE_ID_INVALID_USE_OF_NON_RESIDENT_RESOURCE  = ( D3D12_MESSAGE_ID_POSSIBLY_INVALID_SUBRESOURCE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_POSSIBLE_INVALID_USE_OF_NON_RESIDENT_RESOURCE = ( D3D12_MESSAGE_ID_INVALID_USE_OF_NON_RESIDENT_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_BUNDLE_PIPELINE_STATE_MISMATCH  = ( D3D12_MESSAGE_ID_POSSIBLE_INVALID_USE_OF_NON_RESIDENT_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_PRIMITIVE_TOPOLOGY_MISMATCH_PIPELINE_STATE  = ( D3D12_MESSAGE_ID_BUNDLE_PIPELINE_STATE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_RENDER_TARGET_NUMBER_MISMATCH_PIPELINE_STATE  = ( D3D12_MESSAGE_ID_PRIMITIVE_TOPOLOGY_MISMATCH_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_RENDER_TARGET_FORMAT_MISMATCH_PIPELINE_STATE  = ( D3D12_MESSAGE_ID_RENDER_TARGET_NUMBER_MISMATCH_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_RENDER_TARGET_SAMPLE_DESC_MISMATCH_PIPELINE_STATE = ( D3D12_MESSAGE_ID_RENDER_TARGET_FORMAT_MISMATCH_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_DEPTH_STENCIL_FORMAT_MISMATCH_PIPELINE_STATE  = ( D3D12_MESSAGE_ID_RENDER_TARGET_SAMPLE_DESC_MISMATCH_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_DEPTH_STENCIL_SAMPLE_DESC_MISMATCH_PIPELINE_STATE = ( D3D12_MESSAGE_ID_DEPTH_STENCIL_FORMAT_MISMATCH_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_RENDER_TARGET_NUMBER_MISMATCH_BUNDLE_PIPELINE_STATE = ( D3D12_MESSAGE_ID_DEPTH_STENCIL_SAMPLE_DESC_MISMATCH_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_RENDER_TARGET_FORMAT_MISMATCH_BUNDLE_PIPELINE_STATE = ( D3D12_MESSAGE_ID_RENDER_TARGET_NUMBER_MISMATCH_BUNDLE_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_RENDER_TARGET_SAMPLE_DESC_MISMATCH_BUNDLE_PIPELINE_STATE  = ( D3D12_MESSAGE_ID_RENDER_TARGET_FORMAT_MISMATCH_BUNDLE_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_DEPTH_STENCIL_FORMAT_MISMATCH_BUNDLE_PIPELINE_STATE = ( D3D12_MESSAGE_ID_RENDER_TARGET_SAMPLE_DESC_MISMATCH_BUNDLE_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_DEPTH_STENCIL_SAMPLE_DESC_MISMATCH_BUNDLE_PIPELINE_STATE  = ( D3D12_MESSAGE_ID_DEPTH_STENCIL_FORMAT_MISMATCH_BUNDLE_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADER_INVALIDBYTECODE  = ( D3D12_MESSAGE_ID_DEPTH_STENCIL_SAMPLE_DESC_MISMATCH_BUNDLE_PIPELINE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_NULLDESC = ( D3D12_MESSAGE_ID_CREATESHADER_INVALIDBYTECODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_INVALIDSIZE  = ( D3D12_MESSAGE_ID_CREATEHEAP_NULLDESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDHEAPTYPE = ( D3D12_MESSAGE_ID_CREATEHEAP_INVALIDSIZE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDCPUPAGEPROPERTIES  = ( D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDHEAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDMEMORYPOOL = ( D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDCPUPAGEPROPERTIES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_INVALIDPROPERTIES  = ( D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDMEMORYPOOL + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_INVALIDALIGNMENT = ( D3D12_MESSAGE_ID_CREATEHEAP_INVALIDPROPERTIES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDMISCFLAGS  = ( D3D12_MESSAGE_ID_CREATEHEAP_INVALIDALIGNMENT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_INVALIDMISCFLAGS = ( D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDMISCFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_INVALIDARG_RETURN  = ( D3D12_MESSAGE_ID_CREATEHEAP_INVALIDMISCFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEHEAP_OUTOFMEMORY_RETURN = ( D3D12_MESSAGE_ID_CREATEHEAP_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_NULLHEAPPROPERTIES  = ( D3D12_MESSAGE_ID_CREATEHEAP_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDHEAPTYPE  = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_NULLHEAPPROPERTIES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDCPUPAGEPROPERTIES = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDHEAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDMEMORYPOOL  = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDCPUPAGEPROPERTIES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDHEAPPROPERTIES = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDMEMORYPOOL + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDHEAPMISCFLAGS = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDHEAPPROPERTIES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDHEAPMISCFLAGS  = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDHEAPMISCFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDARG_RETURN = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDHEAPMISCFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_OUTOFMEMORY_RETURN  = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_GETCUSTOMHEAPPROPERTIES_UNRECOGNIZEDHEAPTYPE  = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_GETCUSTOMHEAPPROPERTIES_INVALIDHEAPTYPE = ( D3D12_MESSAGE_ID_GETCUSTOMHEAPPROPERTIES_UNRECOGNIZEDHEAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_DESCRIPTOR_HEAP_INVALID_DESC = ( D3D12_MESSAGE_ID_GETCUSTOMHEAPPROPERTIES_INVALIDHEAPTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_INVALID_DESCRIPTOR_HANDLE = ( D3D12_MESSAGE_ID_CREATE_DESCRIPTOR_HEAP_INVALID_DESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALID_CONSERVATIVERASTERMODE  = ( D3D12_MESSAGE_ID_INVALID_DESCRIPTOR_HANDLE + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_DRAW_INVALID_SYSTEMVALUE = ( D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALID_CONSERVATIVERASTERMODE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_CONSTANT_BUFFER_VIEW_INVALID_RESOURCE  = ( D3D12_MESSAGE_ID_DEVICE_DRAW_INVALID_SYSTEMVALUE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_CONSTANT_BUFFER_VIEW_INVALID_DESC  = ( D3D12_MESSAGE_ID_CREATE_CONSTANT_BUFFER_VIEW_INVALID_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_CONSTANT_BUFFER_VIEW_LARGE_OFFSET  = ( D3D12_MESSAGE_ID_CREATE_CONSTANT_BUFFER_VIEW_INVALID_DESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_UNORDEREDACCESS_VIEW_INVALID_COUNTER_USAGE = ( D3D12_MESSAGE_ID_CREATE_CONSTANT_BUFFER_VIEW_LARGE_OFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_COPY_DESCRIPTORS_INVALID_RANGES = ( D3D12_MESSAGE_ID_CREATE_UNORDEREDACCESS_VIEW_INVALID_COUNTER_USAGE + 1 ) ,
+        D3D12_MESSAGE_ID_COPY_DESCRIPTORS_WRITE_ONLY_DESCRIPTOR  = ( D3D12_MESSAGE_ID_COPY_DESCRIPTORS_INVALID_RANGES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RTV_FORMAT_NOT_UNKNOWN  = ( D3D12_MESSAGE_ID_COPY_DESCRIPTORS_WRITE_ONLY_DESCRIPTOR + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_RENDER_TARGET_COUNT = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RTV_FORMAT_NOT_UNKNOWN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_VERTEX_SHADER_NOT_SET = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_RENDER_TARGET_COUNT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INPUTLAYOUT_NOT_SET = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_VERTEX_SHADER_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_HS_DS_SIGNATURE_MISMATCH = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INPUTLAYOUT_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_REGISTERINDEX  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_HS_DS_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_COMPONENTTYPE  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_REGISTERINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_REGISTERMASK = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_COMPONENTTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_SYSTEMVALUE  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_REGISTERMASK + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_SYSTEMVALUE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_MINPRECISION = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_MINPRECISION + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_XOR_DS_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_XOR_DS_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_DS_CONTROL_POINT_COUNT_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_DS_TESSELLATOR_DOMAIN_MISMATCH = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_DS_CONTROL_POINT_COUNT_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_DS_TESSELLATOR_DOMAIN_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_USE_OF_FORCED_SAMPLE_COUNT  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_PRIMITIVETOPOLOGY = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_USE_OF_FORCED_SAMPLE_COUNT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_SYSTEMVALUE = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_PRIMITIVETOPOLOGY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_SYSTEMVALUE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_PS_OUTPUT_TYPE_MISMATCH = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_OM_RENDER_TARGET_DOES_NOT_SUPPORT_LOGIC_OPS = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_PS_OUTPUT_TYPE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RENDERTARGETVIEW_NOT_SET  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_OM_RENDER_TARGET_DOES_NOT_SUPPORT_LOGIC_OPS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_DEPTHSTENCILVIEW_NOT_SET  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RENDERTARGETVIEW_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_GS_INPUT_PRIMITIVE_MISMATCH = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_DEPTHSTENCILVIEW_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_POSITION_NOT_PRESENT  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_GS_INPUT_PRIMITIVE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_MISSING_ROOT_SIGNATURE_FLAGS  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_POSITION_NOT_PRESENT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_INDEX_BUFFER_PROPERTIES = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_MISSING_ROOT_SIGNATURE_FLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_SAMPLE_DESC = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_INDEX_BUFFER_PROPERTIES + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_ROOT_SIGNATURE_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_SAMPLE_DESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_DS_ROOT_SIGNATURE_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_ROOT_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_VS_ROOT_SIGNATURE_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_DS_ROOT_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_GS_ROOT_SIGNATURE_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_VS_ROOT_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_PS_ROOT_SIGNATURE_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_GS_ROOT_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_MISSING_ROOT_SIGNATURE  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_PS_ROOT_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTE_BUNDLE_OPEN_BUNDLE  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_MISSING_ROOT_SIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTE_BUNDLE_DESCRIPTOR_HEAP_MISMATCH = ( D3D12_MESSAGE_ID_EXECUTE_BUNDLE_OPEN_BUNDLE + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTE_BUNDLE_TYPE = ( D3D12_MESSAGE_ID_EXECUTE_BUNDLE_DESCRIPTOR_HEAP_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_DRAW_EMPTY_SCISSOR_RECTANGLE  = ( D3D12_MESSAGE_ID_EXECUTE_BUNDLE_TYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_BLOB_NOT_FOUND  = ( D3D12_MESSAGE_ID_DRAW_EMPTY_SCISSOR_RECTANGLE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_DESERIALIZE_FAILED  = ( D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_BLOB_NOT_FOUND + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_INVALID_CONFIGURATION = ( D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_DESERIALIZE_FAILED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_NOT_SUPPORTED_ON_DEVICE = ( D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_INVALID_CONFIGURATION + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_NULLRESOURCEPROPERTIES  = ( D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_NOT_SUPPORTED_ON_DEVICE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_NULLHEAP  = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_NULLRESOURCEPROPERTIES + 1 ) ,
+        D3D12_MESSAGE_ID_GETRESOURCEALLOCATIONINFO_INVALIDRDESCS = ( D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_NULLHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_MAKERESIDENT_NULLOBJECTARRAY  = ( D3D12_MESSAGE_ID_GETRESOURCEALLOCATIONINFO_INVALIDRDESCS + 1 ) ,
+        D3D12_MESSAGE_ID_MAKERESIDENT_INVALIDOBJECT  = ( D3D12_MESSAGE_ID_MAKERESIDENT_NULLOBJECTARRAY + 1 ) ,
+        D3D12_MESSAGE_ID_EVICT_NULLOBJECTARRAY = ( D3D12_MESSAGE_ID_MAKERESIDENT_INVALIDOBJECT + 1 ) ,
+        D3D12_MESSAGE_ID_EVICT_INVALIDOBJECT = ( D3D12_MESSAGE_ID_EVICT_NULLOBJECTARRAY + 1 ) ,
+        D3D12_MESSAGE_ID_HEAPS_UNSUPPORTED = ( D3D12_MESSAGE_ID_EVICT_INVALIDOBJECT + 1 ) ,
+        D3D12_MESSAGE_ID_SET_DESCRIPTOR_TABLE_INVALID  = ( D3D12_MESSAGE_ID_HEAPS_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_SET_ROOT_CONSTANT_INVALID = ( D3D12_MESSAGE_ID_SET_DESCRIPTOR_TABLE_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_SET_ROOT_CONSTANT_BUFFER_VIEW_INVALID = ( D3D12_MESSAGE_ID_SET_ROOT_CONSTANT_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_SET_ROOT_SHADER_RESOURCE_VIEW_INVALID = ( D3D12_MESSAGE_ID_SET_ROOT_CONSTANT_BUFFER_VIEW_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_SET_ROOT_UNORDERED_ACCESS_VIEW_INVALID  = ( D3D12_MESSAGE_ID_SET_ROOT_SHADER_RESOURCE_VIEW_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_SET_VERTEX_BUFFERS_INVALID_DESC = ( D3D12_MESSAGE_ID_SET_ROOT_UNORDERED_ACCESS_VIEW_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_SET_VERTEX_BUFFERS_LARGE_OFFSET = ( D3D12_MESSAGE_ID_SET_VERTEX_BUFFERS_INVALID_DESC + 1 ) ,
+        D3D12_MESSAGE_ID_SET_INDEX_BUFFER_INVALID_DESC = ( D3D12_MESSAGE_ID_SET_VERTEX_BUFFERS_LARGE_OFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_SET_INDEX_BUFFER_LARGE_OFFSET = ( D3D12_MESSAGE_ID_SET_INDEX_BUFFER_INVALID_DESC + 1 ) ,
+        D3D12_MESSAGE_ID_SET_STREAM_OUTPUT_BUFFERS_INVALID_DESC  = ( D3D12_MESSAGE_ID_SET_INDEX_BUFFER_LARGE_OFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDDIMENSIONALITY = ( D3D12_MESSAGE_ID_SET_STREAM_OUTPUT_BUFFERS_INVALID_DESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDLAYOUT = ( D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDDIMENSIONALITY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDDIMENSIONALITY  = ( D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDLAYOUT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDALIGNMENT = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDDIMENSIONALITY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDMIPLEVELS = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDALIGNMENT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDSAMPLEDESC  = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDMIPLEVELS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDLAYOUT  = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDSAMPLEDESC + 1 ) ,
+        D3D12_MESSAGE_ID_SET_INDEX_BUFFER_INVALID  = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDLAYOUT + 1 ) ,
+        D3D12_MESSAGE_ID_SET_VERTEX_BUFFERS_INVALID  = ( D3D12_MESSAGE_ID_SET_INDEX_BUFFER_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_SET_STREAM_OUTPUT_BUFFERS_INVALID = ( D3D12_MESSAGE_ID_SET_VERTEX_BUFFERS_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_SET_RENDER_TARGETS_INVALID  = ( D3D12_MESSAGE_ID_SET_STREAM_OUTPUT_BUFFERS_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEQUERY_HEAP_INVALID_PARAMETERS = ( D3D12_MESSAGE_ID_SET_RENDER_TARGETS_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEQUERY_HEAP_JPEG_NOT_SUPPORTED = ( D3D12_MESSAGE_ID_CREATEQUERY_HEAP_INVALID_PARAMETERS + 1 ) ,
+        D3D12_MESSAGE_ID_BEGIN_END_QUERY_INVALID_PARAMETERS  = ( D3D12_MESSAGE_ID_CREATEQUERY_HEAP_JPEG_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CLOSE_COMMAND_LIST_OPEN_QUERY = ( D3D12_MESSAGE_ID_BEGIN_END_QUERY_INVALID_PARAMETERS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVE_QUERY_DATA_INVALID_PARAMETERS = ( D3D12_MESSAGE_ID_CLOSE_COMMAND_LIST_OPEN_QUERY + 1 ) ,
+        D3D12_MESSAGE_ID_SET_PREDICATION_INVALID_PARAMETERS  = ( D3D12_MESSAGE_ID_RESOLVE_QUERY_DATA_INVALID_PARAMETERS + 1 ) ,
+        D3D12_MESSAGE_ID_TIMESTAMPS_NOT_SUPPORTED  = ( D3D12_MESSAGE_ID_SET_PREDICATION_INVALID_PARAMETERS + 1 ) ,
+        D3D12_MESSAGE_ID_UNSTABLE_POWER_STATE  = ( D3D12_MESSAGE_ID_TIMESTAMPS_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDFORMAT = ( D3D12_MESSAGE_ID_UNSTABLE_POWER_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDFORMAT  = ( D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_GETCOPYABLELAYOUT_INVALIDSUBRESOURCERANGE = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_GETCOPYABLELAYOUT_INVALIDBASEOFFSET = ( D3D12_MESSAGE_ID_GETCOPYABLELAYOUT_INVALIDSUBRESOURCERANGE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_HEAP = ( D3D12_MESSAGE_ID_GETCOPYABLELAYOUT_INVALIDBASEOFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_SAMPLER_INVALID  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_HEAP + 1 ) ,
+        D3D12_MESSAGE_ID_CREATECOMMANDSIGNATURE_INVALID  = ( D3D12_MESSAGE_ID_CREATE_SAMPLER_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTE_INDIRECT_INVALID_PARAMETERS = ( D3D12_MESSAGE_ID_CREATECOMMANDSIGNATURE_INVALID + 1 ) ,
+        D3D12_MESSAGE_ID_GETGPUVIRTUALADDRESS_INVALID_RESOURCE_DIMENSION = ( D3D12_MESSAGE_ID_EXECUTE_INDIRECT_INVALID_PARAMETERS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDPLANEINDEX  = ( D3D12_MESSAGE_ID_GETGPUVIRTUALADDRESS_INVALID_RESOURCE_DIMENSION + 4 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDVIDEOPLANEINDEX = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDPLANEINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_AMBIGUOUSVIDEOPLANEINDEX = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDVIDEOPLANEINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDPLANEINDEX  = ( D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_AMBIGUOUSVIDEOPLANEINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDVIDEOPLANEINDEX = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDPLANEINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_AMBIGUOUSVIDEOPLANEINDEX = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDVIDEOPLANEINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDPLANEINDEX = ( D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_AMBIGUOUSVIDEOPLANEINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDVIDEOPLANEINDEX  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDPLANEINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_AMBIGUOUSVIDEOPLANEINDEX  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDVIDEOPLANEINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_INVALIDSCANDATAOFFSET  = ( D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_AMBIGUOUSVIDEOPLANEINDEX + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_NOTSUPPORTED = ( D3D12_MESSAGE_ID_JPEGDECODE_INVALIDSCANDATAOFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_DIMENSIONSTOOLARGE = ( D3D12_MESSAGE_ID_JPEGDECODE_NOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_INVALIDCOMPONENTS  = ( D3D12_MESSAGE_ID_JPEGDECODE_DIMENSIONSTOOLARGE + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDCOMPONENTS  = ( D3D12_MESSAGE_ID_JPEGDECODE_INVALIDCOMPONENTS + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_DESTINATIONNOT2D = ( D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDCOMPONENTS + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_TILEDRESOURCESUNSUPPORTED  = ( D3D12_MESSAGE_ID_JPEGDECODE_DESTINATIONNOT2D + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_GUARDRECTSUNSUPPORTED  = ( D3D12_MESSAGE_ID_JPEGDECODE_TILEDRESOURCESUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_FORMATUNSUPPORTED  = ( D3D12_MESSAGE_ID_JPEGDECODE_GUARDRECTSUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_INVALIDSUBRESOURCE = ( D3D12_MESSAGE_ID_JPEGDECODE_FORMATUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_INVALIDMIPLEVEL  = ( D3D12_MESSAGE_ID_JPEGDECODE_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_EMPTYDESTBOX = ( D3D12_MESSAGE_ID_JPEGDECODE_INVALIDMIPLEVEL + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_DESTBOXNOT2D = ( D3D12_MESSAGE_ID_JPEGDECODE_EMPTYDESTBOX + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_DESTBOXNOTSUB  = ( D3D12_MESSAGE_ID_JPEGDECODE_DESTBOXNOT2D + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_DESTBOXESINTERSECT = ( D3D12_MESSAGE_ID_JPEGDECODE_DESTBOXNOTSUB + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_XSUBSAMPLEMISMATCH = ( D3D12_MESSAGE_ID_JPEGDECODE_DESTBOXESINTERSECT + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_YSUBSAMPLEMISMATCH = ( D3D12_MESSAGE_ID_JPEGDECODE_XSUBSAMPLEMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_XSUBSAMPLEODD  = ( D3D12_MESSAGE_ID_JPEGDECODE_YSUBSAMPLEMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_YSUBSAMPLEODD  = ( D3D12_MESSAGE_ID_JPEGDECODE_XSUBSAMPLEODD + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_UPSCALEUNSUPPORTED = ( D3D12_MESSAGE_ID_JPEGDECODE_YSUBSAMPLEODD + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_TIER4DOWNSCALETOLARGE  = ( D3D12_MESSAGE_ID_JPEGDECODE_UPSCALEUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_TIER3DOWNSCALEUNSUPPORTED  = ( D3D12_MESSAGE_ID_JPEGDECODE_TIER4DOWNSCALETOLARGE + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_CHROMASIZEMISMATCH = ( D3D12_MESSAGE_ID_JPEGDECODE_TIER3DOWNSCALEUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_LUMACHROMASIZEMISMATCH = ( D3D12_MESSAGE_ID_JPEGDECODE_CHROMASIZEMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_INVALIDNUMDESTINATIONS = ( D3D12_MESSAGE_ID_JPEGDECODE_LUMACHROMASIZEMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_SUBBOXUNSUPPORTED  = ( D3D12_MESSAGE_ID_JPEGDECODE_INVALIDNUMDESTINATIONS + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_1DESTUNSUPPORTEDFORMAT = ( D3D12_MESSAGE_ID_JPEGDECODE_SUBBOXUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_3DESTUNSUPPORTEDFORMAT = ( D3D12_MESSAGE_ID_JPEGDECODE_1DESTUNSUPPORTEDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_SCALEUNSUPPORTED = ( D3D12_MESSAGE_ID_JPEGDECODE_3DESTUNSUPPORTEDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_INVALIDSOURCESIZE  = ( D3D12_MESSAGE_ID_JPEGDECODE_SCALEUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_INVALIDCOPYFLAGS = ( D3D12_MESSAGE_ID_JPEGDECODE_INVALIDSOURCESIZE + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_HAZARD = ( D3D12_MESSAGE_ID_JPEGDECODE_INVALIDCOPYFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDSRCBUFFERUSAGE  = ( D3D12_MESSAGE_ID_JPEGDECODE_HAZARD + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDSRCBUFFERMISCFLAGS  = ( D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDSRCBUFFERUSAGE + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDDSTTEXTUREUSAGE = ( D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDSRCBUFFERMISCFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_BACKBUFFERNOTSUPPORTED = ( D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDDSTTEXTUREUSAGE + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDCOPYFLAGS = ( D3D12_MESSAGE_ID_JPEGDECODE_BACKBUFFERNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_NOTSUPPORTED = ( D3D12_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDCOPYFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_INVALIDSCANDATAOFFSET  = ( D3D12_MESSAGE_ID_JPEGENCODE_NOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_INVALIDCOMPONENTS  = ( D3D12_MESSAGE_ID_JPEGENCODE_INVALIDSCANDATAOFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_SOURCENOT2D  = ( D3D12_MESSAGE_ID_JPEGENCODE_INVALIDCOMPONENTS + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_TILEDRESOURCESUNSUPPORTED  = ( D3D12_MESSAGE_ID_JPEGENCODE_SOURCENOT2D + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_GUARDRECTSUNSUPPORTED  = ( D3D12_MESSAGE_ID_JPEGENCODE_TILEDRESOURCESUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_XSUBSAMPLEMISMATCH = ( D3D12_MESSAGE_ID_JPEGENCODE_GUARDRECTSUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_YSUBSAMPLEMISMATCH = ( D3D12_MESSAGE_ID_JPEGENCODE_XSUBSAMPLEMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDCOMPONENTS  = ( D3D12_MESSAGE_ID_JPEGENCODE_YSUBSAMPLEMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_FORMATUNSUPPORTED  = ( D3D12_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDCOMPONENTS + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_INVALIDSUBRESOURCE = ( D3D12_MESSAGE_ID_JPEGENCODE_FORMATUNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_INVALIDMIPLEVEL  = ( D3D12_MESSAGE_ID_JPEGENCODE_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_DIMENSIONSTOOLARGE = ( D3D12_MESSAGE_ID_JPEGENCODE_INVALIDMIPLEVEL + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_HAZARD = ( D3D12_MESSAGE_ID_JPEGENCODE_DIMENSIONSTOOLARGE + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDDSTBUFFERUSAGE  = ( D3D12_MESSAGE_ID_JPEGENCODE_HAZARD + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDDSTBUFFERMISCFLAGS  = ( D3D12_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDDSTBUFFERUSAGE + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDSRCTEXTUREUSAGE = ( D3D12_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDDSTBUFFERMISCFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_JPEGENCODE_BACKBUFFERNOTSUPPORTED = ( D3D12_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDSRCTEXTUREUSAGE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEQUERYORPREDICATE_UNSUPPORTEDCONTEXTTYPEFORQUERY = ( D3D12_MESSAGE_ID_JPEGENCODE_BACKBUFFERNOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_FLUSH1_INVALIDCONTEXTTYPE = ( D3D12_MESSAGE_ID_CREATEQUERYORPREDICATE_UNSUPPORTEDCONTEXTTYPEFORQUERY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDCLEARVALUE  = ( D3D12_MESSAGE_ID_FLUSH1_INVALIDCONTEXTTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDCLEARVALUEFORMAT = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDCLEARVALUE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDCLEARVALUEFORMAT  = ( D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDCLEARVALUEFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATERESOURCE_CLEARVALUEDENORMFLUSH  = ( D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDCLEARVALUEFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALIDDEPTH  = ( D3D12_MESSAGE_ID_CREATERESOURCE_CLEARVALUEDENORMFLUSH + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE = ( D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALIDDEPTH + 1 ) ,
+        D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_MISMATCHINGCLEARVALUE = ( D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_INVALIDHEAP = ( D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_MISMATCHINGCLEARVALUE + 1 ) ,
+        D3D12_MESSAGE_ID_UNMAP_INVALIDHEAP = ( D3D12_MESSAGE_ID_MAP_INVALIDHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_INVALIDRESOURCE = ( D3D12_MESSAGE_ID_UNMAP_INVALIDHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_UNMAP_INVALIDRESOURCE = ( D3D12_MESSAGE_ID_MAP_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_INVALIDSUBRESOURCE  = ( D3D12_MESSAGE_ID_UNMAP_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_UNMAP_INVALIDSUBRESOURCE  = ( D3D12_MESSAGE_ID_MAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_INVALIDRANGE  = ( D3D12_MESSAGE_ID_UNMAP_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_UNMAP_INVALIDRANGE  = ( D3D12_MESSAGE_ID_MAP_INVALIDRANGE + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_NULLRANGE = ( D3D12_MESSAGE_ID_UNMAP_INVALIDRANGE + 1 ) ,
+        D3D12_MESSAGE_ID_UNMAP_NULLRANGE = ( D3D12_MESSAGE_ID_MAP_NULLRANGE + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_INVALIDDATAPOINTER  = ( D3D12_MESSAGE_ID_UNMAP_NULLRANGE + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_INVALIDARG_RETURN = ( D3D12_MESSAGE_ID_MAP_INVALIDDATAPOINTER + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_OUTOFMEMORY_RETURN  = ( D3D12_MESSAGE_ID_MAP_INVALIDARG_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_BUNDLENOTSUPPORTED  = ( D3D12_MESSAGE_ID_MAP_OUTOFMEMORY_RETURN + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_COMMANDLISTMISMATCH = ( D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_BUNDLENOTSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_OPENCOMMANDLIST = ( D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_COMMANDLISTMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_FAILEDCOMMANDLIST = ( D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_OPENCOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_COPYBUFFERREGION_NULLDST  = ( D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_FAILEDCOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALIDDSTRESOURCEDIMENSION  = ( D3D12_MESSAGE_ID_COPYBUFFERREGION_NULLDST + 1 ) ,
+        D3D12_MESSAGE_ID_COPYBUFFERREGION_DSTRANGEOUTOFBOUNDS  = ( D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALIDDSTRESOURCEDIMENSION + 1 ) ,
+        D3D12_MESSAGE_ID_COPYBUFFERREGION_NULLSRC  = ( D3D12_MESSAGE_ID_COPYBUFFERREGION_DSTRANGEOUTOFBOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALIDSRCRESOURCEDIMENSION  = ( D3D12_MESSAGE_ID_COPYBUFFERREGION_NULLSRC + 1 ) ,
+        D3D12_MESSAGE_ID_COPYBUFFERREGION_SRCRANGEOUTOFBOUNDS  = ( D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALIDSRCRESOURCEDIMENSION + 1 ) ,
+        D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALIDCOPYFLAGS = ( D3D12_MESSAGE_ID_COPYBUFFERREGION_SRCRANGEOUTOFBOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_NULLDST = ( D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALIDCOPYFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDDSTTYPE = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_NULLDST + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTRESOURCEDIMENSION = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDDSTTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTRESOURCE  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTRESOURCEDIMENSION + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTSUBRESOURCE = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTOFFSET  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDDSTFORMAT = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTOFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTFORMAT  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDDSTFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTDIMENSIONS  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTROWPITCH  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTDIMENSIONS + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTPLACEMENT = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTROWPITCH + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTDSPLACEDFOOTPRINTFORMAT = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTPLACEMENT + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_DSTREGIONOUTOFBOUNDS  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTDSPLACEDFOOTPRINTFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_NULLSRC = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_DSTREGIONOUTOFBOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDSRCTYPE = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_NULLSRC + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCRESOURCEDIMENSION = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDSRCTYPE + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCRESOURCE  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCRESOURCEDIMENSION + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCSUBRESOURCE = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCOFFSET  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDSRCFORMAT = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCOFFSET + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCFORMAT  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDSRCFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCDIMENSIONS  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCROWPITCH  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCDIMENSIONS + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCPLACEMENT = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCROWPITCH + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCDSPLACEDFOOTPRINTFORMAT = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCPLACEMENT + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_SRCREGIONOUTOFBOUNDS  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCDSPLACEDFOOTPRINTFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTCOORDINATES = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_SRCREGIONOUTOFBOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCBOX = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTCOORDINATES + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_FORMATMISMATCH  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCBOX + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_EMPTYBOX  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_FORMATMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDCOPYFLAGS  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_EMPTYBOX + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALID_SUBRESOURCE_INDEX  = ( D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDCOPYFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALID_FORMAT = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALID_SUBRESOURCE_INDEX + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_RESOURCE_MISMATCH  = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALID_FORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALID_SAMPLE_COUNT = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_RESOURCE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATECOMPUTEPIPELINESTATE_INVALID_SHADER = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALID_SAMPLE_COUNT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATECOMPUTEPIPELINESTATE_CS_ROOT_SIGNATURE_MISMATCH = ( D3D12_MESSAGE_ID_CREATECOMPUTEPIPELINESTATE_INVALID_SHADER + 1 ) ,
+        D3D12_MESSAGE_ID_CREATECOMPUTEPIPELINESTATE_MISSING_ROOT_SIGNATURE = ( D3D12_MESSAGE_ID_CREATECOMPUTEPIPELINESTATE_CS_ROOT_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_INVALIDCACHEDBLOB = ( D3D12_MESSAGE_ID_CREATECOMPUTEPIPELINESTATE_MISSING_ROOT_SIGNATURE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBADAPTERMISMATCH = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_INVALIDCACHEDBLOB + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBDRIVERVERSIONMISMATCH = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBADAPTERMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBDESCMISMATCH  = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBDRIVERVERSIONMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBIGNORED = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBDESCMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDHEAP  = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBIGNORED + 1 ) ,
+        D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDRESOURCE  = ( D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDBOX = ( D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDSUBRESOURCE = ( D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDBOX + 1 ) ,
+        D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_EMPTYBOX = ( D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDHEAP = ( D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_EMPTYBOX + 1 ) ,
+        D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDRESOURCE = ( D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDHEAP + 1 ) ,
+        D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDBOX  = ( D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDSUBRESOURCE  = ( D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDBOX + 1 ) ,
+        D3D12_MESSAGE_ID_READFROMSUBRESOURCE_EMPTYBOX  = ( D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDSUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_TOO_MANY_NODES_SPECIFIED  = ( D3D12_MESSAGE_ID_READFROMSUBRESOURCE_EMPTYBOX + 1 ) ,
+        D3D12_MESSAGE_ID_INVALID_NODE_INDEX  = ( D3D12_MESSAGE_ID_TOO_MANY_NODES_SPECIFIED + 1 ) ,
+        D3D12_MESSAGE_ID_GETHEAPPROPERTIES_INVALIDRESOURCE = ( D3D12_MESSAGE_ID_INVALID_NODE_INDEX + 1 ) ,
+        D3D12_MESSAGE_ID_NODE_MASK_MISMATCH  = ( D3D12_MESSAGE_ID_GETHEAPPROPERTIES_INVALIDRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_OUTOFMEMORY  = ( D3D12_MESSAGE_ID_NODE_MASK_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_MULTIPLE_SWAPCHAIN_BUFFER_REFERENCES = ( D3D12_MESSAGE_ID_COMMAND_LIST_OUTOFMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_TOO_MANY_SWAPCHAIN_REFERENCES  = ( D3D12_MESSAGE_ID_COMMAND_LIST_MULTIPLE_SWAPCHAIN_BUFFER_REFERENCES + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_QUEUE_TOO_MANY_SWAPCHAIN_REFERENCES = ( D3D12_MESSAGE_ID_COMMAND_LIST_TOO_MANY_SWAPCHAIN_REFERENCES + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_WRONGSWAPCHAINBUFFERREFERENCE = ( D3D12_MESSAGE_ID_COMMAND_QUEUE_TOO_MANY_SWAPCHAIN_REFERENCES + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_SETRENDERTARGETS_INVALIDNUMRENDERTARGETS = ( D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_WRONGSWAPCHAINBUFFERREFERENCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_QUEUE_INVALID_TYPE = ( D3D12_MESSAGE_ID_COMMAND_LIST_SETRENDERTARGETS_INVALIDNUMRENDERTARGETS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_QUEUE_INVALID_FLAGS  = ( D3D12_MESSAGE_ID_CREATE_QUEUE_INVALID_TYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHAREDRESOURCE_INVALIDFLAGS = ( D3D12_MESSAGE_ID_CREATE_QUEUE_INVALID_FLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHAREDRESOURCE_INVALIDFORMAT  = ( D3D12_MESSAGE_ID_CREATESHAREDRESOURCE_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATESHAREDHEAP_INVALIDFLAGS = ( D3D12_MESSAGE_ID_CREATESHAREDRESOURCE_INVALIDFORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_UNRECOGNIZEDPROPERTIES  = ( D3D12_MESSAGE_ID_CREATESHAREDHEAP_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_INVALIDSIZE = ( D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_UNRECOGNIZEDPROPERTIES + 1 ) ,
+        D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_INVALIDOBJECT = ( D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_INVALIDSIZE + 1 ) ,
+        D3D12_MESSAGE_ID_KEYEDMUTEX_INVALIDOBJECT  = ( D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_INVALIDOBJECT + 1 ) ,
+        D3D12_MESSAGE_ID_KEYEDMUTEX_INVALIDKEY = ( D3D12_MESSAGE_ID_KEYEDMUTEX_INVALIDOBJECT + 1 ) ,
+        D3D12_MESSAGE_ID_KEYEDMUTEX_WRONGSTATE = ( D3D12_MESSAGE_ID_KEYEDMUTEX_INVALIDKEY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_QUEUE_INVALID_PRIORITY = ( D3D12_MESSAGE_ID_KEYEDMUTEX_WRONGSTATE + 1 ) ,
+        D3D12_MESSAGE_ID_OBJECT_DELETED_WHILE_STILL_IN_USE = ( D3D12_MESSAGE_ID_CREATE_QUEUE_INVALID_PRIORITY + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_INVALID_FLAGS = ( D3D12_MESSAGE_ID_OBJECT_DELETED_WHILE_STILL_IN_USE + 1 ) ,
+        D3D12_MESSAGE_ID_HEAP_ADDRESS_RANGE_HAS_NO_RESOURCE  = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_INVALID_FLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RENDER_TARGET_DELETED = ( D3D12_MESSAGE_ID_HEAP_ADDRESS_RANGE_HAS_NO_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_ALL_RENDER_TARGETS_HAVE_UNKNOWN_FORMAT  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RENDER_TARGET_DELETED + 1 ) ,
+        D3D12_MESSAGE_ID_HEAP_ADDRESS_RANGE_INTERSECTS_MULTIPLE_BUFFERS  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_ALL_RENDER_TARGETS_HAVE_UNKNOWN_FORMAT + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_GPU_WRITTEN_READBACK_RESOURCE_MAPPED  = ( D3D12_MESSAGE_ID_HEAP_ADDRESS_RANGE_INTERSECTS_MULTIPLE_BUFFERS + 1 ) ,
+        D3D12_MESSAGE_ID_UNMAP_RANGE_NOT_NEEDED  = ( D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_GPU_WRITTEN_READBACK_RESOURCE_MAPPED + 1 ) ,
+        D3D12_MESSAGE_ID_UNMAP_RANGE_NOT_EMPTY = ( D3D12_MESSAGE_ID_UNMAP_RANGE_NOT_NEEDED + 1 ) ,
+        D3D12_MESSAGE_ID_MAP_INVALID_NULLRANGE = ( D3D12_MESSAGE_ID_UNMAP_RANGE_NOT_EMPTY + 1 ) ,
+        D3D12_MESSAGE_ID_UNMAP_INVALID_NULLRANGE = ( D3D12_MESSAGE_ID_MAP_INVALID_NULLRANGE + 1 ) ,
+        D3D12_MESSAGE_ID_NO_GRAPHICS_API_SUPPORT = ( D3D12_MESSAGE_ID_UNMAP_INVALID_NULLRANGE + 1 ) ,
+        D3D12_MESSAGE_ID_NO_COMPUTE_API_SUPPORT  = ( D3D12_MESSAGE_ID_NO_GRAPHICS_API_SUPPORT + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_RESOURCE_FLAGS_NOT_SUPPORTED = ( D3D12_MESSAGE_ID_NO_COMPUTE_API_SUPPORT + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_ROOT_ARGUMENT_UNINITIALIZED  = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_RESOURCE_FLAGS_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_HEAP_INDEX_OUT_OF_BOUNDS  = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_ROOT_ARGUMENT_UNINITIALIZED + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_TABLE_REGISTER_INDEX_OUT_OF_BOUNDS  = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_HEAP_INDEX_OUT_OF_BOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_UNINITIALIZED = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_TABLE_REGISTER_INDEX_OUT_OF_BOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_TYPE_MISMATCH = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_UNINITIALIZED + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_SRV_RESOURCE_DIMENSION_MISMATCH  = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_TYPE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_UAV_RESOURCE_DIMENSION_MISMATCH  = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_SRV_RESOURCE_DIMENSION_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_INCOMPATIBLE_RESOURCE_STATE  = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_UAV_RESOURCE_DIMENSION_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_COPYRESOURCE_NULLDST  = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_INCOMPATIBLE_RESOURCE_STATE + 1 ) ,
+        D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDDSTRESOURCE = ( D3D12_MESSAGE_ID_COPYRESOURCE_NULLDST + 1 ) ,
+        D3D12_MESSAGE_ID_COPYRESOURCE_NULLSRC  = ( D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDDSTRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDSRCRESOURCE = ( D3D12_MESSAGE_ID_COPYRESOURCE_NULLSRC + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_NULLDST  = ( D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDSRCRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALIDDSTRESOURCE = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_NULLDST + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_NULLSRC  = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALIDDSTRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALIDSRCRESOURCE = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_NULLSRC + 1 ) ,
+        D3D12_MESSAGE_ID_PIPELINE_STATE_TYPE_MISMATCH  = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALIDSRCRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DISPATCH_ROOT_SIGNATURE_NOT_SET  = ( D3D12_MESSAGE_ID_PIPELINE_STATE_TYPE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DISPATCH_ROOT_SIGNATURE_MISMATCH = ( D3D12_MESSAGE_ID_COMMAND_LIST_DISPATCH_ROOT_SIGNATURE_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_ZERO_BARRIERS  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DISPATCH_ROOT_SIGNATURE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_BEGIN_END_EVENT_MISMATCH  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_ZERO_BARRIERS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_POSSIBLE_BEFORE_AFTER_MISMATCH = ( D3D12_MESSAGE_ID_BEGIN_END_EVENT_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_BEGIN_END  = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_POSSIBLE_BEFORE_AFTER_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_INVALID_RESOURCE = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_BEGIN_END + 1 ) ,
+        D3D12_MESSAGE_ID_USE_OF_ZERO_REFCOUNT_OBJECT = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_INVALID_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_OBJECT_EVICTED_WHILE_STILL_IN_USE = ( D3D12_MESSAGE_ID_USE_OF_ZERO_REFCOUNT_OBJECT + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_ROOT_DESCRIPTOR_ACCESS_OUT_OF_BOUNDS = ( D3D12_MESSAGE_ID_OBJECT_EVICTED_WHILE_STILL_IN_USE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_INVALIDLIBRARYBLOB  = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_ROOT_DESCRIPTOR_ACCESS_OUT_OF_BOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_DRIVERVERSIONMISMATCH = ( D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_INVALIDLIBRARYBLOB + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_ADAPTERVERSIONMISMATCH  = ( D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_DRIVERVERSIONMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_UNSUPPORTED = ( D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_ADAPTERVERSIONMISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_PIPELINELIBRARY  = ( D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_PIPELINELIBRARY  = ( D3D12_MESSAGE_ID_CREATE_PIPELINELIBRARY + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_PIPELINELIBRARY = ( D3D12_MESSAGE_ID_LIVE_PIPELINELIBRARY + 1 ) ,
+        D3D12_MESSAGE_ID_STOREPIPELINE_NONAME  = ( D3D12_MESSAGE_ID_DESTROY_PIPELINELIBRARY + 1 ) ,
+        D3D12_MESSAGE_ID_STOREPIPELINE_DUPLICATENAME = ( D3D12_MESSAGE_ID_STOREPIPELINE_NONAME + 1 ) ,
+        D3D12_MESSAGE_ID_LOADPIPELINE_NAMENOTFOUND = ( D3D12_MESSAGE_ID_STOREPIPELINE_DUPLICATENAME + 1 ) ,
+        D3D12_MESSAGE_ID_LOADPIPELINE_INVALIDDESC  = ( D3D12_MESSAGE_ID_LOADPIPELINE_NAMENOTFOUND + 1 ) ,
+        D3D12_MESSAGE_ID_PIPELINELIBRARY_SERIALIZE_NOTENOUGHMEMORY = ( D3D12_MESSAGE_ID_LOADPIPELINE_INVALIDDESC + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_PS_OUTPUT_RT_OUTPUT_MISMATCH  = ( D3D12_MESSAGE_ID_PIPELINELIBRARY_SERIALIZE_NOTENOUGHMEMORY + 1 ) ,
+        D3D12_MESSAGE_ID_SETEVENTONMULTIPLEFENCECOMPLETION_INVALIDFLAGS  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_PS_OUTPUT_RT_OUTPUT_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_QUEUE_VIDEO_NOT_SUPPORTED  = ( D3D12_MESSAGE_ID_SETEVENTONMULTIPLEFENCECOMPLETION_INVALIDFLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_ALLOCATOR_VIDEO_NOT_SUPPORTED  = ( D3D12_MESSAGE_ID_CREATE_QUEUE_VIDEO_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEQUERY_HEAP_VIDEO_DECODE_STATISTICS_NOT_SUPPORTED  = ( D3D12_MESSAGE_ID_CREATE_COMMAND_ALLOCATOR_VIDEO_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_VIDEODECODECOMMANDLIST = ( D3D12_MESSAGE_ID_CREATEQUERY_HEAP_VIDEO_DECODE_STATISTICS_NOT_SUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_VIDEODECODER = ( D3D12_MESSAGE_ID_CREATE_VIDEODECODECOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_VIDEODECODESTREAM  = ( D3D12_MESSAGE_ID_CREATE_VIDEODECODER + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_VIDEODECODECOMMANDLIST = ( D3D12_MESSAGE_ID_CREATE_VIDEODECODESTREAM + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_VIDEODECODER = ( D3D12_MESSAGE_ID_LIVE_VIDEODECODECOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_VIDEODECODESTREAM  = ( D3D12_MESSAGE_ID_LIVE_VIDEODECODER + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_VIDEODECODECOMMANDLIST  = ( D3D12_MESSAGE_ID_LIVE_VIDEODECODESTREAM + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_VIDEODECODER  = ( D3D12_MESSAGE_ID_DESTROY_VIDEODECODECOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_VIDEODECODESTREAM = ( D3D12_MESSAGE_ID_DESTROY_VIDEODECODER + 1 ) ,
+        D3D12_MESSAGE_ID_DECODE_FRAME_INVALID_PARAMETERS = ( D3D12_MESSAGE_ID_DESTROY_VIDEODECODESTREAM + 1 ) ,
+        D3D12_MESSAGE_ID_DEPRECATED_API  = ( D3D12_MESSAGE_ID_DECODE_FRAME_INVALID_PARAMETERS + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE  = ( D3D12_MESSAGE_ID_DEPRECATED_API + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_DESCRIPTOR_TABLE_NOT_SET = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_ROOT_CONSTANT_BUFFER_VIEW_NOT_SET  = ( D3D12_MESSAGE_ID_COMMAND_LIST_DESCRIPTOR_TABLE_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_ROOT_SHADER_RESOURCE_VIEW_NOT_SET  = ( D3D12_MESSAGE_ID_COMMAND_LIST_ROOT_CONSTANT_BUFFER_VIEW_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_ROOT_UNORDERED_ACCESS_VIEW_NOT_SET = ( D3D12_MESSAGE_ID_COMMAND_LIST_ROOT_SHADER_RESOURCE_VIEW_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_DISCARD_INVALID_SUBRESOURCE_RANGE = ( D3D12_MESSAGE_ID_COMMAND_LIST_ROOT_UNORDERED_ACCESS_VIEW_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_DISCARD_ONE_SUBRESOURCE_FOR_MIPS_WITH_RECTS = ( D3D12_MESSAGE_ID_DISCARD_INVALID_SUBRESOURCE_RANGE + 1 ) ,
+        D3D12_MESSAGE_ID_DISCARD_NO_RECTS_FOR_NON_TEXTURE2D  = ( D3D12_MESSAGE_ID_DISCARD_ONE_SUBRESOURCE_FOR_MIPS_WITH_RECTS + 1 ) ,
+        D3D12_MESSAGE_ID_COPY_ON_SAME_SUBRESOURCE  = ( D3D12_MESSAGE_ID_DISCARD_NO_RECTS_FOR_NON_TEXTURE2D + 1 ) ,
+        D3D12_MESSAGE_ID_SETRESIDENCYPRIORITY_INVALID_PAGEABLE = ( D3D12_MESSAGE_ID_COPY_ON_SAME_SUBRESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_UNSUPPORTED  = ( D3D12_MESSAGE_ID_SETRESIDENCYPRIORITY_INVALID_PAGEABLE + 1 ) ,
+        D3D12_MESSAGE_ID_STATIC_DESCRIPTOR_INVALID_DESCRIPTOR_CHANGE = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_DATA_STATIC_DESCRIPTOR_INVALID_DATA_CHANGE  = ( D3D12_MESSAGE_ID_STATIC_DESCRIPTOR_INVALID_DESCRIPTOR_CHANGE + 1 ) ,
+        D3D12_MESSAGE_ID_DATA_STATIC_WHILE_SET_AT_EXECUTE_DESCRIPTOR_INVALID_DATA_CHANGE = ( D3D12_MESSAGE_ID_DATA_STATIC_DESCRIPTOR_INVALID_DATA_CHANGE + 1 ) ,
+        D3D12_MESSAGE_ID_EXECUTE_BUNDLE_STATIC_DESCRIPTOR_DATA_STATIC_NOT_SET  = ( D3D12_MESSAGE_ID_DATA_STATIC_WHILE_SET_AT_EXECUTE_DESCRIPTOR_INVALID_DATA_CHANGE + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_RESOURCE_ACCESS_OUT_OF_BOUNDS  = ( D3D12_MESSAGE_ID_EXECUTE_BUNDLE_STATIC_DESCRIPTOR_DATA_STATIC_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_SAMPLER_MODE_MISMATCH  = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_RESOURCE_ACCESS_OUT_OF_BOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_FENCE_INVALID_FLAGS  = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_SAMPLER_MODE_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_RESOURCE_BARRIER_DUPLICATE_SUBRESOURCE_TRANSITIONS  = ( D3D12_MESSAGE_ID_CREATE_FENCE_INVALID_FLAGS + 1 ) ,
+        D3D12_MESSAGE_ID_SETRESIDENCYPRIORITY_INVALID_PRIORITY = ( D3D12_MESSAGE_ID_RESOURCE_BARRIER_DUPLICATE_SUBRESOURCE_TRANSITIONS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_PASS = ( D3D12_MESSAGE_ID_SETRESIDENCYPRIORITY_INVALID_PRIORITY + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_PASS  = ( D3D12_MESSAGE_ID_CREATE_PASS + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_PASS = ( D3D12_MESSAGE_ID_DESTROY_PASS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_DESCRIPTOR_HEAP_LARGE_NUM_DESCRIPTORS  = ( D3D12_MESSAGE_ID_LIVE_PASS + 1 ) ,
+        D3D12_MESSAGE_ID_BEGIN_EVENT = ( D3D12_MESSAGE_ID_CREATE_DESCRIPTOR_HEAP_LARGE_NUM_DESCRIPTORS + 1 ) ,
+        D3D12_MESSAGE_ID_END_EVENT = ( D3D12_MESSAGE_ID_BEGIN_EVENT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEVICE_DEBUG_LAYER_STARTUP_OPTIONS  = ( D3D12_MESSAGE_ID_END_EVENT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_DEPTHBOUNDSTEST_UNSUPPORTED = ( D3D12_MESSAGE_ID_CREATEDEVICE_DEBUG_LAYER_STARTUP_OPTIONS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_DUPLICATE_SUBOBJECT = ( D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_DEPTHBOUNDSTEST_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_UNKNOWN_SUBOBJECT = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_DUPLICATE_SUBOBJECT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_ZERO_SIZE_STREAM  = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_UNKNOWN_SUBOBJECT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_INVALID_STREAM  = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_ZERO_SIZE_STREAM + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CANNOT_DEDUCE_TYPE  = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_INVALID_STREAM + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_STATIC_DESCRIPTOR_RESOURCE_DIMENSION_MISMATCH  = ( D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CANNOT_DEDUCE_TYPE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_QUEUE_INSUFFICIENT_PRIVILEGE_FOR_GLOBAL_REALTIME = ( D3D12_MESSAGE_ID_COMMAND_LIST_STATIC_DESCRIPTOR_RESOURCE_DIMENSION_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_QUEUE_INSUFFICIENT_HARDWARE_SUPPORT_FOR_GLOBAL_REALTIME  = ( D3D12_MESSAGE_ID_CREATE_COMMAND_QUEUE_INSUFFICIENT_PRIVILEGE_FOR_GLOBAL_REALTIME + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_ARCHITECTURE = ( D3D12_MESSAGE_ID_CREATE_COMMAND_QUEUE_INSUFFICIENT_HARDWARE_SUPPORT_FOR_GLOBAL_REALTIME + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_DST = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_ARCHITECTURE + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DST_RESOURCE_DIMENSION = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_DST + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_DST_RANGE_OUT_OF_BOUNDS  = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DST_RESOURCE_DIMENSION + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_SRC = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_DST_RANGE_OUT_OF_BOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_SRC_RESOURCE_DIMENSION = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_SRC + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_SRC_RANGE_OUT_OF_BOUNDS  = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_SRC_RESOURCE_DIMENSION + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_OFFSET_ALIGNMENT = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_SRC_RANGE_OUT_OF_BOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_DEPENDENT_RESOURCES = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_OFFSET_ALIGNMENT + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_DEPENDENT_SUBRESOURCE_RANGES  = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_DEPENDENT_RESOURCES + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DEPENDENT_RESOURCE = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_DEPENDENT_SUBRESOURCE_RANGES + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DEPENDENT_SUBRESOURCE_RANGE  = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DEPENDENT_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_DEPENDENT_SUBRESOURCE_OUT_OF_BOUNDS  = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DEPENDENT_SUBRESOURCE_RANGE + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_DEPENDENT_RANGE_OUT_OF_BOUNDS  = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_DEPENDENT_SUBRESOURCE_OUT_OF_BOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_ZERO_DEPENDENCIES  = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_DEPENDENT_RANGE_OUT_OF_BOUNDS + 1 ) ,
+        D3D12_MESSAGE_ID_DEVICE_CREATE_SHARED_HANDLE_INVALIDARG  = ( D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_ZERO_DEPENDENCIES + 1 ) ,
+        D3D12_MESSAGE_ID_DESCRIPTOR_HANDLE_WITH_INVALID_RESOURCE = ( D3D12_MESSAGE_ID_DEVICE_CREATE_SHARED_HANDLE_INVALIDARG + 1 ) ,
+        D3D12_MESSAGE_ID_SETDEPTHBOUNDS_INVALIDARGS  = ( D3D12_MESSAGE_ID_DESCRIPTOR_HANDLE_WITH_INVALID_RESOURCE + 1 ) ,
+        D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_RESOURCE_STATE_IMPRECISE = ( D3D12_MESSAGE_ID_SETDEPTHBOUNDS_INVALIDARGS + 1 ) ,
+        D3D12_MESSAGE_ID_COMMAND_LIST_PIPELINE_STATE_NOT_SET = ( D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_RESOURCE_STATE_IMPRECISE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_MODEL_MISMATCH = ( D3D12_MESSAGE_ID_COMMAND_LIST_PIPELINE_STATE_NOT_SET + 1 ) ,
+        D3D12_MESSAGE_ID_OBJECT_ACCESSED_WHILE_STILL_IN_USE  = ( D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_MODEL_MISMATCH + 1 ) ,
+        D3D12_MESSAGE_ID_PROGRAMMABLE_MSAA_UNSUPPORTED = ( D3D12_MESSAGE_ID_OBJECT_ACCESSED_WHILE_STILL_IN_USE + 1 ) ,
+        D3D12_MESSAGE_ID_SETSAMPLEPOSITIONS_INVALIDARGS  = ( D3D12_MESSAGE_ID_PROGRAMMABLE_MSAA_UNSUPPORTED + 1 ) ,
+        D3D12_MESSAGE_ID_RESOLVESUBRESOURCEREGION_INVALID_RECT = ( D3D12_MESSAGE_ID_SETSAMPLEPOSITIONS_INVALIDARGS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_VIDEODECODECOMMANDQUEUE  = ( D3D12_MESSAGE_ID_RESOLVESUBRESOURCEREGION_INVALID_RECT + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSCOMMANDLIST  = ( D3D12_MESSAGE_ID_CREATE_VIDEODECODECOMMANDQUEUE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSCOMMANDQUEUE = ( D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSCOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_VIDEODECODECOMMANDQUEUE  = ( D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSCOMMANDQUEUE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSCOMMANDLIST  = ( D3D12_MESSAGE_ID_LIVE_VIDEODECODECOMMANDQUEUE + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSCOMMANDQUEUE = ( D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSCOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_VIDEODECODECOMMANDQUEUE = ( D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSCOMMANDQUEUE + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSCOMMANDLIST = ( D3D12_MESSAGE_ID_DESTROY_VIDEODECODECOMMANDQUEUE + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSCOMMANDQUEUE  = ( D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSCOMMANDLIST + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSOR = ( D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSCOMMANDQUEUE + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSSTREAM = ( D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSOR + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSOR = ( D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSSTREAM + 1 ) ,
+        D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSSTREAM = ( D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSOR + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSOR  = ( D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSSTREAM + 1 ) ,
+        D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSSTREAM  = ( D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSOR + 1 ) ,
+        D3D12_MESSAGE_ID_PROCESS_FRAME_INVALID_PARAMETERS  = ( D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSSTREAM + 1 ) ,
+        D3D12_MESSAGE_ID_COPY_INVALIDLAYOUT  = ( D3D12_MESSAGE_ID_PROCESS_FRAME_INVALID_PARAMETERS + 1 ) ,
+        D3D12_MESSAGE_ID_CREATE_CRYPTO_SESSION = 1068,
+        D3D12_MESSAGE_ID_CREATE_CRYPTO_SESSION_POLICY  = 1069,
+        D3D12_MESSAGE_ID_CREATE_PROTECTED_RESOURCE_SESSION = 1070,
+        D3D12_MESSAGE_ID_LIVE_CRYPTO_SESSION = 1071,
+        D3D12_MESSAGE_ID_LIVE_CRYPTO_SESSION_POLICY  = 1072,
+        D3D12_MESSAGE_ID_LIVE_PROTECTED_RESOURCE_SESSION = 1073,
+        D3D12_MESSAGE_ID_DESTROY_CRYPTO_SESSION  = 1074,
+        D3D12_MESSAGE_ID_DESTROY_CRYPTO_SESSION_POLICY = 1075,
+        D3D12_MESSAGE_ID_DESTROY_PROTECTED_RESOURCE_SESSION  = 1076,
+        D3D12_MESSAGE_ID_PROTECTED_RESOURCE_SESSION_UNSUPPORTED  = 1077,
+        D3D12_MESSAGE_ID_FENCE_INVALIDOPERATION  = 1078,
+        D3D12_MESSAGE_ID_CREATEQUERY_HEAP_COPY_QUEUE_TIMESTAMPS_NOT_SUPPORTED  = 1079,
+        D3D12_MESSAGE_ID_SAMPLEPOSITIONS_MISMATCH_DEFERRED = 1080,
+        D3D12_MESSAGE_ID_SAMPLEPOSITIONS_MISMATCH_RECORDTIME_ASSUMEDFROMFIRSTUSE = 1081,
+        D3D12_MESSAGE_ID_SAMPLEPOSITIONS_MISMATCH_RECORDTIME_ASSUMEDFROMCLEAR  = 1082,
+        D3D12_MESSAGE_ID_CREATE_VIDEODECODERHEAP = 1083,
+        D3D12_MESSAGE_ID_LIVE_VIDEODECODERHEAP = 1084,
+        D3D12_MESSAGE_ID_DESTROY_VIDEODECODERHEAP  = 1085,
+        D3D12_MESSAGE_ID_OPENEXISTINGHEAP_INVALIDARG_RETURN  = 1086,
+        D3D12_MESSAGE_ID_OPENEXISTINGHEAP_OUTOFMEMORY_RETURN = 1087,
+        D3D12_MESSAGE_ID_OPENEXISTINGHEAP_INVALIDADDRESS = 1088,
+        D3D12_MESSAGE_ID_OPENEXISTINGHEAP_INVALIDHANDLE  = 1089,
+        D3D12_MESSAGE_ID_WRITEBUFFERIMMEDIATE_INVALID_DEST = 1090,
+        D3D12_MESSAGE_ID_WRITEBUFFERIMMEDIATE_INVALID_MODE = 1091,
+        D3D12_MESSAGE_ID_WRITEBUFFERIMMEDIATE_INVALID_ALIGNMENT  = 1092,
+        D3D12_MESSAGE_ID_WRITEBUFFERIMMEDIATE_NOT_SUPPORTED  = 1093,
+        D3D12_MESSAGE_ID_SETVIEWINSTANCEMASK_INVALIDARGS = 1094,
+        D3D12_MESSAGE_ID_VIEW_INSTANCING_UNSUPPORTED = 1095,
+        D3D12_MESSAGE_ID_VIEW_INSTANCING_INVALIDARGS = 1096,
+        D3D12_MESSAGE_ID_COPYTEXTUREREGION_MISMATCH_DECODE_REFERENCE_ONLY_FLAG = 1097,
+        D3D12_MESSAGE_ID_COPYRESOURCE_MISMATCH_DECODE_REFERENCE_ONLY_FLAG  = 1098,
+        D3D12_MESSAGE_ID_CREATE_VIDEO_DECODE_HEAP_CAPS_FAILURE = 1099,
+        D3D12_MESSAGE_ID_CREATE_VIDEO_DECODE_HEAP_CAPS_UNSUPPORTED = 1100,
+        D3D12_MESSAGE_ID_VIDEO_DECODE_SUPPORT_INVALID_INPUT  = 1101,
+        D3D12_MESSAGE_ID_CREATE_VIDEO_DECODER_UNSUPPORTED  = 1102,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_METADATA_ERROR  = 1103,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_VIEW_INSTANCING_VERTEX_SIZE_EXCEEDED  = 1104,
+        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RUNTIME_INTERNAL_ERROR  = 1105,
+        D3D12_MESSAGE_ID_NO_VIDEO_API_SUPPORT  = 1106,
+        D3D12_MESSAGE_ID_VIDEO_PROCESS_SUPPORT_INVALID_INPUT = 1107,
+        D3D12_MESSAGE_ID_CREATE_VIDEO_PROCESSOR_CAPS_FAILURE = 1108,
+        D3D12_MESSAGE_ID_VIDEO_PROCESS_SUPPORT_UNSUPPORTED_FORMAT  = 1109,
+        D3D12_MESSAGE_ID_VIDEO_DECODE_FRAME_INVALID_ARGUMENT = 1110,
+        D3D12_MESSAGE_ID_ENQUEUE_MAKE_RESIDENT_INVALID_FLAGS = 1111,
+        D3D12_MESSAGE_ID_OPENEXISTINGHEAP_UNSUPPORTED  = 1112,
+        D3D12_MESSAGE_ID_VIDEO_PROCESS_FRAMES_INVALID_ARGUMENT = 1113,
+        D3D12_MESSAGE_ID_VIDEO_DECODE_SUPPORT_UNSUPPORTED  = 1114,
+        D3D12_MESSAGE_ID_CREATE_COMMANDRECORDER  = 1115,
+        D3D12_MESSAGE_ID_LIVE_COMMANDRECORDER  = 1116,
+        D3D12_MESSAGE_ID_DESTROY_COMMANDRECORDER = 1117,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_RECORDER_VIDEO_NOT_SUPPORTED = 1118,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_RECORDER_INVALID_SUPPORT_FLAGS = 1119,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_RECORDER_INVALID_FLAGS = 1120,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_RECORDER_MORE_RECORDERS_THAN_LOGICAL_PROCESSORS  = 1121,
+        D3D12_MESSAGE_ID_CREATE_COMMANDPOOL  = 1122,
+        D3D12_MESSAGE_ID_LIVE_COMMANDPOOL  = 1123,
+        D3D12_MESSAGE_ID_DESTROY_COMMANDPOOL = 1124,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_POOL_INVALID_FLAGS = 1125,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_LIST_VIDEO_NOT_SUPPORTED = 1126,
+        D3D12_MESSAGE_ID_COMMAND_RECORDER_SUPPORT_FLAGS_MISMATCH = 1127,
+        D3D12_MESSAGE_ID_COMMAND_RECORDER_CONTENTION = 1128,
+        D3D12_MESSAGE_ID_COMMAND_RECORDER_USAGE_WITH_CREATECOMMANDLIST_COMMAND_LIST  = 1129,
+        D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_USAGE_WITH_CREATECOMMANDLIST1_COMMAND_LIST  = 1130,
+        D3D12_MESSAGE_ID_CANNOT_EXECUTE_EMPTY_COMMAND_LIST = 1131,
+        D3D12_MESSAGE_ID_CANNOT_RESET_COMMAND_POOL_WITH_OPEN_COMMAND_LISTS = 1132,
+        D3D12_MESSAGE_ID_CANNOT_USE_COMMAND_RECORDER_WITHOUT_CURRENT_TARGET  = 1133,
+        D3D12_MESSAGE_ID_CANNOT_CHANGE_COMMAND_RECORDER_TARGET_WHILE_RECORDING = 1134,
+        D3D12_MESSAGE_ID_COMMAND_POOL_SYNC = 1135,
+        D3D12_MESSAGE_ID_EVICT_UNDERFLOW = 1136,
+        D3D12_MESSAGE_ID_CREATE_META_COMMAND = 1137,
+        D3D12_MESSAGE_ID_LIVE_META_COMMAND = 1138,
+        D3D12_MESSAGE_ID_DESTROY_META_COMMAND  = 1139,
+        D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALID_DST_RESOURCE = 1140,
+        D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALID_SRC_RESOURCE = 1141,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DST_RESOURCE = 1142,
+        D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_SRC_RESOURCE = 1143,
+        D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_NULL_BUFFER  = 1144,
+        D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_NULL_RESOURCE_DESC = 1145,
+        D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_UNSUPPORTED  = 1146,
+        D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_BUFFER_DIMENSION = 1147,
+        D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_BUFFER_FLAGS = 1148,
+        D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_BUFFER_OFFSET  = 1149,
+        D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_RESOURCE_DIMENSION = 1150,
+        D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_RESOURCE_FLAGS = 1151,
+        D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_OUTOFMEMORY_RETURN = 1152,
+        D3D12_MESSAGE_ID_CANNOT_CREATE_GRAPHICS_AND_VIDEO_COMMAND_RECORDER = 1153,
+        D3D12_MESSAGE_ID_UPDATETILEMAPPINGS_POSSIBLY_MISMATCHING_PROPERTIES  = 1154,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_LIST_INVALID_COMMAND_LIST_TYPE = 1155,
+        D3D12_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_INCOMPATIBLE_WITH_STRUCTURED_BUFFERS = 1156,
+        D3D12_MESSAGE_ID_COMPUTE_ONLY_DEVICE_OPERATION_UNSUPPORTED = 1157,
+        D3D12_MESSAGE_ID_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INVALID = 1158,
+        D3D12_MESSAGE_ID_EMIT_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_INVALID = 1159,
+        D3D12_MESSAGE_ID_COPY_RAYTRACING_ACCELERATION_STRUCTURE_INVALID  = 1160,
+        D3D12_MESSAGE_ID_DISPATCH_RAYS_INVALID = 1161,
+        D3D12_MESSAGE_ID_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_INVALID = 1162,
+        D3D12_MESSAGE_ID_CREATE_LIFETIMETRACKER  = 1163,
+        D3D12_MESSAGE_ID_LIVE_LIFETIMETRACKER  = 1164,
+        D3D12_MESSAGE_ID_DESTROY_LIFETIMETRACKER = 1165,
+        D3D12_MESSAGE_ID_DESTROYOWNEDOBJECT_OBJECTNOTOWNED = 1166,
+        D3D12_MESSAGE_ID_CREATE_TRACKEDWORKLOAD  = 1167,
+        D3D12_MESSAGE_ID_LIVE_TRACKEDWORKLOAD  = 1168,
+        D3D12_MESSAGE_ID_DESTROY_TRACKEDWORKLOAD = 1169,
+        D3D12_MESSAGE_ID_RENDER_PASS_ERROR = 1170,
+        D3D12_MESSAGE_ID_META_COMMAND_ID_INVALID = 1171,
+        D3D12_MESSAGE_ID_META_COMMAND_UNSUPPORTED_PARAMS = 1172,
+        D3D12_MESSAGE_ID_META_COMMAND_FAILED_ENUMERATION = 1173,
+        D3D12_MESSAGE_ID_META_COMMAND_PARAMETER_SIZE_MISMATCH  = 1174,
+        D3D12_MESSAGE_ID_UNINITIALIZED_META_COMMAND  = 1175,
+        D3D12_MESSAGE_ID_META_COMMAND_INVALID_GPU_VIRTUAL_ADDRESS  = 1176,
+        D3D12_MESSAGE_ID_CREATE_VIDEOENCODECOMMANDLIST = 1177,
+        D3D12_MESSAGE_ID_LIVE_VIDEOENCODECOMMANDLIST = 1178,
+        D3D12_MESSAGE_ID_DESTROY_VIDEOENCODECOMMANDLIST  = 1179,
+        D3D12_MESSAGE_ID_CREATE_VIDEOENCODECOMMANDQUEUE  = 1180,
+        D3D12_MESSAGE_ID_LIVE_VIDEOENCODECOMMANDQUEUE  = 1181,
+        D3D12_MESSAGE_ID_DESTROY_VIDEOENCODECOMMANDQUEUE = 1182,
+        D3D12_MESSAGE_ID_CREATE_VIDEOMOTIONESTIMATOR = 1183,
+        D3D12_MESSAGE_ID_LIVE_VIDEOMOTIONESTIMATOR = 1184,
+        D3D12_MESSAGE_ID_DESTROY_VIDEOMOTIONESTIMATOR  = 1185,
+        D3D12_MESSAGE_ID_CREATE_VIDEOMOTIONVECTORHEAP  = 1186,
+        D3D12_MESSAGE_ID_LIVE_VIDEOMOTIONVECTORHEAP  = 1187,
+        D3D12_MESSAGE_ID_DESTROY_VIDEOMOTIONVECTORHEAP = 1188,
+        D3D12_MESSAGE_ID_MULTIPLE_TRACKED_WORKLOADS  = 1189,
+        D3D12_MESSAGE_ID_MULTIPLE_TRACKED_WORKLOAD_PAIRS = 1190,
+        D3D12_MESSAGE_ID_OUT_OF_ORDER_TRACKED_WORKLOAD_PAIR  = 1191,
+        D3D12_MESSAGE_ID_CANNOT_ADD_TRACKED_WORKLOAD = 1192,
+        D3D12_MESSAGE_ID_INCOMPLETE_TRACKED_WORKLOAD_PAIR  = 1193,
+        D3D12_MESSAGE_ID_CREATE_STATE_OBJECT_ERROR = 1194,
+        D3D12_MESSAGE_ID_GET_SHADER_IDENTIFIER_ERROR = 1195,
+        D3D12_MESSAGE_ID_GET_SHADER_STACK_SIZE_ERROR = 1196,
+        D3D12_MESSAGE_ID_GET_PIPELINE_STACK_SIZE_ERROR = 1197,
+        D3D12_MESSAGE_ID_SET_PIPELINE_STACK_SIZE_ERROR = 1198,
+        D3D12_MESSAGE_ID_GET_SHADER_IDENTIFIER_SIZE_INVALID  = 1199,
+        D3D12_MESSAGE_ID_CHECK_DRIVER_MATCHING_IDENTIFIER_INVALID  = 1200,
+        D3D12_MESSAGE_ID_CHECK_DRIVER_MATCHING_IDENTIFIER_DRIVER_REPORTED_ISSUE  = 1201,
+        D3D12_MESSAGE_ID_RENDER_PASS_INVALID_RESOURCE_BARRIER  = 1202,
+        D3D12_MESSAGE_ID_RENDER_PASS_DISALLOWED_API_CALLED = 1203,
+        D3D12_MESSAGE_ID_RENDER_PASS_CANNOT_NEST_RENDER_PASSES = 1204,
+        D3D12_MESSAGE_ID_RENDER_PASS_CANNOT_END_WITHOUT_BEGIN  = 1205,
+        D3D12_MESSAGE_ID_RENDER_PASS_CANNOT_CLOSE_COMMAND_LIST = 1206,
+        D3D12_MESSAGE_ID_RENDER_PASS_GPU_WORK_WHILE_SUSPENDED  = 1207,
+        D3D12_MESSAGE_ID_RENDER_PASS_MISMATCHING_SUSPEND_RESUME  = 1208,
+        D3D12_MESSAGE_ID_RENDER_PASS_NO_PRIOR_SUSPEND_WITHIN_EXECUTECOMMANDLISTS = 1209,
+        D3D12_MESSAGE_ID_RENDER_PASS_NO_SUBSEQUENT_RESUME_WITHIN_EXECUTECOMMANDLISTS = 1210,
+        D3D12_MESSAGE_ID_TRACKED_WORKLOAD_COMMAND_QUEUE_MISMATCH = 1211,
+        D3D12_MESSAGE_ID_TRACKED_WORKLOAD_NOT_SUPPORTED  = 1212,
+        D3D12_MESSAGE_ID_RENDER_PASS_MISMATCHING_NO_ACCESS = 1213,
+        D3D12_MESSAGE_ID_RENDER_PASS_UNSUPPORTED_RESOLVE = 1214,
+        D3D12_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_INVALID_RESOURCE_PTR = 1215,
+        D3D12_MESSAGE_ID_WINDOWS7_FENCE_OUTOFORDER_SIGNAL  = 1216,
+        D3D12_MESSAGE_ID_WINDOWS7_FENCE_OUTOFORDER_WAIT  = 1217,
+        D3D12_MESSAGE_ID_VIDEO_CREATE_MOTION_ESTIMATOR_INVALID_ARGUMENT  = 1218,
+        D3D12_MESSAGE_ID_VIDEO_CREATE_MOTION_VECTOR_HEAP_INVALID_ARGUMENT  = 1219,
+        D3D12_MESSAGE_ID_ESTIMATE_MOTION_INVALID_ARGUMENT  = 1220,
+        D3D12_MESSAGE_ID_RESOLVE_MOTION_VECTOR_HEAP_INVALID_ARGUMENT = 1221,
+        D3D12_MESSAGE_ID_GETGPUVIRTUALADDRESS_INVALID_HEAP_TYPE  = 1222,
+        D3D12_MESSAGE_ID_SET_BACKGROUND_PROCESSING_MODE_INVALID_ARGUMENT = 1223,
+        D3D12_MESSAGE_ID_CREATE_COMMAND_LIST_INVALID_COMMAND_LIST_TYPE_FOR_FEATURE_LEVEL = 1224,
+        D3D12_MESSAGE_ID_CREATE_VIDEOEXTENSIONCOMMAND  = 1225,
+        D3D12_MESSAGE_ID_LIVE_VIDEOEXTENSIONCOMMAND  = 1226,
+        D3D12_MESSAGE_ID_DESTROY_VIDEOEXTENSIONCOMMAND = 1227,
+        D3D12_MESSAGE_ID_INVALID_VIDEO_EXTENSION_COMMAND_ID  = 1228,
+        D3D12_MESSAGE_ID_VIDEO_EXTENSION_COMMAND_INVALID_ARGUMENT  = 1229,
+        D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_NOT_UNIQUE_IN_DXIL_LIBRARY  = 1230,
+        D3D12_MESSAGE_ID_VARIABLE_SHADING_RATE_NOT_ALLOWED_WITH_TIR  = 1231,
+        D3D12_MESSAGE_ID_GEOMETRY_SHADER_OUTPUTTING_BOTH_VIEWPORT_ARRAY_INDEX_AND_SHADING_RATE_NOT_SUPPORTED_ON_DEVICE = 1232,
+        D3D12_MESSAGE_ID_RSSETSHADING_RATE_INVALID_SHADING_RATE  = 1233,
+        D3D12_MESSAGE_ID_RSSETSHADING_RATE_SHADING_RATE_NOT_PERMITTED_BY_CAP = 1234,
+        D3D12_MESSAGE_ID_RSSETSHADING_RATE_INVALID_COMBINER  = 1235,
+        D3D12_MESSAGE_ID_RSSETSHADINGRATEIMAGE_REQUIRES_TIER_2 = 1236,
+        D3D12_MESSAGE_ID_RSSETSHADINGRATE_REQUIRES_TIER_1  = 1237,
+        D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_FORMAT = 1238,
+        D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_ARRAY_SIZE = 1239,
+        D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_MIP_LEVEL  = 1240,
+        D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_SAMPLE_COUNT = 1241,
+        D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_SAMPLE_QUALITY = 1242,
+        D3D12_MESSAGE_ID_NON_RETAIL_SHADER_MODEL_WONT_VALIDATE = 1243,
+        D3D12_MESSAGE_ID_D3D12_MESSAGES_END  = ( D3D12_MESSAGE_ID_NON_RETAIL_SHADER_MODEL_WONT_VALIDATE + 1 ) 
+    }  D3D12_MESSAGE_ID;
+
+static_assert(D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_UNSUPPORTED == 1000, "Publicly released SDK D3D12_MESSAGE_ID enum values must not be changed. New enum values must be added to the end of the list.");
+static_assert(D3D12_MESSAGE_ID_COPY_INVALIDLAYOUT == 1067, "Publicly released SDK D3D12_MESSAGE_ID enum values must not be changed. New enum values must be added to the end of the list.");
+typedef struct D3D12_MESSAGE
+    {
+    D3D12_MESSAGE_CATEGORY Category;
+    D3D12_MESSAGE_SEVERITY Severity;
+    D3D12_MESSAGE_ID ID;
+    _Field_size_(DescriptionByteLength)  const char *pDescription;
+    SIZE_T DescriptionByteLength;
+    }  D3D12_MESSAGE;
+
+typedef struct D3D12_INFO_QUEUE_FILTER_DESC
+    {
+    UINT NumCategories;
+    _Field_size_(NumCategories)  D3D12_MESSAGE_CATEGORY *pCategoryList;
+    UINT NumSeverities;
+    _Field_size_(NumSeverities)  D3D12_MESSAGE_SEVERITY *pSeverityList;
+    UINT NumIDs;
+    _Field_size_(NumIDs)  D3D12_MESSAGE_ID *pIDList;
+    }  D3D12_INFO_QUEUE_FILTER_DESC;
+
+typedef struct D3D12_INFO_QUEUE_FILTER
+    {
+    D3D12_INFO_QUEUE_FILTER_DESC AllowList;
+    D3D12_INFO_QUEUE_FILTER_DESC DenyList;
+    }  D3D12_INFO_QUEUE_FILTER;
+
+#define D3D12_INFO_QUEUE_DEFAULT_MESSAGE_COUNT_LIMIT 1024
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0012_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0012_v0_0_s_ifspec;
+
+#ifndef __ID3D12InfoQueue_INTERFACE_DEFINED__
+#define __ID3D12InfoQueue_INTERFACE_DEFINED__
+
+/* interface ID3D12InfoQueue */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D12InfoQueue;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("0742a90b-c387-483f-b946-30a7e4e61458")
+    ID3D12InfoQueue : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetMessageCountLimit( 
+            _In_  UINT64 MessageCountLimit) = 0;
+        
+        virtual void STDMETHODCALLTYPE ClearStoredMessages( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetMessage( 
+            _In_  UINT64 MessageIndex,
+            _Out_writes_bytes_opt_(*pMessageByteLength)  D3D12_MESSAGE *pMessage,
+            _Inout_  SIZE_T *pMessageByteLength) = 0;
+        
+        virtual UINT64 STDMETHODCALLTYPE GetNumMessagesAllowedByStorageFilter( void) = 0;
+        
+        virtual UINT64 STDMETHODCALLTYPE GetNumMessagesDeniedByStorageFilter( void) = 0;
+        
+        virtual UINT64 STDMETHODCALLTYPE GetNumStoredMessages( void) = 0;
+        
+        virtual UINT64 STDMETHODCALLTYPE GetNumStoredMessagesAllowedByRetrievalFilter( void) = 0;
+        
+        virtual UINT64 STDMETHODCALLTYPE GetNumMessagesDiscardedByMessageCountLimit( void) = 0;
+        
+        virtual UINT64 STDMETHODCALLTYPE GetMessageCountLimit( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE AddStorageFilterEntries( 
+            _In_  D3D12_INFO_QUEUE_FILTER *pFilter) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetStorageFilter( 
+            _Out_writes_bytes_opt_(*pFilterByteLength)  D3D12_INFO_QUEUE_FILTER *pFilter,
+            _Inout_  SIZE_T *pFilterByteLength) = 0;
+        
+        virtual void STDMETHODCALLTYPE ClearStorageFilter( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE PushEmptyStorageFilter( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE PushCopyOfStorageFilter( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE PushStorageFilter( 
+            _In_  D3D12_INFO_QUEUE_FILTER *pFilter) = 0;
+        
+        virtual void STDMETHODCALLTYPE PopStorageFilter( void) = 0;
+        
+        virtual UINT STDMETHODCALLTYPE GetStorageFilterStackSize( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE AddRetrievalFilterEntries( 
+            _In_  D3D12_INFO_QUEUE_FILTER *pFilter) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetRetrievalFilter( 
+            _Out_writes_bytes_opt_(*pFilterByteLength)  D3D12_INFO_QUEUE_FILTER *pFilter,
+            _Inout_  SIZE_T *pFilterByteLength) = 0;
+        
+        virtual void STDMETHODCALLTYPE ClearRetrievalFilter( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE PushEmptyRetrievalFilter( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE PushCopyOfRetrievalFilter( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE PushRetrievalFilter( 
+            _In_  D3D12_INFO_QUEUE_FILTER *pFilter) = 0;
+        
+        virtual void STDMETHODCALLTYPE PopRetrievalFilter( void) = 0;
+        
+        virtual UINT STDMETHODCALLTYPE GetRetrievalFilterStackSize( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE AddMessage( 
+            _In_  D3D12_MESSAGE_CATEGORY Category,
+            _In_  D3D12_MESSAGE_SEVERITY Severity,
+            _In_  D3D12_MESSAGE_ID ID,
+            _In_  LPCSTR pDescription) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE AddApplicationMessage( 
+            _In_  D3D12_MESSAGE_SEVERITY Severity,
+            _In_  LPCSTR pDescription) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetBreakOnCategory( 
+            _In_  D3D12_MESSAGE_CATEGORY Category,
+            _In_  BOOL bEnable) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetBreakOnSeverity( 
+            _In_  D3D12_MESSAGE_SEVERITY Severity,
+            _In_  BOOL bEnable) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetBreakOnID( 
+            _In_  D3D12_MESSAGE_ID ID,
+            _In_  BOOL bEnable) = 0;
+        
+        virtual BOOL STDMETHODCALLTYPE GetBreakOnCategory( 
+            _In_  D3D12_MESSAGE_CATEGORY Category) = 0;
+        
+        virtual BOOL STDMETHODCALLTYPE GetBreakOnSeverity( 
+            _In_  D3D12_MESSAGE_SEVERITY Severity) = 0;
+        
+        virtual BOOL STDMETHODCALLTYPE GetBreakOnID( 
+            _In_  D3D12_MESSAGE_ID ID) = 0;
+        
+        virtual void STDMETHODCALLTYPE SetMuteDebugOutput( 
+            _In_  BOOL bMute) = 0;
+        
+        virtual BOOL STDMETHODCALLTYPE GetMuteDebugOutput( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D12InfoQueueVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D12InfoQueue * This,
+            REFIID riid,
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D12InfoQueue * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetMessageCountLimit )( 
+            ID3D12InfoQueue * This,
+            _In_  UINT64 MessageCountLimit);
+        
+        void ( STDMETHODCALLTYPE *ClearStoredMessages )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetMessage )( 
+            ID3D12InfoQueue * This,
+            _In_  UINT64 MessageIndex,
+            _Out_writes_bytes_opt_(*pMessageByteLength)  D3D12_MESSAGE *pMessage,
+            _Inout_  SIZE_T *pMessageByteLength);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetNumMessagesAllowedByStorageFilter )( 
+            ID3D12InfoQueue * This);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetNumMessagesDeniedByStorageFilter )( 
+            ID3D12InfoQueue * This);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetNumStoredMessages )( 
+            ID3D12InfoQueue * This);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetNumStoredMessagesAllowedByRetrievalFilter )( 
+            ID3D12InfoQueue * This);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetNumMessagesDiscardedByMessageCountLimit )( 
+            ID3D12InfoQueue * This);
+        
+        UINT64 ( STDMETHODCALLTYPE *GetMessageCountLimit )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *AddStorageFilterEntries )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_INFO_QUEUE_FILTER *pFilter);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetStorageFilter )( 
+            ID3D12InfoQueue * This,
+            _Out_writes_bytes_opt_(*pFilterByteLength)  D3D12_INFO_QUEUE_FILTER *pFilter,
+            _Inout_  SIZE_T *pFilterByteLength);
+        
+        void ( STDMETHODCALLTYPE *ClearStorageFilter )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *PushEmptyStorageFilter )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *PushCopyOfStorageFilter )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *PushStorageFilter )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_INFO_QUEUE_FILTER *pFilter);
+        
+        void ( STDMETHODCALLTYPE *PopStorageFilter )( 
+            ID3D12InfoQueue * This);
+        
+        UINT ( STDMETHODCALLTYPE *GetStorageFilterStackSize )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *AddRetrievalFilterEntries )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_INFO_QUEUE_FILTER *pFilter);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRetrievalFilter )( 
+            ID3D12InfoQueue * This,
+            _Out_writes_bytes_opt_(*pFilterByteLength)  D3D12_INFO_QUEUE_FILTER *pFilter,
+            _Inout_  SIZE_T *pFilterByteLength);
+        
+        void ( STDMETHODCALLTYPE *ClearRetrievalFilter )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *PushEmptyRetrievalFilter )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *PushCopyOfRetrievalFilter )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *PushRetrievalFilter )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_INFO_QUEUE_FILTER *pFilter);
+        
+        void ( STDMETHODCALLTYPE *PopRetrievalFilter )( 
+            ID3D12InfoQueue * This);
+        
+        UINT ( STDMETHODCALLTYPE *GetRetrievalFilterStackSize )( 
+            ID3D12InfoQueue * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *AddMessage )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_MESSAGE_CATEGORY Category,
+            _In_  D3D12_MESSAGE_SEVERITY Severity,
+            _In_  D3D12_MESSAGE_ID ID,
+            _In_  LPCSTR pDescription);
+        
+        HRESULT ( STDMETHODCALLTYPE *AddApplicationMessage )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_MESSAGE_SEVERITY Severity,
+            _In_  LPCSTR pDescription);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetBreakOnCategory )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_MESSAGE_CATEGORY Category,
+            _In_  BOOL bEnable);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetBreakOnSeverity )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_MESSAGE_SEVERITY Severity,
+            _In_  BOOL bEnable);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetBreakOnID )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_MESSAGE_ID ID,
+            _In_  BOOL bEnable);
+        
+        BOOL ( STDMETHODCALLTYPE *GetBreakOnCategory )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_MESSAGE_CATEGORY Category);
+        
+        BOOL ( STDMETHODCALLTYPE *GetBreakOnSeverity )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_MESSAGE_SEVERITY Severity);
+        
+        BOOL ( STDMETHODCALLTYPE *GetBreakOnID )( 
+            ID3D12InfoQueue * This,
+            _In_  D3D12_MESSAGE_ID ID);
+        
+        void ( STDMETHODCALLTYPE *SetMuteDebugOutput )( 
+            ID3D12InfoQueue * This,
+            _In_  BOOL bMute);
+        
+        BOOL ( STDMETHODCALLTYPE *GetMuteDebugOutput )( 
+            ID3D12InfoQueue * This);
+        
+        END_INTERFACE
+    } ID3D12InfoQueueVtbl;
+
+    interface ID3D12InfoQueue
+    {
+        CONST_VTBL struct ID3D12InfoQueueVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D12InfoQueue_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D12InfoQueue_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D12InfoQueue_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D12InfoQueue_SetMessageCountLimit(This,MessageCountLimit) \
+    ( (This)->lpVtbl -> SetMessageCountLimit(This,MessageCountLimit) ) 
+
+#define ID3D12InfoQueue_ClearStoredMessages(This)  \
+    ( (This)->lpVtbl -> ClearStoredMessages(This) ) 
+
+#define ID3D12InfoQueue_GetMessage(This,MessageIndex,pMessage,pMessageByteLength)  \
+    ( (This)->lpVtbl -> GetMessage(This,MessageIndex,pMessage,pMessageByteLength) ) 
+
+#define ID3D12InfoQueue_GetNumMessagesAllowedByStorageFilter(This) \
+    ( (This)->lpVtbl -> GetNumMessagesAllowedByStorageFilter(This) ) 
+
+#define ID3D12InfoQueue_GetNumMessagesDeniedByStorageFilter(This)  \
+    ( (This)->lpVtbl -> GetNumMessagesDeniedByStorageFilter(This) ) 
+
+#define ID3D12InfoQueue_GetNumStoredMessages(This) \
+    ( (This)->lpVtbl -> GetNumStoredMessages(This) ) 
+
+#define ID3D12InfoQueue_GetNumStoredMessagesAllowedByRetrievalFilter(This) \
+    ( (This)->lpVtbl -> GetNumStoredMessagesAllowedByRetrievalFilter(This) ) 
+
+#define ID3D12InfoQueue_GetNumMessagesDiscardedByMessageCountLimit(This) \
+    ( (This)->lpVtbl -> GetNumMessagesDiscardedByMessageCountLimit(This) ) 
+
+#define ID3D12InfoQueue_GetMessageCountLimit(This) \
+    ( (This)->lpVtbl -> GetMessageCountLimit(This) ) 
+
+#define ID3D12InfoQueue_AddStorageFilterEntries(This,pFilter)  \
+    ( (This)->lpVtbl -> AddStorageFilterEntries(This,pFilter) ) 
+
+#define ID3D12InfoQueue_GetStorageFilter(This,pFilter,pFilterByteLength) \
+    ( (This)->lpVtbl -> GetStorageFilter(This,pFilter,pFilterByteLength) ) 
+
+#define ID3D12InfoQueue_ClearStorageFilter(This) \
+    ( (This)->lpVtbl -> ClearStorageFilter(This) ) 
+
+#define ID3D12InfoQueue_PushEmptyStorageFilter(This) \
+    ( (This)->lpVtbl -> PushEmptyStorageFilter(This) ) 
+
+#define ID3D12InfoQueue_PushCopyOfStorageFilter(This)  \
+    ( (This)->lpVtbl -> PushCopyOfStorageFilter(This) ) 
+
+#define ID3D12InfoQueue_PushStorageFilter(This,pFilter)  \
+    ( (This)->lpVtbl -> PushStorageFilter(This,pFilter) ) 
+
+#define ID3D12InfoQueue_PopStorageFilter(This) \
+    ( (This)->lpVtbl -> PopStorageFilter(This) ) 
+
+#define ID3D12InfoQueue_GetStorageFilterStackSize(This)  \
+    ( (This)->lpVtbl -> GetStorageFilterStackSize(This) ) 
+
+#define ID3D12InfoQueue_AddRetrievalFilterEntries(This,pFilter)  \
+    ( (This)->lpVtbl -> AddRetrievalFilterEntries(This,pFilter) ) 
+
+#define ID3D12InfoQueue_GetRetrievalFilter(This,pFilter,pFilterByteLength) \
+    ( (This)->lpVtbl -> GetRetrievalFilter(This,pFilter,pFilterByteLength) ) 
+
+#define ID3D12InfoQueue_ClearRetrievalFilter(This) \
+    ( (This)->lpVtbl -> ClearRetrievalFilter(This) ) 
+
+#define ID3D12InfoQueue_PushEmptyRetrievalFilter(This) \
+    ( (This)->lpVtbl -> PushEmptyRetrievalFilter(This) ) 
+
+#define ID3D12InfoQueue_PushCopyOfRetrievalFilter(This)  \
+    ( (This)->lpVtbl -> PushCopyOfRetrievalFilter(This) ) 
+
+#define ID3D12InfoQueue_PushRetrievalFilter(This,pFilter)  \
+    ( (This)->lpVtbl -> PushRetrievalFilter(This,pFilter) ) 
+
+#define ID3D12InfoQueue_PopRetrievalFilter(This) \
+    ( (This)->lpVtbl -> PopRetrievalFilter(This) ) 
+
+#define ID3D12InfoQueue_GetRetrievalFilterStackSize(This)  \
+    ( (This)->lpVtbl -> GetRetrievalFilterStackSize(This) ) 
+
+#define ID3D12InfoQueue_AddMessage(This,Category,Severity,ID,pDescription) \
+    ( (This)->lpVtbl -> AddMessage(This,Category,Severity,ID,pDescription) ) 
+
+#define ID3D12InfoQueue_AddApplicationMessage(This,Severity,pDescription)  \
+    ( (This)->lpVtbl -> AddApplicationMessage(This,Severity,pDescription) ) 
+
+#define ID3D12InfoQueue_SetBreakOnCategory(This,Category,bEnable)  \
+    ( (This)->lpVtbl -> SetBreakOnCategory(This,Category,bEnable) ) 
+
+#define ID3D12InfoQueue_SetBreakOnSeverity(This,Severity,bEnable)  \
+    ( (This)->lpVtbl -> SetBreakOnSeverity(This,Severity,bEnable) ) 
+
+#define ID3D12InfoQueue_SetBreakOnID(This,ID,bEnable)  \
+    ( (This)->lpVtbl -> SetBreakOnID(This,ID,bEnable) ) 
+
+#define ID3D12InfoQueue_GetBreakOnCategory(This,Category)  \
+    ( (This)->lpVtbl -> GetBreakOnCategory(This,Category) ) 
+
+#define ID3D12InfoQueue_GetBreakOnSeverity(This,Severity)  \
+    ( (This)->lpVtbl -> GetBreakOnSeverity(This,Severity) ) 
+
+#define ID3D12InfoQueue_GetBreakOnID(This,ID)  \
+    ( (This)->lpVtbl -> GetBreakOnID(This,ID) ) 
+
+#define ID3D12InfoQueue_SetMuteDebugOutput(This,bMute) \
+    ( (This)->lpVtbl -> SetMuteDebugOutput(This,bMute) ) 
+
+#define ID3D12InfoQueue_GetMuteDebugOutput(This) \
+    ( (This)->lpVtbl -> GetMuteDebugOutput(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D12InfoQueue_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3d12sdklayers_0000_0013 */
+/* [local] */ 
+
+#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_GAMES) */
+#pragma endregion
+DEFINE_GUID(IID_ID3D12Debug,0x344488b7,0x6846,0x474b,0xb9,0x89,0xf0,0x27,0x44,0x82,0x45,0xe0);
+DEFINE_GUID(IID_ID3D12Debug1,0xaffaa4ca,0x63fe,0x4d8e,0xb8,0xad,0x15,0x90,0x00,0xaf,0x43,0x04);
+DEFINE_GUID(IID_ID3D12Debug2,0x93a665c4,0xa3b2,0x4e5d,0xb6,0x92,0xa2,0x6a,0xe1,0x4e,0x33,0x74);
+DEFINE_GUID(IID_ID3D12Debug3,0x5cf4e58f,0xf671,0x4ff1,0xa5,0x42,0x36,0x86,0xe3,0xd1,0x53,0xd1);
+DEFINE_GUID(IID_ID3D12DebugDevice1,0xa9b71770,0xd099,0x4a65,0xa6,0x98,0x3d,0xee,0x10,0x02,0x0f,0x88);
+DEFINE_GUID(IID_ID3D12DebugDevice,0x3febd6dd,0x4973,0x4787,0x81,0x94,0xe4,0x5f,0x9e,0x28,0x92,0x3e);
+DEFINE_GUID(IID_ID3D12DebugDevice2,0x60eccbc1,0x378d,0x4df1,0x89,0x4c,0xf8,0xac,0x5c,0xe4,0xd7,0xdd);
+DEFINE_GUID(IID_ID3D12DebugCommandQueue,0x09e0bf36,0x54ac,0x484f,0x88,0x47,0x4b,0xae,0xea,0xb6,0x05,0x3a);
+DEFINE_GUID(IID_ID3D12DebugCommandList1,0x102ca951,0x311b,0x4b01,0xb1,0x1f,0xec,0xb8,0x3e,0x06,0x1b,0x37);
+DEFINE_GUID(IID_ID3D12DebugCommandList,0x09e0bf36,0x54ac,0x484f,0x88,0x47,0x4b,0xae,0xea,0xb6,0x05,0x3f);
+DEFINE_GUID(IID_ID3D12DebugCommandList2,0xaeb575cf,0x4e06,0x48be,0xba,0x3b,0xc4,0x50,0xfc,0x96,0x65,0x2e);
+DEFINE_GUID(IID_ID3D12SharingContract,0x0adf7d52,0x929c,0x4e61,0xad,0xdb,0xff,0xed,0x30,0xde,0x66,0xef);
+DEFINE_GUID(IID_ID3D12InfoQueue,0x0742a90b,0xc387,0x483f,0xb9,0x46,0x30,0xa7,0xe4,0xe6,0x14,0x58);
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0013_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3d12sdklayers_0000_0013_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/pc/gfx/dxsdk/d3d12shader.h b/src/pc/gfx/dxsdk/d3d12shader.h
new file mode 100644
index 0000000..fbeb763
--- /dev/null
+++ b/src/pc/gfx/dxsdk/d3d12shader.h
@@ -0,0 +1,459 @@
+//////////////////////////////////////////////////////////////////////////////
+//
+//  Copyright (c) Microsoft Corporation.  All rights reserved.
+//
+//  File:       D3D12Shader.h
+//  Content:    D3D12 Shader Types and APIs
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#ifndef __D3D12SHADER_H__
+#define __D3D12SHADER_H__
+
+#include "d3dcommon.h"
+
+typedef enum D3D12_SHADER_VERSION_TYPE
+{
+    D3D12_SHVER_PIXEL_SHADER    = 0,
+    D3D12_SHVER_VERTEX_SHADER   = 1,
+    D3D12_SHVER_GEOMETRY_SHADER = 2,
+    
+    // D3D11 Shaders
+    D3D12_SHVER_HULL_SHADER     = 3,
+    D3D12_SHVER_DOMAIN_SHADER   = 4,
+    D3D12_SHVER_COMPUTE_SHADER  = 5,
+
+    D3D12_SHVER_RESERVED0       = 0xFFF0,
+} D3D12_SHADER_VERSION_TYPE;
+
+#define D3D12_SHVER_GET_TYPE(_Version) \
+    (((_Version) >> 16) & 0xffff)
+#define D3D12_SHVER_GET_MAJOR(_Version) \
+    (((_Version) >> 4) & 0xf)
+#define D3D12_SHVER_GET_MINOR(_Version) \
+    (((_Version) >> 0) & 0xf)
+
+// Slot ID for library function return
+#define D3D_RETURN_PARAMETER_INDEX (-1)
+
+typedef D3D_RESOURCE_RETURN_TYPE D3D12_RESOURCE_RETURN_TYPE;
+
+typedef D3D_CBUFFER_TYPE D3D12_CBUFFER_TYPE;
+
+
+typedef struct _D3D12_SIGNATURE_PARAMETER_DESC
+{
+    LPCSTR                      SemanticName;   // Name of the semantic
+    UINT                        SemanticIndex;  // Index of the semantic
+    UINT                        Register;       // Number of member variables
+    D3D_NAME                    SystemValueType;// A predefined system value, or D3D_NAME_UNDEFINED if not applicable
+    D3D_REGISTER_COMPONENT_TYPE ComponentType;  // Scalar type (e.g. uint, float, etc.)
+    BYTE                        Mask;           // Mask to indicate which components of the register
+                                                // are used (combination of D3D10_COMPONENT_MASK values)
+    BYTE                        ReadWriteMask;  // Mask to indicate whether a given component is 
+                                                // never written (if this is an output signature) or
+                                                // always read (if this is an input signature).
+                                                // (combination of D3D_MASK_* values)
+    UINT                        Stream;         // Stream index
+    D3D_MIN_PRECISION           MinPrecision;   // Minimum desired interpolation precision
+} D3D12_SIGNATURE_PARAMETER_DESC;
+
+typedef struct _D3D12_SHADER_BUFFER_DESC
+{
+    LPCSTR                  Name;           // Name of the constant buffer
+    D3D_CBUFFER_TYPE        Type;           // Indicates type of buffer content
+    UINT                    Variables;      // Number of member variables
+    UINT                    Size;           // Size of CB (in bytes)
+    UINT                    uFlags;         // Buffer description flags
+} D3D12_SHADER_BUFFER_DESC;
+
+typedef struct _D3D12_SHADER_VARIABLE_DESC
+{
+    LPCSTR                  Name;           // Name of the variable
+    UINT                    StartOffset;    // Offset in constant buffer's backing store
+    UINT                    Size;           // Size of variable (in bytes)
+    UINT                    uFlags;         // Variable flags
+    LPVOID                  DefaultValue;   // Raw pointer to default value
+    UINT                    StartTexture;   // First texture index (or -1 if no textures used)
+    UINT                    TextureSize;    // Number of texture slots possibly used.
+    UINT                    StartSampler;   // First sampler index (or -1 if no textures used)
+    UINT                    SamplerSize;    // Number of sampler slots possibly used.
+} D3D12_SHADER_VARIABLE_DESC;
+
+typedef struct _D3D12_SHADER_TYPE_DESC
+{
+    D3D_SHADER_VARIABLE_CLASS   Class;          // Variable class (e.g. object, matrix, etc.)
+    D3D_SHADER_VARIABLE_TYPE    Type;           // Variable type (e.g. float, sampler, etc.)
+    UINT                        Rows;           // Number of rows (for matrices, 1 for other numeric, 0 if not applicable)
+    UINT                        Columns;        // Number of columns (for vectors & matrices, 1 for other numeric, 0 if not applicable)
+    UINT                        Elements;       // Number of elements (0 if not an array)
+    UINT                        Members;        // Number of members (0 if not a structure)
+    UINT                        Offset;         // Offset from the start of structure (0 if not a structure member)
+    LPCSTR                      Name;           // Name of type, can be NULL
+} D3D12_SHADER_TYPE_DESC;
+
+typedef D3D_TESSELLATOR_DOMAIN D3D12_TESSELLATOR_DOMAIN;
+
+typedef D3D_TESSELLATOR_PARTITIONING D3D12_TESSELLATOR_PARTITIONING;
+
+typedef D3D_TESSELLATOR_OUTPUT_PRIMITIVE D3D12_TESSELLATOR_OUTPUT_PRIMITIVE;
+
+typedef struct _D3D12_SHADER_DESC
+{
+    UINT                    Version;                     // Shader version
+    LPCSTR                  Creator;                     // Creator string
+    UINT                    Flags;                       // Shader compilation/parse flags
+    
+    UINT                    ConstantBuffers;             // Number of constant buffers
+    UINT                    BoundResources;              // Number of bound resources
+    UINT                    InputParameters;             // Number of parameters in the input signature
+    UINT                    OutputParameters;            // Number of parameters in the output signature
+
+    UINT                    InstructionCount;            // Number of emitted instructions
+    UINT                    TempRegisterCount;           // Number of temporary registers used 
+    UINT                    TempArrayCount;              // Number of temporary arrays used
+    UINT                    DefCount;                    // Number of constant defines 
+    UINT                    DclCount;                    // Number of declarations (input + output)
+    UINT                    TextureNormalInstructions;   // Number of non-categorized texture instructions
+    UINT                    TextureLoadInstructions;     // Number of texture load instructions
+    UINT                    TextureCompInstructions;     // Number of texture comparison instructions
+    UINT                    TextureBiasInstructions;     // Number of texture bias instructions
+    UINT                    TextureGradientInstructions; // Number of texture gradient instructions
+    UINT                    FloatInstructionCount;       // Number of floating point arithmetic instructions used
+    UINT                    IntInstructionCount;         // Number of signed integer arithmetic instructions used
+    UINT                    UintInstructionCount;        // Number of unsigned integer arithmetic instructions used
+    UINT                    StaticFlowControlCount;      // Number of static flow control instructions used
+    UINT                    DynamicFlowControlCount;     // Number of dynamic flow control instructions used
+    UINT                    MacroInstructionCount;       // Number of macro instructions used
+    UINT                    ArrayInstructionCount;       // Number of array instructions used
+    UINT                    CutInstructionCount;         // Number of cut instructions used
+    UINT                    EmitInstructionCount;        // Number of emit instructions used
+    D3D_PRIMITIVE_TOPOLOGY  GSOutputTopology;            // Geometry shader output topology
+    UINT                    GSMaxOutputVertexCount;      // Geometry shader maximum output vertex count
+    D3D_PRIMITIVE           InputPrimitive;              // GS/HS input primitive
+    UINT                    PatchConstantParameters;     // Number of parameters in the patch constant signature
+    UINT                    cGSInstanceCount;            // Number of Geometry shader instances
+    UINT                    cControlPoints;              // Number of control points in the HS->DS stage
+    D3D_TESSELLATOR_OUTPUT_PRIMITIVE HSOutputPrimitive;  // Primitive output by the tessellator
+    D3D_TESSELLATOR_PARTITIONING HSPartitioning;         // Partitioning mode of the tessellator
+    D3D_TESSELLATOR_DOMAIN  TessellatorDomain;           // Domain of the tessellator (quad, tri, isoline)
+    // instruction counts
+    UINT cBarrierInstructions;                           // Number of barrier instructions in a compute shader
+    UINT cInterlockedInstructions;                       // Number of interlocked instructions
+    UINT cTextureStoreInstructions;                      // Number of texture writes
+} D3D12_SHADER_DESC;
+
+typedef struct _D3D12_SHADER_INPUT_BIND_DESC
+{
+    LPCSTR                      Name;           // Name of the resource
+    D3D_SHADER_INPUT_TYPE       Type;           // Type of resource (e.g. texture, cbuffer, etc.)
+    UINT                        BindPoint;      // Starting bind point
+    UINT                        BindCount;      // Number of contiguous bind points (for arrays)
+
+    UINT                        uFlags;         // Input binding flags
+    D3D_RESOURCE_RETURN_TYPE    ReturnType;     // Return type (if texture)
+    D3D_SRV_DIMENSION           Dimension;      // Dimension (if texture)
+    UINT                        NumSamples;     // Number of samples (0 if not MS texture)
+    UINT                        Space;          // Register space
+    UINT uID;                                   // Range ID in the bytecode
+} D3D12_SHADER_INPUT_BIND_DESC;
+
+#define D3D_SHADER_REQUIRES_DOUBLES                                                         0x00000001
+#define D3D_SHADER_REQUIRES_EARLY_DEPTH_STENCIL                                             0x00000002
+#define D3D_SHADER_REQUIRES_UAVS_AT_EVERY_STAGE                                             0x00000004
+#define D3D_SHADER_REQUIRES_64_UAVS                                                         0x00000008
+#define D3D_SHADER_REQUIRES_MINIMUM_PRECISION                                               0x00000010
+#define D3D_SHADER_REQUIRES_11_1_DOUBLE_EXTENSIONS                                          0x00000020
+#define D3D_SHADER_REQUIRES_11_1_SHADER_EXTENSIONS                                          0x00000040
+#define D3D_SHADER_REQUIRES_LEVEL_9_COMPARISON_FILTERING                                    0x00000080
+#define D3D_SHADER_REQUIRES_TILED_RESOURCES                                                 0x00000100
+#define D3D_SHADER_REQUIRES_STENCIL_REF                                                     0x00000200
+#define D3D_SHADER_REQUIRES_INNER_COVERAGE                                                  0x00000400
+#define D3D_SHADER_REQUIRES_TYPED_UAV_LOAD_ADDITIONAL_FORMATS                               0x00000800
+#define D3D_SHADER_REQUIRES_ROVS                                                            0x00001000
+#define D3D_SHADER_REQUIRES_VIEWPORT_AND_RT_ARRAY_INDEX_FROM_ANY_SHADER_FEEDING_RASTERIZER  0x00002000
+
+
+typedef struct _D3D12_LIBRARY_DESC
+{
+    LPCSTR    Creator;           // The name of the originator of the library.
+    UINT      Flags;             // Compilation flags.
+    UINT      FunctionCount;     // Number of functions exported from the library.
+} D3D12_LIBRARY_DESC;
+
+typedef struct _D3D12_FUNCTION_DESC
+{
+    UINT                    Version;                     // Shader version
+    LPCSTR                  Creator;                     // Creator string
+    UINT                    Flags;                       // Shader compilation/parse flags
+    
+    UINT                    ConstantBuffers;             // Number of constant buffers
+    UINT                    BoundResources;              // Number of bound resources
+
+    UINT                    InstructionCount;            // Number of emitted instructions
+    UINT                    TempRegisterCount;           // Number of temporary registers used 
+    UINT                    TempArrayCount;              // Number of temporary arrays used
+    UINT                    DefCount;                    // Number of constant defines 
+    UINT                    DclCount;                    // Number of declarations (input + output)
+    UINT                    TextureNormalInstructions;   // Number of non-categorized texture instructions
+    UINT                    TextureLoadInstructions;     // Number of texture load instructions
+    UINT                    TextureCompInstructions;     // Number of texture comparison instructions
+    UINT                    TextureBiasInstructions;     // Number of texture bias instructions
+    UINT                    TextureGradientInstructions; // Number of texture gradient instructions
+    UINT                    FloatInstructionCount;       // Number of floating point arithmetic instructions used
+    UINT                    IntInstructionCount;         // Number of signed integer arithmetic instructions used
+    UINT                    UintInstructionCount;        // Number of unsigned integer arithmetic instructions used
+    UINT                    StaticFlowControlCount;      // Number of static flow control instructions used
+    UINT                    DynamicFlowControlCount;     // Number of dynamic flow control instructions used
+    UINT                    MacroInstructionCount;       // Number of macro instructions used
+    UINT                    ArrayInstructionCount;       // Number of array instructions used
+    UINT                    MovInstructionCount;         // Number of mov instructions used
+    UINT                    MovcInstructionCount;        // Number of movc instructions used
+    UINT                    ConversionInstructionCount;  // Number of type conversion instructions used
+    UINT                    BitwiseInstructionCount;     // Number of bitwise arithmetic instructions used
+    D3D_FEATURE_LEVEL       MinFeatureLevel;             // Min target of the function byte code
+    UINT64                  RequiredFeatureFlags;        // Required feature flags
+
+    LPCSTR                  Name;                        // Function name
+    INT                     FunctionParameterCount;      // Number of logical parameters in the function signature (not including return)
+    BOOL                    HasReturn;                   // TRUE, if function returns a value, false - it is a subroutine
+    BOOL                    Has10Level9VertexShader;     // TRUE, if there is a 10L9 VS blob
+    BOOL                    Has10Level9PixelShader;      // TRUE, if there is a 10L9 PS blob
+} D3D12_FUNCTION_DESC;
+
+typedef struct _D3D12_PARAMETER_DESC
+{
+    LPCSTR                      Name;               // Parameter name.
+    LPCSTR                      SemanticName;       // Parameter semantic name (+index).
+    D3D_SHADER_VARIABLE_TYPE    Type;               // Element type.
+    D3D_SHADER_VARIABLE_CLASS   Class;              // Scalar/Vector/Matrix.
+    UINT                        Rows;               // Rows are for matrix parameters.
+    UINT                        Columns;            // Components or Columns in matrix.
+    D3D_INTERPOLATION_MODE      InterpolationMode;  // Interpolation mode.
+    D3D_PARAMETER_FLAGS         Flags;              // Parameter modifiers.
+
+    UINT                        FirstInRegister;    // The first input register for this parameter.
+    UINT                        FirstInComponent;   // The first input register component for this parameter.
+    UINT                        FirstOutRegister;   // The first output register for this parameter.
+    UINT                        FirstOutComponent;  // The first output register component for this parameter.
+} D3D12_PARAMETER_DESC;
+
+
+//////////////////////////////////////////////////////////////////////////////
+// Interfaces ////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+
+typedef interface ID3D12ShaderReflectionType ID3D12ShaderReflectionType;
+typedef interface ID3D12ShaderReflectionType *LPD3D12SHADERREFLECTIONTYPE;
+
+typedef interface ID3D12ShaderReflectionVariable ID3D12ShaderReflectionVariable;
+typedef interface ID3D12ShaderReflectionVariable *LPD3D12SHADERREFLECTIONVARIABLE;
+
+typedef interface ID3D12ShaderReflectionConstantBuffer ID3D12ShaderReflectionConstantBuffer;
+typedef interface ID3D12ShaderReflectionConstantBuffer *LPD3D12SHADERREFLECTIONCONSTANTBUFFER;
+
+typedef interface ID3D12ShaderReflection ID3D12ShaderReflection;
+typedef interface ID3D12ShaderReflection *LPD3D12SHADERREFLECTION;
+
+typedef interface ID3D12LibraryReflection ID3D12LibraryReflection;
+typedef interface ID3D12LibraryReflection *LPD3D12LIBRARYREFLECTION;
+
+typedef interface ID3D12FunctionReflection ID3D12FunctionReflection;
+typedef interface ID3D12FunctionReflection *LPD3D12FUNCTIONREFLECTION;
+
+typedef interface ID3D12FunctionParameterReflection ID3D12FunctionParameterReflection;
+typedef interface ID3D12FunctionParameterReflection *LPD3D12FUNCTIONPARAMETERREFLECTION;
+
+
+// {E913C351-783D-48CA-A1D1-4F306284AD56}
+interface DECLSPEC_UUID("E913C351-783D-48CA-A1D1-4F306284AD56") ID3D12ShaderReflectionType;
+DEFINE_GUID(IID_ID3D12ShaderReflectionType, 
+0xe913c351, 0x783d, 0x48ca, 0xa1, 0xd1, 0x4f, 0x30, 0x62, 0x84, 0xad, 0x56);
+
+#undef INTERFACE
+#define INTERFACE ID3D12ShaderReflectionType
+
+DECLARE_INTERFACE(ID3D12ShaderReflectionType)
+{
+    STDMETHOD(GetDesc)(THIS_ _Out_ D3D12_SHADER_TYPE_DESC *pDesc) PURE;
+    
+    STDMETHOD_(ID3D12ShaderReflectionType*, GetMemberTypeByIndex)(THIS_ _In_ UINT Index) PURE;
+    STDMETHOD_(ID3D12ShaderReflectionType*, GetMemberTypeByName)(THIS_ _In_ LPCSTR Name) PURE;
+    STDMETHOD_(LPCSTR, GetMemberTypeName)(THIS_ _In_ UINT Index) PURE;
+
+    STDMETHOD(IsEqual)(THIS_ _In_ ID3D12ShaderReflectionType* pType) PURE;
+    STDMETHOD_(ID3D12ShaderReflectionType*, GetSubType)(THIS) PURE;
+    STDMETHOD_(ID3D12ShaderReflectionType*, GetBaseClass)(THIS) PURE;
+    STDMETHOD_(UINT, GetNumInterfaces)(THIS) PURE;
+    STDMETHOD_(ID3D12ShaderReflectionType*, GetInterfaceByIndex)(THIS_ _In_ UINT uIndex) PURE;
+    STDMETHOD(IsOfType)(THIS_ _In_ ID3D12ShaderReflectionType* pType) PURE;
+    STDMETHOD(ImplementsInterface)(THIS_ _In_ ID3D12ShaderReflectionType* pBase) PURE;
+};
+
+// {8337A8A6-A216-444A-B2F4-314733A73AEA}
+interface DECLSPEC_UUID("8337A8A6-A216-444A-B2F4-314733A73AEA") ID3D12ShaderReflectionVariable;
+DEFINE_GUID(IID_ID3D12ShaderReflectionVariable, 
+0x8337a8a6, 0xa216, 0x444a, 0xb2, 0xf4, 0x31, 0x47, 0x33, 0xa7, 0x3a, 0xea);
+
+#undef INTERFACE
+#define INTERFACE ID3D12ShaderReflectionVariable
+
+DECLARE_INTERFACE(ID3D12ShaderReflectionVariable)
+{
+    STDMETHOD(GetDesc)(THIS_ _Out_ D3D12_SHADER_VARIABLE_DESC *pDesc) PURE;
+    
+    STDMETHOD_(ID3D12ShaderReflectionType*, GetType)(THIS) PURE;
+    STDMETHOD_(ID3D12ShaderReflectionConstantBuffer*, GetBuffer)(THIS) PURE;
+
+    STDMETHOD_(UINT, GetInterfaceSlot)(THIS_ _In_ UINT uArrayIndex) PURE;
+};
+
+// {C59598B4-48B3-4869-B9B1-B1618B14A8B7}
+interface DECLSPEC_UUID("C59598B4-48B3-4869-B9B1-B1618B14A8B7") ID3D12ShaderReflectionConstantBuffer;
+DEFINE_GUID(IID_ID3D12ShaderReflectionConstantBuffer, 
+0xc59598b4, 0x48b3, 0x4869, 0xb9, 0xb1, 0xb1, 0x61, 0x8b, 0x14, 0xa8, 0xb7);
+
+#undef INTERFACE
+#define INTERFACE ID3D12ShaderReflectionConstantBuffer
+
+DECLARE_INTERFACE(ID3D12ShaderReflectionConstantBuffer)
+{
+    STDMETHOD(GetDesc)(THIS_ D3D12_SHADER_BUFFER_DESC *pDesc) PURE;
+    
+    STDMETHOD_(ID3D12ShaderReflectionVariable*, GetVariableByIndex)(THIS_ _In_ UINT Index) PURE;
+    STDMETHOD_(ID3D12ShaderReflectionVariable*, GetVariableByName)(THIS_ _In_ LPCSTR Name) PURE;
+};
+
+// The ID3D12ShaderReflection IID may change from SDK version to SDK version
+// if the reflection API changes.  This prevents new code with the new API
+// from working with an old binary.  Recompiling with the new header
+// will pick up the new IID.
+
+// {5A58797D-A72C-478D-8BA2-EFC6B0EFE88E}
+interface DECLSPEC_UUID("5A58797D-A72C-478D-8BA2-EFC6B0EFE88E") ID3D12ShaderReflection;
+DEFINE_GUID(IID_ID3D12ShaderReflection, 
+0x5a58797d, 0xa72c, 0x478d, 0x8b, 0xa2, 0xef, 0xc6, 0xb0, 0xef, 0xe8, 0x8e);
+
+#undef INTERFACE
+#define INTERFACE ID3D12ShaderReflection
+
+DECLARE_INTERFACE_(ID3D12ShaderReflection, IUnknown)
+{
+    STDMETHOD(QueryInterface)(THIS_ _In_ REFIID iid,
+                              _Out_ LPVOID *ppv) PURE;
+    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG, Release)(THIS) PURE;
+
+    STDMETHOD(GetDesc)(THIS_ _Out_ D3D12_SHADER_DESC *pDesc) PURE;
+    
+    STDMETHOD_(ID3D12ShaderReflectionConstantBuffer*, GetConstantBufferByIndex)(THIS_ _In_ UINT Index) PURE;
+    STDMETHOD_(ID3D12ShaderReflectionConstantBuffer*, GetConstantBufferByName)(THIS_ _In_ LPCSTR Name) PURE;
+    
+    STDMETHOD(GetResourceBindingDesc)(THIS_ _In_ UINT ResourceIndex,
+                                      _Out_ D3D12_SHADER_INPUT_BIND_DESC *pDesc) PURE;
+    
+    STDMETHOD(GetInputParameterDesc)(THIS_ _In_ UINT ParameterIndex,
+                                     _Out_ D3D12_SIGNATURE_PARAMETER_DESC *pDesc) PURE;
+    STDMETHOD(GetOutputParameterDesc)(THIS_ _In_ UINT ParameterIndex,
+                                      _Out_ D3D12_SIGNATURE_PARAMETER_DESC *pDesc) PURE;
+    STDMETHOD(GetPatchConstantParameterDesc)(THIS_ _In_ UINT ParameterIndex,
+                                             _Out_ D3D12_SIGNATURE_PARAMETER_DESC *pDesc) PURE;
+
+    STDMETHOD_(ID3D12ShaderReflectionVariable*, GetVariableByName)(THIS_ _In_ LPCSTR Name) PURE;
+
+    STDMETHOD(GetResourceBindingDescByName)(THIS_ _In_ LPCSTR Name,
+                                            _Out_ D3D12_SHADER_INPUT_BIND_DESC *pDesc) PURE;
+
+    STDMETHOD_(UINT, GetMovInstructionCount)(THIS) PURE;
+    STDMETHOD_(UINT, GetMovcInstructionCount)(THIS) PURE;
+    STDMETHOD_(UINT, GetConversionInstructionCount)(THIS) PURE;
+    STDMETHOD_(UINT, GetBitwiseInstructionCount)(THIS) PURE;
+    
+    STDMETHOD_(D3D_PRIMITIVE, GetGSInputPrimitive)(THIS) PURE;
+    STDMETHOD_(BOOL, IsSampleFrequencyShader)(THIS) PURE;
+
+    STDMETHOD_(UINT, GetNumInterfaceSlots)(THIS) PURE;
+    STDMETHOD(GetMinFeatureLevel)(THIS_ _Out_ enum D3D_FEATURE_LEVEL* pLevel) PURE;
+
+    STDMETHOD_(UINT, GetThreadGroupSize)(THIS_
+                                         _Out_opt_ UINT* pSizeX,
+                                         _Out_opt_ UINT* pSizeY,
+                                         _Out_opt_ UINT* pSizeZ) PURE;
+
+    STDMETHOD_(UINT64, GetRequiresFlags)(THIS) PURE;
+};
+
+// {8E349D19-54DB-4A56-9DC9-119D87BDB804}
+interface DECLSPEC_UUID("8E349D19-54DB-4A56-9DC9-119D87BDB804") ID3D12LibraryReflection;
+DEFINE_GUID(IID_ID3D12LibraryReflection, 
+0x8e349d19, 0x54db, 0x4a56, 0x9d, 0xc9, 0x11, 0x9d, 0x87, 0xbd, 0xb8, 0x4);
+
+#undef INTERFACE
+#define INTERFACE ID3D12LibraryReflection
+
+DECLARE_INTERFACE_(ID3D12LibraryReflection, IUnknown)
+{
+    STDMETHOD(QueryInterface)(THIS_ _In_ REFIID iid, _Out_ LPVOID * ppv) PURE;
+    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG, Release)(THIS) PURE;
+
+    STDMETHOD(GetDesc)(THIS_ _Out_ D3D12_LIBRARY_DESC * pDesc) PURE;
+    
+    STDMETHOD_(ID3D12FunctionReflection *, GetFunctionByIndex)(THIS_ _In_ INT FunctionIndex) PURE;
+};
+
+// {1108795C-2772-4BA9-B2A8-D464DC7E2799}
+interface DECLSPEC_UUID("1108795C-2772-4BA9-B2A8-D464DC7E2799") ID3D12FunctionReflection;
+DEFINE_GUID(IID_ID3D12FunctionReflection, 
+0x1108795c, 0x2772, 0x4ba9, 0xb2, 0xa8, 0xd4, 0x64, 0xdc, 0x7e, 0x27, 0x99);
+
+#undef INTERFACE
+#define INTERFACE ID3D12FunctionReflection
+
+DECLARE_INTERFACE(ID3D12FunctionReflection)
+{
+    STDMETHOD(GetDesc)(THIS_ _Out_ D3D12_FUNCTION_DESC * pDesc) PURE;
+    
+    STDMETHOD_(ID3D12ShaderReflectionConstantBuffer *, GetConstantBufferByIndex)(THIS_ _In_ UINT BufferIndex) PURE;
+    STDMETHOD_(ID3D12ShaderReflectionConstantBuffer *, GetConstantBufferByName)(THIS_ _In_ LPCSTR Name) PURE;
+    
+    STDMETHOD(GetResourceBindingDesc)(THIS_ _In_ UINT ResourceIndex,
+                                      _Out_ D3D12_SHADER_INPUT_BIND_DESC * pDesc) PURE;
+    
+    STDMETHOD_(ID3D12ShaderReflectionVariable *, GetVariableByName)(THIS_ _In_ LPCSTR Name) PURE;
+
+    STDMETHOD(GetResourceBindingDescByName)(THIS_ _In_ LPCSTR Name,
+                                            _Out_ D3D12_SHADER_INPUT_BIND_DESC * pDesc) PURE;
+
+    // Use D3D_RETURN_PARAMETER_INDEX to get description of the return value.
+    STDMETHOD_(ID3D12FunctionParameterReflection *, GetFunctionParameter)(THIS_ _In_ INT ParameterIndex) PURE;
+};
+
+// {EC25F42D-7006-4F2B-B33E-02CC3375733F}
+interface DECLSPEC_UUID("EC25F42D-7006-4F2B-B33E-02CC3375733F") ID3D12FunctionParameterReflection;
+DEFINE_GUID(IID_ID3D12FunctionParameterReflection, 
+0xec25f42d, 0x7006, 0x4f2b, 0xb3, 0x3e, 0x2, 0xcc, 0x33, 0x75, 0x73, 0x3f);
+
+#undef INTERFACE
+#define INTERFACE ID3D12FunctionParameterReflection
+
+DECLARE_INTERFACE(ID3D12FunctionParameterReflection)
+{
+    STDMETHOD(GetDesc)(THIS_ _Out_ D3D12_PARAMETER_DESC * pDesc) PURE;
+};
+
+
+//////////////////////////////////////////////////////////////////////////////
+// APIs //////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+
+#ifdef __cplusplus
+extern "C" {
+#endif //__cplusplus
+
+#ifdef __cplusplus
+}
+#endif //__cplusplus
+    
+#endif //__D3D12SHADER_H__
+
diff --git a/src/pc/gfx/dxsdk/d3dcommon.h b/src/pc/gfx/dxsdk/d3dcommon.h
new file mode 100644
index 0000000..8f00a40
--- /dev/null
+++ b/src/pc/gfx/dxsdk/d3dcommon.h
@@ -0,0 +1,1009 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 8.01.0622 */
+/* @@MIDL_FILE_HEADING(  ) */
+
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 500
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif /* __RPCNDR_H_VERSION__ */
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __d3dcommon_h__
+#define __d3dcommon_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __ID3D10Blob_FWD_DEFINED__
+#define __ID3D10Blob_FWD_DEFINED__
+typedef interface ID3D10Blob ID3D10Blob;
+
+#endif   /* __ID3D10Blob_FWD_DEFINED__ */
+
+
+#ifndef __ID3DDestructionNotifier_FWD_DEFINED__
+#define __ID3DDestructionNotifier_FWD_DEFINED__
+typedef interface ID3DDestructionNotifier ID3DDestructionNotifier;
+
+#endif   /* __ID3DDestructionNotifier_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "oaidl.h"
+#include "ocidl.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_d3dcommon_0000_0000 */
+/* [local] */ 
+
+typedef 
+enum D3D_DRIVER_TYPE
+    {
+        D3D_DRIVER_TYPE_UNKNOWN  = 0,
+        D3D_DRIVER_TYPE_HARDWARE = ( D3D_DRIVER_TYPE_UNKNOWN + 1 ) ,
+        D3D_DRIVER_TYPE_REFERENCE  = ( D3D_DRIVER_TYPE_HARDWARE + 1 ) ,
+        D3D_DRIVER_TYPE_NULL = ( D3D_DRIVER_TYPE_REFERENCE + 1 ) ,
+        D3D_DRIVER_TYPE_SOFTWARE = ( D3D_DRIVER_TYPE_NULL + 1 ) ,
+        D3D_DRIVER_TYPE_WARP = ( D3D_DRIVER_TYPE_SOFTWARE + 1 ) 
+    }  D3D_DRIVER_TYPE;
+
+typedef 
+enum D3D_FEATURE_LEVEL
+    {
+        D3D_FEATURE_LEVEL_1_0_CORE = 0x1000,
+        D3D_FEATURE_LEVEL_9_1  = 0x9100,
+        D3D_FEATURE_LEVEL_9_2  = 0x9200,
+        D3D_FEATURE_LEVEL_9_3  = 0x9300,
+        D3D_FEATURE_LEVEL_10_0 = 0xa000,
+        D3D_FEATURE_LEVEL_10_1 = 0xa100,
+        D3D_FEATURE_LEVEL_11_0 = 0xb000,
+        D3D_FEATURE_LEVEL_11_1 = 0xb100,
+        D3D_FEATURE_LEVEL_12_0 = 0xc000,
+        D3D_FEATURE_LEVEL_12_1 = 0xc100
+    }  D3D_FEATURE_LEVEL;
+
+#define D3D_FL9_1_REQ_TEXTURE1D_U_DIMENSION          2048
+#define D3D_FL9_3_REQ_TEXTURE1D_U_DIMENSION          4096
+#define D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION     2048
+#define D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION     4096
+#define D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION          512
+#define D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION          4096
+#define D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION   256
+#define D3D_FL9_1_DEFAULT_MAX_ANISOTROPY             2
+#define D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT             65535
+#define D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT             1048575
+#define D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT   1
+#define D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT   4
+#define D3D_FL9_1_MAX_TEXTURE_REPEAT                 128
+#define D3D_FL9_2_MAX_TEXTURE_REPEAT                 2048
+#define D3D_FL9_3_MAX_TEXTURE_REPEAT                 8192
+typedef 
+enum D3D_PRIMITIVE_TOPOLOGY
+    {
+        D3D_PRIMITIVE_TOPOLOGY_UNDEFINED = 0,
+        D3D_PRIMITIVE_TOPOLOGY_POINTLIST = 1,
+        D3D_PRIMITIVE_TOPOLOGY_LINELIST  = 2,
+        D3D_PRIMITIVE_TOPOLOGY_LINESTRIP = 3,
+        D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST  = 4,
+        D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = 5,
+        D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ  = 10,
+        D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = 11,
+        D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ  = 12,
+        D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = 13,
+        D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST = 33,
+        D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST = 34,
+        D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST = 35,
+        D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST = 36,
+        D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST = 37,
+        D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST = 38,
+        D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST = 39,
+        D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST = 40,
+        D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST = 41,
+        D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST  = 42,
+        D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST  = 43,
+        D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST  = 44,
+        D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST  = 45,
+        D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST  = 46,
+        D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST  = 47,
+        D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST  = 48,
+        D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST  = 49,
+        D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST  = 50,
+        D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST  = 51,
+        D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST  = 52,
+        D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST  = 53,
+        D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST  = 54,
+        D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST  = 55,
+        D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST  = 56,
+        D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST  = 57,
+        D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST  = 58,
+        D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST  = 59,
+        D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST  = 60,
+        D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST  = 61,
+        D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST  = 62,
+        D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST  = 63,
+        D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST  = 64,
+        D3D10_PRIMITIVE_TOPOLOGY_UNDEFINED = D3D_PRIMITIVE_TOPOLOGY_UNDEFINED,
+        D3D10_PRIMITIVE_TOPOLOGY_POINTLIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST,
+        D3D10_PRIMITIVE_TOPOLOGY_LINELIST  = D3D_PRIMITIVE_TOPOLOGY_LINELIST,
+        D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP,
+        D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST  = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST,
+        D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP,
+        D3D10_PRIMITIVE_TOPOLOGY_LINELIST_ADJ  = D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ,
+        D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ,
+        D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ  = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ,
+        D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ,
+        D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED = D3D_PRIMITIVE_TOPOLOGY_UNDEFINED,
+        D3D11_PRIMITIVE_TOPOLOGY_POINTLIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_LINELIST  = D3D_PRIMITIVE_TOPOLOGY_LINELIST,
+        D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP,
+        D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST  = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST,
+        D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP,
+        D3D11_PRIMITIVE_TOPOLOGY_LINELIST_ADJ  = D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ,
+        D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ,
+        D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ  = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ,
+        D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ,
+        D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST,
+        D3D11_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST  = D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST
+    }  D3D_PRIMITIVE_TOPOLOGY;
+
+typedef 
+enum D3D_PRIMITIVE
+    {
+        D3D_PRIMITIVE_UNDEFINED  = 0,
+        D3D_PRIMITIVE_POINT  = 1,
+        D3D_PRIMITIVE_LINE = 2,
+        D3D_PRIMITIVE_TRIANGLE = 3,
+        D3D_PRIMITIVE_LINE_ADJ = 6,
+        D3D_PRIMITIVE_TRIANGLE_ADJ = 7,
+        D3D_PRIMITIVE_1_CONTROL_POINT_PATCH  = 8,
+        D3D_PRIMITIVE_2_CONTROL_POINT_PATCH  = 9,
+        D3D_PRIMITIVE_3_CONTROL_POINT_PATCH  = 10,
+        D3D_PRIMITIVE_4_CONTROL_POINT_PATCH  = 11,
+        D3D_PRIMITIVE_5_CONTROL_POINT_PATCH  = 12,
+        D3D_PRIMITIVE_6_CONTROL_POINT_PATCH  = 13,
+        D3D_PRIMITIVE_7_CONTROL_POINT_PATCH  = 14,
+        D3D_PRIMITIVE_8_CONTROL_POINT_PATCH  = 15,
+        D3D_PRIMITIVE_9_CONTROL_POINT_PATCH  = 16,
+        D3D_PRIMITIVE_10_CONTROL_POINT_PATCH = 17,
+        D3D_PRIMITIVE_11_CONTROL_POINT_PATCH = 18,
+        D3D_PRIMITIVE_12_CONTROL_POINT_PATCH = 19,
+        D3D_PRIMITIVE_13_CONTROL_POINT_PATCH = 20,
+        D3D_PRIMITIVE_14_CONTROL_POINT_PATCH = 21,
+        D3D_PRIMITIVE_15_CONTROL_POINT_PATCH = 22,
+        D3D_PRIMITIVE_16_CONTROL_POINT_PATCH = 23,
+        D3D_PRIMITIVE_17_CONTROL_POINT_PATCH = 24,
+        D3D_PRIMITIVE_18_CONTROL_POINT_PATCH = 25,
+        D3D_PRIMITIVE_19_CONTROL_POINT_PATCH = 26,
+        D3D_PRIMITIVE_20_CONTROL_POINT_PATCH = 27,
+        D3D_PRIMITIVE_21_CONTROL_POINT_PATCH = 28,
+        D3D_PRIMITIVE_22_CONTROL_POINT_PATCH = 29,
+        D3D_PRIMITIVE_23_CONTROL_POINT_PATCH = 30,
+        D3D_PRIMITIVE_24_CONTROL_POINT_PATCH = 31,
+        D3D_PRIMITIVE_25_CONTROL_POINT_PATCH = 32,
+        D3D_PRIMITIVE_26_CONTROL_POINT_PATCH = 33,
+        D3D_PRIMITIVE_27_CONTROL_POINT_PATCH = 34,
+        D3D_PRIMITIVE_28_CONTROL_POINT_PATCH = 35,
+        D3D_PRIMITIVE_29_CONTROL_POINT_PATCH = 36,
+        D3D_PRIMITIVE_30_CONTROL_POINT_PATCH = 37,
+        D3D_PRIMITIVE_31_CONTROL_POINT_PATCH = 38,
+        D3D_PRIMITIVE_32_CONTROL_POINT_PATCH = 39,
+        D3D10_PRIMITIVE_UNDEFINED  = D3D_PRIMITIVE_UNDEFINED,
+        D3D10_PRIMITIVE_POINT  = D3D_PRIMITIVE_POINT,
+        D3D10_PRIMITIVE_LINE = D3D_PRIMITIVE_LINE,
+        D3D10_PRIMITIVE_TRIANGLE = D3D_PRIMITIVE_TRIANGLE,
+        D3D10_PRIMITIVE_LINE_ADJ = D3D_PRIMITIVE_LINE_ADJ,
+        D3D10_PRIMITIVE_TRIANGLE_ADJ = D3D_PRIMITIVE_TRIANGLE_ADJ,
+        D3D11_PRIMITIVE_UNDEFINED  = D3D_PRIMITIVE_UNDEFINED,
+        D3D11_PRIMITIVE_POINT  = D3D_PRIMITIVE_POINT,
+        D3D11_PRIMITIVE_LINE = D3D_PRIMITIVE_LINE,
+        D3D11_PRIMITIVE_TRIANGLE = D3D_PRIMITIVE_TRIANGLE,
+        D3D11_PRIMITIVE_LINE_ADJ = D3D_PRIMITIVE_LINE_ADJ,
+        D3D11_PRIMITIVE_TRIANGLE_ADJ = D3D_PRIMITIVE_TRIANGLE_ADJ,
+        D3D11_PRIMITIVE_1_CONTROL_POINT_PATCH  = D3D_PRIMITIVE_1_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_2_CONTROL_POINT_PATCH  = D3D_PRIMITIVE_2_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_3_CONTROL_POINT_PATCH  = D3D_PRIMITIVE_3_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_4_CONTROL_POINT_PATCH  = D3D_PRIMITIVE_4_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_5_CONTROL_POINT_PATCH  = D3D_PRIMITIVE_5_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_6_CONTROL_POINT_PATCH  = D3D_PRIMITIVE_6_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_7_CONTROL_POINT_PATCH  = D3D_PRIMITIVE_7_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_8_CONTROL_POINT_PATCH  = D3D_PRIMITIVE_8_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_9_CONTROL_POINT_PATCH  = D3D_PRIMITIVE_9_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_10_CONTROL_POINT_PATCH = D3D_PRIMITIVE_10_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_11_CONTROL_POINT_PATCH = D3D_PRIMITIVE_11_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_12_CONTROL_POINT_PATCH = D3D_PRIMITIVE_12_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_13_CONTROL_POINT_PATCH = D3D_PRIMITIVE_13_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_14_CONTROL_POINT_PATCH = D3D_PRIMITIVE_14_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_15_CONTROL_POINT_PATCH = D3D_PRIMITIVE_15_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_16_CONTROL_POINT_PATCH = D3D_PRIMITIVE_16_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_17_CONTROL_POINT_PATCH = D3D_PRIMITIVE_17_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_18_CONTROL_POINT_PATCH = D3D_PRIMITIVE_18_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_19_CONTROL_POINT_PATCH = D3D_PRIMITIVE_19_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_20_CONTROL_POINT_PATCH = D3D_PRIMITIVE_20_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_21_CONTROL_POINT_PATCH = D3D_PRIMITIVE_21_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_22_CONTROL_POINT_PATCH = D3D_PRIMITIVE_22_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_23_CONTROL_POINT_PATCH = D3D_PRIMITIVE_23_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_24_CONTROL_POINT_PATCH = D3D_PRIMITIVE_24_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_25_CONTROL_POINT_PATCH = D3D_PRIMITIVE_25_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_26_CONTROL_POINT_PATCH = D3D_PRIMITIVE_26_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_27_CONTROL_POINT_PATCH = D3D_PRIMITIVE_27_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_28_CONTROL_POINT_PATCH = D3D_PRIMITIVE_28_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_29_CONTROL_POINT_PATCH = D3D_PRIMITIVE_29_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_30_CONTROL_POINT_PATCH = D3D_PRIMITIVE_30_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_31_CONTROL_POINT_PATCH = D3D_PRIMITIVE_31_CONTROL_POINT_PATCH,
+        D3D11_PRIMITIVE_32_CONTROL_POINT_PATCH = D3D_PRIMITIVE_32_CONTROL_POINT_PATCH
+    }  D3D_PRIMITIVE;
+
+typedef 
+enum D3D_SRV_DIMENSION
+    {
+        D3D_SRV_DIMENSION_UNKNOWN  = 0,
+        D3D_SRV_DIMENSION_BUFFER = 1,
+        D3D_SRV_DIMENSION_TEXTURE1D  = 2,
+        D3D_SRV_DIMENSION_TEXTURE1DARRAY = 3,
+        D3D_SRV_DIMENSION_TEXTURE2D  = 4,
+        D3D_SRV_DIMENSION_TEXTURE2DARRAY = 5,
+        D3D_SRV_DIMENSION_TEXTURE2DMS  = 6,
+        D3D_SRV_DIMENSION_TEXTURE2DMSARRAY = 7,
+        D3D_SRV_DIMENSION_TEXTURE3D  = 8,
+        D3D_SRV_DIMENSION_TEXTURECUBE  = 9,
+        D3D_SRV_DIMENSION_TEXTURECUBEARRAY = 10,
+        D3D_SRV_DIMENSION_BUFFEREX = 11,
+        D3D10_SRV_DIMENSION_UNKNOWN  = D3D_SRV_DIMENSION_UNKNOWN,
+        D3D10_SRV_DIMENSION_BUFFER = D3D_SRV_DIMENSION_BUFFER,
+        D3D10_SRV_DIMENSION_TEXTURE1D  = D3D_SRV_DIMENSION_TEXTURE1D,
+        D3D10_SRV_DIMENSION_TEXTURE1DARRAY = D3D_SRV_DIMENSION_TEXTURE1DARRAY,
+        D3D10_SRV_DIMENSION_TEXTURE2D  = D3D_SRV_DIMENSION_TEXTURE2D,
+        D3D10_SRV_DIMENSION_TEXTURE2DARRAY = D3D_SRV_DIMENSION_TEXTURE2DARRAY,
+        D3D10_SRV_DIMENSION_TEXTURE2DMS  = D3D_SRV_DIMENSION_TEXTURE2DMS,
+        D3D10_SRV_DIMENSION_TEXTURE2DMSARRAY = D3D_SRV_DIMENSION_TEXTURE2DMSARRAY,
+        D3D10_SRV_DIMENSION_TEXTURE3D  = D3D_SRV_DIMENSION_TEXTURE3D,
+        D3D10_SRV_DIMENSION_TEXTURECUBE  = D3D_SRV_DIMENSION_TEXTURECUBE,
+        D3D10_1_SRV_DIMENSION_UNKNOWN  = D3D_SRV_DIMENSION_UNKNOWN,
+        D3D10_1_SRV_DIMENSION_BUFFER = D3D_SRV_DIMENSION_BUFFER,
+        D3D10_1_SRV_DIMENSION_TEXTURE1D  = D3D_SRV_DIMENSION_TEXTURE1D,
+        D3D10_1_SRV_DIMENSION_TEXTURE1DARRAY = D3D_SRV_DIMENSION_TEXTURE1DARRAY,
+        D3D10_1_SRV_DIMENSION_TEXTURE2D  = D3D_SRV_DIMENSION_TEXTURE2D,
+        D3D10_1_SRV_DIMENSION_TEXTURE2DARRAY = D3D_SRV_DIMENSION_TEXTURE2DARRAY,
+        D3D10_1_SRV_DIMENSION_TEXTURE2DMS  = D3D_SRV_DIMENSION_TEXTURE2DMS,
+        D3D10_1_SRV_DIMENSION_TEXTURE2DMSARRAY = D3D_SRV_DIMENSION_TEXTURE2DMSARRAY,
+        D3D10_1_SRV_DIMENSION_TEXTURE3D  = D3D_SRV_DIMENSION_TEXTURE3D,
+        D3D10_1_SRV_DIMENSION_TEXTURECUBE  = D3D_SRV_DIMENSION_TEXTURECUBE,
+        D3D10_1_SRV_DIMENSION_TEXTURECUBEARRAY = D3D_SRV_DIMENSION_TEXTURECUBEARRAY,
+        D3D11_SRV_DIMENSION_UNKNOWN  = D3D_SRV_DIMENSION_UNKNOWN,
+        D3D11_SRV_DIMENSION_BUFFER = D3D_SRV_DIMENSION_BUFFER,
+        D3D11_SRV_DIMENSION_TEXTURE1D  = D3D_SRV_DIMENSION_TEXTURE1D,
+        D3D11_SRV_DIMENSION_TEXTURE1DARRAY = D3D_SRV_DIMENSION_TEXTURE1DARRAY,
+        D3D11_SRV_DIMENSION_TEXTURE2D  = D3D_SRV_DIMENSION_TEXTURE2D,
+        D3D11_SRV_DIMENSION_TEXTURE2DARRAY = D3D_SRV_DIMENSION_TEXTURE2DARRAY,
+        D3D11_SRV_DIMENSION_TEXTURE2DMS  = D3D_SRV_DIMENSION_TEXTURE2DMS,
+        D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY = D3D_SRV_DIMENSION_TEXTURE2DMSARRAY,
+        D3D11_SRV_DIMENSION_TEXTURE3D  = D3D_SRV_DIMENSION_TEXTURE3D,
+        D3D11_SRV_DIMENSION_TEXTURECUBE  = D3D_SRV_DIMENSION_TEXTURECUBE,
+        D3D11_SRV_DIMENSION_TEXTURECUBEARRAY = D3D_SRV_DIMENSION_TEXTURECUBEARRAY,
+        D3D11_SRV_DIMENSION_BUFFEREX = D3D_SRV_DIMENSION_BUFFEREX
+    }  D3D_SRV_DIMENSION;
+
+typedef struct _D3D_SHADER_MACRO
+    {
+    LPCSTR Name;
+    LPCSTR Definition;
+    }  D3D_SHADER_MACRO;
+
+typedef struct _D3D_SHADER_MACRO *LPD3D_SHADER_MACRO;
+
+DEFINE_GUID(IID_ID3D10Blob, 0x8ba5fb08, 0x5195, 0x40e2, 0xac, 0x58, 0xd, 0x98, 0x9c, 0x3a, 0x1, 0x2);
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0000_v0_0_s_ifspec;
+
+#ifndef __ID3D10Blob_INTERFACE_DEFINED__
+#define __ID3D10Blob_INTERFACE_DEFINED__
+
+/* interface ID3D10Blob */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3D10Blob;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("8BA5FB08-5195-40e2-AC58-0D989C3A0102")
+    ID3D10Blob : public IUnknown
+    {
+    public:
+        virtual LPVOID STDMETHODCALLTYPE GetBufferPointer( void) = 0;
+        
+        virtual SIZE_T STDMETHODCALLTYPE GetBufferSize( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3D10BlobVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3D10Blob * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3D10Blob * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3D10Blob * This);
+        
+        LPVOID ( STDMETHODCALLTYPE *GetBufferPointer )( 
+            ID3D10Blob * This);
+        
+        SIZE_T ( STDMETHODCALLTYPE *GetBufferSize )( 
+            ID3D10Blob * This);
+        
+        END_INTERFACE
+    } ID3D10BlobVtbl;
+
+    interface ID3D10Blob
+    {
+        CONST_VTBL struct ID3D10BlobVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3D10Blob_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3D10Blob_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3D10Blob_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3D10Blob_GetBufferPointer(This)  \
+    ( (This)->lpVtbl -> GetBufferPointer(This) ) 
+
+#define ID3D10Blob_GetBufferSize(This) \
+    ( (This)->lpVtbl -> GetBufferSize(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3D10Blob_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3dcommon_0000_0001 */
+/* [local] */ 
+
+typedef interface ID3D10Blob* LPD3D10BLOB;
+typedef ID3D10Blob ID3DBlob;
+
+typedef ID3DBlob* LPD3DBLOB;
+#define IID_ID3DBlob IID_ID3D10Blob
+typedef void ( __stdcall *PFN_DESTRUCTION_CALLBACK )( 
+    void *pData);
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0001_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0001_v0_0_s_ifspec;
+
+#ifndef __ID3DDestructionNotifier_INTERFACE_DEFINED__
+#define __ID3DDestructionNotifier_INTERFACE_DEFINED__
+
+/* interface ID3DDestructionNotifier */
+/* [unique][local][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ID3DDestructionNotifier;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("a06eb39a-50da-425b-8c31-4eecd6c270f3")
+    ID3DDestructionNotifier : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE RegisterDestructionCallback( 
+            /* [annotation] */ 
+            _In_  PFN_DESTRUCTION_CALLBACK callbackFn,
+            /* [annotation] */ 
+            _In_  void *pData,
+            /* [annotation] */ 
+            _Out_  UINT *pCallbackID) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE UnregisterDestructionCallback( 
+            /* [annotation] */ 
+            _In_  UINT callbackID) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct ID3DDestructionNotifierVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ID3DDestructionNotifier * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ID3DDestructionNotifier * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ID3DDestructionNotifier * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *RegisterDestructionCallback )( 
+            ID3DDestructionNotifier * This,
+            /* [annotation] */ 
+            _In_  PFN_DESTRUCTION_CALLBACK callbackFn,
+            /* [annotation] */ 
+            _In_  void *pData,
+            /* [annotation] */ 
+            _Out_  UINT *pCallbackID);
+        
+        HRESULT ( STDMETHODCALLTYPE *UnregisterDestructionCallback )( 
+            ID3DDestructionNotifier * This,
+            /* [annotation] */ 
+            _In_  UINT callbackID);
+        
+        END_INTERFACE
+    } ID3DDestructionNotifierVtbl;
+
+    interface ID3DDestructionNotifier
+    {
+        CONST_VTBL struct ID3DDestructionNotifierVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ID3DDestructionNotifier_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ID3DDestructionNotifier_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ID3DDestructionNotifier_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ID3DDestructionNotifier_RegisterDestructionCallback(This,callbackFn,pData,pCallbackID) \
+    ( (This)->lpVtbl -> RegisterDestructionCallback(This,callbackFn,pData,pCallbackID) ) 
+
+#define ID3DDestructionNotifier_UnregisterDestructionCallback(This,callbackID) \
+    ( (This)->lpVtbl -> UnregisterDestructionCallback(This,callbackID) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __ID3DDestructionNotifier_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_d3dcommon_0000_0002 */
+/* [local] */ 
+
+typedef 
+enum _D3D_INCLUDE_TYPE
+    {
+        D3D_INCLUDE_LOCAL  = 0,
+        D3D_INCLUDE_SYSTEM = ( D3D_INCLUDE_LOCAL + 1 ) ,
+        D3D10_INCLUDE_LOCAL  = D3D_INCLUDE_LOCAL,
+        D3D10_INCLUDE_SYSTEM = D3D_INCLUDE_SYSTEM,
+        D3D_INCLUDE_FORCE_DWORD  = 0x7fffffff
+    }  D3D_INCLUDE_TYPE;
+
+typedef interface ID3DInclude ID3DInclude;
+#undef INTERFACE
+#define INTERFACE ID3DInclude
+DECLARE_INTERFACE(ID3DInclude)
+{
+    STDMETHOD(Open)(THIS_ D3D_INCLUDE_TYPE IncludeType, LPCSTR pFileName, LPCVOID pParentData, LPCVOID *ppData, UINT *pBytes) PURE;
+    STDMETHOD(Close)(THIS_ LPCVOID pData) PURE;
+};
+typedef ID3DInclude* LPD3DINCLUDE;
+typedef 
+enum _D3D_SHADER_VARIABLE_CLASS
+    {
+        D3D_SVC_SCALAR = 0,
+        D3D_SVC_VECTOR = ( D3D_SVC_SCALAR + 1 ) ,
+        D3D_SVC_MATRIX_ROWS  = ( D3D_SVC_VECTOR + 1 ) ,
+        D3D_SVC_MATRIX_COLUMNS = ( D3D_SVC_MATRIX_ROWS + 1 ) ,
+        D3D_SVC_OBJECT = ( D3D_SVC_MATRIX_COLUMNS + 1 ) ,
+        D3D_SVC_STRUCT = ( D3D_SVC_OBJECT + 1 ) ,
+        D3D_SVC_INTERFACE_CLASS  = ( D3D_SVC_STRUCT + 1 ) ,
+        D3D_SVC_INTERFACE_POINTER  = ( D3D_SVC_INTERFACE_CLASS + 1 ) ,
+        D3D10_SVC_SCALAR = D3D_SVC_SCALAR,
+        D3D10_SVC_VECTOR = D3D_SVC_VECTOR,
+        D3D10_SVC_MATRIX_ROWS  = D3D_SVC_MATRIX_ROWS,
+        D3D10_SVC_MATRIX_COLUMNS = D3D_SVC_MATRIX_COLUMNS,
+        D3D10_SVC_OBJECT = D3D_SVC_OBJECT,
+        D3D10_SVC_STRUCT = D3D_SVC_STRUCT,
+        D3D11_SVC_INTERFACE_CLASS  = D3D_SVC_INTERFACE_CLASS,
+        D3D11_SVC_INTERFACE_POINTER  = D3D_SVC_INTERFACE_POINTER,
+        D3D_SVC_FORCE_DWORD  = 0x7fffffff
+    }  D3D_SHADER_VARIABLE_CLASS;
+
+typedef 
+enum _D3D_SHADER_VARIABLE_FLAGS
+    {
+        D3D_SVF_USERPACKED = 1,
+        D3D_SVF_USED = 2,
+        D3D_SVF_INTERFACE_POINTER  = 4,
+        D3D_SVF_INTERFACE_PARAMETER  = 8,
+        D3D10_SVF_USERPACKED = D3D_SVF_USERPACKED,
+        D3D10_SVF_USED = D3D_SVF_USED,
+        D3D11_SVF_INTERFACE_POINTER  = D3D_SVF_INTERFACE_POINTER,
+        D3D11_SVF_INTERFACE_PARAMETER  = D3D_SVF_INTERFACE_PARAMETER,
+        D3D_SVF_FORCE_DWORD  = 0x7fffffff
+    }  D3D_SHADER_VARIABLE_FLAGS;
+
+typedef 
+enum _D3D_SHADER_VARIABLE_TYPE
+    {
+        D3D_SVT_VOID = 0,
+        D3D_SVT_BOOL = 1,
+        D3D_SVT_INT  = 2,
+        D3D_SVT_FLOAT  = 3,
+        D3D_SVT_STRING = 4,
+        D3D_SVT_TEXTURE  = 5,
+        D3D_SVT_TEXTURE1D  = 6,
+        D3D_SVT_TEXTURE2D  = 7,
+        D3D_SVT_TEXTURE3D  = 8,
+        D3D_SVT_TEXTURECUBE  = 9,
+        D3D_SVT_SAMPLER  = 10,
+        D3D_SVT_SAMPLER1D  = 11,
+        D3D_SVT_SAMPLER2D  = 12,
+        D3D_SVT_SAMPLER3D  = 13,
+        D3D_SVT_SAMPLERCUBE  = 14,
+        D3D_SVT_PIXELSHADER  = 15,
+        D3D_SVT_VERTEXSHADER = 16,
+        D3D_SVT_PIXELFRAGMENT  = 17,
+        D3D_SVT_VERTEXFRAGMENT = 18,
+        D3D_SVT_UINT = 19,
+        D3D_SVT_UINT8  = 20,
+        D3D_SVT_GEOMETRYSHADER = 21,
+        D3D_SVT_RASTERIZER = 22,
+        D3D_SVT_DEPTHSTENCIL = 23,
+        D3D_SVT_BLEND  = 24,
+        D3D_SVT_BUFFER = 25,
+        D3D_SVT_CBUFFER  = 26,
+        D3D_SVT_TBUFFER  = 27,
+        D3D_SVT_TEXTURE1DARRAY = 28,
+        D3D_SVT_TEXTURE2DARRAY = 29,
+        D3D_SVT_RENDERTARGETVIEW = 30,
+        D3D_SVT_DEPTHSTENCILVIEW = 31,
+        D3D_SVT_TEXTURE2DMS  = 32,
+        D3D_SVT_TEXTURE2DMSARRAY = 33,
+        D3D_SVT_TEXTURECUBEARRAY = 34,
+        D3D_SVT_HULLSHADER = 35,
+        D3D_SVT_DOMAINSHADER = 36,
+        D3D_SVT_INTERFACE_POINTER  = 37,
+        D3D_SVT_COMPUTESHADER  = 38,
+        D3D_SVT_DOUBLE = 39,
+        D3D_SVT_RWTEXTURE1D  = 40,
+        D3D_SVT_RWTEXTURE1DARRAY = 41,
+        D3D_SVT_RWTEXTURE2D  = 42,
+        D3D_SVT_RWTEXTURE2DARRAY = 43,
+        D3D_SVT_RWTEXTURE3D  = 44,
+        D3D_SVT_RWBUFFER = 45,
+        D3D_SVT_BYTEADDRESS_BUFFER = 46,
+        D3D_SVT_RWBYTEADDRESS_BUFFER = 47,
+        D3D_SVT_STRUCTURED_BUFFER  = 48,
+        D3D_SVT_RWSTRUCTURED_BUFFER  = 49,
+        D3D_SVT_APPEND_STRUCTURED_BUFFER = 50,
+        D3D_SVT_CONSUME_STRUCTURED_BUFFER  = 51,
+        D3D_SVT_MIN8FLOAT  = 52,
+        D3D_SVT_MIN10FLOAT = 53,
+        D3D_SVT_MIN16FLOAT = 54,
+        D3D_SVT_MIN12INT = 55,
+        D3D_SVT_MIN16INT = 56,
+        D3D_SVT_MIN16UINT  = 57,
+        D3D10_SVT_VOID = D3D_SVT_VOID,
+        D3D10_SVT_BOOL = D3D_SVT_BOOL,
+        D3D10_SVT_INT  = D3D_SVT_INT,
+        D3D10_SVT_FLOAT  = D3D_SVT_FLOAT,
+        D3D10_SVT_STRING = D3D_SVT_STRING,
+        D3D10_SVT_TEXTURE  = D3D_SVT_TEXTURE,
+        D3D10_SVT_TEXTURE1D  = D3D_SVT_TEXTURE1D,
+        D3D10_SVT_TEXTURE2D  = D3D_SVT_TEXTURE2D,
+        D3D10_SVT_TEXTURE3D  = D3D_SVT_TEXTURE3D,
+        D3D10_SVT_TEXTURECUBE  = D3D_SVT_TEXTURECUBE,
+        D3D10_SVT_SAMPLER  = D3D_SVT_SAMPLER,
+        D3D10_SVT_SAMPLER1D  = D3D_SVT_SAMPLER1D,
+        D3D10_SVT_SAMPLER2D  = D3D_SVT_SAMPLER2D,
+        D3D10_SVT_SAMPLER3D  = D3D_SVT_SAMPLER3D,
+        D3D10_SVT_SAMPLERCUBE  = D3D_SVT_SAMPLERCUBE,
+        D3D10_SVT_PIXELSHADER  = D3D_SVT_PIXELSHADER,
+        D3D10_SVT_VERTEXSHADER = D3D_SVT_VERTEXSHADER,
+        D3D10_SVT_PIXELFRAGMENT  = D3D_SVT_PIXELFRAGMENT,
+        D3D10_SVT_VERTEXFRAGMENT = D3D_SVT_VERTEXFRAGMENT,
+        D3D10_SVT_UINT = D3D_SVT_UINT,
+        D3D10_SVT_UINT8  = D3D_SVT_UINT8,
+        D3D10_SVT_GEOMETRYSHADER = D3D_SVT_GEOMETRYSHADER,
+        D3D10_SVT_RASTERIZER = D3D_SVT_RASTERIZER,
+        D3D10_SVT_DEPTHSTENCIL = D3D_SVT_DEPTHSTENCIL,
+        D3D10_SVT_BLEND  = D3D_SVT_BLEND,
+        D3D10_SVT_BUFFER = D3D_SVT_BUFFER,
+        D3D10_SVT_CBUFFER  = D3D_SVT_CBUFFER,
+        D3D10_SVT_TBUFFER  = D3D_SVT_TBUFFER,
+        D3D10_SVT_TEXTURE1DARRAY = D3D_SVT_TEXTURE1DARRAY,
+        D3D10_SVT_TEXTURE2DARRAY = D3D_SVT_TEXTURE2DARRAY,
+        D3D10_SVT_RENDERTARGETVIEW = D3D_SVT_RENDERTARGETVIEW,
+        D3D10_SVT_DEPTHSTENCILVIEW = D3D_SVT_DEPTHSTENCILVIEW,
+        D3D10_SVT_TEXTURE2DMS  = D3D_SVT_TEXTURE2DMS,
+        D3D10_SVT_TEXTURE2DMSARRAY = D3D_SVT_TEXTURE2DMSARRAY,
+        D3D10_SVT_TEXTURECUBEARRAY = D3D_SVT_TEXTURECUBEARRAY,
+        D3D11_SVT_HULLSHADER = D3D_SVT_HULLSHADER,
+        D3D11_SVT_DOMAINSHADER = D3D_SVT_DOMAINSHADER,
+        D3D11_SVT_INTERFACE_POINTER  = D3D_SVT_INTERFACE_POINTER,
+        D3D11_SVT_COMPUTESHADER  = D3D_SVT_COMPUTESHADER,
+        D3D11_SVT_DOUBLE = D3D_SVT_DOUBLE,
+        D3D11_SVT_RWTEXTURE1D  = D3D_SVT_RWTEXTURE1D,
+        D3D11_SVT_RWTEXTURE1DARRAY = D3D_SVT_RWTEXTURE1DARRAY,
+        D3D11_SVT_RWTEXTURE2D  = D3D_SVT_RWTEXTURE2D,
+        D3D11_SVT_RWTEXTURE2DARRAY = D3D_SVT_RWTEXTURE2DARRAY,
+        D3D11_SVT_RWTEXTURE3D  = D3D_SVT_RWTEXTURE3D,
+        D3D11_SVT_RWBUFFER = D3D_SVT_RWBUFFER,
+        D3D11_SVT_BYTEADDRESS_BUFFER = D3D_SVT_BYTEADDRESS_BUFFER,
+        D3D11_SVT_RWBYTEADDRESS_BUFFER = D3D_SVT_RWBYTEADDRESS_BUFFER,
+        D3D11_SVT_STRUCTURED_BUFFER  = D3D_SVT_STRUCTURED_BUFFER,
+        D3D11_SVT_RWSTRUCTURED_BUFFER  = D3D_SVT_RWSTRUCTURED_BUFFER,
+        D3D11_SVT_APPEND_STRUCTURED_BUFFER = D3D_SVT_APPEND_STRUCTURED_BUFFER,
+        D3D11_SVT_CONSUME_STRUCTURED_BUFFER  = D3D_SVT_CONSUME_STRUCTURED_BUFFER,
+        D3D_SVT_FORCE_DWORD  = 0x7fffffff
+    }  D3D_SHADER_VARIABLE_TYPE;
+
+typedef 
+enum _D3D_SHADER_INPUT_FLAGS
+    {
+        D3D_SIF_USERPACKED = 0x1,
+        D3D_SIF_COMPARISON_SAMPLER = 0x2,
+        D3D_SIF_TEXTURE_COMPONENT_0  = 0x4,
+        D3D_SIF_TEXTURE_COMPONENT_1  = 0x8,
+        D3D_SIF_TEXTURE_COMPONENTS = 0xc,
+        D3D_SIF_UNUSED = 0x10,
+        D3D10_SIF_USERPACKED = D3D_SIF_USERPACKED,
+        D3D10_SIF_COMPARISON_SAMPLER = D3D_SIF_COMPARISON_SAMPLER,
+        D3D10_SIF_TEXTURE_COMPONENT_0  = D3D_SIF_TEXTURE_COMPONENT_0,
+        D3D10_SIF_TEXTURE_COMPONENT_1  = D3D_SIF_TEXTURE_COMPONENT_1,
+        D3D10_SIF_TEXTURE_COMPONENTS = D3D_SIF_TEXTURE_COMPONENTS,
+        D3D_SIF_FORCE_DWORD  = 0x7fffffff
+    }  D3D_SHADER_INPUT_FLAGS;
+
+typedef 
+enum _D3D_SHADER_INPUT_TYPE
+    {
+        D3D_SIT_CBUFFER  = 0,
+        D3D_SIT_TBUFFER  = ( D3D_SIT_CBUFFER + 1 ) ,
+        D3D_SIT_TEXTURE  = ( D3D_SIT_TBUFFER + 1 ) ,
+        D3D_SIT_SAMPLER  = ( D3D_SIT_TEXTURE + 1 ) ,
+        D3D_SIT_UAV_RWTYPED  = ( D3D_SIT_SAMPLER + 1 ) ,
+        D3D_SIT_STRUCTURED = ( D3D_SIT_UAV_RWTYPED + 1 ) ,
+        D3D_SIT_UAV_RWSTRUCTURED = ( D3D_SIT_STRUCTURED + 1 ) ,
+        D3D_SIT_BYTEADDRESS  = ( D3D_SIT_UAV_RWSTRUCTURED + 1 ) ,
+        D3D_SIT_UAV_RWBYTEADDRESS  = ( D3D_SIT_BYTEADDRESS + 1 ) ,
+        D3D_SIT_UAV_APPEND_STRUCTURED  = ( D3D_SIT_UAV_RWBYTEADDRESS + 1 ) ,
+        D3D_SIT_UAV_CONSUME_STRUCTURED = ( D3D_SIT_UAV_APPEND_STRUCTURED + 1 ) ,
+        D3D_SIT_UAV_RWSTRUCTURED_WITH_COUNTER  = ( D3D_SIT_UAV_CONSUME_STRUCTURED + 1 ) ,
+        D3D10_SIT_CBUFFER  = D3D_SIT_CBUFFER,
+        D3D10_SIT_TBUFFER  = D3D_SIT_TBUFFER,
+        D3D10_SIT_TEXTURE  = D3D_SIT_TEXTURE,
+        D3D10_SIT_SAMPLER  = D3D_SIT_SAMPLER,
+        D3D11_SIT_UAV_RWTYPED  = D3D_SIT_UAV_RWTYPED,
+        D3D11_SIT_STRUCTURED = D3D_SIT_STRUCTURED,
+        D3D11_SIT_UAV_RWSTRUCTURED = D3D_SIT_UAV_RWSTRUCTURED,
+        D3D11_SIT_BYTEADDRESS  = D3D_SIT_BYTEADDRESS,
+        D3D11_SIT_UAV_RWBYTEADDRESS  = D3D_SIT_UAV_RWBYTEADDRESS,
+        D3D11_SIT_UAV_APPEND_STRUCTURED  = D3D_SIT_UAV_APPEND_STRUCTURED,
+        D3D11_SIT_UAV_CONSUME_STRUCTURED = D3D_SIT_UAV_CONSUME_STRUCTURED,
+        D3D11_SIT_UAV_RWSTRUCTURED_WITH_COUNTER  = D3D_SIT_UAV_RWSTRUCTURED_WITH_COUNTER
+    }  D3D_SHADER_INPUT_TYPE;
+
+typedef 
+enum _D3D_SHADER_CBUFFER_FLAGS
+    {
+        D3D_CBF_USERPACKED = 1,
+        D3D10_CBF_USERPACKED = D3D_CBF_USERPACKED,
+        D3D_CBF_FORCE_DWORD  = 0x7fffffff
+    }  D3D_SHADER_CBUFFER_FLAGS;
+
+typedef 
+enum _D3D_CBUFFER_TYPE
+    {
+        D3D_CT_CBUFFER = 0,
+        D3D_CT_TBUFFER = ( D3D_CT_CBUFFER + 1 ) ,
+        D3D_CT_INTERFACE_POINTERS  = ( D3D_CT_TBUFFER + 1 ) ,
+        D3D_CT_RESOURCE_BIND_INFO  = ( D3D_CT_INTERFACE_POINTERS + 1 ) ,
+        D3D10_CT_CBUFFER = D3D_CT_CBUFFER,
+        D3D10_CT_TBUFFER = D3D_CT_TBUFFER,
+        D3D11_CT_CBUFFER = D3D_CT_CBUFFER,
+        D3D11_CT_TBUFFER = D3D_CT_TBUFFER,
+        D3D11_CT_INTERFACE_POINTERS  = D3D_CT_INTERFACE_POINTERS,
+        D3D11_CT_RESOURCE_BIND_INFO  = D3D_CT_RESOURCE_BIND_INFO
+    }  D3D_CBUFFER_TYPE;
+
+typedef 
+enum D3D_NAME
+    {
+        D3D_NAME_UNDEFINED = 0,
+        D3D_NAME_POSITION  = 1,
+        D3D_NAME_CLIP_DISTANCE = 2,
+        D3D_NAME_CULL_DISTANCE = 3,
+        D3D_NAME_RENDER_TARGET_ARRAY_INDEX = 4,
+        D3D_NAME_VIEWPORT_ARRAY_INDEX  = 5,
+        D3D_NAME_VERTEX_ID = 6,
+        D3D_NAME_PRIMITIVE_ID  = 7,
+        D3D_NAME_INSTANCE_ID = 8,
+        D3D_NAME_IS_FRONT_FACE = 9,
+        D3D_NAME_SAMPLE_INDEX  = 10,
+        D3D_NAME_FINAL_QUAD_EDGE_TESSFACTOR  = 11,
+        D3D_NAME_FINAL_QUAD_INSIDE_TESSFACTOR  = 12,
+        D3D_NAME_FINAL_TRI_EDGE_TESSFACTOR = 13,
+        D3D_NAME_FINAL_TRI_INSIDE_TESSFACTOR = 14,
+        D3D_NAME_FINAL_LINE_DETAIL_TESSFACTOR  = 15,
+        D3D_NAME_FINAL_LINE_DENSITY_TESSFACTOR = 16,
+        D3D_NAME_BARYCENTRICS  = 23,
+        D3D_NAME_SHADINGRATE = 24,
+        D3D_NAME_TARGET  = 64,
+        D3D_NAME_DEPTH = 65,
+        D3D_NAME_COVERAGE  = 66,
+        D3D_NAME_DEPTH_GREATER_EQUAL = 67,
+        D3D_NAME_DEPTH_LESS_EQUAL  = 68,
+        D3D_NAME_STENCIL_REF = 69,
+        D3D_NAME_INNER_COVERAGE  = 70,
+        D3D10_NAME_UNDEFINED = D3D_NAME_UNDEFINED,
+        D3D10_NAME_POSITION  = D3D_NAME_POSITION,
+        D3D10_NAME_CLIP_DISTANCE = D3D_NAME_CLIP_DISTANCE,
+        D3D10_NAME_CULL_DISTANCE = D3D_NAME_CULL_DISTANCE,
+        D3D10_NAME_RENDER_TARGET_ARRAY_INDEX = D3D_NAME_RENDER_TARGET_ARRAY_INDEX,
+        D3D10_NAME_VIEWPORT_ARRAY_INDEX  = D3D_NAME_VIEWPORT_ARRAY_INDEX,
+        D3D10_NAME_VERTEX_ID = D3D_NAME_VERTEX_ID,
+        D3D10_NAME_PRIMITIVE_ID  = D3D_NAME_PRIMITIVE_ID,
+        D3D10_NAME_INSTANCE_ID = D3D_NAME_INSTANCE_ID,
+        D3D10_NAME_IS_FRONT_FACE = D3D_NAME_IS_FRONT_FACE,
+        D3D10_NAME_SAMPLE_INDEX  = D3D_NAME_SAMPLE_INDEX,
+        D3D10_NAME_TARGET  = D3D_NAME_TARGET,
+        D3D10_NAME_DEPTH = D3D_NAME_DEPTH,
+        D3D10_NAME_COVERAGE  = D3D_NAME_COVERAGE,
+        D3D11_NAME_FINAL_QUAD_EDGE_TESSFACTOR  = D3D_NAME_FINAL_QUAD_EDGE_TESSFACTOR,
+        D3D11_NAME_FINAL_QUAD_INSIDE_TESSFACTOR  = D3D_NAME_FINAL_QUAD_INSIDE_TESSFACTOR,
+        D3D11_NAME_FINAL_TRI_EDGE_TESSFACTOR = D3D_NAME_FINAL_TRI_EDGE_TESSFACTOR,
+        D3D11_NAME_FINAL_TRI_INSIDE_TESSFACTOR = D3D_NAME_FINAL_TRI_INSIDE_TESSFACTOR,
+        D3D11_NAME_FINAL_LINE_DETAIL_TESSFACTOR  = D3D_NAME_FINAL_LINE_DETAIL_TESSFACTOR,
+        D3D11_NAME_FINAL_LINE_DENSITY_TESSFACTOR = D3D_NAME_FINAL_LINE_DENSITY_TESSFACTOR,
+        D3D11_NAME_DEPTH_GREATER_EQUAL = D3D_NAME_DEPTH_GREATER_EQUAL,
+        D3D11_NAME_DEPTH_LESS_EQUAL  = D3D_NAME_DEPTH_LESS_EQUAL,
+        D3D11_NAME_STENCIL_REF = D3D_NAME_STENCIL_REF,
+        D3D11_NAME_INNER_COVERAGE  = D3D_NAME_INNER_COVERAGE,
+        D3D12_NAME_BARYCENTRICS  = D3D_NAME_BARYCENTRICS,
+        D3D12_NAME_SHADINGRATE = D3D_NAME_SHADINGRATE
+    }  D3D_NAME;
+
+typedef 
+enum D3D_RESOURCE_RETURN_TYPE
+    {
+        D3D_RETURN_TYPE_UNORM  = 1,
+        D3D_RETURN_TYPE_SNORM  = 2,
+        D3D_RETURN_TYPE_SINT = 3,
+        D3D_RETURN_TYPE_UINT = 4,
+        D3D_RETURN_TYPE_FLOAT  = 5,
+        D3D_RETURN_TYPE_MIXED  = 6,
+        D3D_RETURN_TYPE_DOUBLE = 7,
+        D3D_RETURN_TYPE_CONTINUED  = 8,
+        D3D10_RETURN_TYPE_UNORM  = D3D_RETURN_TYPE_UNORM,
+        D3D10_RETURN_TYPE_SNORM  = D3D_RETURN_TYPE_SNORM,
+        D3D10_RETURN_TYPE_SINT = D3D_RETURN_TYPE_SINT,
+        D3D10_RETURN_TYPE_UINT = D3D_RETURN_TYPE_UINT,
+        D3D10_RETURN_TYPE_FLOAT  = D3D_RETURN_TYPE_FLOAT,
+        D3D10_RETURN_TYPE_MIXED  = D3D_RETURN_TYPE_MIXED,
+        D3D11_RETURN_TYPE_UNORM  = D3D_RETURN_TYPE_UNORM,
+        D3D11_RETURN_TYPE_SNORM  = D3D_RETURN_TYPE_SNORM,
+        D3D11_RETURN_TYPE_SINT = D3D_RETURN_TYPE_SINT,
+        D3D11_RETURN_TYPE_UINT = D3D_RETURN_TYPE_UINT,
+        D3D11_RETURN_TYPE_FLOAT  = D3D_RETURN_TYPE_FLOAT,
+        D3D11_RETURN_TYPE_MIXED  = D3D_RETURN_TYPE_MIXED,
+        D3D11_RETURN_TYPE_DOUBLE = D3D_RETURN_TYPE_DOUBLE,
+        D3D11_RETURN_TYPE_CONTINUED  = D3D_RETURN_TYPE_CONTINUED
+    }  D3D_RESOURCE_RETURN_TYPE;
+
+typedef 
+enum D3D_REGISTER_COMPONENT_TYPE
+    {
+        D3D_REGISTER_COMPONENT_UNKNOWN = 0,
+        D3D_REGISTER_COMPONENT_UINT32  = 1,
+        D3D_REGISTER_COMPONENT_SINT32  = 2,
+        D3D_REGISTER_COMPONENT_FLOAT32 = 3,
+        D3D10_REGISTER_COMPONENT_UNKNOWN = D3D_REGISTER_COMPONENT_UNKNOWN,
+        D3D10_REGISTER_COMPONENT_UINT32  = D3D_REGISTER_COMPONENT_UINT32,
+        D3D10_REGISTER_COMPONENT_SINT32  = D3D_REGISTER_COMPONENT_SINT32,
+        D3D10_REGISTER_COMPONENT_FLOAT32 = D3D_REGISTER_COMPONENT_FLOAT32
+    }  D3D_REGISTER_COMPONENT_TYPE;
+
+typedef 
+enum D3D_TESSELLATOR_DOMAIN
+    {
+        D3D_TESSELLATOR_DOMAIN_UNDEFINED = 0,
+        D3D_TESSELLATOR_DOMAIN_ISOLINE = 1,
+        D3D_TESSELLATOR_DOMAIN_TRI = 2,
+        D3D_TESSELLATOR_DOMAIN_QUAD  = 3,
+        D3D11_TESSELLATOR_DOMAIN_UNDEFINED = D3D_TESSELLATOR_DOMAIN_UNDEFINED,
+        D3D11_TESSELLATOR_DOMAIN_ISOLINE = D3D_TESSELLATOR_DOMAIN_ISOLINE,
+        D3D11_TESSELLATOR_DOMAIN_TRI = D3D_TESSELLATOR_DOMAIN_TRI,
+        D3D11_TESSELLATOR_DOMAIN_QUAD  = D3D_TESSELLATOR_DOMAIN_QUAD
+    }  D3D_TESSELLATOR_DOMAIN;
+
+typedef 
+enum D3D_TESSELLATOR_PARTITIONING
+    {
+        D3D_TESSELLATOR_PARTITIONING_UNDEFINED = 0,
+        D3D_TESSELLATOR_PARTITIONING_INTEGER = 1,
+        D3D_TESSELLATOR_PARTITIONING_POW2  = 2,
+        D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD  = 3,
+        D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN = 4,
+        D3D11_TESSELLATOR_PARTITIONING_UNDEFINED = D3D_TESSELLATOR_PARTITIONING_UNDEFINED,
+        D3D11_TESSELLATOR_PARTITIONING_INTEGER = D3D_TESSELLATOR_PARTITIONING_INTEGER,
+        D3D11_TESSELLATOR_PARTITIONING_POW2  = D3D_TESSELLATOR_PARTITIONING_POW2,
+        D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD  = D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD,
+        D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN = D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN
+    }  D3D_TESSELLATOR_PARTITIONING;
+
+typedef 
+enum D3D_TESSELLATOR_OUTPUT_PRIMITIVE
+    {
+        D3D_TESSELLATOR_OUTPUT_UNDEFINED = 0,
+        D3D_TESSELLATOR_OUTPUT_POINT = 1,
+        D3D_TESSELLATOR_OUTPUT_LINE  = 2,
+        D3D_TESSELLATOR_OUTPUT_TRIANGLE_CW = 3,
+        D3D_TESSELLATOR_OUTPUT_TRIANGLE_CCW  = 4,
+        D3D11_TESSELLATOR_OUTPUT_UNDEFINED = D3D_TESSELLATOR_OUTPUT_UNDEFINED,
+        D3D11_TESSELLATOR_OUTPUT_POINT = D3D_TESSELLATOR_OUTPUT_POINT,
+        D3D11_TESSELLATOR_OUTPUT_LINE  = D3D_TESSELLATOR_OUTPUT_LINE,
+        D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CW = D3D_TESSELLATOR_OUTPUT_TRIANGLE_CW,
+        D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CCW  = D3D_TESSELLATOR_OUTPUT_TRIANGLE_CCW
+    }  D3D_TESSELLATOR_OUTPUT_PRIMITIVE;
+
+typedef 
+enum D3D_MIN_PRECISION
+    {
+        D3D_MIN_PRECISION_DEFAULT  = 0,
+        D3D_MIN_PRECISION_FLOAT_16 = 1,
+        D3D_MIN_PRECISION_FLOAT_2_8  = 2,
+        D3D_MIN_PRECISION_RESERVED = 3,
+        D3D_MIN_PRECISION_SINT_16  = 4,
+        D3D_MIN_PRECISION_UINT_16  = 5,
+        D3D_MIN_PRECISION_ANY_16 = 0xf0,
+        D3D_MIN_PRECISION_ANY_10 = 0xf1
+    }  D3D_MIN_PRECISION;
+
+typedef 
+enum D3D_INTERPOLATION_MODE
+    {
+        D3D_INTERPOLATION_UNDEFINED  = 0,
+        D3D_INTERPOLATION_CONSTANT = 1,
+        D3D_INTERPOLATION_LINEAR = 2,
+        D3D_INTERPOLATION_LINEAR_CENTROID  = 3,
+        D3D_INTERPOLATION_LINEAR_NOPERSPECTIVE = 4,
+        D3D_INTERPOLATION_LINEAR_NOPERSPECTIVE_CENTROID  = 5,
+        D3D_INTERPOLATION_LINEAR_SAMPLE  = 6,
+        D3D_INTERPOLATION_LINEAR_NOPERSPECTIVE_SAMPLE  = 7
+    }  D3D_INTERPOLATION_MODE;
+
+typedef 
+enum _D3D_PARAMETER_FLAGS
+    {
+        D3D_PF_NONE  = 0,
+        D3D_PF_IN  = 0x1,
+        D3D_PF_OUT = 0x2,
+        D3D_PF_FORCE_DWORD = 0x7fffffff
+    }  D3D_PARAMETER_FLAGS;
+
+DEFINE_GUID(WKPDID_D3DDebugObjectName,0x429b8c22,0x9188,0x4b0c,0x87,0x42,0xac,0xb0,0xbf,0x85,0xc2,0x00);
+DEFINE_GUID(WKPDID_D3DDebugObjectNameW,0x4cca5fd8,0x921f,0x42c8,0x85,0x66,0x70,0xca,0xf2,0xa9,0xb7,0x41);
+DEFINE_GUID(WKPDID_CommentStringW,0xd0149dc0,0x90e8,0x4ec8,0x81, 0x44, 0xe9, 0x00, 0xad, 0x26, 0x6b, 0xb2);
+#define D3D_SET_OBJECT_NAME_N_A(pObject, Chars, pName) (pObject)->SetPrivateData(WKPDID_D3DDebugObjectName, Chars, pName)
+#define D3D_SET_OBJECT_NAME_A(pObject, pName) D3D_SET_OBJECT_NAME_N_A(pObject, lstrlenA(pName), pName)
+#define D3D_SET_OBJECT_NAME_N_W(pObject, Chars, pName) (pObject)->SetPrivateData(WKPDID_D3DDebugObjectNameW, Chars*2, pName)
+#define D3D_SET_OBJECT_NAME_W(pObject, pName) D3D_SET_OBJECT_NAME_N_W(pObject, wcslen(pName), pName)
+#define D3D_COMPONENT_MASK_X   1
+#define D3D_COMPONENT_MASK_Y   2
+#define D3D_COMPONENT_MASK_Z   4
+#define D3D_COMPONENT_MASK_W   8
+DEFINE_GUID(D3D_TEXTURE_LAYOUT_ROW_MAJOR,0xb5dc234f,0x72bb,0x4bec,0x97,0x05,0x8c,0xf2,0x58,0xdf,0x6b,0x6c);
+DEFINE_GUID(D3D_TEXTURE_LAYOUT_64KB_STANDARD_SWIZZLE,0x4c0f29e3,0x3f5f,0x4d35,0x84,0xc9,0xbc,0x09,0x83,0xb6,0x2c,0x28);
+
+
+extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0002_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0002_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/pc/gfx/dxsdk/d3dcompiler.h b/src/pc/gfx/dxsdk/d3dcompiler.h
new file mode 100644
index 0000000..a201668
--- /dev/null
+++ b/src/pc/gfx/dxsdk/d3dcompiler.h
@@ -0,0 +1,586 @@
+//////////////////////////////////////////////////////////////////////////////
+//
+//  Copyright (c) Microsoft Corporation.  All rights reserved.
+//
+//  File:       D3DCompiler.h
+//  Content:    D3D Compilation Types and APIs
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#ifndef __D3DCOMPILER_H__
+#define __D3DCOMPILER_H__
+
+#include <winapifamily.h>
+
+// Current name of the DLL shipped in the same SDK as this header.
+
+
+
+#define D3DCOMPILER_DLL_W L"d3dcompiler_47.dll"
+#define D3DCOMPILER_DLL_A "d3dcompiler_47.dll"
+
+// Current HLSL compiler version.
+
+#define D3D_COMPILER_VERSION 47
+
+#ifdef UNICODE
+    #define D3DCOMPILER_DLL D3DCOMPILER_DLL_W 
+#else
+    #define D3DCOMPILER_DLL D3DCOMPILER_DLL_A
+#endif
+
+#include "d3d11shader.h"
+#include "d3d12shader.h"
+
+//////////////////////////////////////////////////////////////////////////////
+// APIs //////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+
+#ifdef __cplusplus
+extern "C" {
+#endif //__cplusplus
+
+
+#pragma region Application Family
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_GAMES)
+
+//----------------------------------------------------------------------------
+// D3DReadFileToBlob:
+// -----------------
+// Simple helper routine to read a file on disk into memory
+// for passing to other routines in this API.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DReadFileToBlob(_In_ LPCWSTR pFileName,
+                  _Out_ ID3DBlob** ppContents);
+
+//----------------------------------------------------------------------------
+// D3DWriteBlobToFile:
+// ------------------
+// Simple helper routine to write a memory blob to a file on disk.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DWriteBlobToFile(_In_ ID3DBlob* pBlob,
+                   _In_ LPCWSTR pFileName,
+                   _In_ BOOL bOverwrite);
+
+//----------------------------------------------------------------------------
+// D3DCOMPILE flags:
+// -----------------
+// D3DCOMPILE_DEBUG
+//   Insert debug file/line/type/symbol information.
+//
+// D3DCOMPILE_SKIP_VALIDATION
+//   Do not validate the generated code against known capabilities and
+//   constraints.  This option is only recommended when compiling shaders
+//   you KNOW will work.  (ie. have compiled before without this option.)
+//   Shaders are always validated by D3D before they are set to the device.
+//
+// D3DCOMPILE_SKIP_OPTIMIZATION 
+//   Instructs the compiler to skip optimization steps during code generation.
+//   Unless you are trying to isolate a problem in your code using this option 
+//   is not recommended.
+//
+// D3DCOMPILE_PACK_MATRIX_ROW_MAJOR
+//   Unless explicitly specified, matrices will be packed in row-major order
+//   on input and output from the shader.
+//
+// D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR
+//   Unless explicitly specified, matrices will be packed in column-major 
+//   order on input and output from the shader.  This is generally more 
+//   efficient, since it allows vector-matrix multiplication to be performed
+//   using a series of dot-products.
+//
+// D3DCOMPILE_PARTIAL_PRECISION
+//   Force all computations in resulting shader to occur at partial precision.
+//   This may result in faster evaluation of shaders on some hardware.
+//
+// D3DCOMPILE_FORCE_VS_SOFTWARE_NO_OPT
+//   Force compiler to compile against the next highest available software
+//   target for vertex shaders.  This flag also turns optimizations off, 
+//   and debugging on.  
+//
+// D3DCOMPILE_FORCE_PS_SOFTWARE_NO_OPT
+//   Force compiler to compile against the next highest available software
+//   target for pixel shaders.  This flag also turns optimizations off, 
+//   and debugging on.
+//
+// D3DCOMPILE_NO_PRESHADER
+//   Disables Preshaders. Using this flag will cause the compiler to not 
+//   pull out static expression for evaluation on the host cpu
+//
+// D3DCOMPILE_AVOID_FLOW_CONTROL
+//   Hint compiler to avoid flow-control constructs where possible.
+//
+// D3DCOMPILE_PREFER_FLOW_CONTROL
+//   Hint compiler to prefer flow-control constructs where possible.
+//
+// D3DCOMPILE_ENABLE_STRICTNESS
+//   By default, the HLSL/Effect compilers are not strict on deprecated syntax.
+//   Specifying this flag enables the strict mode. Deprecated syntax may be
+//   removed in a future release, and enabling syntax is a good way to make
+//   sure your shaders comply to the latest spec.
+//
+// D3DCOMPILE_ENABLE_BACKWARDS_COMPATIBILITY
+//   This enables older shaders to compile to 4_0 targets.
+//
+// D3DCOMPILE_DEBUG_NAME_FOR_SOURCE
+//   This enables a debug name to be generated based on source information.
+//   It requires D3DCOMPILE_DEBUG to be set, and is exclusive with
+//   D3DCOMPILE_DEBUG_NAME_FOR_BINARY.
+//
+// D3DCOMPILE_DEBUG_NAME_FOR_BINARY
+//   This enables a debug name to be generated based on compiled information.
+//   It requires D3DCOMPILE_DEBUG to be set, and is exclusive with
+//   D3DCOMPILE_DEBUG_NAME_FOR_SOURCE.
+//
+//----------------------------------------------------------------------------
+
+#define D3DCOMPILE_DEBUG                                (1 << 0)
+#define D3DCOMPILE_SKIP_VALIDATION                      (1 << 1)
+#define D3DCOMPILE_SKIP_OPTIMIZATION                    (1 << 2)
+#define D3DCOMPILE_PACK_MATRIX_ROW_MAJOR                (1 << 3)
+#define D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR             (1 << 4)
+#define D3DCOMPILE_PARTIAL_PRECISION                    (1 << 5)
+#define D3DCOMPILE_FORCE_VS_SOFTWARE_NO_OPT             (1 << 6)
+#define D3DCOMPILE_FORCE_PS_SOFTWARE_NO_OPT             (1 << 7)
+#define D3DCOMPILE_NO_PRESHADER                         (1 << 8)
+#define D3DCOMPILE_AVOID_FLOW_CONTROL                   (1 << 9)
+#define D3DCOMPILE_PREFER_FLOW_CONTROL                  (1 << 10)
+#define D3DCOMPILE_ENABLE_STRICTNESS                    (1 << 11)
+#define D3DCOMPILE_ENABLE_BACKWARDS_COMPATIBILITY       (1 << 12)
+#define D3DCOMPILE_IEEE_STRICTNESS                      (1 << 13)
+#define D3DCOMPILE_OPTIMIZATION_LEVEL0                  (1 << 14)
+#define D3DCOMPILE_OPTIMIZATION_LEVEL1                  0
+#define D3DCOMPILE_OPTIMIZATION_LEVEL2                  ((1 << 14) | (1 << 15))
+#define D3DCOMPILE_OPTIMIZATION_LEVEL3                  (1 << 15)
+#define D3DCOMPILE_RESERVED16                           (1 << 16)
+#define D3DCOMPILE_RESERVED17                           (1 << 17)
+#define D3DCOMPILE_WARNINGS_ARE_ERRORS                  (1 << 18)
+#define D3DCOMPILE_RESOURCES_MAY_ALIAS                  (1 << 19)
+#define D3DCOMPILE_ENABLE_UNBOUNDED_DESCRIPTOR_TABLES   (1 << 20)
+#define D3DCOMPILE_ALL_RESOURCES_BOUND                  (1 << 21)
+#define D3DCOMPILE_DEBUG_NAME_FOR_SOURCE                (1 << 22)
+#define D3DCOMPILE_DEBUG_NAME_FOR_BINARY                (1 << 23)
+
+//----------------------------------------------------------------------------
+// D3DCOMPILE_EFFECT flags:
+// -------------------------------------
+// These flags are passed in when creating an effect, and affect
+// either compilation behavior or runtime effect behavior
+//
+// D3DCOMPILE_EFFECT_CHILD_EFFECT
+//   Compile this .fx file to a child effect. Child effects have no
+//   initializers for any shared values as these are initialied in the
+//   master effect (pool).
+//
+// D3DCOMPILE_EFFECT_ALLOW_SLOW_OPS
+//   By default, performance mode is enabled.  Performance mode
+//   disallows mutable state objects by preventing non-literal
+//   expressions from appearing in state object definitions.
+//   Specifying this flag will disable the mode and allow for mutable
+//   state objects.
+//
+//----------------------------------------------------------------------------
+
+#define D3DCOMPILE_EFFECT_CHILD_EFFECT              (1 << 0)
+#define D3DCOMPILE_EFFECT_ALLOW_SLOW_OPS            (1 << 1)
+
+//----------------------------------------------------------------------------
+// D3DCOMPILE Flags2:
+// -----------------
+// Root signature flags. (passed in Flags2)
+#define D3DCOMPILE_FLAGS2_FORCE_ROOT_SIGNATURE_LATEST    0
+#define D3DCOMPILE_FLAGS2_FORCE_ROOT_SIGNATURE_1_0     (1 << 4)
+#define D3DCOMPILE_FLAGS2_FORCE_ROOT_SIGNATURE_1_1     (1 << 5)
+
+//----------------------------------------------------------------------------
+// D3DCompile:
+// ----------
+// Compile source text into bytecode appropriate for the given target.
+//----------------------------------------------------------------------------
+
+// D3D_COMPILE_STANDARD_FILE_INCLUDE can be passed for pInclude in any
+// API and indicates that a simple default include handler should be
+// used.  The include handler will include files relative to the
+// current directory and files relative to the directory of the initial source
+// file.  When used with APIs like D3DCompile pSourceName must be a
+// file name and the initial relative directory will be derived from it.
+#define D3D_COMPILE_STANDARD_FILE_INCLUDE ((ID3DInclude*)(UINT_PTR)1)
+
+HRESULT WINAPI
+D3DCompile(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+           _In_ SIZE_T SrcDataSize,
+           _In_opt_ LPCSTR pSourceName,
+           _In_reads_opt_(_Inexpressible_(pDefines->Name != NULL)) CONST D3D_SHADER_MACRO* pDefines,
+           _In_opt_ ID3DInclude* pInclude,
+           _In_opt_ LPCSTR pEntrypoint,
+           _In_ LPCSTR pTarget,
+           _In_ UINT Flags1,
+           _In_ UINT Flags2,
+           _Out_ ID3DBlob** ppCode,
+           _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorMsgs);
+
+typedef HRESULT (WINAPI *pD3DCompile)
+    (LPCVOID                         pSrcData,
+     SIZE_T                          SrcDataSize,
+     LPCSTR                          pFileName,
+     CONST D3D_SHADER_MACRO*         pDefines,
+     ID3DInclude*                    pInclude,
+     LPCSTR                          pEntrypoint,
+     LPCSTR                          pTarget,
+     UINT                            Flags1,
+     UINT                            Flags2,
+     ID3DBlob**                      ppCode,
+     ID3DBlob**                      ppErrorMsgs);
+
+#define D3DCOMPILE_SECDATA_MERGE_UAV_SLOTS              0x00000001
+#define D3DCOMPILE_SECDATA_PRESERVE_TEMPLATE_SLOTS      0x00000002
+#define D3DCOMPILE_SECDATA_REQUIRE_TEMPLATE_MATCH       0x00000004
+
+HRESULT WINAPI
+D3DCompile2(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+            _In_ SIZE_T SrcDataSize,
+            _In_opt_ LPCSTR pSourceName,
+            _In_reads_opt_(_Inexpressible_(pDefines->Name != NULL)) CONST D3D_SHADER_MACRO* pDefines,
+            _In_opt_ ID3DInclude* pInclude,
+            _In_ LPCSTR pEntrypoint,
+            _In_ LPCSTR pTarget,
+            _In_ UINT Flags1,
+            _In_ UINT Flags2,
+            _In_ UINT SecondaryDataFlags,
+            _In_reads_bytes_opt_(SecondaryDataSize) LPCVOID pSecondaryData,
+            _In_ SIZE_T SecondaryDataSize,
+            _Out_ ID3DBlob** ppCode,
+            _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorMsgs);
+
+HRESULT WINAPI
+D3DCompileFromFile(_In_ LPCWSTR pFileName,
+                   _In_reads_opt_(_Inexpressible_(pDefines->Name != NULL)) CONST D3D_SHADER_MACRO* pDefines,
+                   _In_opt_ ID3DInclude* pInclude,
+                   _In_ LPCSTR pEntrypoint,
+                   _In_ LPCSTR pTarget,
+                   _In_ UINT Flags1,
+                   _In_ UINT Flags2,
+                   _Out_ ID3DBlob** ppCode,
+                   _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorMsgs);
+
+//----------------------------------------------------------------------------
+// D3DPreprocess:
+// -------------
+// Process source text with the compiler's preprocessor and return
+// the resulting text.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DPreprocess(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+              _In_ SIZE_T SrcDataSize,
+              _In_opt_ LPCSTR pSourceName,
+              _In_opt_ CONST D3D_SHADER_MACRO* pDefines,
+              _In_opt_ ID3DInclude* pInclude,
+              _Out_ ID3DBlob** ppCodeText,
+              _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorMsgs);
+
+typedef HRESULT (WINAPI *pD3DPreprocess)
+    (LPCVOID                      pSrcData,
+     SIZE_T                       SrcDataSize,
+     LPCSTR                       pFileName,
+     CONST D3D_SHADER_MACRO*      pDefines,
+     ID3DInclude*                 pInclude,
+     ID3DBlob**                   ppCodeText,
+     ID3DBlob**                   ppErrorMsgs);
+
+//----------------------------------------------------------------------------
+// D3DGetDebugInfo:
+// -----------------------
+// Gets shader debug info.  Debug info is generated by D3DCompile and is
+// embedded in the body of the shader.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DGetDebugInfo(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+                _In_ SIZE_T SrcDataSize,
+                _Out_ ID3DBlob** ppDebugInfo);
+
+//----------------------------------------------------------------------------
+// D3DReflect:
+// ----------
+// Shader code contains metadata that can be inspected via the
+// reflection APIs.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DReflect(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+           _In_ SIZE_T SrcDataSize,
+           _In_ REFIID pInterface,
+           _Out_ void** ppReflector);
+
+//----------------------------------------------------------------------------
+// D3DReflectLibrary:
+// ----------
+// Library code contains metadata that can be inspected via the library
+// reflection APIs.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DReflectLibrary(__in_bcount(SrcDataSize) LPCVOID pSrcData,
+                  __in SIZE_T SrcDataSize,
+               __in REFIID riid,
+                  __out LPVOID * ppReflector);
+
+//----------------------------------------------------------------------------
+// D3DDisassemble:
+// ----------------------
+// Takes a binary shader and returns a buffer containing text assembly.
+//----------------------------------------------------------------------------
+
+#define D3D_DISASM_ENABLE_COLOR_CODE            0x00000001
+#define D3D_DISASM_ENABLE_DEFAULT_VALUE_PRINTS  0x00000002
+#define D3D_DISASM_ENABLE_INSTRUCTION_NUMBERING 0x00000004
+#define D3D_DISASM_ENABLE_INSTRUCTION_CYCLE     0x00000008
+#define D3D_DISASM_DISABLE_DEBUG_INFO           0x00000010
+#define D3D_DISASM_ENABLE_INSTRUCTION_OFFSET    0x00000020
+#define D3D_DISASM_INSTRUCTION_ONLY             0x00000040
+#define D3D_DISASM_PRINT_HEX_LITERALS           0x00000080
+
+HRESULT WINAPI
+D3DDisassemble(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+               _In_ SIZE_T SrcDataSize,
+               _In_ UINT Flags,
+               _In_opt_ LPCSTR szComments,
+               _Out_ ID3DBlob** ppDisassembly);
+
+typedef HRESULT (WINAPI *pD3DDisassemble)
+    (_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+     _In_ SIZE_T SrcDataSize,
+     _In_ UINT Flags,
+     _In_opt_ LPCSTR szComments,
+     _Out_ ID3DBlob** ppDisassembly);
+
+HRESULT WINAPI
+D3DDisassembleRegion(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+                     _In_ SIZE_T SrcDataSize,
+                     _In_ UINT Flags,
+                     _In_opt_ LPCSTR szComments,
+                     _In_ SIZE_T StartByteOffset,
+                     _In_ SIZE_T NumInsts,
+                     _Out_opt_ SIZE_T* pFinishByteOffset,
+                     _Out_ ID3DBlob** ppDisassembly);
+    
+//----------------------------------------------------------------------------
+// Shader linking and Function Linking Graph (FLG) APIs
+//----------------------------------------------------------------------------
+HRESULT WINAPI
+D3DCreateLinker(__out interface ID3D11Linker ** ppLinker);
+
+HRESULT WINAPI
+D3DLoadModule(_In_ LPCVOID pSrcData,
+              _In_ SIZE_T cbSrcDataSize,
+              _Out_ interface ID3D11Module ** ppModule);
+
+HRESULT WINAPI
+D3DCreateFunctionLinkingGraph(_In_ UINT uFlags,
+                              _Out_ interface ID3D11FunctionLinkingGraph ** ppFunctionLinkingGraph);
+
+//----------------------------------------------------------------------------
+// D3DGetTraceInstructionOffsets:
+// -----------------------
+// Determines byte offsets for instructions within a shader blob.
+// This information is useful for going between trace instruction
+// indices and byte offsets that are used in debug information.
+//----------------------------------------------------------------------------
+
+#define D3D_GET_INST_OFFSETS_INCLUDE_NON_EXECUTABLE 0x00000001
+
+HRESULT WINAPI
+D3DGetTraceInstructionOffsets(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+                              _In_ SIZE_T SrcDataSize,
+                              _In_ UINT Flags,
+                              _In_ SIZE_T StartInstIndex,
+                              _In_ SIZE_T NumInsts,
+                              _Out_writes_to_opt_(NumInsts, min(NumInsts, *pTotalInsts)) SIZE_T* pOffsets,
+                              _Out_opt_ SIZE_T* pTotalInsts);
+
+//----------------------------------------------------------------------------
+// D3DGetInputSignatureBlob:
+// -----------------------
+// Retrieve the input signature from a compilation result.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DGetInputSignatureBlob(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+                         _In_ SIZE_T SrcDataSize,
+                         _Out_ ID3DBlob** ppSignatureBlob);
+
+//----------------------------------------------------------------------------
+// D3DGetOutputSignatureBlob:
+// -----------------------
+// Retrieve the output signature from a compilation result.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DGetOutputSignatureBlob(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+                          _In_ SIZE_T SrcDataSize,
+                          _Out_ ID3DBlob** ppSignatureBlob);
+
+//----------------------------------------------------------------------------
+// D3DGetInputAndOutputSignatureBlob:
+// -----------------------
+// Retrieve the input and output signatures from a compilation result.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DGetInputAndOutputSignatureBlob(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+                                  _In_ SIZE_T SrcDataSize,
+                                  _Out_ ID3DBlob** ppSignatureBlob);
+
+//----------------------------------------------------------------------------
+// D3DStripShader:
+// -----------------------
+// Removes unwanted blobs from a compilation result
+//----------------------------------------------------------------------------
+
+typedef enum D3DCOMPILER_STRIP_FLAGS
+{
+    D3DCOMPILER_STRIP_REFLECTION_DATA       = 0x00000001,
+    D3DCOMPILER_STRIP_DEBUG_INFO            = 0x00000002,
+    D3DCOMPILER_STRIP_TEST_BLOBS            = 0x00000004,
+    D3DCOMPILER_STRIP_PRIVATE_DATA          = 0x00000008,
+    D3DCOMPILER_STRIP_ROOT_SIGNATURE        = 0x00000010,
+    D3DCOMPILER_STRIP_FORCE_DWORD           = 0x7fffffff,
+} D3DCOMPILER_STRIP_FLAGS;
+
+HRESULT WINAPI
+D3DStripShader(_In_reads_bytes_(BytecodeLength) LPCVOID pShaderBytecode,
+               _In_ SIZE_T BytecodeLength,
+               _In_ UINT uStripFlags,
+               _Out_ ID3DBlob** ppStrippedBlob);
+
+//----------------------------------------------------------------------------
+// D3DGetBlobPart:
+// -----------------------
+// Extracts information from a compilation result.
+//----------------------------------------------------------------------------
+
+typedef enum D3D_BLOB_PART
+{
+    D3D_BLOB_INPUT_SIGNATURE_BLOB,
+    D3D_BLOB_OUTPUT_SIGNATURE_BLOB,
+    D3D_BLOB_INPUT_AND_OUTPUT_SIGNATURE_BLOB,
+    D3D_BLOB_PATCH_CONSTANT_SIGNATURE_BLOB,
+    D3D_BLOB_ALL_SIGNATURE_BLOB,
+    D3D_BLOB_DEBUG_INFO,
+    D3D_BLOB_LEGACY_SHADER,
+    D3D_BLOB_XNA_PREPASS_SHADER,
+    D3D_BLOB_XNA_SHADER,
+    D3D_BLOB_PDB,
+    D3D_BLOB_PRIVATE_DATA,
+    D3D_BLOB_ROOT_SIGNATURE,
+    D3D_BLOB_DEBUG_NAME,
+
+    // Test parts are only produced by special compiler versions and so
+    // are usually not present in shaders.
+    D3D_BLOB_TEST_ALTERNATE_SHADER = 0x8000,
+    D3D_BLOB_TEST_COMPILE_DETAILS,
+    D3D_BLOB_TEST_COMPILE_PERF,
+    D3D_BLOB_TEST_COMPILE_REPORT,
+} D3D_BLOB_PART;
+
+HRESULT WINAPI 
+D3DGetBlobPart(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+               _In_ SIZE_T SrcDataSize,
+               _In_ D3D_BLOB_PART Part,
+               _In_ UINT Flags,
+               _Out_ ID3DBlob** ppPart);
+
+//----------------------------------------------------------------------------
+// D3DSetBlobPart:
+// -----------------------
+// Update information in a compilation result.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI 
+D3DSetBlobPart(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+               _In_ SIZE_T SrcDataSize,
+               _In_ D3D_BLOB_PART Part,
+               _In_ UINT Flags,
+               _In_reads_bytes_(PartSize) LPCVOID pPart,
+               _In_ SIZE_T PartSize,
+               _Out_ ID3DBlob** ppNewShader);
+
+//----------------------------------------------------------------------------
+// D3DCreateBlob:
+// -----------------------
+// Create an ID3DBlob instance.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DCreateBlob(_In_ SIZE_T Size,
+              _Out_ ID3DBlob** ppBlob);
+
+//----------------------------------------------------------------------------
+// D3DCompressShaders:
+// -----------------------
+// Compresses a set of shaders into a more compact form.
+//----------------------------------------------------------------------------
+
+typedef struct _D3D_SHADER_DATA
+{
+    LPCVOID pBytecode;
+    SIZE_T BytecodeLength;
+} D3D_SHADER_DATA;
+
+#define D3D_COMPRESS_SHADER_KEEP_ALL_PARTS 0x00000001
+
+HRESULT WINAPI
+D3DCompressShaders(_In_ UINT uNumShaders,
+                   _In_reads_(uNumShaders) D3D_SHADER_DATA* pShaderData,
+                   _In_ UINT uFlags,
+                   _Out_ ID3DBlob** ppCompressedData);
+
+//----------------------------------------------------------------------------
+// D3DDecompressShaders:
+// -----------------------
+// Decompresses one or more shaders from a compressed set.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DDecompressShaders(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
+                     _In_ SIZE_T SrcDataSize,
+                     _In_ UINT uNumShaders,        
+                     _In_ UINT uStartIndex,
+                     _In_reads_opt_(uNumShaders) UINT* pIndices,
+                     _In_ UINT uFlags,
+                     _Out_writes_(uNumShaders) ID3DBlob** ppShaders,
+                     _Out_opt_ UINT* pTotalShaders);
+
+#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_GAMES) */
+#pragma endregion
+
+
+#pragma region Desktop Family
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+
+//----------------------------------------------------------------------------
+// D3DDisassemble10Effect:
+// -----------------------
+// Takes a D3D10 effect interface and returns a
+// buffer containing text assembly.
+//----------------------------------------------------------------------------
+
+HRESULT WINAPI
+D3DDisassemble10Effect(_In_ interface ID3D10Effect *pEffect, 
+                       _In_ UINT Flags,
+                       _Out_ ID3DBlob** ppDisassembly);
+
+#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
+#pragma endregion
+
+
+#ifdef __cplusplus
+}
+#endif //__cplusplus
+    
+#endif // #ifndef __D3DCOMPILER_H__
diff --git a/src/pc/gfx/dxsdk/d3dx12.h b/src/pc/gfx/dxsdk/d3dx12.h
new file mode 100644
index 0000000..3aafbd2
--- /dev/null
+++ b/src/pc/gfx/dxsdk/d3dx12.h
@@ -0,0 +1,3440 @@
+//*********************************************************
+//
+// Copyright (c) Microsoft. All rights reserved.
+// This code is licensed under the MIT License (MIT).
+// THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
+// ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
+// IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
+// PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
+//
+//*********************************************************
+
+#ifndef __D3DX12_H__
+#define __D3DX12_H__
+
+#include "d3d12.h"
+
+#if defined( __cplusplus )
+
+struct CD3DX12_DEFAULT {};
+extern const DECLSPEC_SELECTANY CD3DX12_DEFAULT D3D12_DEFAULT;
+
+//------------------------------------------------------------------------------------------------
+inline bool operator==( const D3D12_VIEWPORT& l, const D3D12_VIEWPORT& r )
+{
+    return l.TopLeftX == r.TopLeftX && l.TopLeftY == r.TopLeftY && l.Width == r.Width &&
+        l.Height == r.Height && l.MinDepth == r.MinDepth && l.MaxDepth == r.MaxDepth;
+}
+
+//------------------------------------------------------------------------------------------------
+inline bool operator!=( const D3D12_VIEWPORT& l, const D3D12_VIEWPORT& r )
+{ return !( l == r ); }
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_RECT : public D3D12_RECT
+{
+    CD3DX12_RECT() = default;
+    explicit CD3DX12_RECT( const D3D12_RECT& o ) :
+        D3D12_RECT( o )
+    {}
+    explicit CD3DX12_RECT(
+        LONG Left,
+        LONG Top,
+        LONG Right,
+        LONG Bottom )
+    {
+        left = Left;
+        top = Top;
+        right = Right;
+        bottom = Bottom;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_VIEWPORT : public D3D12_VIEWPORT
+{
+    CD3DX12_VIEWPORT() = default;
+    explicit CD3DX12_VIEWPORT( const D3D12_VIEWPORT& o ) :
+        D3D12_VIEWPORT( o )
+    {}
+    explicit CD3DX12_VIEWPORT(
+        FLOAT topLeftX,
+        FLOAT topLeftY,
+        FLOAT width,
+        FLOAT height,
+        FLOAT minDepth = D3D12_MIN_DEPTH,
+        FLOAT maxDepth = D3D12_MAX_DEPTH )
+    {
+        TopLeftX = topLeftX;
+        TopLeftY = topLeftY;
+        Width = width;
+        Height = height;
+        MinDepth = minDepth;
+        MaxDepth = maxDepth;
+    }
+    explicit CD3DX12_VIEWPORT(
+        _In_ ID3D12Resource* pResource,
+        UINT mipSlice = 0,
+        FLOAT topLeftX = 0.0f,
+        FLOAT topLeftY = 0.0f,
+        FLOAT minDepth = D3D12_MIN_DEPTH,
+        FLOAT maxDepth = D3D12_MAX_DEPTH )
+    {
+        auto Desc = pResource->GetDesc();
+        const UINT64 SubresourceWidth = Desc.Width >> mipSlice;
+        const UINT64 SubresourceHeight = Desc.Height >> mipSlice;
+        switch (Desc.Dimension)
+        {
+        case D3D12_RESOURCE_DIMENSION_BUFFER:
+            TopLeftX = topLeftX;
+            TopLeftY = 0.0f;
+            Width = Desc.Width - topLeftX;
+            Height = 1.0f;
+            break;
+        case D3D12_RESOURCE_DIMENSION_TEXTURE1D:
+            TopLeftX = topLeftX;
+            TopLeftY = 0.0f;
+            Width = (SubresourceWidth ? SubresourceWidth : 1.0f) - topLeftX;
+            Height = 1.0f;
+            break;
+        case D3D12_RESOURCE_DIMENSION_TEXTURE2D:
+        case D3D12_RESOURCE_DIMENSION_TEXTURE3D:
+            TopLeftX = topLeftX;
+            TopLeftY = topLeftY;
+            Width = (SubresourceWidth ? SubresourceWidth : 1.0f) - topLeftX;
+            Height = (SubresourceHeight ? SubresourceHeight: 1.0f) - topLeftY;
+            break;
+        default: break;
+        }
+
+        MinDepth = minDepth;
+        MaxDepth = maxDepth;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_BOX : public D3D12_BOX
+{
+    CD3DX12_BOX() = default;
+    explicit CD3DX12_BOX( const D3D12_BOX& o ) :
+        D3D12_BOX( o )
+    {}
+    explicit CD3DX12_BOX(
+        LONG Left,
+        LONG Right )
+    {
+        left = static_cast<UINT>(Left);
+        top = 0;
+        front = 0;
+        right = static_cast<UINT>(Right);
+        bottom = 1;
+        back = 1;
+    }
+    explicit CD3DX12_BOX(
+        LONG Left,
+        LONG Top,
+        LONG Right,
+        LONG Bottom )
+    {
+        left = static_cast<UINT>(Left);
+        top = static_cast<UINT>(Top);
+        front = 0;
+        right = static_cast<UINT>(Right);
+        bottom = static_cast<UINT>(Bottom);
+        back = 1;
+    }
+    explicit CD3DX12_BOX(
+        LONG Left,
+        LONG Top,
+        LONG Front,
+        LONG Right,
+        LONG Bottom,
+        LONG Back )
+    {
+        left = static_cast<UINT>(Left);
+        top = static_cast<UINT>(Top);
+        front = static_cast<UINT>(Front);
+        right = static_cast<UINT>(Right);
+        bottom = static_cast<UINT>(Bottom);
+        back = static_cast<UINT>(Back);
+    }
+};
+inline bool operator==( const D3D12_BOX& l, const D3D12_BOX& r )
+{
+    return l.left == r.left && l.top == r.top && l.front == r.front &&
+        l.right == r.right && l.bottom == r.bottom && l.back == r.back;
+}
+inline bool operator!=( const D3D12_BOX& l, const D3D12_BOX& r )
+{ return !( l == r ); }
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_DEPTH_STENCIL_DESC : public D3D12_DEPTH_STENCIL_DESC
+{
+    CD3DX12_DEPTH_STENCIL_DESC() = default;
+    explicit CD3DX12_DEPTH_STENCIL_DESC( const D3D12_DEPTH_STENCIL_DESC& o ) :
+        D3D12_DEPTH_STENCIL_DESC( o )
+    {}
+    explicit CD3DX12_DEPTH_STENCIL_DESC( CD3DX12_DEFAULT )
+    {
+        DepthEnable = TRUE;
+        DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
+        DepthFunc = D3D12_COMPARISON_FUNC_LESS;
+        StencilEnable = FALSE;
+        StencilReadMask = D3D12_DEFAULT_STENCIL_READ_MASK;
+        StencilWriteMask = D3D12_DEFAULT_STENCIL_WRITE_MASK;
+        const D3D12_DEPTH_STENCILOP_DESC defaultStencilOp =
+        { D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_COMPARISON_FUNC_ALWAYS };
+        FrontFace = defaultStencilOp;
+        BackFace = defaultStencilOp;
+    }
+    explicit CD3DX12_DEPTH_STENCIL_DESC(
+        BOOL depthEnable,
+        D3D12_DEPTH_WRITE_MASK depthWriteMask,
+        D3D12_COMPARISON_FUNC depthFunc,
+        BOOL stencilEnable,
+        UINT8 stencilReadMask,
+        UINT8 stencilWriteMask,
+        D3D12_STENCIL_OP frontStencilFailOp,
+        D3D12_STENCIL_OP frontStencilDepthFailOp,
+        D3D12_STENCIL_OP frontStencilPassOp,
+        D3D12_COMPARISON_FUNC frontStencilFunc,
+        D3D12_STENCIL_OP backStencilFailOp,
+        D3D12_STENCIL_OP backStencilDepthFailOp,
+        D3D12_STENCIL_OP backStencilPassOp,
+        D3D12_COMPARISON_FUNC backStencilFunc )
+    {
+        DepthEnable = depthEnable;
+        DepthWriteMask = depthWriteMask;
+        DepthFunc = depthFunc;
+        StencilEnable = stencilEnable;
+        StencilReadMask = stencilReadMask;
+        StencilWriteMask = stencilWriteMask;
+        FrontFace.StencilFailOp = frontStencilFailOp;
+        FrontFace.StencilDepthFailOp = frontStencilDepthFailOp;
+        FrontFace.StencilPassOp = frontStencilPassOp;
+        FrontFace.StencilFunc = frontStencilFunc;
+        BackFace.StencilFailOp = backStencilFailOp;
+        BackFace.StencilDepthFailOp = backStencilDepthFailOp;
+        BackFace.StencilPassOp = backStencilPassOp;
+        BackFace.StencilFunc = backStencilFunc;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_DEPTH_STENCIL_DESC1 : public D3D12_DEPTH_STENCIL_DESC1
+{
+    CD3DX12_DEPTH_STENCIL_DESC1() = default;
+    explicit CD3DX12_DEPTH_STENCIL_DESC1( const D3D12_DEPTH_STENCIL_DESC1& o ) :
+        D3D12_DEPTH_STENCIL_DESC1( o )
+    {}
+    explicit CD3DX12_DEPTH_STENCIL_DESC1( const D3D12_DEPTH_STENCIL_DESC& o )
+    {
+        DepthEnable                  = o.DepthEnable;
+        DepthWriteMask               = o.DepthWriteMask;
+        DepthFunc                    = o.DepthFunc;
+        StencilEnable                = o.StencilEnable;
+        StencilReadMask              = o.StencilReadMask;
+        StencilWriteMask             = o.StencilWriteMask;
+        FrontFace.StencilFailOp      = o.FrontFace.StencilFailOp;
+        FrontFace.StencilDepthFailOp = o.FrontFace.StencilDepthFailOp;
+        FrontFace.StencilPassOp      = o.FrontFace.StencilPassOp;
+        FrontFace.StencilFunc        = o.FrontFace.StencilFunc;
+        BackFace.StencilFailOp       = o.BackFace.StencilFailOp;
+        BackFace.StencilDepthFailOp  = o.BackFace.StencilDepthFailOp;
+        BackFace.StencilPassOp       = o.BackFace.StencilPassOp;
+        BackFace.StencilFunc         = o.BackFace.StencilFunc;
+        DepthBoundsTestEnable        = FALSE;
+    }
+    explicit CD3DX12_DEPTH_STENCIL_DESC1( CD3DX12_DEFAULT )
+    {
+        DepthEnable = TRUE;
+        DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
+        DepthFunc = D3D12_COMPARISON_FUNC_LESS;
+        StencilEnable = FALSE;
+        StencilReadMask = D3D12_DEFAULT_STENCIL_READ_MASK;
+        StencilWriteMask = D3D12_DEFAULT_STENCIL_WRITE_MASK;
+        const D3D12_DEPTH_STENCILOP_DESC defaultStencilOp =
+        { D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_COMPARISON_FUNC_ALWAYS };
+        FrontFace = defaultStencilOp;
+        BackFace = defaultStencilOp;
+        DepthBoundsTestEnable = FALSE;
+    }
+    explicit CD3DX12_DEPTH_STENCIL_DESC1(
+        BOOL depthEnable,
+        D3D12_DEPTH_WRITE_MASK depthWriteMask,
+        D3D12_COMPARISON_FUNC depthFunc,
+        BOOL stencilEnable,
+        UINT8 stencilReadMask,
+        UINT8 stencilWriteMask,
+        D3D12_STENCIL_OP frontStencilFailOp,
+        D3D12_STENCIL_OP frontStencilDepthFailOp,
+        D3D12_STENCIL_OP frontStencilPassOp,
+        D3D12_COMPARISON_FUNC frontStencilFunc,
+        D3D12_STENCIL_OP backStencilFailOp,
+        D3D12_STENCIL_OP backStencilDepthFailOp,
+        D3D12_STENCIL_OP backStencilPassOp,
+        D3D12_COMPARISON_FUNC backStencilFunc,
+        BOOL depthBoundsTestEnable )
+    {
+        DepthEnable = depthEnable;
+        DepthWriteMask = depthWriteMask;
+        DepthFunc = depthFunc;
+        StencilEnable = stencilEnable;
+        StencilReadMask = stencilReadMask;
+        StencilWriteMask = stencilWriteMask;
+        FrontFace.StencilFailOp = frontStencilFailOp;
+        FrontFace.StencilDepthFailOp = frontStencilDepthFailOp;
+        FrontFace.StencilPassOp = frontStencilPassOp;
+        FrontFace.StencilFunc = frontStencilFunc;
+        BackFace.StencilFailOp = backStencilFailOp;
+        BackFace.StencilDepthFailOp = backStencilDepthFailOp;
+        BackFace.StencilPassOp = backStencilPassOp;
+        BackFace.StencilFunc = backStencilFunc;
+        DepthBoundsTestEnable = depthBoundsTestEnable;
+    }
+    operator D3D12_DEPTH_STENCIL_DESC() const
+    {
+        D3D12_DEPTH_STENCIL_DESC D;
+        D.DepthEnable                  = DepthEnable;
+        D.DepthWriteMask               = DepthWriteMask;
+        D.DepthFunc                    = DepthFunc;
+        D.StencilEnable                = StencilEnable;
+        D.StencilReadMask              = StencilReadMask;
+        D.StencilWriteMask             = StencilWriteMask;
+        D.FrontFace.StencilFailOp      = FrontFace.StencilFailOp;
+        D.FrontFace.StencilDepthFailOp = FrontFace.StencilDepthFailOp;
+        D.FrontFace.StencilPassOp      = FrontFace.StencilPassOp;
+        D.FrontFace.StencilFunc        = FrontFace.StencilFunc;
+        D.BackFace.StencilFailOp       = BackFace.StencilFailOp;
+        D.BackFace.StencilDepthFailOp  = BackFace.StencilDepthFailOp;
+        D.BackFace.StencilPassOp       = BackFace.StencilPassOp;
+        D.BackFace.StencilFunc         = BackFace.StencilFunc;
+        return D;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_BLEND_DESC : public D3D12_BLEND_DESC
+{
+    CD3DX12_BLEND_DESC() = default;
+    explicit CD3DX12_BLEND_DESC( const D3D12_BLEND_DESC& o ) :
+        D3D12_BLEND_DESC( o )
+    {}
+    explicit CD3DX12_BLEND_DESC( CD3DX12_DEFAULT )
+    {
+        AlphaToCoverageEnable = FALSE;
+        IndependentBlendEnable = FALSE;
+        const D3D12_RENDER_TARGET_BLEND_DESC defaultRenderTargetBlendDesc =
+        {
+            FALSE,FALSE,
+            D3D12_BLEND_ONE, D3D12_BLEND_ZERO, D3D12_BLEND_OP_ADD,
+            D3D12_BLEND_ONE, D3D12_BLEND_ZERO, D3D12_BLEND_OP_ADD,
+            D3D12_LOGIC_OP_NOOP,
+            D3D12_COLOR_WRITE_ENABLE_ALL,
+        };
+        for (UINT i = 0; i < D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT; ++i)
+            RenderTarget[ i ] = defaultRenderTargetBlendDesc;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_RASTERIZER_DESC : public D3D12_RASTERIZER_DESC
+{
+    CD3DX12_RASTERIZER_DESC() = default;
+    explicit CD3DX12_RASTERIZER_DESC( const D3D12_RASTERIZER_DESC& o ) :
+        D3D12_RASTERIZER_DESC( o )
+    {}
+    explicit CD3DX12_RASTERIZER_DESC( CD3DX12_DEFAULT )
+    {
+        FillMode = D3D12_FILL_MODE_SOLID;
+        CullMode = D3D12_CULL_MODE_BACK;
+        FrontCounterClockwise = FALSE;
+        DepthBias = D3D12_DEFAULT_DEPTH_BIAS;
+        DepthBiasClamp = D3D12_DEFAULT_DEPTH_BIAS_CLAMP;
+        SlopeScaledDepthBias = D3D12_DEFAULT_SLOPE_SCALED_DEPTH_BIAS;
+        DepthClipEnable = TRUE;
+        MultisampleEnable = FALSE;
+        AntialiasedLineEnable = FALSE;
+        ForcedSampleCount = 0;
+        ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;
+    }
+    explicit CD3DX12_RASTERIZER_DESC(
+        D3D12_FILL_MODE fillMode,
+        D3D12_CULL_MODE cullMode,
+        BOOL frontCounterClockwise,
+        INT depthBias,
+        FLOAT depthBiasClamp,
+        FLOAT slopeScaledDepthBias,
+        BOOL depthClipEnable,
+        BOOL multisampleEnable,
+        BOOL antialiasedLineEnable, 
+        UINT forcedSampleCount, 
+        D3D12_CONSERVATIVE_RASTERIZATION_MODE conservativeRaster)
+    {
+        FillMode = fillMode;
+        CullMode = cullMode;
+        FrontCounterClockwise = frontCounterClockwise;
+        DepthBias = depthBias;
+        DepthBiasClamp = depthBiasClamp;
+        SlopeScaledDepthBias = slopeScaledDepthBias;
+        DepthClipEnable = depthClipEnable;
+        MultisampleEnable = multisampleEnable;
+        AntialiasedLineEnable = antialiasedLineEnable;
+        ForcedSampleCount = forcedSampleCount;
+        ConservativeRaster = conservativeRaster;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_RESOURCE_ALLOCATION_INFO : public D3D12_RESOURCE_ALLOCATION_INFO
+{
+    CD3DX12_RESOURCE_ALLOCATION_INFO() = default;
+    explicit CD3DX12_RESOURCE_ALLOCATION_INFO( const D3D12_RESOURCE_ALLOCATION_INFO& o ) :
+        D3D12_RESOURCE_ALLOCATION_INFO( o )
+    {}
+    CD3DX12_RESOURCE_ALLOCATION_INFO(
+        UINT64 size,
+        UINT64 alignment )
+    {
+        SizeInBytes = size;
+        Alignment = alignment;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_HEAP_PROPERTIES : public D3D12_HEAP_PROPERTIES
+{
+    CD3DX12_HEAP_PROPERTIES() = default;
+    explicit CD3DX12_HEAP_PROPERTIES(const D3D12_HEAP_PROPERTIES &o) :
+        D3D12_HEAP_PROPERTIES(o)
+    {}
+    CD3DX12_HEAP_PROPERTIES( 
+        D3D12_CPU_PAGE_PROPERTY cpuPageProperty, 
+        D3D12_MEMORY_POOL memoryPoolPreference,
+        UINT creationNodeMask = 1, 
+        UINT nodeMask = 1 )
+    {
+        Type = D3D12_HEAP_TYPE_CUSTOM;
+        CPUPageProperty = cpuPageProperty;
+        MemoryPoolPreference = memoryPoolPreference;
+        CreationNodeMask = creationNodeMask;
+        VisibleNodeMask = nodeMask;
+    }
+    explicit CD3DX12_HEAP_PROPERTIES( 
+        D3D12_HEAP_TYPE type, 
+        UINT creationNodeMask = 1, 
+        UINT nodeMask = 1 )
+    {
+        Type = type;
+        CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
+        MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
+        CreationNodeMask = creationNodeMask;
+        VisibleNodeMask = nodeMask;
+    }
+    bool IsCPUAccessible() const
+    {
+        return Type == D3D12_HEAP_TYPE_UPLOAD || Type == D3D12_HEAP_TYPE_READBACK || (Type == D3D12_HEAP_TYPE_CUSTOM &&
+            (CPUPageProperty == D3D12_CPU_PAGE_PROPERTY_WRITE_COMBINE || CPUPageProperty == D3D12_CPU_PAGE_PROPERTY_WRITE_BACK));
+    }
+};
+inline bool operator==( const D3D12_HEAP_PROPERTIES& l, const D3D12_HEAP_PROPERTIES& r )
+{
+    return l.Type == r.Type && l.CPUPageProperty == r.CPUPageProperty && 
+        l.MemoryPoolPreference == r.MemoryPoolPreference &&
+        l.CreationNodeMask == r.CreationNodeMask &&
+        l.VisibleNodeMask == r.VisibleNodeMask;
+}
+inline bool operator!=( const D3D12_HEAP_PROPERTIES& l, const D3D12_HEAP_PROPERTIES& r )
+{ return !( l == r ); }
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_HEAP_DESC : public D3D12_HEAP_DESC
+{
+    CD3DX12_HEAP_DESC() = default;
+    explicit CD3DX12_HEAP_DESC(const D3D12_HEAP_DESC &o) :
+        D3D12_HEAP_DESC(o)
+    {}
+    CD3DX12_HEAP_DESC( 
+        UINT64 size, 
+        D3D12_HEAP_PROPERTIES properties, 
+        UINT64 alignment = 0, 
+        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE )
+    {
+        SizeInBytes = size;
+        Properties = properties;
+        Alignment = alignment;
+        Flags = flags;
+    }
+    CD3DX12_HEAP_DESC( 
+        UINT64 size, 
+        D3D12_HEAP_TYPE type, 
+        UINT64 alignment = 0, 
+        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE )
+    {
+        SizeInBytes = size;
+        Properties = CD3DX12_HEAP_PROPERTIES( type );
+        Alignment = alignment;
+        Flags = flags;
+    }
+    CD3DX12_HEAP_DESC( 
+        UINT64 size, 
+        D3D12_CPU_PAGE_PROPERTY cpuPageProperty, 
+        D3D12_MEMORY_POOL memoryPoolPreference, 
+        UINT64 alignment = 0, 
+        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE )
+    {
+        SizeInBytes = size;
+        Properties = CD3DX12_HEAP_PROPERTIES( cpuPageProperty, memoryPoolPreference );
+        Alignment = alignment;
+        Flags = flags;
+    }
+    CD3DX12_HEAP_DESC( 
+        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
+        D3D12_HEAP_PROPERTIES properties, 
+        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE )
+    {
+        SizeInBytes = resAllocInfo.SizeInBytes;
+        Properties = properties;
+        Alignment = resAllocInfo.Alignment;
+        Flags = flags;
+    }
+    CD3DX12_HEAP_DESC( 
+        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
+        D3D12_HEAP_TYPE type, 
+        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE )
+    {
+        SizeInBytes = resAllocInfo.SizeInBytes;
+        Properties = CD3DX12_HEAP_PROPERTIES( type );
+        Alignment = resAllocInfo.Alignment;
+        Flags = flags;
+    }
+    CD3DX12_HEAP_DESC( 
+        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
+        D3D12_CPU_PAGE_PROPERTY cpuPageProperty, 
+        D3D12_MEMORY_POOL memoryPoolPreference, 
+        D3D12_HEAP_FLAGS flags = D3D12_HEAP_FLAG_NONE )
+    {
+        SizeInBytes = resAllocInfo.SizeInBytes;
+        Properties = CD3DX12_HEAP_PROPERTIES( cpuPageProperty, memoryPoolPreference );
+        Alignment = resAllocInfo.Alignment;
+        Flags = flags;
+    }
+    bool IsCPUAccessible() const
+    { return static_cast< const CD3DX12_HEAP_PROPERTIES* >( &Properties )->IsCPUAccessible(); }
+};
+inline bool operator==( const D3D12_HEAP_DESC& l, const D3D12_HEAP_DESC& r )
+{
+    return l.SizeInBytes == r.SizeInBytes &&
+        l.Properties == r.Properties && 
+        l.Alignment == r.Alignment &&
+        l.Flags == r.Flags;
+}
+inline bool operator!=( const D3D12_HEAP_DESC& l, const D3D12_HEAP_DESC& r )
+{ return !( l == r ); }
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_CLEAR_VALUE : public D3D12_CLEAR_VALUE
+{
+    CD3DX12_CLEAR_VALUE() = default;
+    explicit CD3DX12_CLEAR_VALUE(const D3D12_CLEAR_VALUE &o) :
+        D3D12_CLEAR_VALUE(o)
+    {}
+    CD3DX12_CLEAR_VALUE( 
+        DXGI_FORMAT format, 
+        const FLOAT color[4] )
+    {
+        Format = format;
+        memcpy( Color, color, sizeof( Color ) );
+    }
+    CD3DX12_CLEAR_VALUE( 
+        DXGI_FORMAT format, 
+        FLOAT depth,
+        UINT8 stencil )
+    {
+        Format = format;
+        memset( &Color, 0, sizeof( Color ) );
+        /* Use memcpy to preserve NAN values */
+        memcpy( &DepthStencil.Depth, &depth, sizeof( depth ) );
+        DepthStencil.Stencil = stencil;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_RANGE : public D3D12_RANGE
+{
+    CD3DX12_RANGE() = default;
+    explicit CD3DX12_RANGE(const D3D12_RANGE &o) :
+        D3D12_RANGE(o)
+    {}
+    CD3DX12_RANGE( 
+        SIZE_T begin, 
+        SIZE_T end )
+    {
+        Begin = begin;
+        End = end;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_RANGE_UINT64 : public D3D12_RANGE_UINT64
+{
+    CD3DX12_RANGE_UINT64() = default;
+    explicit CD3DX12_RANGE_UINT64(const D3D12_RANGE_UINT64 &o) :
+        D3D12_RANGE_UINT64(o)
+    {}
+    CD3DX12_RANGE_UINT64( 
+        UINT64 begin, 
+        UINT64 end )
+    {
+        Begin = begin;
+        End = end;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_SUBRESOURCE_RANGE_UINT64 : public D3D12_SUBRESOURCE_RANGE_UINT64
+{
+    CD3DX12_SUBRESOURCE_RANGE_UINT64() = default;
+    explicit CD3DX12_SUBRESOURCE_RANGE_UINT64(const D3D12_SUBRESOURCE_RANGE_UINT64 &o) :
+        D3D12_SUBRESOURCE_RANGE_UINT64(o)
+    {}
+    CD3DX12_SUBRESOURCE_RANGE_UINT64( 
+        UINT subresource,
+        const D3D12_RANGE_UINT64& range )
+    {
+        Subresource = subresource;
+        Range = range;
+    }
+    CD3DX12_SUBRESOURCE_RANGE_UINT64( 
+        UINT subresource,
+        UINT64 begin, 
+        UINT64 end )
+    {
+        Subresource = subresource;
+        Range.Begin = begin;
+        Range.End = end;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_SHADER_BYTECODE : public D3D12_SHADER_BYTECODE
+{
+    CD3DX12_SHADER_BYTECODE() = default;
+    explicit CD3DX12_SHADER_BYTECODE(const D3D12_SHADER_BYTECODE &o) :
+        D3D12_SHADER_BYTECODE(o)
+    {}
+    CD3DX12_SHADER_BYTECODE(
+        _In_ ID3DBlob* pShaderBlob )
+    {
+        pShaderBytecode = pShaderBlob->GetBufferPointer();
+        BytecodeLength = pShaderBlob->GetBufferSize();
+    }
+    CD3DX12_SHADER_BYTECODE(
+        const void* _pShaderBytecode,
+        SIZE_T bytecodeLength )
+    {
+        pShaderBytecode = _pShaderBytecode;
+        BytecodeLength = bytecodeLength;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_TILED_RESOURCE_COORDINATE : public D3D12_TILED_RESOURCE_COORDINATE
+{
+    CD3DX12_TILED_RESOURCE_COORDINATE() = default;
+    explicit CD3DX12_TILED_RESOURCE_COORDINATE(const D3D12_TILED_RESOURCE_COORDINATE &o) :
+        D3D12_TILED_RESOURCE_COORDINATE(o)
+    {}
+    CD3DX12_TILED_RESOURCE_COORDINATE( 
+        UINT x, 
+        UINT y, 
+        UINT z, 
+        UINT subresource ) 
+    {
+        X = x;
+        Y = y;
+        Z = z;
+        Subresource = subresource;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_TILE_REGION_SIZE : public D3D12_TILE_REGION_SIZE
+{
+    CD3DX12_TILE_REGION_SIZE() = default;
+    explicit CD3DX12_TILE_REGION_SIZE(const D3D12_TILE_REGION_SIZE &o) :
+        D3D12_TILE_REGION_SIZE(o)
+    {}
+    CD3DX12_TILE_REGION_SIZE( 
+        UINT numTiles, 
+        BOOL useBox, 
+        UINT width, 
+        UINT16 height, 
+        UINT16 depth ) 
+    {
+        NumTiles = numTiles;
+        UseBox = useBox;
+        Width = width;
+        Height = height;
+        Depth = depth;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_SUBRESOURCE_TILING : public D3D12_SUBRESOURCE_TILING
+{
+    CD3DX12_SUBRESOURCE_TILING() = default;
+    explicit CD3DX12_SUBRESOURCE_TILING(const D3D12_SUBRESOURCE_TILING &o) :
+        D3D12_SUBRESOURCE_TILING(o)
+    {}
+    CD3DX12_SUBRESOURCE_TILING( 
+        UINT widthInTiles, 
+        UINT16 heightInTiles, 
+        UINT16 depthInTiles, 
+        UINT startTileIndexInOverallResource ) 
+    {
+        WidthInTiles = widthInTiles;
+        HeightInTiles = heightInTiles;
+        DepthInTiles = depthInTiles;
+        StartTileIndexInOverallResource = startTileIndexInOverallResource;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_TILE_SHAPE : public D3D12_TILE_SHAPE
+{
+    CD3DX12_TILE_SHAPE() = default;
+    explicit CD3DX12_TILE_SHAPE(const D3D12_TILE_SHAPE &o) :
+        D3D12_TILE_SHAPE(o)
+    {}
+    CD3DX12_TILE_SHAPE( 
+        UINT widthInTexels, 
+        UINT heightInTexels, 
+        UINT depthInTexels ) 
+    {
+        WidthInTexels = widthInTexels;
+        HeightInTexels = heightInTexels;
+        DepthInTexels = depthInTexels;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_RESOURCE_BARRIER : public D3D12_RESOURCE_BARRIER
+{
+    CD3DX12_RESOURCE_BARRIER() = default;
+    explicit CD3DX12_RESOURCE_BARRIER(const D3D12_RESOURCE_BARRIER &o) :
+        D3D12_RESOURCE_BARRIER(o)
+    {}
+    static inline CD3DX12_RESOURCE_BARRIER Transition(
+        _In_ ID3D12Resource* pResource,
+        D3D12_RESOURCE_STATES stateBefore,
+        D3D12_RESOURCE_STATES stateAfter,
+        UINT subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES,
+        D3D12_RESOURCE_BARRIER_FLAGS flags = D3D12_RESOURCE_BARRIER_FLAG_NONE)
+    {
+        CD3DX12_RESOURCE_BARRIER result = {};
+        D3D12_RESOURCE_BARRIER &barrier = result;
+        result.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
+        result.Flags = flags;
+        barrier.Transition.pResource = pResource;
+        barrier.Transition.StateBefore = stateBefore;
+        barrier.Transition.StateAfter = stateAfter;
+        barrier.Transition.Subresource = subresource;
+        return result;
+    }
+    static inline CD3DX12_RESOURCE_BARRIER Aliasing(
+        _In_ ID3D12Resource* pResourceBefore,
+        _In_ ID3D12Resource* pResourceAfter)
+    {
+        CD3DX12_RESOURCE_BARRIER result = {};
+        D3D12_RESOURCE_BARRIER &barrier = result;
+        result.Type = D3D12_RESOURCE_BARRIER_TYPE_ALIASING;
+        barrier.Aliasing.pResourceBefore = pResourceBefore;
+        barrier.Aliasing.pResourceAfter = pResourceAfter;
+        return result;
+    }
+    static inline CD3DX12_RESOURCE_BARRIER UAV(
+        _In_ ID3D12Resource* pResource)
+    {
+        CD3DX12_RESOURCE_BARRIER result = {};
+        D3D12_RESOURCE_BARRIER &barrier = result;
+        result.Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;
+        barrier.UAV.pResource = pResource;
+        return result;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_PACKED_MIP_INFO : public D3D12_PACKED_MIP_INFO
+{
+    CD3DX12_PACKED_MIP_INFO() = default;
+    explicit CD3DX12_PACKED_MIP_INFO(const D3D12_PACKED_MIP_INFO &o) :
+        D3D12_PACKED_MIP_INFO(o)
+    {}
+    CD3DX12_PACKED_MIP_INFO( 
+        UINT8 numStandardMips, 
+        UINT8 numPackedMips, 
+        UINT numTilesForPackedMips, 
+        UINT startTileIndexInOverallResource ) 
+    {
+        NumStandardMips = numStandardMips;
+        NumPackedMips = numPackedMips;
+        NumTilesForPackedMips = numTilesForPackedMips;
+        StartTileIndexInOverallResource = startTileIndexInOverallResource;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_SUBRESOURCE_FOOTPRINT : public D3D12_SUBRESOURCE_FOOTPRINT
+{
+    CD3DX12_SUBRESOURCE_FOOTPRINT() = default;
+    explicit CD3DX12_SUBRESOURCE_FOOTPRINT(const D3D12_SUBRESOURCE_FOOTPRINT &o) :
+        D3D12_SUBRESOURCE_FOOTPRINT(o)
+    {}
+    CD3DX12_SUBRESOURCE_FOOTPRINT( 
+        DXGI_FORMAT format, 
+        UINT width, 
+        UINT height, 
+        UINT depth, 
+        UINT rowPitch ) 
+    {
+        Format = format;
+        Width = width;
+        Height = height;
+        Depth = depth;
+        RowPitch = rowPitch;
+    }
+    explicit CD3DX12_SUBRESOURCE_FOOTPRINT( 
+        const D3D12_RESOURCE_DESC& resDesc, 
+        UINT rowPitch ) 
+    {
+        Format = resDesc.Format;
+        Width = UINT( resDesc.Width );
+        Height = resDesc.Height;
+        Depth = (resDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D ? resDesc.DepthOrArraySize : 1);
+        RowPitch = rowPitch;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_TEXTURE_COPY_LOCATION : public D3D12_TEXTURE_COPY_LOCATION
+{ 
+    CD3DX12_TEXTURE_COPY_LOCATION() = default;
+    explicit CD3DX12_TEXTURE_COPY_LOCATION(const D3D12_TEXTURE_COPY_LOCATION &o) :
+        D3D12_TEXTURE_COPY_LOCATION(o)
+    {}
+    CD3DX12_TEXTURE_COPY_LOCATION(_In_ ID3D12Resource* pRes)
+    {
+        pResource = pRes;
+        Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
+        PlacedFootprint = {};
+    }
+    CD3DX12_TEXTURE_COPY_LOCATION(_In_ ID3D12Resource* pRes, D3D12_PLACED_SUBRESOURCE_FOOTPRINT const& Footprint)
+    {
+        pResource = pRes;
+        Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
+        PlacedFootprint = Footprint;
+    }
+    CD3DX12_TEXTURE_COPY_LOCATION(_In_ ID3D12Resource* pRes, UINT Sub)
+    {
+        pResource = pRes;
+        Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
+        PlacedFootprint = {};
+        SubresourceIndex = Sub;
+    }
+}; 
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_DESCRIPTOR_RANGE : public D3D12_DESCRIPTOR_RANGE
+{
+    CD3DX12_DESCRIPTOR_RANGE() = default;
+    explicit CD3DX12_DESCRIPTOR_RANGE(const D3D12_DESCRIPTOR_RANGE &o) :
+        D3D12_DESCRIPTOR_RANGE(o)
+    {}
+    CD3DX12_DESCRIPTOR_RANGE(
+        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
+        UINT numDescriptors,
+        UINT baseShaderRegister,
+        UINT registerSpace = 0,
+        UINT offsetInDescriptorsFromTableStart =
+        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND)
+    {
+        Init(rangeType, numDescriptors, baseShaderRegister, registerSpace, offsetInDescriptorsFromTableStart);
+    }
+    
+    inline void Init(
+        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
+        UINT numDescriptors,
+        UINT baseShaderRegister,
+        UINT registerSpace = 0,
+        UINT offsetInDescriptorsFromTableStart =
+        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND)
+    {
+        Init(*this, rangeType, numDescriptors, baseShaderRegister, registerSpace, offsetInDescriptorsFromTableStart);
+    }
+    
+    static inline void Init(
+        _Out_ D3D12_DESCRIPTOR_RANGE &range,
+        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
+        UINT numDescriptors,
+        UINT baseShaderRegister,
+        UINT registerSpace = 0,
+        UINT offsetInDescriptorsFromTableStart =
+        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND)
+    {
+        range.RangeType = rangeType;
+        range.NumDescriptors = numDescriptors;
+        range.BaseShaderRegister = baseShaderRegister;
+        range.RegisterSpace = registerSpace;
+        range.OffsetInDescriptorsFromTableStart = offsetInDescriptorsFromTableStart;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_ROOT_DESCRIPTOR_TABLE : public D3D12_ROOT_DESCRIPTOR_TABLE
+{
+    CD3DX12_ROOT_DESCRIPTOR_TABLE() = default;
+    explicit CD3DX12_ROOT_DESCRIPTOR_TABLE(const D3D12_ROOT_DESCRIPTOR_TABLE &o) :
+        D3D12_ROOT_DESCRIPTOR_TABLE(o)
+    {}
+    CD3DX12_ROOT_DESCRIPTOR_TABLE(
+        UINT numDescriptorRanges,
+        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* _pDescriptorRanges)
+    {
+        Init(numDescriptorRanges, _pDescriptorRanges);
+    }
+    
+    inline void Init(
+        UINT numDescriptorRanges,
+        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* _pDescriptorRanges)
+    {
+        Init(*this, numDescriptorRanges, _pDescriptorRanges);
+    }
+    
+    static inline void Init(
+        _Out_ D3D12_ROOT_DESCRIPTOR_TABLE &rootDescriptorTable,
+        UINT numDescriptorRanges,
+        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* _pDescriptorRanges)
+    {
+        rootDescriptorTable.NumDescriptorRanges = numDescriptorRanges;
+        rootDescriptorTable.pDescriptorRanges = _pDescriptorRanges;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_ROOT_CONSTANTS : public D3D12_ROOT_CONSTANTS
+{
+    CD3DX12_ROOT_CONSTANTS() = default;
+    explicit CD3DX12_ROOT_CONSTANTS(const D3D12_ROOT_CONSTANTS &o) :
+        D3D12_ROOT_CONSTANTS(o)
+    {}
+    CD3DX12_ROOT_CONSTANTS(
+        UINT num32BitValues,
+        UINT shaderRegister,
+        UINT registerSpace = 0)
+    {
+        Init(num32BitValues, shaderRegister, registerSpace);
+    }
+    
+    inline void Init(
+        UINT num32BitValues,
+        UINT shaderRegister,
+        UINT registerSpace = 0)
+    {
+        Init(*this, num32BitValues, shaderRegister, registerSpace);
+    }
+    
+    static inline void Init(
+        _Out_ D3D12_ROOT_CONSTANTS &rootConstants,
+        UINT num32BitValues,
+        UINT shaderRegister,
+        UINT registerSpace = 0)
+    {
+        rootConstants.Num32BitValues = num32BitValues;
+        rootConstants.ShaderRegister = shaderRegister;
+        rootConstants.RegisterSpace = registerSpace;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_ROOT_DESCRIPTOR : public D3D12_ROOT_DESCRIPTOR
+{
+    CD3DX12_ROOT_DESCRIPTOR() = default;
+    explicit CD3DX12_ROOT_DESCRIPTOR(const D3D12_ROOT_DESCRIPTOR &o) :
+        D3D12_ROOT_DESCRIPTOR(o)
+    {}
+    CD3DX12_ROOT_DESCRIPTOR(
+        UINT shaderRegister,
+        UINT registerSpace = 0)
+    {
+        Init(shaderRegister, registerSpace);
+    }
+    
+    inline void Init(
+        UINT shaderRegister,
+        UINT registerSpace = 0)
+    {
+        Init(*this, shaderRegister, registerSpace);
+    }
+    
+    static inline void Init(_Out_ D3D12_ROOT_DESCRIPTOR &table, UINT shaderRegister, UINT registerSpace = 0)
+    {
+        table.ShaderRegister = shaderRegister;
+        table.RegisterSpace = registerSpace;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_ROOT_PARAMETER : public D3D12_ROOT_PARAMETER
+{
+    CD3DX12_ROOT_PARAMETER() = default;
+    explicit CD3DX12_ROOT_PARAMETER(const D3D12_ROOT_PARAMETER &o) :
+        D3D12_ROOT_PARAMETER(o)
+    {}
+    
+    static inline void InitAsDescriptorTable(
+        _Out_ D3D12_ROOT_PARAMETER &rootParam,
+        UINT numDescriptorRanges,
+        _In_reads_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* pDescriptorRanges,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_DESCRIPTOR_TABLE::Init(rootParam.DescriptorTable, numDescriptorRanges, pDescriptorRanges);
+    }
+
+    static inline void InitAsConstants(
+        _Out_ D3D12_ROOT_PARAMETER &rootParam,
+        UINT num32BitValues,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_CONSTANTS::Init(rootParam.Constants, num32BitValues, shaderRegister, registerSpace);
+    }
+
+    static inline void InitAsConstantBufferView(
+        _Out_ D3D12_ROOT_PARAMETER &rootParam,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_DESCRIPTOR::Init(rootParam.Descriptor, shaderRegister, registerSpace);
+    }
+
+    static inline void InitAsShaderResourceView(
+        _Out_ D3D12_ROOT_PARAMETER &rootParam,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_SRV;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_DESCRIPTOR::Init(rootParam.Descriptor, shaderRegister, registerSpace);
+    }
+
+    static inline void InitAsUnorderedAccessView(
+        _Out_ D3D12_ROOT_PARAMETER &rootParam,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_UAV;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_DESCRIPTOR::Init(rootParam.Descriptor, shaderRegister, registerSpace);
+    }
+    
+    inline void InitAsDescriptorTable(
+        UINT numDescriptorRanges,
+        _In_reads_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE* pDescriptorRanges,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsDescriptorTable(*this, numDescriptorRanges, pDescriptorRanges, visibility);
+    }
+    
+    inline void InitAsConstants(
+        UINT num32BitValues,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsConstants(*this, num32BitValues, shaderRegister, registerSpace, visibility);
+    }
+
+    inline void InitAsConstantBufferView(
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsConstantBufferView(*this, shaderRegister, registerSpace, visibility);
+    }
+
+    inline void InitAsShaderResourceView(
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsShaderResourceView(*this, shaderRegister, registerSpace, visibility);
+    }
+
+    inline void InitAsUnorderedAccessView(
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsUnorderedAccessView(*this, shaderRegister, registerSpace, visibility);
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_STATIC_SAMPLER_DESC : public D3D12_STATIC_SAMPLER_DESC
+{
+    CD3DX12_STATIC_SAMPLER_DESC() = default;
+    explicit CD3DX12_STATIC_SAMPLER_DESC(const D3D12_STATIC_SAMPLER_DESC &o) :
+        D3D12_STATIC_SAMPLER_DESC(o)
+    {}
+    CD3DX12_STATIC_SAMPLER_DESC(
+         UINT shaderRegister,
+         D3D12_FILTER filter = D3D12_FILTER_ANISOTROPIC,
+         D3D12_TEXTURE_ADDRESS_MODE addressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+         D3D12_TEXTURE_ADDRESS_MODE addressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+         D3D12_TEXTURE_ADDRESS_MODE addressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+         FLOAT mipLODBias = 0,
+         UINT maxAnisotropy = 16,
+         D3D12_COMPARISON_FUNC comparisonFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL,
+         D3D12_STATIC_BORDER_COLOR borderColor = D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE,
+         FLOAT minLOD = 0.f,
+         FLOAT maxLOD = D3D12_FLOAT32_MAX,
+         D3D12_SHADER_VISIBILITY shaderVisibility = D3D12_SHADER_VISIBILITY_ALL, 
+         UINT registerSpace = 0)
+    {
+        Init(
+            shaderRegister,
+            filter,
+            addressU,
+            addressV,
+            addressW,
+            mipLODBias,
+            maxAnisotropy,
+            comparisonFunc,
+            borderColor,
+            minLOD,
+            maxLOD,
+            shaderVisibility,
+            registerSpace);
+    }
+    
+    static inline void Init(
+        _Out_ D3D12_STATIC_SAMPLER_DESC &samplerDesc,
+         UINT shaderRegister,
+         D3D12_FILTER filter = D3D12_FILTER_ANISOTROPIC,
+         D3D12_TEXTURE_ADDRESS_MODE addressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+         D3D12_TEXTURE_ADDRESS_MODE addressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+         D3D12_TEXTURE_ADDRESS_MODE addressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+         FLOAT mipLODBias = 0,
+         UINT maxAnisotropy = 16,
+         D3D12_COMPARISON_FUNC comparisonFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL,
+         D3D12_STATIC_BORDER_COLOR borderColor = D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE,
+         FLOAT minLOD = 0.f,
+         FLOAT maxLOD = D3D12_FLOAT32_MAX,
+         D3D12_SHADER_VISIBILITY shaderVisibility = D3D12_SHADER_VISIBILITY_ALL, 
+         UINT registerSpace = 0)
+    {
+        samplerDesc.ShaderRegister = shaderRegister;
+        samplerDesc.Filter = filter;
+        samplerDesc.AddressU = addressU;
+        samplerDesc.AddressV = addressV;
+        samplerDesc.AddressW = addressW;
+        samplerDesc.MipLODBias = mipLODBias;
+        samplerDesc.MaxAnisotropy = maxAnisotropy;
+        samplerDesc.ComparisonFunc = comparisonFunc;
+        samplerDesc.BorderColor = borderColor;
+        samplerDesc.MinLOD = minLOD;
+        samplerDesc.MaxLOD = maxLOD;
+        samplerDesc.ShaderVisibility = shaderVisibility;
+        samplerDesc.RegisterSpace = registerSpace;
+    }
+    inline void Init(
+         UINT shaderRegister,
+         D3D12_FILTER filter = D3D12_FILTER_ANISOTROPIC,
+         D3D12_TEXTURE_ADDRESS_MODE addressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+         D3D12_TEXTURE_ADDRESS_MODE addressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+         D3D12_TEXTURE_ADDRESS_MODE addressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+         FLOAT mipLODBias = 0,
+         UINT maxAnisotropy = 16,
+         D3D12_COMPARISON_FUNC comparisonFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL,
+         D3D12_STATIC_BORDER_COLOR borderColor = D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE,
+         FLOAT minLOD = 0.f,
+         FLOAT maxLOD = D3D12_FLOAT32_MAX,
+         D3D12_SHADER_VISIBILITY shaderVisibility = D3D12_SHADER_VISIBILITY_ALL, 
+         UINT registerSpace = 0)
+    {
+        Init(
+            *this,
+            shaderRegister,
+            filter,
+            addressU,
+            addressV,
+            addressW,
+            mipLODBias,
+            maxAnisotropy,
+            comparisonFunc,
+            borderColor,
+            minLOD,
+            maxLOD,
+            shaderVisibility,
+            registerSpace);
+    }
+    
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_ROOT_SIGNATURE_DESC : public D3D12_ROOT_SIGNATURE_DESC
+{
+    CD3DX12_ROOT_SIGNATURE_DESC() = default;
+    explicit CD3DX12_ROOT_SIGNATURE_DESC(const D3D12_ROOT_SIGNATURE_DESC &o) :
+        D3D12_ROOT_SIGNATURE_DESC(o)
+    {}
+    CD3DX12_ROOT_SIGNATURE_DESC(
+        UINT numParameters,
+        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
+        UINT numStaticSamplers = 0,
+        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
+        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE)
+    {
+        Init(numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
+    }
+    CD3DX12_ROOT_SIGNATURE_DESC(CD3DX12_DEFAULT)
+    {
+        Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_NONE);
+    }
+    
+    inline void Init(
+        UINT numParameters,
+        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
+        UINT numStaticSamplers = 0,
+        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
+        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE)
+    {
+        Init(*this, numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
+    }
+
+    static inline void Init(
+        _Out_ D3D12_ROOT_SIGNATURE_DESC &desc,
+        UINT numParameters,
+        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
+        UINT numStaticSamplers = 0,
+        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
+        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE)
+    {
+        desc.NumParameters = numParameters;
+        desc.pParameters = _pParameters;
+        desc.NumStaticSamplers = numStaticSamplers;
+        desc.pStaticSamplers = _pStaticSamplers;
+        desc.Flags = flags;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_DESCRIPTOR_RANGE1 : public D3D12_DESCRIPTOR_RANGE1
+{
+    CD3DX12_DESCRIPTOR_RANGE1() = default;
+    explicit CD3DX12_DESCRIPTOR_RANGE1(const D3D12_DESCRIPTOR_RANGE1 &o) :
+        D3D12_DESCRIPTOR_RANGE1(o)
+    {}
+    CD3DX12_DESCRIPTOR_RANGE1(
+        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
+        UINT numDescriptors,
+        UINT baseShaderRegister,
+        UINT registerSpace = 0,
+        D3D12_DESCRIPTOR_RANGE_FLAGS flags = D3D12_DESCRIPTOR_RANGE_FLAG_NONE,
+        UINT offsetInDescriptorsFromTableStart =
+        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND)
+    {
+        Init(rangeType, numDescriptors, baseShaderRegister, registerSpace, flags, offsetInDescriptorsFromTableStart);
+    }
+    
+    inline void Init(
+        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
+        UINT numDescriptors,
+        UINT baseShaderRegister,
+        UINT registerSpace = 0,
+        D3D12_DESCRIPTOR_RANGE_FLAGS flags = D3D12_DESCRIPTOR_RANGE_FLAG_NONE,
+        UINT offsetInDescriptorsFromTableStart =
+        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND)
+    {
+        Init(*this, rangeType, numDescriptors, baseShaderRegister, registerSpace, flags, offsetInDescriptorsFromTableStart);
+    }
+    
+    static inline void Init(
+        _Out_ D3D12_DESCRIPTOR_RANGE1 &range,
+        D3D12_DESCRIPTOR_RANGE_TYPE rangeType,
+        UINT numDescriptors,
+        UINT baseShaderRegister,
+        UINT registerSpace = 0,
+        D3D12_DESCRIPTOR_RANGE_FLAGS flags = D3D12_DESCRIPTOR_RANGE_FLAG_NONE,
+        UINT offsetInDescriptorsFromTableStart =
+        D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND)
+    {
+        range.RangeType = rangeType;
+        range.NumDescriptors = numDescriptors;
+        range.BaseShaderRegister = baseShaderRegister;
+        range.RegisterSpace = registerSpace;
+        range.Flags = flags;
+        range.OffsetInDescriptorsFromTableStart = offsetInDescriptorsFromTableStart;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_ROOT_DESCRIPTOR_TABLE1 : public D3D12_ROOT_DESCRIPTOR_TABLE1
+{
+    CD3DX12_ROOT_DESCRIPTOR_TABLE1() = default;
+    explicit CD3DX12_ROOT_DESCRIPTOR_TABLE1(const D3D12_ROOT_DESCRIPTOR_TABLE1 &o) :
+        D3D12_ROOT_DESCRIPTOR_TABLE1(o)
+    {}
+    CD3DX12_ROOT_DESCRIPTOR_TABLE1(
+        UINT numDescriptorRanges,
+        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* _pDescriptorRanges)
+    {
+        Init(numDescriptorRanges, _pDescriptorRanges);
+    }
+    
+    inline void Init(
+        UINT numDescriptorRanges,
+        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* _pDescriptorRanges)
+    {
+        Init(*this, numDescriptorRanges, _pDescriptorRanges);
+    }
+    
+    static inline void Init(
+        _Out_ D3D12_ROOT_DESCRIPTOR_TABLE1 &rootDescriptorTable,
+        UINT numDescriptorRanges,
+        _In_reads_opt_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* _pDescriptorRanges)
+    {
+        rootDescriptorTable.NumDescriptorRanges = numDescriptorRanges;
+        rootDescriptorTable.pDescriptorRanges = _pDescriptorRanges;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_ROOT_DESCRIPTOR1 : public D3D12_ROOT_DESCRIPTOR1
+{
+    CD3DX12_ROOT_DESCRIPTOR1() = default;
+    explicit CD3DX12_ROOT_DESCRIPTOR1(const D3D12_ROOT_DESCRIPTOR1 &o) :
+        D3D12_ROOT_DESCRIPTOR1(o)
+    {}
+    CD3DX12_ROOT_DESCRIPTOR1(
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE)
+    {
+        Init(shaderRegister, registerSpace, flags);
+    }
+    
+    inline void Init(
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE)
+    {
+        Init(*this, shaderRegister, registerSpace, flags);
+    }
+    
+    static inline void Init(
+        _Out_ D3D12_ROOT_DESCRIPTOR1 &table, 
+        UINT shaderRegister, 
+        UINT registerSpace = 0, 
+        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE)
+    {
+        table.ShaderRegister = shaderRegister;
+        table.RegisterSpace = registerSpace;
+        table.Flags = flags;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_ROOT_PARAMETER1 : public D3D12_ROOT_PARAMETER1
+{
+    CD3DX12_ROOT_PARAMETER1() = default;
+    explicit CD3DX12_ROOT_PARAMETER1(const D3D12_ROOT_PARAMETER1 &o) :
+        D3D12_ROOT_PARAMETER1(o)
+    {}
+    
+    static inline void InitAsDescriptorTable(
+        _Out_ D3D12_ROOT_PARAMETER1 &rootParam,
+        UINT numDescriptorRanges,
+        _In_reads_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* pDescriptorRanges,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_DESCRIPTOR_TABLE1::Init(rootParam.DescriptorTable, numDescriptorRanges, pDescriptorRanges);
+    }
+
+    static inline void InitAsConstants(
+        _Out_ D3D12_ROOT_PARAMETER1 &rootParam,
+        UINT num32BitValues,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_CONSTANTS::Init(rootParam.Constants, num32BitValues, shaderRegister, registerSpace);
+    }
+
+    static inline void InitAsConstantBufferView(
+        _Out_ D3D12_ROOT_PARAMETER1 &rootParam,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_DESCRIPTOR1::Init(rootParam.Descriptor, shaderRegister, registerSpace, flags);
+    }
+
+    static inline void InitAsShaderResourceView(
+        _Out_ D3D12_ROOT_PARAMETER1 &rootParam,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_SRV;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_DESCRIPTOR1::Init(rootParam.Descriptor, shaderRegister, registerSpace, flags);
+    }
+
+    static inline void InitAsUnorderedAccessView(
+        _Out_ D3D12_ROOT_PARAMETER1 &rootParam,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_UAV;
+        rootParam.ShaderVisibility = visibility;
+        CD3DX12_ROOT_DESCRIPTOR1::Init(rootParam.Descriptor, shaderRegister, registerSpace, flags);
+    }
+    
+    inline void InitAsDescriptorTable(
+        UINT numDescriptorRanges,
+        _In_reads_(numDescriptorRanges) const D3D12_DESCRIPTOR_RANGE1* pDescriptorRanges,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsDescriptorTable(*this, numDescriptorRanges, pDescriptorRanges, visibility);
+    }
+    
+    inline void InitAsConstants(
+        UINT num32BitValues,
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsConstants(*this, num32BitValues, shaderRegister, registerSpace, visibility);
+    }
+
+    inline void InitAsConstantBufferView(
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsConstantBufferView(*this, shaderRegister, registerSpace, flags, visibility);
+    }
+
+    inline void InitAsShaderResourceView(
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsShaderResourceView(*this, shaderRegister, registerSpace, flags, visibility);
+    }
+
+    inline void InitAsUnorderedAccessView(
+        UINT shaderRegister,
+        UINT registerSpace = 0,
+        D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
+        D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL)
+    {
+        InitAsUnorderedAccessView(*this, shaderRegister, registerSpace, flags, visibility);
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC : public D3D12_VERSIONED_ROOT_SIGNATURE_DESC
+{
+    CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC() = default;
+    explicit CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(const D3D12_VERSIONED_ROOT_SIGNATURE_DESC &o) :
+        D3D12_VERSIONED_ROOT_SIGNATURE_DESC(o)
+    {}
+    explicit CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(const D3D12_ROOT_SIGNATURE_DESC &o)
+    {
+        Version = D3D_ROOT_SIGNATURE_VERSION_1_0;
+        Desc_1_0 = o;
+    }
+    explicit CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(const D3D12_ROOT_SIGNATURE_DESC1 &o)
+    {
+        Version = D3D_ROOT_SIGNATURE_VERSION_1_1;
+        Desc_1_1 = o;
+    }
+    CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(
+        UINT numParameters,
+        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
+        UINT numStaticSamplers = 0,
+        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
+        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE)
+    {
+        Init_1_0(numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
+    }
+    CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(
+        UINT numParameters,
+        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER1* _pParameters,
+        UINT numStaticSamplers = 0,
+        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
+        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE)
+    {
+        Init_1_1(numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
+    }
+    CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC(CD3DX12_DEFAULT)
+    {
+        Init_1_1(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_NONE);
+    }
+    
+    inline void Init_1_0(
+        UINT numParameters,
+        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
+        UINT numStaticSamplers = 0,
+        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
+        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE)
+    {
+        Init_1_0(*this, numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
+    }
+
+    static inline void Init_1_0(
+        _Out_ D3D12_VERSIONED_ROOT_SIGNATURE_DESC &desc,
+        UINT numParameters,
+        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER* _pParameters,
+        UINT numStaticSamplers = 0,
+        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
+        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE)
+    {
+        desc.Version = D3D_ROOT_SIGNATURE_VERSION_1_0;
+        desc.Desc_1_0.NumParameters = numParameters;
+        desc.Desc_1_0.pParameters = _pParameters;
+        desc.Desc_1_0.NumStaticSamplers = numStaticSamplers;
+        desc.Desc_1_0.pStaticSamplers = _pStaticSamplers;
+        desc.Desc_1_0.Flags = flags;
+    }
+
+    inline void Init_1_1(
+        UINT numParameters,
+        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER1* _pParameters,
+        UINT numStaticSamplers = 0,
+        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
+        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE)
+    {
+        Init_1_1(*this, numParameters, _pParameters, numStaticSamplers, _pStaticSamplers, flags);
+    }
+
+    static inline void Init_1_1(
+        _Out_ D3D12_VERSIONED_ROOT_SIGNATURE_DESC &desc,
+        UINT numParameters,
+        _In_reads_opt_(numParameters) const D3D12_ROOT_PARAMETER1* _pParameters,
+        UINT numStaticSamplers = 0,
+        _In_reads_opt_(numStaticSamplers) const D3D12_STATIC_SAMPLER_DESC* _pStaticSamplers = nullptr,
+        D3D12_ROOT_SIGNATURE_FLAGS flags = D3D12_ROOT_SIGNATURE_FLAG_NONE)
+    {
+        desc.Version = D3D_ROOT_SIGNATURE_VERSION_1_1;
+        desc.Desc_1_1.NumParameters = numParameters;
+        desc.Desc_1_1.pParameters = _pParameters;
+        desc.Desc_1_1.NumStaticSamplers = numStaticSamplers;
+        desc.Desc_1_1.pStaticSamplers = _pStaticSamplers;
+        desc.Desc_1_1.Flags = flags;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_CPU_DESCRIPTOR_HANDLE : public D3D12_CPU_DESCRIPTOR_HANDLE
+{
+    CD3DX12_CPU_DESCRIPTOR_HANDLE() = default;
+    explicit CD3DX12_CPU_DESCRIPTOR_HANDLE(const D3D12_CPU_DESCRIPTOR_HANDLE &o) :
+        D3D12_CPU_DESCRIPTOR_HANDLE(o)
+    {}
+    CD3DX12_CPU_DESCRIPTOR_HANDLE(CD3DX12_DEFAULT) { ptr = 0; }
+    CD3DX12_CPU_DESCRIPTOR_HANDLE(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE &other, INT offsetScaledByIncrementSize)
+    {
+        InitOffsetted(other, offsetScaledByIncrementSize);
+    }
+    CD3DX12_CPU_DESCRIPTOR_HANDLE(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE &other, INT offsetInDescriptors, UINT descriptorIncrementSize)
+    {
+        InitOffsetted(other, offsetInDescriptors, descriptorIncrementSize);
+    }
+    CD3DX12_CPU_DESCRIPTOR_HANDLE& Offset(INT offsetInDescriptors, UINT descriptorIncrementSize)
+    { 
+        ptr = SIZE_T(INT64(ptr) + INT64(offsetInDescriptors) * INT64(descriptorIncrementSize));
+        return *this;
+    }
+    CD3DX12_CPU_DESCRIPTOR_HANDLE& Offset(INT offsetScaledByIncrementSize) 
+    { 
+        ptr = SIZE_T(INT64(ptr) + INT64(offsetScaledByIncrementSize));
+        return *this;
+    }
+    bool operator==(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE& other) const
+    {
+        return (ptr == other.ptr);
+    }
+    bool operator!=(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE& other) const
+    {
+        return (ptr != other.ptr);
+    }
+    CD3DX12_CPU_DESCRIPTOR_HANDLE &operator=(const D3D12_CPU_DESCRIPTOR_HANDLE &other)
+    {
+        ptr = other.ptr;
+        return *this;
+    }
+
+    inline void InitOffsetted(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE &base, INT offsetScaledByIncrementSize)
+    {
+        InitOffsetted(*this, base, offsetScaledByIncrementSize);
+    }
+    
+    inline void InitOffsetted(_In_ const D3D12_CPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize)
+    {
+        InitOffsetted(*this, base, offsetInDescriptors, descriptorIncrementSize);
+    }
+    
+    static inline void InitOffsetted(_Out_ D3D12_CPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_CPU_DESCRIPTOR_HANDLE &base, INT offsetScaledByIncrementSize)
+    {
+        handle.ptr = SIZE_T(INT64(base.ptr) + INT64(offsetScaledByIncrementSize));
+    }
+    
+    static inline void InitOffsetted(_Out_ D3D12_CPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_CPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize)
+    {
+        handle.ptr = SIZE_T(INT64(base.ptr) + INT64(offsetInDescriptors) * INT64(descriptorIncrementSize));
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_GPU_DESCRIPTOR_HANDLE : public D3D12_GPU_DESCRIPTOR_HANDLE
+{
+    CD3DX12_GPU_DESCRIPTOR_HANDLE() = default;
+    explicit CD3DX12_GPU_DESCRIPTOR_HANDLE(const D3D12_GPU_DESCRIPTOR_HANDLE &o) :
+        D3D12_GPU_DESCRIPTOR_HANDLE(o)
+    {}
+    CD3DX12_GPU_DESCRIPTOR_HANDLE(CD3DX12_DEFAULT) { ptr = 0; }
+    CD3DX12_GPU_DESCRIPTOR_HANDLE(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE &other, INT offsetScaledByIncrementSize)
+    {
+        InitOffsetted(other, offsetScaledByIncrementSize);
+    }
+    CD3DX12_GPU_DESCRIPTOR_HANDLE(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE &other, INT offsetInDescriptors, UINT descriptorIncrementSize)
+    {
+        InitOffsetted(other, offsetInDescriptors, descriptorIncrementSize);
+    }
+    CD3DX12_GPU_DESCRIPTOR_HANDLE& Offset(INT offsetInDescriptors, UINT descriptorIncrementSize)
+    { 
+        ptr = UINT64(INT64(ptr) + INT64(offsetInDescriptors) * INT64(descriptorIncrementSize));
+        return *this;
+    }
+    CD3DX12_GPU_DESCRIPTOR_HANDLE& Offset(INT offsetScaledByIncrementSize) 
+    { 
+        ptr = UINT64(INT64(ptr) + INT64(offsetScaledByIncrementSize));
+        return *this;
+    }
+    inline bool operator==(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE& other) const
+    {
+        return (ptr == other.ptr);
+    }
+    inline bool operator!=(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE& other) const
+    {
+        return (ptr != other.ptr);
+    }
+    CD3DX12_GPU_DESCRIPTOR_HANDLE &operator=(const D3D12_GPU_DESCRIPTOR_HANDLE &other)
+    {
+        ptr = other.ptr;
+        return *this;
+    }
+
+    inline void InitOffsetted(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE &base, INT offsetScaledByIncrementSize)
+    {
+        InitOffsetted(*this, base, offsetScaledByIncrementSize);
+    }
+    
+    inline void InitOffsetted(_In_ const D3D12_GPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize)
+    {
+        InitOffsetted(*this, base, offsetInDescriptors, descriptorIncrementSize);
+    }
+    
+    static inline void InitOffsetted(_Out_ D3D12_GPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_GPU_DESCRIPTOR_HANDLE &base, INT offsetScaledByIncrementSize)
+    {
+        handle.ptr = UINT64(INT64(base.ptr) + INT64(offsetScaledByIncrementSize));
+    }
+    
+    static inline void InitOffsetted(_Out_ D3D12_GPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_GPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize)
+    {
+        handle.ptr = UINT64(INT64(base.ptr) + INT64(offsetInDescriptors) * INT64(descriptorIncrementSize));
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+inline UINT D3D12CalcSubresource( UINT MipSlice, UINT ArraySlice, UINT PlaneSlice, UINT MipLevels, UINT ArraySize )
+{ 
+    return MipSlice + ArraySlice * MipLevels + PlaneSlice * MipLevels * ArraySize; 
+}
+
+//------------------------------------------------------------------------------------------------
+template <typename T, typename U, typename V>
+inline void D3D12DecomposeSubresource( UINT Subresource, UINT MipLevels, UINT ArraySize, _Out_ T& MipSlice, _Out_ U& ArraySlice, _Out_ V& PlaneSlice )
+{
+    MipSlice = static_cast<T>(Subresource % MipLevels);
+    ArraySlice = static_cast<U>((Subresource / MipLevels) % ArraySize);
+    PlaneSlice = static_cast<V>(Subresource / (MipLevels * ArraySize));
+}
+
+//------------------------------------------------------------------------------------------------
+inline UINT8 D3D12GetFormatPlaneCount(
+    _In_ ID3D12Device* pDevice,
+    DXGI_FORMAT Format
+    )
+{
+    D3D12_FEATURE_DATA_FORMAT_INFO formatInfo = { Format, 0 };
+    if (FAILED(pDevice->CheckFeatureSupport(D3D12_FEATURE_FORMAT_INFO, &formatInfo, sizeof(formatInfo))))
+    {
+        return 0;
+    }
+    return formatInfo.PlaneCount;
+}
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_RESOURCE_DESC : public D3D12_RESOURCE_DESC
+{
+    CD3DX12_RESOURCE_DESC() = default;
+    explicit CD3DX12_RESOURCE_DESC( const D3D12_RESOURCE_DESC& o ) :
+        D3D12_RESOURCE_DESC( o )
+    {}
+    CD3DX12_RESOURCE_DESC( 
+        D3D12_RESOURCE_DIMENSION dimension,
+        UINT64 alignment,
+        UINT64 width,
+        UINT height,
+        UINT16 depthOrArraySize,
+        UINT16 mipLevels,
+        DXGI_FORMAT format,
+        UINT sampleCount,
+        UINT sampleQuality,
+        D3D12_TEXTURE_LAYOUT layout,
+        D3D12_RESOURCE_FLAGS flags )
+    {
+        Dimension = dimension;
+        Alignment = alignment;
+        Width = width;
+        Height = height;
+        DepthOrArraySize = depthOrArraySize;
+        MipLevels = mipLevels;
+        Format = format;
+        SampleDesc.Count = sampleCount;
+        SampleDesc.Quality = sampleQuality;
+        Layout = layout;
+        Flags = flags;
+    }
+    static inline CD3DX12_RESOURCE_DESC Buffer( 
+        const D3D12_RESOURCE_ALLOCATION_INFO& resAllocInfo,
+        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE )
+    {
+        return CD3DX12_RESOURCE_DESC( D3D12_RESOURCE_DIMENSION_BUFFER, resAllocInfo.Alignment, resAllocInfo.SizeInBytes, 
+            1, 1, 1, DXGI_FORMAT_UNKNOWN, 1, 0, D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags );
+    }
+    static inline CD3DX12_RESOURCE_DESC Buffer( 
+        UINT64 width,
+        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
+        UINT64 alignment = 0 )
+    {
+        return CD3DX12_RESOURCE_DESC( D3D12_RESOURCE_DIMENSION_BUFFER, alignment, width, 1, 1, 1, 
+            DXGI_FORMAT_UNKNOWN, 1, 0, D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags );
+    }
+    static inline CD3DX12_RESOURCE_DESC Tex1D( 
+        DXGI_FORMAT format,
+        UINT64 width,
+        UINT16 arraySize = 1,
+        UINT16 mipLevels = 0,
+        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
+        D3D12_TEXTURE_LAYOUT layout = D3D12_TEXTURE_LAYOUT_UNKNOWN,
+        UINT64 alignment = 0 )
+    {
+        return CD3DX12_RESOURCE_DESC( D3D12_RESOURCE_DIMENSION_TEXTURE1D, alignment, width, 1, arraySize, 
+            mipLevels, format, 1, 0, layout, flags );
+    }
+    static inline CD3DX12_RESOURCE_DESC Tex2D( 
+        DXGI_FORMAT format,
+        UINT64 width,
+        UINT height,
+        UINT16 arraySize = 1,
+        UINT16 mipLevels = 0,
+        UINT sampleCount = 1,
+        UINT sampleQuality = 0,
+        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
+        D3D12_TEXTURE_LAYOUT layout = D3D12_TEXTURE_LAYOUT_UNKNOWN,
+        UINT64 alignment = 0 )
+    {
+        return CD3DX12_RESOURCE_DESC( D3D12_RESOURCE_DIMENSION_TEXTURE2D, alignment, width, height, arraySize, 
+            mipLevels, format, sampleCount, sampleQuality, layout, flags );
+    }
+    static inline CD3DX12_RESOURCE_DESC Tex3D( 
+        DXGI_FORMAT format,
+        UINT64 width,
+        UINT height,
+        UINT16 depth,
+        UINT16 mipLevels = 0,
+        D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE,
+        D3D12_TEXTURE_LAYOUT layout = D3D12_TEXTURE_LAYOUT_UNKNOWN,
+        UINT64 alignment = 0 )
+    {
+        return CD3DX12_RESOURCE_DESC( D3D12_RESOURCE_DIMENSION_TEXTURE3D, alignment, width, height, depth, 
+            mipLevels, format, 1, 0, layout, flags );
+    }
+    inline UINT16 Depth() const
+    { return (Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D ? DepthOrArraySize : 1); }
+    inline UINT16 ArraySize() const
+    { return (Dimension != D3D12_RESOURCE_DIMENSION_TEXTURE3D ? DepthOrArraySize : 1); }
+    inline UINT8 PlaneCount(_In_ ID3D12Device* pDevice) const
+    { return D3D12GetFormatPlaneCount(pDevice, Format); }
+    inline UINT Subresources(_In_ ID3D12Device* pDevice) const
+    { return MipLevels * ArraySize() * PlaneCount(pDevice); }
+    inline UINT CalcSubresource(UINT MipSlice, UINT ArraySlice, UINT PlaneSlice)
+    { return D3D12CalcSubresource(MipSlice, ArraySlice, PlaneSlice, MipLevels, ArraySize()); }
+};
+inline bool operator==( const D3D12_RESOURCE_DESC& l, const D3D12_RESOURCE_DESC& r )
+{
+    return l.Dimension == r.Dimension &&
+        l.Alignment == r.Alignment &&
+        l.Width == r.Width &&
+        l.Height == r.Height &&
+        l.DepthOrArraySize == r.DepthOrArraySize &&
+        l.MipLevels == r.MipLevels &&
+        l.Format == r.Format &&
+        l.SampleDesc.Count == r.SampleDesc.Count &&
+        l.SampleDesc.Quality == r.SampleDesc.Quality &&
+        l.Layout == r.Layout &&
+        l.Flags == r.Flags;
+}
+inline bool operator!=( const D3D12_RESOURCE_DESC& l, const D3D12_RESOURCE_DESC& r )
+{ return !( l == r ); }
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_VIEW_INSTANCING_DESC : public D3D12_VIEW_INSTANCING_DESC
+{
+    CD3DX12_VIEW_INSTANCING_DESC() = default;
+    explicit CD3DX12_VIEW_INSTANCING_DESC( const D3D12_VIEW_INSTANCING_DESC& o ) :
+        D3D12_VIEW_INSTANCING_DESC( o )
+    {}
+    explicit CD3DX12_VIEW_INSTANCING_DESC( CD3DX12_DEFAULT )
+    {
+        ViewInstanceCount = 0;
+        pViewInstanceLocations = nullptr;
+        Flags = D3D12_VIEW_INSTANCING_FLAG_NONE;
+    }
+    explicit CD3DX12_VIEW_INSTANCING_DESC( 
+        UINT InViewInstanceCount,
+        const D3D12_VIEW_INSTANCE_LOCATION* InViewInstanceLocations,
+        D3D12_VIEW_INSTANCING_FLAGS InFlags)
+    {
+        ViewInstanceCount = InViewInstanceCount;
+        pViewInstanceLocations = InViewInstanceLocations;
+        Flags = InFlags;
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+// Row-by-row memcpy
+inline void MemcpySubresource(
+    _In_ const D3D12_MEMCPY_DEST* pDest,
+    _In_ const D3D12_SUBRESOURCE_DATA* pSrc,
+    SIZE_T RowSizeInBytes,
+    UINT NumRows,
+    UINT NumSlices)
+{
+    for (UINT z = 0; z < NumSlices; ++z)
+    {
+        auto pDestSlice = reinterpret_cast<BYTE*>(pDest->pData) + pDest->SlicePitch * z;
+        auto pSrcSlice = reinterpret_cast<const BYTE*>(pSrc->pData) + pSrc->SlicePitch * LONG_PTR(z);
+        for (UINT y = 0; y < NumRows; ++y)
+        {
+            memcpy(pDestSlice + pDest->RowPitch * y,
+                   pSrcSlice + pSrc->RowPitch * LONG_PTR(y),
+                   RowSizeInBytes);
+        }
+    }
+}
+
+//------------------------------------------------------------------------------------------------
+// Returns required size of a buffer to be used for data upload
+inline UINT64 GetRequiredIntermediateSize(
+    _In_ ID3D12Resource* pDestinationResource,
+    _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
+    _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources)
+{
+    auto Desc = pDestinationResource->GetDesc();
+    UINT64 RequiredSize = 0;
+    
+    ID3D12Device* pDevice = nullptr;
+    pDestinationResource->GetDevice(IID_ID3D12Device, reinterpret_cast<void**>(&pDevice));
+    pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr, &RequiredSize);
+    pDevice->Release();
+    
+    return RequiredSize;
+}
+
+//------------------------------------------------------------------------------------------------
+// All arrays must be populated (e.g. by calling GetCopyableFootprints)
+inline UINT64 UpdateSubresources(
+    _In_ ID3D12GraphicsCommandList* pCmdList,
+    _In_ ID3D12Resource* pDestinationResource,
+    _In_ ID3D12Resource* pIntermediate,
+    _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
+    _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources,
+    UINT64 RequiredSize,
+    _In_reads_(NumSubresources) const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts,
+    _In_reads_(NumSubresources) const UINT* pNumRows,
+    _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes,
+    _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData)
+{
+    // Minor validation
+    auto IntermediateDesc = pIntermediate->GetDesc();
+    auto DestinationDesc = pDestinationResource->GetDesc();
+    if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER || 
+        IntermediateDesc.Width < RequiredSize + pLayouts[0].Offset || 
+        RequiredSize > SIZE_T(-1) || 
+        (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER && 
+            (FirstSubresource != 0 || NumSubresources != 1)))
+    {
+        return 0;
+    }
+    
+    BYTE* pData;
+    HRESULT hr = pIntermediate->Map(0, nullptr, reinterpret_cast<void**>(&pData));
+    if (FAILED(hr))
+    {
+        return 0;
+    }
+    
+    for (UINT i = 0; i < NumSubresources; ++i)
+    {
+        if (pRowSizesInBytes[i] > SIZE_T(-1)) return 0;
+        D3D12_MEMCPY_DEST DestData = { pData + pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, SIZE_T(pLayouts[i].Footprint.RowPitch) * SIZE_T(pNumRows[i]) };
+        MemcpySubresource(&DestData, &pSrcData[i], static_cast<SIZE_T>(pRowSizesInBytes[i]), pNumRows[i], pLayouts[i].Footprint.Depth);
+    }
+    pIntermediate->Unmap(0, nullptr);
+    
+    if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER)
+    {
+        pCmdList->CopyBufferRegion(
+            pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width);
+    }
+    else
+    {
+        for (UINT i = 0; i < NumSubresources; ++i)
+        {
+            CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
+            CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]);
+            pCmdList->CopyTextureRegion(&Dst, 0, 0, 0, &Src, nullptr);
+        }
+    }
+    return RequiredSize;
+}
+
+//------------------------------------------------------------------------------------------------
+// Heap-allocating UpdateSubresources implementation
+inline UINT64 UpdateSubresources( 
+    _In_ ID3D12GraphicsCommandList* pCmdList,
+    _In_ ID3D12Resource* pDestinationResource,
+    _In_ ID3D12Resource* pIntermediate,
+    UINT64 IntermediateOffset,
+    _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
+    _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources,
+    _In_reads_(NumSubresources) D3D12_SUBRESOURCE_DATA* pSrcData)
+{
+    UINT64 RequiredSize = 0;
+    UINT64 MemToAlloc = static_cast<UINT64>(sizeof(D3D12_PLACED_SUBRESOURCE_FOOTPRINT) + sizeof(UINT) + sizeof(UINT64)) * NumSubresources;
+    if (MemToAlloc > SIZE_MAX)
+    {
+       return 0;
+    }
+    void* pMem = HeapAlloc(GetProcessHeap(), 0, static_cast<SIZE_T>(MemToAlloc));
+    if (pMem == nullptr)
+    {
+       return 0;
+    }
+    auto pLayouts = reinterpret_cast<D3D12_PLACED_SUBRESOURCE_FOOTPRINT*>(pMem);
+    UINT64* pRowSizesInBytes = reinterpret_cast<UINT64*>(pLayouts + NumSubresources);
+    UINT* pNumRows = reinterpret_cast<UINT*>(pRowSizesInBytes + NumSubresources);
+    
+    auto Desc = pDestinationResource->GetDesc();
+    ID3D12Device* pDevice = nullptr;
+    pDestinationResource->GetDevice(IID_ID3D12Device, reinterpret_cast<void**>(&pDevice));
+    pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, IntermediateOffset, pLayouts, pNumRows, pRowSizesInBytes, &RequiredSize);
+    pDevice->Release();
+    
+    UINT64 Result = UpdateSubresources(pCmdList, pDestinationResource, pIntermediate, FirstSubresource, NumSubresources, RequiredSize, pLayouts, pNumRows, pRowSizesInBytes, pSrcData);
+    HeapFree(GetProcessHeap(), 0, pMem);
+    return Result;
+}
+
+//------------------------------------------------------------------------------------------------
+// Stack-allocating UpdateSubresources implementation
+template <UINT MaxSubresources>
+inline UINT64 UpdateSubresources( 
+    _In_ ID3D12GraphicsCommandList* pCmdList,
+    _In_ ID3D12Resource* pDestinationResource,
+    _In_ ID3D12Resource* pIntermediate,
+    UINT64 IntermediateOffset,
+    _In_range_(0, MaxSubresources) UINT FirstSubresource,
+    _In_range_(1, MaxSubresources - FirstSubresource) UINT NumSubresources,
+    _In_reads_(NumSubresources) D3D12_SUBRESOURCE_DATA* pSrcData)
+{
+    UINT64 RequiredSize = 0;
+    D3D12_PLACED_SUBRESOURCE_FOOTPRINT Layouts[MaxSubresources];
+    UINT NumRows[MaxSubresources];
+    UINT64 RowSizesInBytes[MaxSubresources];
+    
+    auto Desc = pDestinationResource->GetDesc();
+    ID3D12Device* pDevice = nullptr;
+    pDestinationResource->GetDevice(IID_ID3D12Device, reinterpret_cast<void**>(&pDevice));
+    pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, IntermediateOffset, Layouts, NumRows, RowSizesInBytes, &RequiredSize);
+    pDevice->Release();
+    
+    return UpdateSubresources(pCmdList, pDestinationResource, pIntermediate, FirstSubresource, NumSubresources, RequiredSize, Layouts, NumRows, RowSizesInBytes, pSrcData);
+}
+
+//------------------------------------------------------------------------------------------------
+inline bool D3D12IsLayoutOpaque( D3D12_TEXTURE_LAYOUT Layout )
+{ return Layout == D3D12_TEXTURE_LAYOUT_UNKNOWN || Layout == D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE; }
+
+//------------------------------------------------------------------------------------------------
+template <typename t_CommandListType>
+inline ID3D12CommandList * const * CommandListCast(t_CommandListType * const * pp)
+{
+    // This cast is useful for passing strongly typed command list pointers into
+    // ExecuteCommandLists.
+    // This cast is valid as long as the const-ness is respected. D3D12 APIs do
+    // respect the const-ness of their arguments.
+    return reinterpret_cast<ID3D12CommandList * const *>(pp);
+}
+
+//------------------------------------------------------------------------------------------------
+// D3D12 exports a new method for serializing root signatures in the Windows 10 Anniversary Update.
+// To help enable root signature 1.1 features when they are available and not require maintaining
+// two code paths for building root signatures, this helper method reconstructs a 1.0 signature when
+// 1.1 is not supported.
+inline HRESULT D3DX12SerializeVersionedRootSignature(
+    _In_ const D3D12_VERSIONED_ROOT_SIGNATURE_DESC* pRootSignatureDesc,
+    D3D_ROOT_SIGNATURE_VERSION MaxVersion,
+    _Outptr_ ID3DBlob** ppBlob,
+    _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorBlob)
+{
+    if (ppErrorBlob != nullptr)
+    {
+        *ppErrorBlob = nullptr;
+    }
+
+    switch (MaxVersion)
+    {
+        case D3D_ROOT_SIGNATURE_VERSION_1_0:
+            switch (pRootSignatureDesc->Version)
+            {
+                case D3D_ROOT_SIGNATURE_VERSION_1_0:
+                    return D3D12SerializeRootSignature(&pRootSignatureDesc->Desc_1_0, D3D_ROOT_SIGNATURE_VERSION_1, ppBlob, ppErrorBlob);
+
+                case D3D_ROOT_SIGNATURE_VERSION_1_1:
+                {
+                    HRESULT hr = S_OK;
+                    const D3D12_ROOT_SIGNATURE_DESC1& desc_1_1 = pRootSignatureDesc->Desc_1_1;
+
+                    const SIZE_T ParametersSize = sizeof(D3D12_ROOT_PARAMETER) * desc_1_1.NumParameters;
+                    void* pParameters = (ParametersSize > 0) ? HeapAlloc(GetProcessHeap(), 0, ParametersSize) : nullptr;
+                    if (ParametersSize > 0 && pParameters == nullptr)
+                    {
+                        hr = E_OUTOFMEMORY;
+                    }
+                    auto pParameters_1_0 = reinterpret_cast<D3D12_ROOT_PARAMETER*>(pParameters);
+
+                    if (SUCCEEDED(hr))
+                    {
+                        for (UINT n = 0; n < desc_1_1.NumParameters; n++)
+                        {
+                            __analysis_assume(ParametersSize == sizeof(D3D12_ROOT_PARAMETER) * desc_1_1.NumParameters);
+                            pParameters_1_0[n].ParameterType = desc_1_1.pParameters[n].ParameterType;
+                            pParameters_1_0[n].ShaderVisibility = desc_1_1.pParameters[n].ShaderVisibility;
+
+                            switch (desc_1_1.pParameters[n].ParameterType)
+                            {
+                            case D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS:
+                                pParameters_1_0[n].Constants.Num32BitValues = desc_1_1.pParameters[n].Constants.Num32BitValues;
+                                pParameters_1_0[n].Constants.RegisterSpace = desc_1_1.pParameters[n].Constants.RegisterSpace;
+                                pParameters_1_0[n].Constants.ShaderRegister = desc_1_1.pParameters[n].Constants.ShaderRegister;
+                                break;
+
+                            case D3D12_ROOT_PARAMETER_TYPE_CBV:
+                            case D3D12_ROOT_PARAMETER_TYPE_SRV:
+                            case D3D12_ROOT_PARAMETER_TYPE_UAV:
+                                pParameters_1_0[n].Descriptor.RegisterSpace = desc_1_1.pParameters[n].Descriptor.RegisterSpace;
+                                pParameters_1_0[n].Descriptor.ShaderRegister = desc_1_1.pParameters[n].Descriptor.ShaderRegister;
+                                break;
+
+                            case D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE:
+                                const D3D12_ROOT_DESCRIPTOR_TABLE1& table_1_1 = desc_1_1.pParameters[n].DescriptorTable;
+
+                                const SIZE_T DescriptorRangesSize = sizeof(D3D12_DESCRIPTOR_RANGE) * table_1_1.NumDescriptorRanges;
+                                void* pDescriptorRanges = (DescriptorRangesSize > 0 && SUCCEEDED(hr)) ? HeapAlloc(GetProcessHeap(), 0, DescriptorRangesSize) : nullptr;
+                                if (DescriptorRangesSize > 0 && pDescriptorRanges == nullptr)
+                                {
+                                    hr = E_OUTOFMEMORY;
+                                }
+                                auto pDescriptorRanges_1_0 = reinterpret_cast<D3D12_DESCRIPTOR_RANGE*>(pDescriptorRanges);
+
+                                if (SUCCEEDED(hr))
+                                {
+                                    for (UINT x = 0; x < table_1_1.NumDescriptorRanges; x++)
+                                    {
+                                        __analysis_assume(DescriptorRangesSize == sizeof(D3D12_DESCRIPTOR_RANGE) * table_1_1.NumDescriptorRanges);
+                                        pDescriptorRanges_1_0[x].BaseShaderRegister = table_1_1.pDescriptorRanges[x].BaseShaderRegister;
+                                        pDescriptorRanges_1_0[x].NumDescriptors = table_1_1.pDescriptorRanges[x].NumDescriptors;
+                                        pDescriptorRanges_1_0[x].OffsetInDescriptorsFromTableStart = table_1_1.pDescriptorRanges[x].OffsetInDescriptorsFromTableStart;
+                                        pDescriptorRanges_1_0[x].RangeType = table_1_1.pDescriptorRanges[x].RangeType;
+                                        pDescriptorRanges_1_0[x].RegisterSpace = table_1_1.pDescriptorRanges[x].RegisterSpace;
+                                    }
+                                }
+
+                                D3D12_ROOT_DESCRIPTOR_TABLE& table_1_0 = pParameters_1_0[n].DescriptorTable;
+                                table_1_0.NumDescriptorRanges = table_1_1.NumDescriptorRanges;
+                                table_1_0.pDescriptorRanges = pDescriptorRanges_1_0;
+                            }
+                        }
+                    }
+
+                    if (SUCCEEDED(hr))
+                    {
+                        CD3DX12_ROOT_SIGNATURE_DESC desc_1_0(desc_1_1.NumParameters, pParameters_1_0, desc_1_1.NumStaticSamplers, desc_1_1.pStaticSamplers, desc_1_1.Flags);
+                        hr = D3D12SerializeRootSignature(&desc_1_0, D3D_ROOT_SIGNATURE_VERSION_1, ppBlob, ppErrorBlob);
+                    }
+
+                    if (pParameters)
+                    {
+                        for (UINT n = 0; n < desc_1_1.NumParameters; n++)
+                        {
+                            if (desc_1_1.pParameters[n].ParameterType == D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE)
+                            {
+                                HeapFree(GetProcessHeap(), 0, reinterpret_cast<void*>(const_cast<D3D12_DESCRIPTOR_RANGE*>(pParameters_1_0[n].DescriptorTable.pDescriptorRanges)));
+                            }
+                        }
+                        HeapFree(GetProcessHeap(), 0, pParameters);
+                    }
+                    return hr;
+                }
+            }
+            break;
+
+        case D3D_ROOT_SIGNATURE_VERSION_1_1:
+            return D3D12SerializeVersionedRootSignature(pRootSignatureDesc, ppBlob, ppErrorBlob);
+    }
+
+    return E_INVALIDARG;
+}
+
+//------------------------------------------------------------------------------------------------
+struct CD3DX12_RT_FORMAT_ARRAY : public D3D12_RT_FORMAT_ARRAY
+{
+    CD3DX12_RT_FORMAT_ARRAY() = default;
+    explicit CD3DX12_RT_FORMAT_ARRAY(const D3D12_RT_FORMAT_ARRAY& o)
+        : D3D12_RT_FORMAT_ARRAY(o)
+    {}
+    explicit CD3DX12_RT_FORMAT_ARRAY(_In_reads_(NumFormats) const DXGI_FORMAT* pFormats, UINT NumFormats)
+    {
+        NumRenderTargets = NumFormats;
+        memcpy(RTFormats, pFormats, sizeof(RTFormats));
+        // assumes ARRAY_SIZE(pFormats) == ARRAY_SIZE(RTFormats)
+    }
+};
+
+//------------------------------------------------------------------------------------------------
+// Pipeline State Stream Helpers
+//------------------------------------------------------------------------------------------------
+
+//------------------------------------------------------------------------------------------------
+// Stream Subobjects, i.e. elements of a stream
+
+struct DefaultSampleMask { operator UINT() { return UINT_MAX; } };
+struct DefaultSampleDesc { operator DXGI_SAMPLE_DESC() { return DXGI_SAMPLE_DESC{1, 0}; } };
+
+#pragma warning(push)
+#pragma warning(disable : 4324)
+template <typename InnerStructType, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE Type, typename DefaultArg = InnerStructType>
+class alignas(void*) CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT
+{
+private:
+    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE _Type;
+    InnerStructType _Inner;
+public:
+    CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT() noexcept : _Type(Type), _Inner(DefaultArg()) {}
+    CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT(InnerStructType const& i) : _Type(Type), _Inner(i) {}
+    CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT& operator=(InnerStructType const& i) { _Inner = i; return *this; }
+    operator InnerStructType const&() const { return _Inner; }
+    operator InnerStructType&() { return _Inner; }
+    InnerStructType* operator&() { return &_Inner; }
+    InnerStructType const* operator&() const { return &_Inner; }
+};
+#pragma warning(pop)
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_PIPELINE_STATE_FLAGS,         D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS>                             CD3DX12_PIPELINE_STATE_STREAM_FLAGS;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< UINT,                               D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK>                         CD3DX12_PIPELINE_STATE_STREAM_NODE_MASK;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< ID3D12RootSignature*,               D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE>                    CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_INPUT_LAYOUT_DESC,            D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT>                      CD3DX12_PIPELINE_STATE_STREAM_INPUT_LAYOUT;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_INDEX_BUFFER_STRIP_CUT_VALUE, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE>                CD3DX12_PIPELINE_STATE_STREAM_IB_STRIP_CUT_VALUE;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_PRIMITIVE_TOPOLOGY_TYPE,      D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY>                CD3DX12_PIPELINE_STATE_STREAM_PRIMITIVE_TOPOLOGY;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE,              D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VS>                                CD3DX12_PIPELINE_STATE_STREAM_VS;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE,              D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_GS>                                CD3DX12_PIPELINE_STATE_STREAM_GS;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_STREAM_OUTPUT_DESC,           D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT>                     CD3DX12_PIPELINE_STATE_STREAM_STREAM_OUTPUT;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE,              D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_HS>                                CD3DX12_PIPELINE_STATE_STREAM_HS;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE,              D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DS>                                CD3DX12_PIPELINE_STATE_STREAM_DS;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE,              D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS>                                CD3DX12_PIPELINE_STATE_STREAM_PS;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_SHADER_BYTECODE,              D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CS>                                CD3DX12_PIPELINE_STATE_STREAM_CS;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_BLEND_DESC,                 D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND,          CD3DX12_DEFAULT>   CD3DX12_PIPELINE_STATE_STREAM_BLEND_DESC;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_DEPTH_STENCIL_DESC,         D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL,  CD3DX12_DEFAULT>   CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_DEPTH_STENCIL_DESC1,        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1, CD3DX12_DEFAULT>   CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL1;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< DXGI_FORMAT,                        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT>              CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_RASTERIZER_DESC,            D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER,     CD3DX12_DEFAULT>   CD3DX12_PIPELINE_STATE_STREAM_RASTERIZER;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_RT_FORMAT_ARRAY,              D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS>             CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< DXGI_SAMPLE_DESC,                   D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC,    DefaultSampleDesc> CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_DESC;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< UINT,                               D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK,    DefaultSampleMask> CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_MASK;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< D3D12_CACHED_PIPELINE_STATE,        D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO>                        CD3DX12_PIPELINE_STATE_STREAM_CACHED_PSO;
+typedef CD3DX12_PIPELINE_STATE_STREAM_SUBOBJECT< CD3DX12_VIEW_INSTANCING_DESC,       D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING, CD3DX12_DEFAULT>  CD3DX12_PIPELINE_STATE_STREAM_VIEW_INSTANCING;
+
+//------------------------------------------------------------------------------------------------
+// Stream Parser Helpers
+
+struct ID3DX12PipelineParserCallbacks
+{
+    // Subobject Callbacks
+    virtual void FlagsCb(D3D12_PIPELINE_STATE_FLAGS) {}
+    virtual void NodeMaskCb(UINT) {}
+    virtual void RootSignatureCb(ID3D12RootSignature*) {}
+    virtual void InputLayoutCb(const D3D12_INPUT_LAYOUT_DESC&) {}
+    virtual void IBStripCutValueCb(D3D12_INDEX_BUFFER_STRIP_CUT_VALUE) {}
+    virtual void PrimitiveTopologyTypeCb(D3D12_PRIMITIVE_TOPOLOGY_TYPE) {}
+    virtual void VSCb(const D3D12_SHADER_BYTECODE&) {}
+    virtual void GSCb(const D3D12_SHADER_BYTECODE&) {}
+    virtual void StreamOutputCb(const D3D12_STREAM_OUTPUT_DESC&) {}
+    virtual void HSCb(const D3D12_SHADER_BYTECODE&) {}
+    virtual void DSCb(const D3D12_SHADER_BYTECODE&) {}
+    virtual void PSCb(const D3D12_SHADER_BYTECODE&) {}
+    virtual void CSCb(const D3D12_SHADER_BYTECODE&) {}
+    virtual void BlendStateCb(const D3D12_BLEND_DESC&) {}
+    virtual void DepthStencilStateCb(const D3D12_DEPTH_STENCIL_DESC&) {}
+    virtual void DepthStencilState1Cb(const D3D12_DEPTH_STENCIL_DESC1&) {}
+    virtual void DSVFormatCb(DXGI_FORMAT) {}
+    virtual void RasterizerStateCb(const D3D12_RASTERIZER_DESC&) {}
+    virtual void RTVFormatsCb(const D3D12_RT_FORMAT_ARRAY&) {}
+    virtual void SampleDescCb(const DXGI_SAMPLE_DESC&) {}
+    virtual void SampleMaskCb(UINT) {}
+    virtual void ViewInstancingCb(const D3D12_VIEW_INSTANCING_DESC&) {}
+    virtual void CachedPSOCb(const D3D12_CACHED_PIPELINE_STATE&) {}
+
+    // Error Callbacks
+    virtual void ErrorBadInputParameter(UINT /*ParameterIndex*/) {}
+    virtual void ErrorDuplicateSubobject(D3D12_PIPELINE_STATE_SUBOBJECT_TYPE /*DuplicateType*/) {}
+    virtual void ErrorUnknownSubobject(UINT /*UnknownTypeValue*/) {}
+
+    virtual ~ID3DX12PipelineParserCallbacks() = default;
+};
+
+// CD3DX12_PIPELINE_STATE_STREAM1 Works on RS3+ (where there is a new view instancing subobject).  
+// Use CD3DX12_PIPELINE_STATE_STREAM for RS2+ support.
+struct CD3DX12_PIPELINE_STATE_STREAM1
+{
+    CD3DX12_PIPELINE_STATE_STREAM1() = default;
+    CD3DX12_PIPELINE_STATE_STREAM1(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& Desc)
+        : Flags(Desc.Flags)
+        , NodeMask(Desc.NodeMask)
+        , pRootSignature(Desc.pRootSignature)
+        , InputLayout(Desc.InputLayout)
+        , IBStripCutValue(Desc.IBStripCutValue)
+        , PrimitiveTopologyType(Desc.PrimitiveTopologyType)
+        , VS(Desc.VS)
+        , GS(Desc.GS)
+        , StreamOutput(Desc.StreamOutput)
+        , HS(Desc.HS)
+        , DS(Desc.DS)
+        , PS(Desc.PS)
+        , BlendState(CD3DX12_BLEND_DESC(Desc.BlendState))
+        , DepthStencilState(CD3DX12_DEPTH_STENCIL_DESC1(Desc.DepthStencilState))
+        , DSVFormat(Desc.DSVFormat)
+        , RasterizerState(CD3DX12_RASTERIZER_DESC(Desc.RasterizerState))
+        , RTVFormats(CD3DX12_RT_FORMAT_ARRAY(Desc.RTVFormats, Desc.NumRenderTargets))
+        , SampleDesc(Desc.SampleDesc)
+        , SampleMask(Desc.SampleMask)
+        , CachedPSO(Desc.CachedPSO)
+        , ViewInstancingDesc(CD3DX12_VIEW_INSTANCING_DESC(CD3DX12_DEFAULT()))
+    {}
+    CD3DX12_PIPELINE_STATE_STREAM1(const D3D12_COMPUTE_PIPELINE_STATE_DESC& Desc)
+        : Flags(Desc.Flags)
+        , NodeMask(Desc.NodeMask)
+        , pRootSignature(Desc.pRootSignature)
+        , CS(CD3DX12_SHADER_BYTECODE(Desc.CS))
+        , CachedPSO(Desc.CachedPSO)
+    {
+        static_cast<D3D12_DEPTH_STENCIL_DESC1&>(DepthStencilState).DepthEnable = false;
+    }
+    CD3DX12_PIPELINE_STATE_STREAM_FLAGS Flags;
+    CD3DX12_PIPELINE_STATE_STREAM_NODE_MASK NodeMask;
+    CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE pRootSignature;
+    CD3DX12_PIPELINE_STATE_STREAM_INPUT_LAYOUT InputLayout;
+    CD3DX12_PIPELINE_STATE_STREAM_IB_STRIP_CUT_VALUE IBStripCutValue;
+    CD3DX12_PIPELINE_STATE_STREAM_PRIMITIVE_TOPOLOGY PrimitiveTopologyType;
+    CD3DX12_PIPELINE_STATE_STREAM_VS VS;
+    CD3DX12_PIPELINE_STATE_STREAM_GS GS;
+    CD3DX12_PIPELINE_STATE_STREAM_STREAM_OUTPUT StreamOutput;
+    CD3DX12_PIPELINE_STATE_STREAM_HS HS;
+    CD3DX12_PIPELINE_STATE_STREAM_DS DS;
+    CD3DX12_PIPELINE_STATE_STREAM_PS PS;
+    CD3DX12_PIPELINE_STATE_STREAM_CS CS;
+    CD3DX12_PIPELINE_STATE_STREAM_BLEND_DESC BlendState;
+    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL1 DepthStencilState;
+    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT DSVFormat;
+    CD3DX12_PIPELINE_STATE_STREAM_RASTERIZER RasterizerState;
+    CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS RTVFormats;
+    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_DESC SampleDesc;
+    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_MASK SampleMask;
+    CD3DX12_PIPELINE_STATE_STREAM_CACHED_PSO CachedPSO;
+    CD3DX12_PIPELINE_STATE_STREAM_VIEW_INSTANCING ViewInstancingDesc;
+    D3D12_GRAPHICS_PIPELINE_STATE_DESC GraphicsDescV0() const
+    {
+        D3D12_GRAPHICS_PIPELINE_STATE_DESC D;
+        D.Flags                 = this->Flags;
+        D.NodeMask              = this->NodeMask;
+        D.pRootSignature        = this->pRootSignature;
+        D.InputLayout           = this->InputLayout;
+        D.IBStripCutValue       = this->IBStripCutValue;
+        D.PrimitiveTopologyType = this->PrimitiveTopologyType;
+        D.VS                    = this->VS;
+        D.GS                    = this->GS;
+        D.StreamOutput          = this->StreamOutput;
+        D.HS                    = this->HS;
+        D.DS                    = this->DS;
+        D.PS                    = this->PS;
+        D.BlendState            = this->BlendState;
+        D.DepthStencilState     = CD3DX12_DEPTH_STENCIL_DESC1(D3D12_DEPTH_STENCIL_DESC1(this->DepthStencilState));
+        D.DSVFormat             = this->DSVFormat;
+        D.RasterizerState       = this->RasterizerState;
+        D.NumRenderTargets      = D3D12_RT_FORMAT_ARRAY(this->RTVFormats).NumRenderTargets;
+        memcpy(D.RTVFormats, D3D12_RT_FORMAT_ARRAY(this->RTVFormats).RTFormats, sizeof(D.RTVFormats));
+        D.SampleDesc            = this->SampleDesc;
+        D.SampleMask            = this->SampleMask;
+        D.CachedPSO             = this->CachedPSO;
+        return D;
+    }
+    D3D12_COMPUTE_PIPELINE_STATE_DESC ComputeDescV0() const
+    {
+        D3D12_COMPUTE_PIPELINE_STATE_DESC D;
+        D.Flags                 = this->Flags;
+        D.NodeMask              = this->NodeMask;
+        D.pRootSignature        = this->pRootSignature;
+        D.CS                    = this->CS;
+        D.CachedPSO             = this->CachedPSO;
+        return D;
+    }
+};
+
+// CD3DX12_PIPELINE_STATE_STREAM works on RS2+ but does not support new subobject(s) added in RS3+.
+// See CD3DX12_PIPELINE_STATE_STREAM1 for instance.
+struct CD3DX12_PIPELINE_STATE_STREAM
+{
+    CD3DX12_PIPELINE_STATE_STREAM() = default;
+    CD3DX12_PIPELINE_STATE_STREAM(const D3D12_GRAPHICS_PIPELINE_STATE_DESC& Desc)
+        : Flags(Desc.Flags)
+        , NodeMask(Desc.NodeMask)
+        , pRootSignature(Desc.pRootSignature)
+        , InputLayout(Desc.InputLayout)
+        , IBStripCutValue(Desc.IBStripCutValue)
+        , PrimitiveTopologyType(Desc.PrimitiveTopologyType)
+        , VS(Desc.VS)
+        , GS(Desc.GS)
+        , StreamOutput(Desc.StreamOutput)
+        , HS(Desc.HS)
+        , DS(Desc.DS)
+        , PS(Desc.PS)
+        , BlendState(CD3DX12_BLEND_DESC(Desc.BlendState))
+        , DepthStencilState(CD3DX12_DEPTH_STENCIL_DESC1(Desc.DepthStencilState))
+        , DSVFormat(Desc.DSVFormat)
+        , RasterizerState(CD3DX12_RASTERIZER_DESC(Desc.RasterizerState))
+        , RTVFormats(CD3DX12_RT_FORMAT_ARRAY(Desc.RTVFormats, Desc.NumRenderTargets))
+        , SampleDesc(Desc.SampleDesc)
+        , SampleMask(Desc.SampleMask)
+        , CachedPSO(Desc.CachedPSO)
+    {}
+    CD3DX12_PIPELINE_STATE_STREAM(const D3D12_COMPUTE_PIPELINE_STATE_DESC& Desc)
+        : Flags(Desc.Flags)
+        , NodeMask(Desc.NodeMask)
+        , pRootSignature(Desc.pRootSignature)
+        , CS(CD3DX12_SHADER_BYTECODE(Desc.CS))
+        , CachedPSO(Desc.CachedPSO)
+    {}
+    CD3DX12_PIPELINE_STATE_STREAM_FLAGS Flags;
+    CD3DX12_PIPELINE_STATE_STREAM_NODE_MASK NodeMask;
+    CD3DX12_PIPELINE_STATE_STREAM_ROOT_SIGNATURE pRootSignature;
+    CD3DX12_PIPELINE_STATE_STREAM_INPUT_LAYOUT InputLayout;
+    CD3DX12_PIPELINE_STATE_STREAM_IB_STRIP_CUT_VALUE IBStripCutValue;
+    CD3DX12_PIPELINE_STATE_STREAM_PRIMITIVE_TOPOLOGY PrimitiveTopologyType;
+    CD3DX12_PIPELINE_STATE_STREAM_VS VS;
+    CD3DX12_PIPELINE_STATE_STREAM_GS GS;
+    CD3DX12_PIPELINE_STATE_STREAM_STREAM_OUTPUT StreamOutput;
+    CD3DX12_PIPELINE_STATE_STREAM_HS HS;
+    CD3DX12_PIPELINE_STATE_STREAM_DS DS;
+    CD3DX12_PIPELINE_STATE_STREAM_PS PS;
+    CD3DX12_PIPELINE_STATE_STREAM_CS CS;
+    CD3DX12_PIPELINE_STATE_STREAM_BLEND_DESC BlendState;
+    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL1 DepthStencilState;
+    CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL_FORMAT DSVFormat;
+    CD3DX12_PIPELINE_STATE_STREAM_RASTERIZER RasterizerState;
+    CD3DX12_PIPELINE_STATE_STREAM_RENDER_TARGET_FORMATS RTVFormats;
+    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_DESC SampleDesc;
+    CD3DX12_PIPELINE_STATE_STREAM_SAMPLE_MASK SampleMask;
+    CD3DX12_PIPELINE_STATE_STREAM_CACHED_PSO CachedPSO;
+    D3D12_GRAPHICS_PIPELINE_STATE_DESC GraphicsDescV0() const
+    {
+        D3D12_GRAPHICS_PIPELINE_STATE_DESC D;
+        D.Flags                 = this->Flags;
+        D.NodeMask              = this->NodeMask;
+        D.pRootSignature        = this->pRootSignature;
+        D.InputLayout           = this->InputLayout;
+        D.IBStripCutValue       = this->IBStripCutValue;
+        D.PrimitiveTopologyType = this->PrimitiveTopologyType;
+        D.VS                    = this->VS;
+        D.GS                    = this->GS;
+        D.StreamOutput          = this->StreamOutput;
+        D.HS                    = this->HS;
+        D.DS                    = this->DS;
+        D.PS                    = this->PS;
+        D.BlendState            = this->BlendState;
+        D.DepthStencilState     = CD3DX12_DEPTH_STENCIL_DESC1(D3D12_DEPTH_STENCIL_DESC1(this->DepthStencilState));
+        D.DSVFormat             = this->DSVFormat;
+        D.RasterizerState       = this->RasterizerState;
+        D.NumRenderTargets      = D3D12_RT_FORMAT_ARRAY(this->RTVFormats).NumRenderTargets;
+        memcpy(D.RTVFormats, D3D12_RT_FORMAT_ARRAY(this->RTVFormats).RTFormats, sizeof(D.RTVFormats));
+        D.SampleDesc            = this->SampleDesc;
+        D.SampleMask            = this->SampleMask;
+        D.CachedPSO             = this->CachedPSO;
+        return D;
+    }
+    D3D12_COMPUTE_PIPELINE_STATE_DESC ComputeDescV0() const
+    {
+        D3D12_COMPUTE_PIPELINE_STATE_DESC D;
+        D.Flags                 = this->Flags;
+        D.NodeMask              = this->NodeMask;
+        D.pRootSignature        = this->pRootSignature;
+        D.CS                    = this->CS;
+        D.CachedPSO             = this->CachedPSO;
+        return D;
+    }
+};
+
+struct CD3DX12_PIPELINE_STATE_STREAM_PARSE_HELPER : public ID3DX12PipelineParserCallbacks
+{
+    CD3DX12_PIPELINE_STATE_STREAM1 PipelineStream;
+    CD3DX12_PIPELINE_STATE_STREAM_PARSE_HELPER() noexcept
+        : SeenDSS(false)
+    {
+        // Adjust defaults to account for absent members.
+        PipelineStream.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
+
+        // Depth disabled if no DSV format specified.
+        static_cast<D3D12_DEPTH_STENCIL_DESC1&>(PipelineStream.DepthStencilState).DepthEnable = false;
+    }
+
+    // ID3DX12PipelineParserCallbacks
+    void FlagsCb(D3D12_PIPELINE_STATE_FLAGS Flags) override {PipelineStream.Flags = Flags;}
+    void NodeMaskCb(UINT NodeMask) override {PipelineStream.NodeMask = NodeMask;}
+    void RootSignatureCb(ID3D12RootSignature* pRootSignature) override {PipelineStream.pRootSignature = pRootSignature;}
+    void InputLayoutCb(const D3D12_INPUT_LAYOUT_DESC& InputLayout) override {PipelineStream.InputLayout = InputLayout;}
+    void IBStripCutValueCb(D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue) override {PipelineStream.IBStripCutValue = IBStripCutValue;}
+    void PrimitiveTopologyTypeCb(D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyType) override {PipelineStream.PrimitiveTopologyType = PrimitiveTopologyType;}
+    void VSCb(const D3D12_SHADER_BYTECODE& VS) override {PipelineStream.VS = VS;}
+    void GSCb(const D3D12_SHADER_BYTECODE& GS) override {PipelineStream.GS = GS;}
+    void StreamOutputCb(const D3D12_STREAM_OUTPUT_DESC& StreamOutput) override {PipelineStream.StreamOutput = StreamOutput;}
+    void HSCb(const D3D12_SHADER_BYTECODE& HS) override {PipelineStream.HS = HS;}
+    void DSCb(const D3D12_SHADER_BYTECODE& DS) override {PipelineStream.DS = DS;}
+    void PSCb(const D3D12_SHADER_BYTECODE& PS) override {PipelineStream.PS = PS;}
+    void CSCb(const D3D12_SHADER_BYTECODE& CS) override {PipelineStream.CS = CS;}
+    void BlendStateCb(const D3D12_BLEND_DESC& BlendState) override {PipelineStream.BlendState = CD3DX12_BLEND_DESC(BlendState);}
+    void DepthStencilStateCb(const D3D12_DEPTH_STENCIL_DESC& DepthStencilState) override
+    {
+        PipelineStream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(DepthStencilState);
+        SeenDSS = true;
+    }
+    void DepthStencilState1Cb(const D3D12_DEPTH_STENCIL_DESC1& DepthStencilState) override
+    {
+        PipelineStream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(DepthStencilState);
+        SeenDSS = true;
+    }
+    void DSVFormatCb(DXGI_FORMAT DSVFormat) override
+    {
+        PipelineStream.DSVFormat = DSVFormat;
+        if (!SeenDSS && DSVFormat != DXGI_FORMAT_UNKNOWN)
+        {
+            // Re-enable depth for the default state.
+            static_cast<D3D12_DEPTH_STENCIL_DESC1&>(PipelineStream.DepthStencilState).DepthEnable = true;
+        }
+    }
+    void RasterizerStateCb(const D3D12_RASTERIZER_DESC& RasterizerState) override {PipelineStream.RasterizerState = CD3DX12_RASTERIZER_DESC(RasterizerState);}
+    void RTVFormatsCb(const D3D12_RT_FORMAT_ARRAY& RTVFormats) override {PipelineStream.RTVFormats = RTVFormats;}
+    void SampleDescCb(const DXGI_SAMPLE_DESC& SampleDesc) override {PipelineStream.SampleDesc = SampleDesc;}
+    void SampleMaskCb(UINT SampleMask) override {PipelineStream.SampleMask = SampleMask;}
+    void ViewInstancingCb(const D3D12_VIEW_INSTANCING_DESC& ViewInstancingDesc) override {PipelineStream.ViewInstancingDesc = CD3DX12_VIEW_INSTANCING_DESC(ViewInstancingDesc);}
+    void CachedPSOCb(const D3D12_CACHED_PIPELINE_STATE& CachedPSO) override {PipelineStream.CachedPSO = CachedPSO;}
+
+private:
+    bool SeenDSS;
+};
+
+inline D3D12_PIPELINE_STATE_SUBOBJECT_TYPE D3DX12GetBaseSubobjectType(D3D12_PIPELINE_STATE_SUBOBJECT_TYPE SubobjectType)
+{
+    switch (SubobjectType)
+    {
+    case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1: 
+        return D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL;
+    default:
+        return SubobjectType;
+    }
+}
+
+inline HRESULT D3DX12ParsePipelineStream(const D3D12_PIPELINE_STATE_STREAM_DESC& Desc, ID3DX12PipelineParserCallbacks* pCallbacks)
+{
+    if (pCallbacks == nullptr)
+    {
+        return E_INVALIDARG;
+    }
+
+    if (Desc.SizeInBytes == 0 || Desc.pPipelineStateSubobjectStream == nullptr)
+    {
+        pCallbacks->ErrorBadInputParameter(1); // first parameter issue
+        return E_INVALIDARG;
+    }
+
+    bool SubobjectSeen[D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MAX_VALID] = {};
+    for (SIZE_T CurOffset = 0, SizeOfSubobject = 0; CurOffset < Desc.SizeInBytes; CurOffset += SizeOfSubobject)
+    {
+        BYTE* pStream = static_cast<BYTE*>(Desc.pPipelineStateSubobjectStream)+CurOffset;
+        auto SubobjectType = *reinterpret_cast<D3D12_PIPELINE_STATE_SUBOBJECT_TYPE*>(pStream);
+        if (SubobjectType < 0 || SubobjectType >= D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MAX_VALID)
+        {
+            pCallbacks->ErrorUnknownSubobject(SubobjectType);
+            return E_INVALIDARG;
+        }
+        if (SubobjectSeen[D3DX12GetBaseSubobjectType(SubobjectType)])
+        {
+            pCallbacks->ErrorDuplicateSubobject(SubobjectType);
+            return E_INVALIDARG; // disallow subobject duplicates in a stream
+        }
+        SubobjectSeen[SubobjectType] = true;
+        switch (SubobjectType)
+        {
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE: 
+            pCallbacks->RootSignatureCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::pRootSignature)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::pRootSignature);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VS:
+            pCallbacks->VSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::VS)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::VS);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS: 
+            pCallbacks->PSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::PS)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::PS);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DS: 
+            pCallbacks->DSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::DS)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::DS);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_HS: 
+            pCallbacks->HSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::HS)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::HS);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_GS: 
+            pCallbacks->GSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::GS)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::GS);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CS:
+            pCallbacks->CSCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::CS)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::CS);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT: 
+            pCallbacks->StreamOutputCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::StreamOutput)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::StreamOutput);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND: 
+            pCallbacks->BlendStateCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::BlendState)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::BlendState);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK: 
+            pCallbacks->SampleMaskCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::SampleMask)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::SampleMask);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER: 
+            pCallbacks->RasterizerStateCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::RasterizerState)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::RasterizerState);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL: 
+            pCallbacks->DepthStencilStateCb(*reinterpret_cast<CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM_DEPTH_STENCIL);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1: 
+            pCallbacks->DepthStencilState1Cb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::DepthStencilState)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::DepthStencilState);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT: 
+            pCallbacks->InputLayoutCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::InputLayout)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::InputLayout);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE: 
+            pCallbacks->IBStripCutValueCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::IBStripCutValue)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::IBStripCutValue);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY: 
+            pCallbacks->PrimitiveTopologyTypeCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::PrimitiveTopologyType)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::PrimitiveTopologyType);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS: 
+            pCallbacks->RTVFormatsCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::RTVFormats)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::RTVFormats);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT: 
+            pCallbacks->DSVFormatCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::DSVFormat)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::DSVFormat);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC: 
+            pCallbacks->SampleDescCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::SampleDesc)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::SampleDesc);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK: 
+            pCallbacks->NodeMaskCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::NodeMask)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::NodeMask);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO: 
+            pCallbacks->CachedPSOCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::CachedPSO)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::CachedPSO);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS:
+            pCallbacks->FlagsCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM::Flags)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM::Flags);
+            break;
+        case D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING:
+            pCallbacks->ViewInstancingCb(*reinterpret_cast<decltype(CD3DX12_PIPELINE_STATE_STREAM1::ViewInstancingDesc)*>(pStream));
+            SizeOfSubobject = sizeof(CD3DX12_PIPELINE_STATE_STREAM1::ViewInstancingDesc);
+            break;
+        default:
+            pCallbacks->ErrorUnknownSubobject(SubobjectType);
+            return E_INVALIDARG;
+            break;
+        }
+    }
+
+    return S_OK;
+}
+
+//------------------------------------------------------------------------------------------------
+inline bool operator==( const D3D12_CLEAR_VALUE &a, const D3D12_CLEAR_VALUE &b)
+{
+    if (a.Format != b.Format) return false;
+    if (a.Format == DXGI_FORMAT_D24_UNORM_S8_UINT
+     || a.Format == DXGI_FORMAT_D16_UNORM
+     || a.Format == DXGI_FORMAT_D32_FLOAT
+     || a.Format == DXGI_FORMAT_D32_FLOAT_S8X24_UINT)
+    {
+        return (a.DepthStencil.Depth == b.DepthStencil.Depth) && 
+          (a.DepthStencil.Stencil == b.DepthStencil.Stencil);
+    } else {
+        return (a.Color[0] == b.Color[0]) && 
+               (a.Color[1] == b.Color[1]) && 
+               (a.Color[2] == b.Color[2]) && 
+               (a.Color[3] == b.Color[3]);
+    }
+}
+inline bool operator==( const D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS &a, const D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS &b)
+{
+    return a.ClearValue == b.ClearValue;
+}
+inline bool operator==( const D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS &a, const D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS &b)
+{
+    if (a.pSrcResource != b.pSrcResource) return false;
+    if (a.pDstResource != b.pDstResource) return false;
+    if (a.SubresourceCount != b.SubresourceCount) return false;
+    if (a.Format != b.Format) return false;
+    if (a.ResolveMode != b.ResolveMode) return false; 
+    if (a.PreserveResolveSource != b.PreserveResolveSource) return false; 
+    return true;
+}
+inline bool operator==( const D3D12_RENDER_PASS_BEGINNING_ACCESS &a, const D3D12_RENDER_PASS_BEGINNING_ACCESS &b)
+{
+    if (a.Type != b.Type) return false;
+    if (a.Type == D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR && !(a.Clear == b.Clear)) return false; 
+    return true;
+}
+inline bool operator==( const D3D12_RENDER_PASS_ENDING_ACCESS &a, const D3D12_RENDER_PASS_ENDING_ACCESS &b)
+{
+    if (a.Type != b.Type) return false;
+    if (a.Type == D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_RESOLVE && !(a.Resolve == b.Resolve)) return false; 
+    return true;
+}
+inline bool operator==( const D3D12_RENDER_PASS_RENDER_TARGET_DESC &a, const D3D12_RENDER_PASS_RENDER_TARGET_DESC &b)
+{
+    if (a.cpuDescriptor.ptr != b.cpuDescriptor.ptr) return false;
+    if (!(a.BeginningAccess == b.BeginningAccess)) return false;
+    if (!(a.EndingAccess == b.EndingAccess)) return false;
+    return true;
+}
+inline bool operator==( const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC &a, const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC &b)
+{
+    if (a.cpuDescriptor.ptr != b.cpuDescriptor.ptr) return false;
+    if (!(a.DepthBeginningAccess == b.DepthBeginningAccess)) return false;
+    if (!(a.StencilBeginningAccess == b.StencilBeginningAccess)) return false;
+    if (!(a.DepthEndingAccess == b.DepthEndingAccess)) return false;
+    if (!(a.StencilEndingAccess == b.StencilEndingAccess)) return false;
+    return true;
+}
+
+
+#ifndef D3DX12_NO_STATE_OBJECT_HELPERS
+
+//================================================================================================
+// D3DX12 State Object Creation Helpers
+// 
+// Helper classes for creating new style state objects out of an arbitrary set of subobjects.
+// Uses STL
+//
+// Start by instantiating CD3DX12_STATE_OBJECT_DESC (see it's public methods).
+// One of its methods is CreateSubobject(), which has a comment showing a couple of options for
+// defining subobjects using the helper classes for each subobject (CD3DX12_DXIL_LIBRARY_SUBOBJECT 
+// etc.). The subobject helpers each have methods specific to the subobject for configuring it's 
+// contents.
+// 
+//================================================================================================
+#include <list>
+#include <vector>
+#include <string>
+#include <memory>
+#include <wrl/client.h>
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_STATE_OBJECT_DESC
+{
+public:
+    CD3DX12_STATE_OBJECT_DESC()
+    {
+        Init(D3D12_STATE_OBJECT_TYPE_COLLECTION);
+    }
+    CD3DX12_STATE_OBJECT_DESC(D3D12_STATE_OBJECT_TYPE Type)
+    {
+        Init(Type);
+    }
+    void SetStateObjectType(D3D12_STATE_OBJECT_TYPE Type) { m_Desc.Type = Type; }
+    operator const D3D12_STATE_OBJECT_DESC&()
+    {
+        // Do final preparation work
+        m_RepointedAssociations.clear();
+        m_SubobjectArray.clear();
+        m_SubobjectArray.reserve(m_Desc.NumSubobjects);
+        // Flatten subobjects into an array (each flattened subobject still has a 
+        // member that's a pointer to it's desc that's not flattened)
+        for (auto Iter = m_SubobjectList.begin();
+            Iter != m_SubobjectList.end(); Iter++)
+        {
+            m_SubobjectArray.push_back(*Iter);
+            // Store new location in array so we can redirect pointers contained in subobjects 
+            Iter->pSubobjectArrayLocation = &m_SubobjectArray.back(); 
+        }
+        // For subobjects with pointer fields, create a new copy of those subobject definitions
+        // with fixed pointers
+        for (UINT i = 0; i < m_Desc.NumSubobjects; i++)
+        {
+            if (m_SubobjectArray[i].Type == D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION)
+            {
+                auto pOriginalSubobjectAssociation = 
+                    reinterpret_cast<const D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION*>(m_SubobjectArray[i].pDesc);
+                D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION Repointed = *pOriginalSubobjectAssociation;
+                auto pWrapper = 
+                    static_cast<const SUBOBJECT_WRAPPER*>(pOriginalSubobjectAssociation->pSubobjectToAssociate);
+                Repointed.pSubobjectToAssociate = pWrapper->pSubobjectArrayLocation;
+                m_RepointedAssociations.push_back(Repointed);
+                m_SubobjectArray[i].pDesc = &m_RepointedAssociations.back();
+            }
+        }
+        // Below: using ugly way to get pointer in case .data() is not defined
+        m_Desc.pSubobjects = m_Desc.NumSubobjects ? &m_SubobjectArray[0] : nullptr; 
+        return m_Desc;
+    }
+    operator const D3D12_STATE_OBJECT_DESC*()
+    {
+        // Cast calls the above final preparation work
+        return &static_cast<const D3D12_STATE_OBJECT_DESC&>(*this);
+    }
+
+    // CreateSubobject creates a sububject helper (e.g. CD3DX12_HIT_GROUP_SUBOBJECT) 
+    // whose lifetime is owned by this class.
+    // e.g. 
+    // 
+    //    CD3DX12_STATE_OBJECT_DESC Collection1(D3D12_STATE_OBJECT_TYPE_COLLECTION);
+    //    auto Lib0 = Collection1.CreateSubobject<CD3DX12_DXIL_LIBRARY_SUBOBJECT>();
+    //    Lib0->SetDXILLibrary(&pMyAppDxilLibs[0]);
+    //    Lib0->DefineExport(L"rayGenShader0"); // in practice these export listings might be 
+    //                                          // data/engine driven
+    //    etc.
+    //
+    // Alternatively, users can instantiate sububject helpers explicitly, such as via local 
+    // variables instead, passing the state object desc that should point to it into the helper 
+    // constructor (or call mySubobjectHelper.AddToStateObject(Collection1)).  
+    // In this alternative scenario, the user must keep the subobject alive as long as the state 
+    // object it is associated with is alive, else it's pointer references will be stale.
+    // e.g.
+    //
+    //    CD3DX12_STATE_OBJECT_DESC RaytracingState2(D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE);
+    //    CD3DX12_DXIL_LIBRARY_SUBOBJECT LibA(RaytracingState2);
+    //    LibA.SetDXILLibrary(&pMyAppDxilLibs[4]); // not manually specifying exports 
+    //                                             // - meaning all exports in the libraries 
+    //                                             // are exported
+    //    etc.
+
+    template<typename T>
+    T* CreateSubobject()
+    {
+        T* pSubobject = new T(*this);
+        m_OwnedSubobjectHelpers.emplace_back(pSubobject);
+        return pSubobject;
+    }
+
+private:
+    D3D12_STATE_SUBOBJECT* TrackSubobject(D3D12_STATE_SUBOBJECT_TYPE Type, void* pDesc)
+    {
+        SUBOBJECT_WRAPPER Subobject;
+        Subobject.pSubobjectArrayLocation = nullptr;
+        Subobject.Type = Type;
+        Subobject.pDesc = pDesc;
+        m_SubobjectList.push_back(Subobject);
+        m_Desc.NumSubobjects++;
+        return &m_SubobjectList.back();
+    }
+    void Init(D3D12_STATE_OBJECT_TYPE Type)
+    {
+        SetStateObjectType(Type);
+        m_Desc.pSubobjects = nullptr;
+        m_Desc.NumSubobjects = 0;
+        m_SubobjectList.clear();
+        m_SubobjectArray.clear();
+        m_RepointedAssociations.clear();
+    }
+    typedef struct SUBOBJECT_WRAPPER : public D3D12_STATE_SUBOBJECT
+    {
+        D3D12_STATE_SUBOBJECT* pSubobjectArrayLocation; // new location when flattened into array 
+                                                        // for repointing pointers in subobjects
+    } SUBOBJECT_WRAPPER;
+    D3D12_STATE_OBJECT_DESC m_Desc;
+    std::list<SUBOBJECT_WRAPPER>   m_SubobjectList; // Pointers to list nodes handed out so 
+                                                    // these can be edited live
+    std::vector<D3D12_STATE_SUBOBJECT> m_SubobjectArray; // Built at the end, copying list contents
+
+    std::list<D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION> 
+            m_RepointedAssociations; // subobject type that contains pointers to other subobjects, 
+                                     // repointed to flattened array
+
+    class StringContainer
+    {
+    public:
+        LPCWSTR LocalCopy(LPCWSTR string, bool bSingleString = false)
+        {
+            if (string)
+            {
+                if (bSingleString)
+                {
+                    m_Strings.clear();
+                    m_Strings.push_back(string);
+                }
+                else
+                {
+                    m_Strings.push_back(string);
+                }
+                return m_Strings.back().c_str();
+            }
+            else
+            {
+                return nullptr;
+            }
+        }
+        void clear() { m_Strings.clear(); }
+    private:
+        std::list<std::wstring> m_Strings;
+    };
+
+    class SUBOBJECT_HELPER_BASE
+    {
+    public:
+        SUBOBJECT_HELPER_BASE() { Init(); }
+        virtual ~SUBOBJECT_HELPER_BASE() {}
+        virtual D3D12_STATE_SUBOBJECT_TYPE Type() const = 0;
+        void AddToStateObject(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+        {
+            m_pSubobject = ContainingStateObject.TrackSubobject(Type(), Data());
+        }
+    protected:
+        virtual void* Data() = 0;
+        void Init() { m_pSubobject = nullptr; }
+        D3D12_STATE_SUBOBJECT* m_pSubobject;
+    };
+
+#if(__cplusplus >= 201103L)
+    std::list<std::unique_ptr<const SUBOBJECT_HELPER_BASE>> m_OwnedSubobjectHelpers;
+#else
+    class OWNED_HELPER
+    {
+    public:
+        OWNED_HELPER(const SUBOBJECT_HELPER_BASE* pHelper) { m_pHelper = pHelper; }
+        ~OWNED_HELPER() { delete m_pHelper; }
+        const SUBOBJECT_HELPER_BASE* m_pHelper;
+    };
+
+    std::list<OWNED_HELPER> m_OwnedSubobjectHelpers;
+#endif
+
+    friend class CD3DX12_DXIL_LIBRARY_SUBOBJECT;
+    friend class CD3DX12_EXISTING_COLLECTION_SUBOBJECT;
+    friend class CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT;
+    friend class CD3DX12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
+    friend class CD3DX12_HIT_GROUP_SUBOBJECT;
+    friend class CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT;
+    friend class CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT;
+    friend class CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT;
+    friend class CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT;
+    friend class CD3DX12_STATE_OBJECT_CONFIG_SUBOBJECT;
+    friend class CD3DX12_NODE_MASK_SUBOBJECT;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_DXIL_LIBRARY_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_DXIL_LIBRARY_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_DXIL_LIBRARY_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void SetDXILLibrary(D3D12_SHADER_BYTECODE*pCode) 
+    { 
+        static const D3D12_SHADER_BYTECODE Default = {}; 
+        m_Desc.DXILLibrary = pCode ? *pCode : Default; 
+    }
+    void DefineExport(
+        LPCWSTR Name, 
+        LPCWSTR ExportToRename = nullptr, 
+        D3D12_EXPORT_FLAGS Flags = D3D12_EXPORT_FLAG_NONE)
+    {
+        D3D12_EXPORT_DESC Export;
+        Export.Name = m_Strings.LocalCopy(Name);
+        Export.ExportToRename = m_Strings.LocalCopy(ExportToRename);
+        Export.Flags = Flags;
+        m_Exports.push_back(Export);
+        m_Desc.pExports = &m_Exports[0];  // using ugly way to get pointer in case .data() is not defined
+        m_Desc.NumExports = static_cast<UINT>(m_Exports.size());
+    }
+    template<size_t N>
+    void DefineExports(LPCWSTR(&Exports)[N])
+    {
+        for (UINT i = 0; i < N; i++)
+        {
+            DefineExport(Exports[i]);
+        }
+    }
+    void DefineExports(LPCWSTR* Exports, UINT N)
+    {
+        for (UINT i = 0; i < N; i++)
+        {
+            DefineExport(Exports[i]);
+        }
+    }    
+    D3D12_STATE_SUBOBJECT_TYPE Type() const 
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator const D3D12_DXIL_LIBRARY_DESC&() const { return m_Desc; }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_Desc = {};
+        m_Strings.clear();
+        m_Exports.clear();
+    }
+    void* Data() { return &m_Desc; }
+    D3D12_DXIL_LIBRARY_DESC m_Desc;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer m_Strings;
+    std::vector<D3D12_EXPORT_DESC> m_Exports;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_EXISTING_COLLECTION_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_EXISTING_COLLECTION_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_EXISTING_COLLECTION_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void SetExistingCollection(ID3D12StateObject*pExistingCollection) 
+    { 
+        m_Desc.pExistingCollection = pExistingCollection; 
+        m_CollectionRef = pExistingCollection; 
+    }
+    void DefineExport(
+        LPCWSTR Name, 
+        LPCWSTR ExportToRename = nullptr, 
+        D3D12_EXPORT_FLAGS Flags = D3D12_EXPORT_FLAG_NONE)
+    {
+        D3D12_EXPORT_DESC Export;
+        Export.Name = m_Strings.LocalCopy(Name);
+        Export.ExportToRename = m_Strings.LocalCopy(ExportToRename);
+        Export.Flags = Flags;
+        m_Exports.push_back(Export);
+        m_Desc.pExports = &m_Exports[0]; // using ugly way to get pointer in case .data() is not defined
+        m_Desc.NumExports = static_cast<UINT>(m_Exports.size());
+    }
+    template<size_t N>
+    void DefineExports(LPCWSTR(&Exports)[N])
+    {
+        for (UINT i = 0; i < N; i++)
+        {
+            DefineExport(Exports[i]);
+        }
+    }
+    void DefineExports(LPCWSTR* Exports, UINT N)
+    {
+        for (UINT i = 0; i < N; i++)
+        {
+            DefineExport(Exports[i]);
+        }
+    }    
+    D3D12_STATE_SUBOBJECT_TYPE Type() const
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_EXISTING_COLLECTION; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator const D3D12_EXISTING_COLLECTION_DESC&() const { return m_Desc; }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_Desc = {};
+        m_CollectionRef = nullptr;
+        m_Strings.clear();
+        m_Exports.clear();
+    }
+    void* Data() { return &m_Desc; }
+    D3D12_EXISTING_COLLECTION_DESC m_Desc;
+    Microsoft::WRL::ComPtr<ID3D12StateObject> m_CollectionRef;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer m_Strings;
+    std::vector<D3D12_EXPORT_DESC> m_Exports;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_SUBOBJECT_TO_EXPORTS_ASSOCIATION_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void SetSubobjectToAssociate(const D3D12_STATE_SUBOBJECT& SubobjectToAssociate) 
+    { 
+        m_Desc.pSubobjectToAssociate = &SubobjectToAssociate; 
+    }
+    void AddExport(LPCWSTR Export)
+    {
+        m_Desc.NumExports++;
+        m_Exports.push_back(m_Strings.LocalCopy(Export));
+        m_Desc.pExports = &m_Exports[0];  // using ugly way to get pointer in case .data() is not defined
+    }
+    template<size_t N>
+    void AddExports(LPCWSTR (&Exports)[N])
+    {
+        for (UINT i = 0; i < N; i++)
+        {
+            AddExport(Exports[i]);
+        }
+    }
+    void AddExports(LPCWSTR* Exports, UINT N)
+    {
+        for (UINT i = 0; i < N; i++)
+        {
+            AddExport(Exports[i]);
+        }
+    }    
+    D3D12_STATE_SUBOBJECT_TYPE Type() const 
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator const D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION&() const { return m_Desc; }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_Desc = {};
+        m_Strings.clear();
+        m_Exports.clear();
+    }
+    void* Data() { return &m_Desc; }
+    D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION m_Desc;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer m_Strings;
+    std::vector<LPCWSTR> m_Exports;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION()
+    {
+        Init();
+    }
+    CD3DX12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void SetSubobjectNameToAssociate(LPCWSTR SubobjectToAssociate) 
+    {
+        m_Desc.SubobjectToAssociate = m_SubobjectName.LocalCopy(SubobjectToAssociate, true); 
+    }
+    void AddExport(LPCWSTR Export)
+    {
+        m_Desc.NumExports++;
+        m_Exports.push_back(m_Strings.LocalCopy(Export));
+        m_Desc.pExports = &m_Exports[0];  // using ugly way to get pointer in case .data() is not defined
+    }
+    template<size_t N>
+    void AddExports(LPCWSTR (&Exports)[N])
+    {
+        for (UINT i = 0; i < N; i++)
+        {
+            AddExport(Exports[i]);
+        }
+    }
+    void AddExports(LPCWSTR* Exports, UINT N)
+    {
+        for (UINT i = 0; i < N; i++)
+        {
+            AddExport(Exports[i]);
+        }
+    }    
+    D3D12_STATE_SUBOBJECT_TYPE Type() const
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator const D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION&() const { return m_Desc; }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_Desc = {};
+        m_Strings.clear();
+        m_SubobjectName.clear();
+        m_Exports.clear();
+    }
+    void* Data() { return &m_Desc; }
+    D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION m_Desc;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer m_SubobjectName;
+    std::vector<LPCWSTR> m_Exports;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_HIT_GROUP_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_HIT_GROUP_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_HIT_GROUP_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void SetHitGroupExport(LPCWSTR exportName)
+    { 
+        m_Desc.HitGroupExport = m_Strings[0].LocalCopy(exportName, true); 
+    }
+    void SetHitGroupType(D3D12_HIT_GROUP_TYPE Type) { m_Desc.Type = Type; }
+    void SetAnyHitShaderImport(LPCWSTR importName)
+    { 
+        m_Desc.AnyHitShaderImport = m_Strings[1].LocalCopy(importName, true); 
+    }
+    void SetClosestHitShaderImport(LPCWSTR importName)
+    { 
+        m_Desc.ClosestHitShaderImport = m_Strings[2].LocalCopy(importName, true); 
+    }
+    void SetIntersectionShaderImport(LPCWSTR importName)
+    {
+        m_Desc.IntersectionShaderImport = m_Strings[3].LocalCopy(importName, true); 
+    }
+    D3D12_STATE_SUBOBJECT_TYPE Type() const
+    {
+        return D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator const D3D12_HIT_GROUP_DESC&() const { return m_Desc; }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_Desc = {};
+        for (UINT i = 0; i < m_NumStrings; i++)
+        {
+            m_Strings[i].clear();
+        }
+    }
+    void* Data() { return &m_Desc; }
+    D3D12_HIT_GROUP_DESC m_Desc;
+    static const UINT m_NumStrings = 4;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer 
+        m_Strings[m_NumStrings]; // one string for every entrypoint name
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_RAYTRACING_SHADER_CONFIG_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void Config(UINT MaxPayloadSizeInBytes, UINT MaxAttributeSizeInBytes)
+    {
+        m_Desc.MaxPayloadSizeInBytes = MaxPayloadSizeInBytes;
+        m_Desc.MaxAttributeSizeInBytes = MaxAttributeSizeInBytes;
+    }
+    D3D12_STATE_SUBOBJECT_TYPE Type() const
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator const D3D12_RAYTRACING_SHADER_CONFIG&() const { return m_Desc; }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_Desc = {};
+    }
+    void* Data() { return &m_Desc; }
+    D3D12_RAYTRACING_SHADER_CONFIG m_Desc;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_RAYTRACING_PIPELINE_CONFIG_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void Config(UINT MaxTraceRecursionDepth)
+    {
+        m_Desc.MaxTraceRecursionDepth = MaxTraceRecursionDepth;
+    }
+    D3D12_STATE_SUBOBJECT_TYPE Type() const
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator const D3D12_RAYTRACING_PIPELINE_CONFIG&() const { return m_Desc; }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_Desc = {};
+    }
+    void* Data() { return &m_Desc; }
+    D3D12_RAYTRACING_PIPELINE_CONFIG m_Desc;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_GLOBAL_ROOT_SIGNATURE_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void SetRootSignature(ID3D12RootSignature* pRootSig)
+    {
+        m_pRootSig = pRootSig;
+    }
+    D3D12_STATE_SUBOBJECT_TYPE Type() const
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator ID3D12RootSignature*() const { return m_pRootSig.Get(); }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_pRootSig = nullptr;
+    }
+    void* Data() { return m_pRootSig.GetAddressOf(); }
+    Microsoft::WRL::ComPtr<ID3D12RootSignature> m_pRootSig;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_LOCAL_ROOT_SIGNATURE_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void SetRootSignature(ID3D12RootSignature* pRootSig)
+    {
+        m_pRootSig = pRootSig;
+    }
+    D3D12_STATE_SUBOBJECT_TYPE Type() const
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_LOCAL_ROOT_SIGNATURE; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator ID3D12RootSignature*() const { return m_pRootSig.Get(); }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_pRootSig = nullptr;
+    }
+    void* Data() { return m_pRootSig.GetAddressOf(); }
+    Microsoft::WRL::ComPtr<ID3D12RootSignature> m_pRootSig;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_STATE_OBJECT_CONFIG_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_STATE_OBJECT_CONFIG_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_STATE_OBJECT_CONFIG_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void SetFlags(D3D12_STATE_OBJECT_FLAGS Flags)
+    {
+        m_Desc.Flags = Flags;
+    }
+    D3D12_STATE_SUBOBJECT_TYPE Type() const
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_STATE_OBJECT_CONFIG; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator const D3D12_STATE_OBJECT_CONFIG&() const { return m_Desc; }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_Desc = {};
+    }
+    void* Data() { return &m_Desc; }
+    D3D12_STATE_OBJECT_CONFIG m_Desc;
+};
+
+//------------------------------------------------------------------------------------------------
+class CD3DX12_NODE_MASK_SUBOBJECT 
+    : public CD3DX12_STATE_OBJECT_DESC::SUBOBJECT_HELPER_BASE
+{
+public:
+    CD3DX12_NODE_MASK_SUBOBJECT()
+    {
+        Init();
+    }
+    CD3DX12_NODE_MASK_SUBOBJECT(CD3DX12_STATE_OBJECT_DESC& ContainingStateObject)
+    {
+        Init();
+        AddToStateObject(ContainingStateObject);
+    }
+    void SetNodeMask(UINT NodeMask)
+    {
+        m_Desc.NodeMask = NodeMask;
+    }
+    D3D12_STATE_SUBOBJECT_TYPE Type() const
+    { 
+        return D3D12_STATE_SUBOBJECT_TYPE_NODE_MASK; 
+    }
+    operator const D3D12_STATE_SUBOBJECT&() const { return *m_pSubobject; }
+    operator const D3D12_NODE_MASK&() const { return m_Desc; }
+private:
+    void Init()
+    {
+        SUBOBJECT_HELPER_BASE::Init();
+        m_Desc = {};
+    }
+    void* Data() { return &m_Desc; }
+    D3D12_NODE_MASK m_Desc;
+};
+
+#endif // #ifndef D3DX12_NO_STATE_OBJECT_HELPERS
+
+#endif // defined( __cplusplus )
+
+#endif //__D3DX12_H__
diff --git a/src/pc/gfx/dxsdk/dxgi.h b/src/pc/gfx/dxsdk/dxgi.h
new file mode 100644
index 0000000..13f423b
--- /dev/null
+++ b/src/pc/gfx/dxsdk/dxgi.h
@@ -0,0 +1,2958 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 8.01.0622 */
+/* @@MIDL_FILE_HEADING(  ) */
+
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 500
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif /* __RPCNDR_H_VERSION__ */
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __dxgi_h__
+#define __dxgi_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IDXGIObject_FWD_DEFINED__
+#define __IDXGIObject_FWD_DEFINED__
+typedef interface IDXGIObject IDXGIObject;
+
+#endif   /* __IDXGIObject_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIDeviceSubObject_FWD_DEFINED__
+#define __IDXGIDeviceSubObject_FWD_DEFINED__
+typedef interface IDXGIDeviceSubObject IDXGIDeviceSubObject;
+
+#endif   /* __IDXGIDeviceSubObject_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIResource_FWD_DEFINED__
+#define __IDXGIResource_FWD_DEFINED__
+typedef interface IDXGIResource IDXGIResource;
+
+#endif   /* __IDXGIResource_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIKeyedMutex_FWD_DEFINED__
+#define __IDXGIKeyedMutex_FWD_DEFINED__
+typedef interface IDXGIKeyedMutex IDXGIKeyedMutex;
+
+#endif   /* __IDXGIKeyedMutex_FWD_DEFINED__ */
+
+
+#ifndef __IDXGISurface_FWD_DEFINED__
+#define __IDXGISurface_FWD_DEFINED__
+typedef interface IDXGISurface IDXGISurface;
+
+#endif   /* __IDXGISurface_FWD_DEFINED__ */
+
+
+#ifndef __IDXGISurface1_FWD_DEFINED__
+#define __IDXGISurface1_FWD_DEFINED__
+typedef interface IDXGISurface1 IDXGISurface1;
+
+#endif   /* __IDXGISurface1_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIAdapter_FWD_DEFINED__
+#define __IDXGIAdapter_FWD_DEFINED__
+typedef interface IDXGIAdapter IDXGIAdapter;
+
+#endif   /* __IDXGIAdapter_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIOutput_FWD_DEFINED__
+#define __IDXGIOutput_FWD_DEFINED__
+typedef interface IDXGIOutput IDXGIOutput;
+
+#endif   /* __IDXGIOutput_FWD_DEFINED__ */
+
+
+#ifndef __IDXGISwapChain_FWD_DEFINED__
+#define __IDXGISwapChain_FWD_DEFINED__
+typedef interface IDXGISwapChain IDXGISwapChain;
+
+#endif   /* __IDXGISwapChain_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIFactory_FWD_DEFINED__
+#define __IDXGIFactory_FWD_DEFINED__
+typedef interface IDXGIFactory IDXGIFactory;
+
+#endif   /* __IDXGIFactory_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIDevice_FWD_DEFINED__
+#define __IDXGIDevice_FWD_DEFINED__
+typedef interface IDXGIDevice IDXGIDevice;
+
+#endif   /* __IDXGIDevice_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIFactory1_FWD_DEFINED__
+#define __IDXGIFactory1_FWD_DEFINED__
+typedef interface IDXGIFactory1 IDXGIFactory1;
+
+#endif   /* __IDXGIFactory1_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIAdapter1_FWD_DEFINED__
+#define __IDXGIAdapter1_FWD_DEFINED__
+typedef interface IDXGIAdapter1 IDXGIAdapter1;
+
+#endif   /* __IDXGIAdapter1_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIDevice1_FWD_DEFINED__
+#define __IDXGIDevice1_FWD_DEFINED__
+typedef interface IDXGIDevice1 IDXGIDevice1;
+
+#endif   /* __IDXGIDevice1_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "oaidl.h"
+#include "ocidl.h"
+#include "dxgicommon.h"
+#include "dxgitype.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_dxgi_0000_0000 */
+/* [local] */ 
+
+#include <winapifamily.h>
+#define DXGI_CPU_ACCESS_NONE    ( 0 )
+#define DXGI_CPU_ACCESS_DYNAMIC    ( 1 )
+#define DXGI_CPU_ACCESS_READ_WRITE    ( 2 )
+#define DXGI_CPU_ACCESS_SCRATCH    ( 3 )
+#define DXGI_CPU_ACCESS_FIELD        15
+#define DXGI_USAGE_SHADER_INPUT             0x00000010UL
+#define DXGI_USAGE_RENDER_TARGET_OUTPUT     0x00000020UL
+#define DXGI_USAGE_BACK_BUFFER              0x00000040UL
+#define DXGI_USAGE_SHARED                   0x00000080UL
+#define DXGI_USAGE_READ_ONLY                0x00000100UL
+#define DXGI_USAGE_DISCARD_ON_PRESENT       0x00000200UL
+#define DXGI_USAGE_UNORDERED_ACCESS         0x00000400UL
+typedef UINT DXGI_USAGE;
+
+typedef struct DXGI_FRAME_STATISTICS
+    {
+    UINT PresentCount;
+    UINT PresentRefreshCount;
+    UINT SyncRefreshCount;
+    LARGE_INTEGER SyncQPCTime;
+    LARGE_INTEGER SyncGPUTime;
+    }  DXGI_FRAME_STATISTICS;
+
+typedef struct DXGI_MAPPED_RECT
+    {
+    INT Pitch;
+    BYTE *pBits;
+    }  DXGI_MAPPED_RECT;
+
+#ifdef __midl
+#ifndef LUID_DEFINED
+#define LUID_DEFINED 1
+typedef struct _LUID
+    {
+    DWORD LowPart;
+    LONG HighPart;
+    }  LUID;
+
+typedef struct _LUID *PLUID;
+
+#endif
+#endif
+typedef struct DXGI_ADAPTER_DESC
+    {
+    WCHAR Description[ 128 ];
+    UINT VendorId;
+    UINT DeviceId;
+    UINT SubSysId;
+    UINT Revision;
+    SIZE_T DedicatedVideoMemory;
+    SIZE_T DedicatedSystemMemory;
+    SIZE_T SharedSystemMemory;
+    LUID AdapterLuid;
+    }  DXGI_ADAPTER_DESC;
+
+#if !defined(HMONITOR_DECLARED) && !defined(HMONITOR) && (WINVER < 0x0500)
+#define HMONITOR_DECLARED
+#if 0
+typedef HANDLE HMONITOR;
+
+#endif
+DECLARE_HANDLE(HMONITOR);
+#endif
+typedef struct DXGI_OUTPUT_DESC
+    {
+    WCHAR DeviceName[ 32 ];
+    RECT DesktopCoordinates;
+    BOOL AttachedToDesktop;
+    DXGI_MODE_ROTATION Rotation;
+    HMONITOR Monitor;
+    }  DXGI_OUTPUT_DESC;
+
+typedef struct DXGI_SHARED_RESOURCE
+    {
+    HANDLE Handle;
+    }  DXGI_SHARED_RESOURCE;
+
+#define  DXGI_RESOURCE_PRIORITY_MINIMUM  ( 0x28000000 )
+
+#define  DXGI_RESOURCE_PRIORITY_LOW  ( 0x50000000 )
+
+#define  DXGI_RESOURCE_PRIORITY_NORMAL ( 0x78000000 )
+
+#define  DXGI_RESOURCE_PRIORITY_HIGH ( 0xa0000000 )
+
+#define  DXGI_RESOURCE_PRIORITY_MAXIMUM  ( 0xc8000000 )
+
+typedef 
+enum DXGI_RESIDENCY
+    {
+        DXGI_RESIDENCY_FULLY_RESIDENT  = 1,
+        DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY = 2,
+        DXGI_RESIDENCY_EVICTED_TO_DISK = 3
+    }  DXGI_RESIDENCY;
+
+typedef struct DXGI_SURFACE_DESC
+    {
+    UINT Width;
+    UINT Height;
+    DXGI_FORMAT Format;
+    DXGI_SAMPLE_DESC SampleDesc;
+    }  DXGI_SURFACE_DESC;
+
+typedef 
+enum DXGI_SWAP_EFFECT
+    {
+        DXGI_SWAP_EFFECT_DISCARD = 0,
+        DXGI_SWAP_EFFECT_SEQUENTIAL  = 1,
+        DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL = 3,
+        DXGI_SWAP_EFFECT_FLIP_DISCARD  = 4
+    }  DXGI_SWAP_EFFECT;
+
+typedef 
+enum DXGI_SWAP_CHAIN_FLAG
+    {
+        DXGI_SWAP_CHAIN_FLAG_NONPREROTATED = 1,
+        DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH = 2,
+        DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE  = 4,
+        DXGI_SWAP_CHAIN_FLAG_RESTRICTED_CONTENT  = 8,
+        DXGI_SWAP_CHAIN_FLAG_RESTRICT_SHARED_RESOURCE_DRIVER = 16,
+        DXGI_SWAP_CHAIN_FLAG_DISPLAY_ONLY  = 32,
+        DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT = 64,
+        DXGI_SWAP_CHAIN_FLAG_FOREGROUND_LAYER  = 128,
+        DXGI_SWAP_CHAIN_FLAG_FULLSCREEN_VIDEO  = 256,
+        DXGI_SWAP_CHAIN_FLAG_YUV_VIDEO = 512,
+        DXGI_SWAP_CHAIN_FLAG_HW_PROTECTED  = 1024,
+        DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING = 2048,
+        DXGI_SWAP_CHAIN_FLAG_RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS  = 4096
+    }  DXGI_SWAP_CHAIN_FLAG;
+
+typedef struct DXGI_SWAP_CHAIN_DESC
+    {
+    DXGI_MODE_DESC BufferDesc;
+    DXGI_SAMPLE_DESC SampleDesc;
+    DXGI_USAGE BufferUsage;
+    UINT BufferCount;
+    HWND OutputWindow;
+    BOOL Windowed;
+    DXGI_SWAP_EFFECT SwapEffect;
+    UINT Flags;
+    }  DXGI_SWAP_CHAIN_DESC;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IDXGIObject_INTERFACE_DEFINED__
+#define __IDXGIObject_INTERFACE_DEFINED__
+
+/* interface IDXGIObject */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIObject;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("aec22fb8-76f3-4639-9be0-28eb43a67a2e")
+    IDXGIObject : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetPrivateData( 
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetPrivateDataInterface( 
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetPrivateData( 
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetParent( 
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIObjectVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIObject * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIObject * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIObject * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIObject * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIObject * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIObject * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIObject * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        END_INTERFACE
+    } IDXGIObjectVtbl;
+
+    interface IDXGIObject
+    {
+        CONST_VTBL struct IDXGIObjectVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIObject_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIObject_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIObject_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIObject_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIObject_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIObject_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIObject_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIObject_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDXGIDeviceSubObject_INTERFACE_DEFINED__
+#define __IDXGIDeviceSubObject_INTERFACE_DEFINED__
+
+/* interface IDXGIDeviceSubObject */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIDeviceSubObject;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("3d3e0379-f9de-4d58-bb6c-18d62992f1a6")
+    IDXGIDeviceSubObject : public IDXGIObject
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetDevice( 
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppDevice) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIDeviceSubObjectVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIDeviceSubObject * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIDeviceSubObject * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIDeviceSubObject * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIDeviceSubObject * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIDeviceSubObject * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIDeviceSubObject * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIDeviceSubObject * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            IDXGIDeviceSubObject * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppDevice);
+        
+        END_INTERFACE
+    } IDXGIDeviceSubObjectVtbl;
+
+    interface IDXGIDeviceSubObject
+    {
+        CONST_VTBL struct IDXGIDeviceSubObjectVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIDeviceSubObject_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIDeviceSubObject_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIDeviceSubObject_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIDeviceSubObject_SetPrivateData(This,Name,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIDeviceSubObject_SetPrivateDataInterface(This,Name,pUnknown) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIDeviceSubObject_GetPrivateData(This,Name,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIDeviceSubObject_GetParent(This,riid,ppParent) \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIDeviceSubObject_GetDevice(This,riid,ppDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIDeviceSubObject_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDXGIResource_INTERFACE_DEFINED__
+#define __IDXGIResource_INTERFACE_DEFINED__
+
+/* interface IDXGIResource */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIResource;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("035f3ab4-482e-4e50-b41f-8a7f8bd8960b")
+    IDXGIResource : public IDXGIDeviceSubObject
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetSharedHandle( 
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pSharedHandle) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetUsage( 
+            /* [out] */ DXGI_USAGE *pUsage) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetEvictionPriority( 
+            /* [in] */ UINT EvictionPriority) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetEvictionPriority( 
+            /* [annotation][retval][out] */ 
+            _Out_  UINT *pEvictionPriority) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIResourceVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIResource * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIResource * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIResource * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIResource * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIResource * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIResource * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIResource * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            IDXGIResource * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSharedHandle )( 
+            IDXGIResource * This,
+            /* [annotation][out] */ 
+            _Out_  HANDLE *pSharedHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetUsage )( 
+            IDXGIResource * This,
+            /* [out] */ DXGI_USAGE *pUsage);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEvictionPriority )( 
+            IDXGIResource * This,
+            /* [in] */ UINT EvictionPriority);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetEvictionPriority )( 
+            IDXGIResource * This,
+            /* [annotation][retval][out] */ 
+            _Out_  UINT *pEvictionPriority);
+        
+        END_INTERFACE
+    } IDXGIResourceVtbl;
+
+    interface IDXGIResource
+    {
+        CONST_VTBL struct IDXGIResourceVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIResource_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIResource_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIResource_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIResource_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIResource_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIResource_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIResource_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIResource_GetDevice(This,riid,ppDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 
+
+
+#define IDXGIResource_GetSharedHandle(This,pSharedHandle)  \
+    ( (This)->lpVtbl -> GetSharedHandle(This,pSharedHandle) ) 
+
+#define IDXGIResource_GetUsage(This,pUsage)  \
+    ( (This)->lpVtbl -> GetUsage(This,pUsage) ) 
+
+#define IDXGIResource_SetEvictionPriority(This,EvictionPriority) \
+    ( (This)->lpVtbl -> SetEvictionPriority(This,EvictionPriority) ) 
+
+#define IDXGIResource_GetEvictionPriority(This,pEvictionPriority)  \
+    ( (This)->lpVtbl -> GetEvictionPriority(This,pEvictionPriority) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIResource_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDXGIKeyedMutex_INTERFACE_DEFINED__
+#define __IDXGIKeyedMutex_INTERFACE_DEFINED__
+
+/* interface IDXGIKeyedMutex */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIKeyedMutex;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("9d8e1289-d7b3-465f-8126-250e349af85d")
+    IDXGIKeyedMutex : public IDXGIDeviceSubObject
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE AcquireSync( 
+            /* [in] */ UINT64 Key,
+            /* [in] */ DWORD dwMilliseconds) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ReleaseSync( 
+            /* [in] */ UINT64 Key) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIKeyedMutexVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIKeyedMutex * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIKeyedMutex * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIKeyedMutex * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIKeyedMutex * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIKeyedMutex * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIKeyedMutex * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIKeyedMutex * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            IDXGIKeyedMutex * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *AcquireSync )( 
+            IDXGIKeyedMutex * This,
+            /* [in] */ UINT64 Key,
+            /* [in] */ DWORD dwMilliseconds);
+        
+        HRESULT ( STDMETHODCALLTYPE *ReleaseSync )( 
+            IDXGIKeyedMutex * This,
+            /* [in] */ UINT64 Key);
+        
+        END_INTERFACE
+    } IDXGIKeyedMutexVtbl;
+
+    interface IDXGIKeyedMutex
+    {
+        CONST_VTBL struct IDXGIKeyedMutexVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIKeyedMutex_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIKeyedMutex_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIKeyedMutex_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIKeyedMutex_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIKeyedMutex_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIKeyedMutex_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIKeyedMutex_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIKeyedMutex_GetDevice(This,riid,ppDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 
+
+
+#define IDXGIKeyedMutex_AcquireSync(This,Key,dwMilliseconds) \
+    ( (This)->lpVtbl -> AcquireSync(This,Key,dwMilliseconds) ) 
+
+#define IDXGIKeyedMutex_ReleaseSync(This,Key)  \
+    ( (This)->lpVtbl -> ReleaseSync(This,Key) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIKeyedMutex_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi_0000_0004 */
+/* [local] */ 
+
+#define  DXGI_MAP_READ ( 1UL )
+
+#define  DXGI_MAP_WRITE  ( 2UL )
+
+#define  DXGI_MAP_DISCARD  ( 4UL )
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0004_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0004_v0_0_s_ifspec;
+
+#ifndef __IDXGISurface_INTERFACE_DEFINED__
+#define __IDXGISurface_INTERFACE_DEFINED__
+
+/* interface IDXGISurface */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGISurface;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("cafcb56c-6ac3-4889-bf47-9e23bbd260ec")
+    IDXGISurface : public IDXGIDeviceSubObject
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_SURFACE_DESC *pDesc) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Map( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_MAPPED_RECT *pLockedRect,
+            /* [in] */ UINT MapFlags) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Unmap( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGISurfaceVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGISurface * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGISurface * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGISurface * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGISurface * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGISurface * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGISurface * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGISurface * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            IDXGISurface * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
+            IDXGISurface * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_SURFACE_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *Map )( 
+            IDXGISurface * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_MAPPED_RECT *pLockedRect,
+            /* [in] */ UINT MapFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *Unmap )( 
+            IDXGISurface * This);
+        
+        END_INTERFACE
+    } IDXGISurfaceVtbl;
+
+    interface IDXGISurface
+    {
+        CONST_VTBL struct IDXGISurfaceVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGISurface_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGISurface_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGISurface_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGISurface_SetPrivateData(This,Name,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGISurface_SetPrivateDataInterface(This,Name,pUnknown) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGISurface_GetPrivateData(This,Name,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGISurface_GetParent(This,riid,ppParent) \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGISurface_GetDevice(This,riid,ppDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 
+
+
+#define IDXGISurface_GetDesc(This,pDesc) \
+    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 
+
+#define IDXGISurface_Map(This,pLockedRect,MapFlags)  \
+    ( (This)->lpVtbl -> Map(This,pLockedRect,MapFlags) ) 
+
+#define IDXGISurface_Unmap(This) \
+    ( (This)->lpVtbl -> Unmap(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGISurface_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDXGISurface1_INTERFACE_DEFINED__
+#define __IDXGISurface1_INTERFACE_DEFINED__
+
+/* interface IDXGISurface1 */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGISurface1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("4AE63092-6327-4c1b-80AE-BFE12EA32B86")
+    IDXGISurface1 : public IDXGISurface
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetDC( 
+            /* [in] */ BOOL Discard,
+            /* [annotation][out] */ 
+            _Out_  HDC *phdc) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ReleaseDC( 
+            /* [annotation][in] */ 
+            _In_opt_  RECT *pDirtyRect) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGISurface1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGISurface1 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGISurface1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGISurface1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGISurface1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGISurface1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGISurface1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGISurface1 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            IDXGISurface1 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
+            IDXGISurface1 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_SURFACE_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *Map )( 
+            IDXGISurface1 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_MAPPED_RECT *pLockedRect,
+            /* [in] */ UINT MapFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *Unmap )( 
+            IDXGISurface1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDC )( 
+            IDXGISurface1 * This,
+            /* [in] */ BOOL Discard,
+            /* [annotation][out] */ 
+            _Out_  HDC *phdc);
+        
+        HRESULT ( STDMETHODCALLTYPE *ReleaseDC )( 
+            IDXGISurface1 * This,
+            /* [annotation][in] */ 
+            _In_opt_  RECT *pDirtyRect);
+        
+        END_INTERFACE
+    } IDXGISurface1Vtbl;
+
+    interface IDXGISurface1
+    {
+        CONST_VTBL struct IDXGISurface1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGISurface1_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGISurface1_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGISurface1_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGISurface1_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGISurface1_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGISurface1_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGISurface1_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGISurface1_GetDevice(This,riid,ppDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 
+
+
+#define IDXGISurface1_GetDesc(This,pDesc)  \
+    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 
+
+#define IDXGISurface1_Map(This,pLockedRect,MapFlags) \
+    ( (This)->lpVtbl -> Map(This,pLockedRect,MapFlags) ) 
+
+#define IDXGISurface1_Unmap(This)  \
+    ( (This)->lpVtbl -> Unmap(This) ) 
+
+
+#define IDXGISurface1_GetDC(This,Discard,phdc) \
+    ( (This)->lpVtbl -> GetDC(This,Discard,phdc) ) 
+
+#define IDXGISurface1_ReleaseDC(This,pDirtyRect) \
+    ( (This)->lpVtbl -> ReleaseDC(This,pDirtyRect) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGISurface1_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi_0000_0006 */
+/* [local] */ 
+
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0006_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0006_v0_0_s_ifspec;
+
+#ifndef __IDXGIAdapter_INTERFACE_DEFINED__
+#define __IDXGIAdapter_INTERFACE_DEFINED__
+
+/* interface IDXGIAdapter */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIAdapter;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("2411e7e1-12ac-4ccf-bd14-9798e8534dc0")
+    IDXGIAdapter : public IDXGIObject
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE EnumOutputs( 
+            /* [in] */ UINT Output,
+            /* [annotation][out][in] */ 
+            _COM_Outptr_  IDXGIOutput **ppOutput) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_ADAPTER_DESC *pDesc) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CheckInterfaceSupport( 
+            /* [annotation][in] */ 
+            _In_  REFGUID InterfaceName,
+            /* [annotation][out] */ 
+            _Out_  LARGE_INTEGER *pUMDVersion) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIAdapterVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIAdapter * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIAdapter * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIAdapter * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIAdapter * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIAdapter * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIAdapter * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIAdapter * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumOutputs )( 
+            IDXGIAdapter * This,
+            /* [in] */ UINT Output,
+            /* [annotation][out][in] */ 
+            _COM_Outptr_  IDXGIOutput **ppOutput);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
+            IDXGIAdapter * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_ADAPTER_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckInterfaceSupport )( 
+            IDXGIAdapter * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID InterfaceName,
+            /* [annotation][out] */ 
+            _Out_  LARGE_INTEGER *pUMDVersion);
+        
+        END_INTERFACE
+    } IDXGIAdapterVtbl;
+
+    interface IDXGIAdapter
+    {
+        CONST_VTBL struct IDXGIAdapterVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIAdapter_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIAdapter_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIAdapter_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIAdapter_SetPrivateData(This,Name,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIAdapter_SetPrivateDataInterface(This,Name,pUnknown) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIAdapter_GetPrivateData(This,Name,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIAdapter_GetParent(This,riid,ppParent) \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIAdapter_EnumOutputs(This,Output,ppOutput) \
+    ( (This)->lpVtbl -> EnumOutputs(This,Output,ppOutput) ) 
+
+#define IDXGIAdapter_GetDesc(This,pDesc) \
+    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 
+
+#define IDXGIAdapter_CheckInterfaceSupport(This,InterfaceName,pUMDVersion) \
+    ( (This)->lpVtbl -> CheckInterfaceSupport(This,InterfaceName,pUMDVersion) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIAdapter_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi_0000_0007 */
+/* [local] */ 
+
+#define  DXGI_ENUM_MODES_INTERLACED  ( 1UL )
+
+#define  DXGI_ENUM_MODES_SCALING ( 2UL )
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0007_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0007_v0_0_s_ifspec;
+
+#ifndef __IDXGIOutput_INTERFACE_DEFINED__
+#define __IDXGIOutput_INTERFACE_DEFINED__
+
+/* interface IDXGIOutput */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIOutput;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("ae02eedb-c735-4690-8d52-5a8dc20213aa")
+    IDXGIOutput : public IDXGIObject
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_OUTPUT_DESC *pDesc) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDisplayModeList( 
+            /* [in] */ DXGI_FORMAT EnumFormat,
+            /* [in] */ UINT Flags,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pNumModes,
+            /* [annotation][out] */ 
+            _Out_writes_to_opt_(*pNumModes,*pNumModes)  DXGI_MODE_DESC *pDesc) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE FindClosestMatchingMode( 
+            /* [annotation][in] */ 
+            _In_  const DXGI_MODE_DESC *pModeToMatch,
+            /* [annotation][out] */ 
+            _Out_  DXGI_MODE_DESC *pClosestMatch,
+            /* [annotation][in] */ 
+            _In_opt_  IUnknown *pConcernedDevice) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE WaitForVBlank( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE TakeOwnership( 
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            BOOL Exclusive) = 0;
+        
+        virtual void STDMETHODCALLTYPE ReleaseOwnership( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetGammaControlCapabilities( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_GAMMA_CONTROL_CAPABILITIES *pGammaCaps) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetGammaControl( 
+            /* [annotation][in] */ 
+            _In_  const DXGI_GAMMA_CONTROL *pArray) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetGammaControl( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_GAMMA_CONTROL *pArray) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetDisplaySurface( 
+            /* [annotation][in] */ 
+            _In_  IDXGISurface *pScanoutSurface) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDisplaySurfaceData( 
+            /* [annotation][in] */ 
+            _In_  IDXGISurface *pDestination) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetFrameStatistics( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_FRAME_STATISTICS *pStats) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIOutputVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIOutput * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIOutput * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIOutput * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIOutput * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIOutput * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIOutput * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIOutput * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
+            IDXGIOutput * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_OUTPUT_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayModeList )( 
+            IDXGIOutput * This,
+            /* [in] */ DXGI_FORMAT EnumFormat,
+            /* [in] */ UINT Flags,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pNumModes,
+            /* [annotation][out] */ 
+            _Out_writes_to_opt_(*pNumModes,*pNumModes)  DXGI_MODE_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *FindClosestMatchingMode )( 
+            IDXGIOutput * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_MODE_DESC *pModeToMatch,
+            /* [annotation][out] */ 
+            _Out_  DXGI_MODE_DESC *pClosestMatch,
+            /* [annotation][in] */ 
+            _In_opt_  IUnknown *pConcernedDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *WaitForVBlank )( 
+            IDXGIOutput * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *TakeOwnership )( 
+            IDXGIOutput * This,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            BOOL Exclusive);
+        
+        void ( STDMETHODCALLTYPE *ReleaseOwnership )( 
+            IDXGIOutput * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetGammaControlCapabilities )( 
+            IDXGIOutput * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_GAMMA_CONTROL_CAPABILITIES *pGammaCaps);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetGammaControl )( 
+            IDXGIOutput * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_GAMMA_CONTROL *pArray);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetGammaControl )( 
+            IDXGIOutput * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_GAMMA_CONTROL *pArray);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetDisplaySurface )( 
+            IDXGIOutput * This,
+            /* [annotation][in] */ 
+            _In_  IDXGISurface *pScanoutSurface);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplaySurfaceData )( 
+            IDXGIOutput * This,
+            /* [annotation][in] */ 
+            _In_  IDXGISurface *pDestination);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetFrameStatistics )( 
+            IDXGIOutput * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_FRAME_STATISTICS *pStats);
+        
+        END_INTERFACE
+    } IDXGIOutputVtbl;
+
+    interface IDXGIOutput
+    {
+        CONST_VTBL struct IDXGIOutputVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIOutput_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIOutput_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIOutput_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIOutput_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIOutput_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIOutput_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIOutput_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIOutput_GetDesc(This,pDesc)  \
+    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 
+
+#define IDXGIOutput_GetDisplayModeList(This,EnumFormat,Flags,pNumModes,pDesc)  \
+    ( (This)->lpVtbl -> GetDisplayModeList(This,EnumFormat,Flags,pNumModes,pDesc) ) 
+
+#define IDXGIOutput_FindClosestMatchingMode(This,pModeToMatch,pClosestMatch,pConcernedDevice)  \
+    ( (This)->lpVtbl -> FindClosestMatchingMode(This,pModeToMatch,pClosestMatch,pConcernedDevice) ) 
+
+#define IDXGIOutput_WaitForVBlank(This)  \
+    ( (This)->lpVtbl -> WaitForVBlank(This) ) 
+
+#define IDXGIOutput_TakeOwnership(This,pDevice,Exclusive)  \
+    ( (This)->lpVtbl -> TakeOwnership(This,pDevice,Exclusive) ) 
+
+#define IDXGIOutput_ReleaseOwnership(This) \
+    ( (This)->lpVtbl -> ReleaseOwnership(This) ) 
+
+#define IDXGIOutput_GetGammaControlCapabilities(This,pGammaCaps) \
+    ( (This)->lpVtbl -> GetGammaControlCapabilities(This,pGammaCaps) ) 
+
+#define IDXGIOutput_SetGammaControl(This,pArray) \
+    ( (This)->lpVtbl -> SetGammaControl(This,pArray) ) 
+
+#define IDXGIOutput_GetGammaControl(This,pArray) \
+    ( (This)->lpVtbl -> GetGammaControl(This,pArray) ) 
+
+#define IDXGIOutput_SetDisplaySurface(This,pScanoutSurface)  \
+    ( (This)->lpVtbl -> SetDisplaySurface(This,pScanoutSurface) ) 
+
+#define IDXGIOutput_GetDisplaySurfaceData(This,pDestination) \
+    ( (This)->lpVtbl -> GetDisplaySurfaceData(This,pDestination) ) 
+
+#define IDXGIOutput_GetFrameStatistics(This,pStats)  \
+    ( (This)->lpVtbl -> GetFrameStatistics(This,pStats) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIOutput_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi_0000_0008 */
+/* [local] */ 
+
+#define DXGI_MAX_SWAP_CHAIN_BUFFERS        ( 16 )
+#define DXGI_PRESENT_TEST                      0x00000001UL
+#define DXGI_PRESENT_DO_NOT_SEQUENCE           0x00000002UL
+#define DXGI_PRESENT_RESTART                   0x00000004UL
+#define DXGI_PRESENT_DO_NOT_WAIT               0x00000008UL
+#define DXGI_PRESENT_STEREO_PREFER_RIGHT       0x00000010UL
+#define DXGI_PRESENT_STEREO_TEMPORARY_MONO     0x00000020UL
+#define DXGI_PRESENT_RESTRICT_TO_OUTPUT        0x00000040UL
+#define DXGI_PRESENT_USE_DURATION              0x00000100UL
+#define DXGI_PRESENT_ALLOW_TEARING             0x00000200UL
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0008_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0008_v0_0_s_ifspec;
+
+#ifndef __IDXGISwapChain_INTERFACE_DEFINED__
+#define __IDXGISwapChain_INTERFACE_DEFINED__
+
+/* interface IDXGISwapChain */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGISwapChain;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("310d36a0-d2e7-4c0a-aa04-6a9d23b8886a")
+    IDXGISwapChain : public IDXGIDeviceSubObject
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Present( 
+            /* [in] */ UINT SyncInterval,
+            /* [in] */ UINT Flags) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
+            /* [in] */ UINT Buffer,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][out][in] */ 
+            _COM_Outptr_  void **ppSurface) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetFullscreenState( 
+            /* [in] */ BOOL Fullscreen,
+            /* [annotation][in] */ 
+            _In_opt_  IDXGIOutput *pTarget) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetFullscreenState( 
+            /* [annotation][out] */ 
+            _Out_opt_  BOOL *pFullscreen,
+            /* [annotation][out] */ 
+            _COM_Outptr_opt_result_maybenull_  IDXGIOutput **ppTarget) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_SWAP_CHAIN_DESC *pDesc) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ResizeBuffers( 
+            /* [in] */ UINT BufferCount,
+            /* [in] */ UINT Width,
+            /* [in] */ UINT Height,
+            /* [in] */ DXGI_FORMAT NewFormat,
+            /* [in] */ UINT SwapChainFlags) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ResizeTarget( 
+            /* [annotation][in] */ 
+            _In_  const DXGI_MODE_DESC *pNewTargetParameters) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetContainingOutput( 
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIOutput **ppOutput) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetFrameStatistics( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_FRAME_STATISTICS *pStats) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetLastPresentCount( 
+            /* [annotation][out] */ 
+            _Out_  UINT *pLastPresentCount) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGISwapChainVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGISwapChain * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGISwapChain * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGISwapChain * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGISwapChain * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGISwapChain * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGISwapChain * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGISwapChain * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            IDXGISwapChain * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *Present )( 
+            IDXGISwapChain * This,
+            /* [in] */ UINT SyncInterval,
+            /* [in] */ UINT Flags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
+            IDXGISwapChain * This,
+            /* [in] */ UINT Buffer,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][out][in] */ 
+            _COM_Outptr_  void **ppSurface);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetFullscreenState )( 
+            IDXGISwapChain * This,
+            /* [in] */ BOOL Fullscreen,
+            /* [annotation][in] */ 
+            _In_opt_  IDXGIOutput *pTarget);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetFullscreenState )( 
+            IDXGISwapChain * This,
+            /* [annotation][out] */ 
+            _Out_opt_  BOOL *pFullscreen,
+            /* [annotation][out] */ 
+            _COM_Outptr_opt_result_maybenull_  IDXGIOutput **ppTarget);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
+            IDXGISwapChain * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_SWAP_CHAIN_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *ResizeBuffers )( 
+            IDXGISwapChain * This,
+            /* [in] */ UINT BufferCount,
+            /* [in] */ UINT Width,
+            /* [in] */ UINT Height,
+            /* [in] */ DXGI_FORMAT NewFormat,
+            /* [in] */ UINT SwapChainFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *ResizeTarget )( 
+            IDXGISwapChain * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_MODE_DESC *pNewTargetParameters);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetContainingOutput )( 
+            IDXGISwapChain * This,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIOutput **ppOutput);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetFrameStatistics )( 
+            IDXGISwapChain * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_FRAME_STATISTICS *pStats);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetLastPresentCount )( 
+            IDXGISwapChain * This,
+            /* [annotation][out] */ 
+            _Out_  UINT *pLastPresentCount);
+        
+        END_INTERFACE
+    } IDXGISwapChainVtbl;
+
+    interface IDXGISwapChain
+    {
+        CONST_VTBL struct IDXGISwapChainVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGISwapChain_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGISwapChain_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGISwapChain_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGISwapChain_SetPrivateData(This,Name,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGISwapChain_SetPrivateDataInterface(This,Name,pUnknown) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGISwapChain_GetPrivateData(This,Name,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGISwapChain_GetParent(This,riid,ppParent) \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGISwapChain_GetDevice(This,riid,ppDevice) \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 
+
+
+#define IDXGISwapChain_Present(This,SyncInterval,Flags)  \
+    ( (This)->lpVtbl -> Present(This,SyncInterval,Flags) ) 
+
+#define IDXGISwapChain_GetBuffer(This,Buffer,riid,ppSurface) \
+    ( (This)->lpVtbl -> GetBuffer(This,Buffer,riid,ppSurface) ) 
+
+#define IDXGISwapChain_SetFullscreenState(This,Fullscreen,pTarget) \
+    ( (This)->lpVtbl -> SetFullscreenState(This,Fullscreen,pTarget) ) 
+
+#define IDXGISwapChain_GetFullscreenState(This,pFullscreen,ppTarget) \
+    ( (This)->lpVtbl -> GetFullscreenState(This,pFullscreen,ppTarget) ) 
+
+#define IDXGISwapChain_GetDesc(This,pDesc) \
+    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 
+
+#define IDXGISwapChain_ResizeBuffers(This,BufferCount,Width,Height,NewFormat,SwapChainFlags) \
+    ( (This)->lpVtbl -> ResizeBuffers(This,BufferCount,Width,Height,NewFormat,SwapChainFlags) ) 
+
+#define IDXGISwapChain_ResizeTarget(This,pNewTargetParameters) \
+    ( (This)->lpVtbl -> ResizeTarget(This,pNewTargetParameters) ) 
+
+#define IDXGISwapChain_GetContainingOutput(This,ppOutput)  \
+    ( (This)->lpVtbl -> GetContainingOutput(This,ppOutput) ) 
+
+#define IDXGISwapChain_GetFrameStatistics(This,pStats) \
+    ( (This)->lpVtbl -> GetFrameStatistics(This,pStats) ) 
+
+#define IDXGISwapChain_GetLastPresentCount(This,pLastPresentCount) \
+    ( (This)->lpVtbl -> GetLastPresentCount(This,pLastPresentCount) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGISwapChain_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi_0000_0009 */
+/* [local] */ 
+
+#define DXGI_MWA_NO_WINDOW_CHANGES      ( 1 << 0 )
+#define DXGI_MWA_NO_ALT_ENTER           ( 1 << 1 )
+#define DXGI_MWA_NO_PRINT_SCREEN        ( 1 << 2 )
+#define DXGI_MWA_VALID                  ( 0x7 )
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0009_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0009_v0_0_s_ifspec;
+
+#ifndef __IDXGIFactory_INTERFACE_DEFINED__
+#define __IDXGIFactory_INTERFACE_DEFINED__
+
+/* interface IDXGIFactory */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIFactory;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("7b7166ec-21c7-44ae-b21a-c9ae321ae369")
+    IDXGIFactory : public IDXGIObject
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE EnumAdapters( 
+            /* [in] */ UINT Adapter,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **ppAdapter) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE MakeWindowAssociation( 
+            HWND WindowHandle,
+            UINT Flags) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetWindowAssociation( 
+            /* [annotation][out] */ 
+            _Out_  HWND *pWindowHandle) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateSwapChain( 
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            /* [annotation][in] */ 
+            _In_  DXGI_SWAP_CHAIN_DESC *pDesc,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISwapChain **ppSwapChain) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateSoftwareAdapter( 
+            /* [in] */ HMODULE Module,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **ppAdapter) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIFactoryVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIFactory * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIFactory * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIFactory * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIFactory * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIFactory * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIFactory * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIFactory * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumAdapters )( 
+            IDXGIFactory * This,
+            /* [in] */ UINT Adapter,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **ppAdapter);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeWindowAssociation )( 
+            IDXGIFactory * This,
+            HWND WindowHandle,
+            UINT Flags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetWindowAssociation )( 
+            IDXGIFactory * This,
+            /* [annotation][out] */ 
+            _Out_  HWND *pWindowHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSwapChain )( 
+            IDXGIFactory * This,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            /* [annotation][in] */ 
+            _In_  DXGI_SWAP_CHAIN_DESC *pDesc,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISwapChain **ppSwapChain);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSoftwareAdapter )( 
+            IDXGIFactory * This,
+            /* [in] */ HMODULE Module,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **ppAdapter);
+        
+        END_INTERFACE
+    } IDXGIFactoryVtbl;
+
+    interface IDXGIFactory
+    {
+        CONST_VTBL struct IDXGIFactoryVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIFactory_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIFactory_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIFactory_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIFactory_SetPrivateData(This,Name,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIFactory_SetPrivateDataInterface(This,Name,pUnknown) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIFactory_GetPrivateData(This,Name,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIFactory_GetParent(This,riid,ppParent) \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIFactory_EnumAdapters(This,Adapter,ppAdapter)  \
+    ( (This)->lpVtbl -> EnumAdapters(This,Adapter,ppAdapter) ) 
+
+#define IDXGIFactory_MakeWindowAssociation(This,WindowHandle,Flags)  \
+    ( (This)->lpVtbl -> MakeWindowAssociation(This,WindowHandle,Flags) ) 
+
+#define IDXGIFactory_GetWindowAssociation(This,pWindowHandle)  \
+    ( (This)->lpVtbl -> GetWindowAssociation(This,pWindowHandle) ) 
+
+#define IDXGIFactory_CreateSwapChain(This,pDevice,pDesc,ppSwapChain) \
+    ( (This)->lpVtbl -> CreateSwapChain(This,pDevice,pDesc,ppSwapChain) ) 
+
+#define IDXGIFactory_CreateSoftwareAdapter(This,Module,ppAdapter)  \
+    ( (This)->lpVtbl -> CreateSoftwareAdapter(This,Module,ppAdapter) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIFactory_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi_0000_0010 */
+/* [local] */ 
+
+#pragma region Desktop Family
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+HRESULT WINAPI CreateDXGIFactory(REFIID riid, _COM_Outptr_ void **ppFactory);
+#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
+#pragma endregion
+HRESULT WINAPI CreateDXGIFactory1(REFIID riid, _COM_Outptr_ void **ppFactory);
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0010_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0010_v0_0_s_ifspec;
+
+#ifndef __IDXGIDevice_INTERFACE_DEFINED__
+#define __IDXGIDevice_INTERFACE_DEFINED__
+
+/* interface IDXGIDevice */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIDevice;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("54ec77fa-1377-44e6-8c32-88fd5f44c84c")
+    IDXGIDevice : public IDXGIObject
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetAdapter( 
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **pAdapter) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CreateSurface( 
+            /* [annotation][in] */ 
+            _In_  const DXGI_SURFACE_DESC *pDesc,
+            /* [in] */ UINT NumSurfaces,
+            /* [in] */ DXGI_USAGE Usage,
+            /* [annotation][in] */ 
+            _In_opt_  const DXGI_SHARED_RESOURCE *pSharedResource,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISurface **ppSurface) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE QueryResourceResidency( 
+            /* [annotation][size_is][in] */ 
+            _In_reads_(NumResources)  IUnknown *const *ppResources,
+            /* [annotation][size_is][out] */ 
+            _Out_writes_(NumResources)  DXGI_RESIDENCY *pResidencyStatus,
+            /* [in] */ UINT NumResources) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetGPUThreadPriority( 
+            /* [in] */ INT Priority) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetGPUThreadPriority( 
+            /* [annotation][retval][out] */ 
+            _Out_  INT *pPriority) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIDeviceVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIDevice * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIDevice * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIDevice * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIDevice * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIDevice * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIDevice * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIDevice * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAdapter )( 
+            IDXGIDevice * This,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **pAdapter);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
+            IDXGIDevice * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_SURFACE_DESC *pDesc,
+            /* [in] */ UINT NumSurfaces,
+            /* [in] */ DXGI_USAGE Usage,
+            /* [annotation][in] */ 
+            _In_opt_  const DXGI_SHARED_RESOURCE *pSharedResource,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISurface **ppSurface);
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryResourceResidency )( 
+            IDXGIDevice * This,
+            /* [annotation][size_is][in] */ 
+            _In_reads_(NumResources)  IUnknown *const *ppResources,
+            /* [annotation][size_is][out] */ 
+            _Out_writes_(NumResources)  DXGI_RESIDENCY *pResidencyStatus,
+            /* [in] */ UINT NumResources);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetGPUThreadPriority )( 
+            IDXGIDevice * This,
+            /* [in] */ INT Priority);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetGPUThreadPriority )( 
+            IDXGIDevice * This,
+            /* [annotation][retval][out] */ 
+            _Out_  INT *pPriority);
+        
+        END_INTERFACE
+    } IDXGIDeviceVtbl;
+
+    interface IDXGIDevice
+    {
+        CONST_VTBL struct IDXGIDeviceVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIDevice_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIDevice_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIDevice_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIDevice_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIDevice_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIDevice_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIDevice_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIDevice_GetAdapter(This,pAdapter)  \
+    ( (This)->lpVtbl -> GetAdapter(This,pAdapter) ) 
+
+#define IDXGIDevice_CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface)  \
+    ( (This)->lpVtbl -> CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface) ) 
+
+#define IDXGIDevice_QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources) \
+    ( (This)->lpVtbl -> QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources) ) 
+
+#define IDXGIDevice_SetGPUThreadPriority(This,Priority)  \
+    ( (This)->lpVtbl -> SetGPUThreadPriority(This,Priority) ) 
+
+#define IDXGIDevice_GetGPUThreadPriority(This,pPriority) \
+    ( (This)->lpVtbl -> GetGPUThreadPriority(This,pPriority) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIDevice_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi_0000_0011 */
+/* [local] */ 
+
+typedef 
+enum DXGI_ADAPTER_FLAG
+    {
+        DXGI_ADAPTER_FLAG_NONE = 0,
+        DXGI_ADAPTER_FLAG_REMOTE = 1,
+        DXGI_ADAPTER_FLAG_SOFTWARE = 2,
+        DXGI_ADAPTER_FLAG_FORCE_DWORD  = 0xffffffff
+    }  DXGI_ADAPTER_FLAG;
+
+typedef struct DXGI_ADAPTER_DESC1
+    {
+    WCHAR Description[ 128 ];
+    UINT VendorId;
+    UINT DeviceId;
+    UINT SubSysId;
+    UINT Revision;
+    SIZE_T DedicatedVideoMemory;
+    SIZE_T DedicatedSystemMemory;
+    SIZE_T SharedSystemMemory;
+    LUID AdapterLuid;
+    UINT Flags;
+    }  DXGI_ADAPTER_DESC1;
+
+typedef struct DXGI_DISPLAY_COLOR_SPACE
+    {
+    FLOAT PrimaryCoordinates[ 8 ][ 2 ];
+    FLOAT WhitePoints[ 16 ][ 2 ];
+    }  DXGI_DISPLAY_COLOR_SPACE;
+
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0011_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0011_v0_0_s_ifspec;
+
+#ifndef __IDXGIFactory1_INTERFACE_DEFINED__
+#define __IDXGIFactory1_INTERFACE_DEFINED__
+
+/* interface IDXGIFactory1 */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIFactory1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("770aae78-f26f-4dba-a829-253c83d1b387")
+    IDXGIFactory1 : public IDXGIFactory
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE EnumAdapters1( 
+            /* [in] */ UINT Adapter,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter1 **ppAdapter) = 0;
+        
+        virtual BOOL STDMETHODCALLTYPE IsCurrent( void) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIFactory1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIFactory1 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIFactory1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIFactory1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIFactory1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIFactory1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIFactory1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIFactory1 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumAdapters )( 
+            IDXGIFactory1 * This,
+            /* [in] */ UINT Adapter,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **ppAdapter);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeWindowAssociation )( 
+            IDXGIFactory1 * This,
+            HWND WindowHandle,
+            UINT Flags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetWindowAssociation )( 
+            IDXGIFactory1 * This,
+            /* [annotation][out] */ 
+            _Out_  HWND *pWindowHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSwapChain )( 
+            IDXGIFactory1 * This,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            /* [annotation][in] */ 
+            _In_  DXGI_SWAP_CHAIN_DESC *pDesc,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISwapChain **ppSwapChain);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSoftwareAdapter )( 
+            IDXGIFactory1 * This,
+            /* [in] */ HMODULE Module,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **ppAdapter);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumAdapters1 )( 
+            IDXGIFactory1 * This,
+            /* [in] */ UINT Adapter,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter1 **ppAdapter);
+        
+        BOOL ( STDMETHODCALLTYPE *IsCurrent )( 
+            IDXGIFactory1 * This);
+        
+        END_INTERFACE
+    } IDXGIFactory1Vtbl;
+
+    interface IDXGIFactory1
+    {
+        CONST_VTBL struct IDXGIFactory1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIFactory1_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIFactory1_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIFactory1_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIFactory1_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIFactory1_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIFactory1_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIFactory1_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIFactory1_EnumAdapters(This,Adapter,ppAdapter) \
+    ( (This)->lpVtbl -> EnumAdapters(This,Adapter,ppAdapter) ) 
+
+#define IDXGIFactory1_MakeWindowAssociation(This,WindowHandle,Flags) \
+    ( (This)->lpVtbl -> MakeWindowAssociation(This,WindowHandle,Flags) ) 
+
+#define IDXGIFactory1_GetWindowAssociation(This,pWindowHandle) \
+    ( (This)->lpVtbl -> GetWindowAssociation(This,pWindowHandle) ) 
+
+#define IDXGIFactory1_CreateSwapChain(This,pDevice,pDesc,ppSwapChain)  \
+    ( (This)->lpVtbl -> CreateSwapChain(This,pDevice,pDesc,ppSwapChain) ) 
+
+#define IDXGIFactory1_CreateSoftwareAdapter(This,Module,ppAdapter) \
+    ( (This)->lpVtbl -> CreateSoftwareAdapter(This,Module,ppAdapter) ) 
+
+
+#define IDXGIFactory1_EnumAdapters1(This,Adapter,ppAdapter)  \
+    ( (This)->lpVtbl -> EnumAdapters1(This,Adapter,ppAdapter) ) 
+
+#define IDXGIFactory1_IsCurrent(This)  \
+    ( (This)->lpVtbl -> IsCurrent(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIFactory1_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDXGIAdapter1_INTERFACE_DEFINED__
+#define __IDXGIAdapter1_INTERFACE_DEFINED__
+
+/* interface IDXGIAdapter1 */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIAdapter1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("29038f61-3839-4626-91fd-086879011a05")
+    IDXGIAdapter1 : public IDXGIAdapter
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetDesc1( 
+            /* [annotation][out] */ 
+            _Out_  DXGI_ADAPTER_DESC1 *pDesc) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIAdapter1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIAdapter1 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIAdapter1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIAdapter1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIAdapter1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIAdapter1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIAdapter1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIAdapter1 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumOutputs )( 
+            IDXGIAdapter1 * This,
+            /* [in] */ UINT Output,
+            /* [annotation][out][in] */ 
+            _COM_Outptr_  IDXGIOutput **ppOutput);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
+            IDXGIAdapter1 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_ADAPTER_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckInterfaceSupport )( 
+            IDXGIAdapter1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID InterfaceName,
+            /* [annotation][out] */ 
+            _Out_  LARGE_INTEGER *pUMDVersion);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc1 )( 
+            IDXGIAdapter1 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_ADAPTER_DESC1 *pDesc);
+        
+        END_INTERFACE
+    } IDXGIAdapter1Vtbl;
+
+    interface IDXGIAdapter1
+    {
+        CONST_VTBL struct IDXGIAdapter1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIAdapter1_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIAdapter1_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIAdapter1_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIAdapter1_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIAdapter1_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIAdapter1_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIAdapter1_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIAdapter1_EnumOutputs(This,Output,ppOutput)  \
+    ( (This)->lpVtbl -> EnumOutputs(This,Output,ppOutput) ) 
+
+#define IDXGIAdapter1_GetDesc(This,pDesc)  \
+    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 
+
+#define IDXGIAdapter1_CheckInterfaceSupport(This,InterfaceName,pUMDVersion)  \
+    ( (This)->lpVtbl -> CheckInterfaceSupport(This,InterfaceName,pUMDVersion) ) 
+
+
+#define IDXGIAdapter1_GetDesc1(This,pDesc) \
+    ( (This)->lpVtbl -> GetDesc1(This,pDesc) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIAdapter1_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDXGIDevice1_INTERFACE_DEFINED__
+#define __IDXGIDevice1_INTERFACE_DEFINED__
+
+/* interface IDXGIDevice1 */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIDevice1;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("77db970f-6276-48ba-ba28-070143b4392c")
+    IDXGIDevice1 : public IDXGIDevice
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetMaximumFrameLatency( 
+            /* [in] */ UINT MaxLatency) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetMaximumFrameLatency( 
+            /* [annotation][out] */ 
+            _Out_  UINT *pMaxLatency) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIDevice1Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIDevice1 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIDevice1 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIDevice1 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIDevice1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIDevice1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIDevice1 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIDevice1 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAdapter )( 
+            IDXGIDevice1 * This,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **pAdapter);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
+            IDXGIDevice1 * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_SURFACE_DESC *pDesc,
+            /* [in] */ UINT NumSurfaces,
+            /* [in] */ DXGI_USAGE Usage,
+            /* [annotation][in] */ 
+            _In_opt_  const DXGI_SHARED_RESOURCE *pSharedResource,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISurface **ppSurface);
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryResourceResidency )( 
+            IDXGIDevice1 * This,
+            /* [annotation][size_is][in] */ 
+            _In_reads_(NumResources)  IUnknown *const *ppResources,
+            /* [annotation][size_is][out] */ 
+            _Out_writes_(NumResources)  DXGI_RESIDENCY *pResidencyStatus,
+            /* [in] */ UINT NumResources);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetGPUThreadPriority )( 
+            IDXGIDevice1 * This,
+            /* [in] */ INT Priority);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetGPUThreadPriority )( 
+            IDXGIDevice1 * This,
+            /* [annotation][retval][out] */ 
+            _Out_  INT *pPriority);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetMaximumFrameLatency )( 
+            IDXGIDevice1 * This,
+            /* [in] */ UINT MaxLatency);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetMaximumFrameLatency )( 
+            IDXGIDevice1 * This,
+            /* [annotation][out] */ 
+            _Out_  UINT *pMaxLatency);
+        
+        END_INTERFACE
+    } IDXGIDevice1Vtbl;
+
+    interface IDXGIDevice1
+    {
+        CONST_VTBL struct IDXGIDevice1Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIDevice1_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIDevice1_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIDevice1_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIDevice1_SetPrivateData(This,Name,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIDevice1_SetPrivateDataInterface(This,Name,pUnknown) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIDevice1_GetPrivateData(This,Name,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIDevice1_GetParent(This,riid,ppParent) \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIDevice1_GetAdapter(This,pAdapter) \
+    ( (This)->lpVtbl -> GetAdapter(This,pAdapter) ) 
+
+#define IDXGIDevice1_CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface) \
+    ( (This)->lpVtbl -> CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface) ) 
+
+#define IDXGIDevice1_QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources)  \
+    ( (This)->lpVtbl -> QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources) ) 
+
+#define IDXGIDevice1_SetGPUThreadPriority(This,Priority) \
+    ( (This)->lpVtbl -> SetGPUThreadPriority(This,Priority) ) 
+
+#define IDXGIDevice1_GetGPUThreadPriority(This,pPriority)  \
+    ( (This)->lpVtbl -> GetGPUThreadPriority(This,pPriority) ) 
+
+
+#define IDXGIDevice1_SetMaximumFrameLatency(This,MaxLatency) \
+    ( (This)->lpVtbl -> SetMaximumFrameLatency(This,MaxLatency) ) 
+
+#define IDXGIDevice1_GetMaximumFrameLatency(This,pMaxLatency)  \
+    ( (This)->lpVtbl -> GetMaximumFrameLatency(This,pMaxLatency) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIDevice1_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi_0000_0014 */
+/* [local] */ 
+
+#ifdef __cplusplus
+#endif /*__cplusplus*/
+DEFINE_GUID(IID_IDXGIObject,0xaec22fb8,0x76f3,0x4639,0x9b,0xe0,0x28,0xeb,0x43,0xa6,0x7a,0x2e);
+DEFINE_GUID(IID_IDXGIDeviceSubObject,0x3d3e0379,0xf9de,0x4d58,0xbb,0x6c,0x18,0xd6,0x29,0x92,0xf1,0xa6);
+DEFINE_GUID(IID_IDXGIResource,0x035f3ab4,0x482e,0x4e50,0xb4,0x1f,0x8a,0x7f,0x8b,0xd8,0x96,0x0b);
+DEFINE_GUID(IID_IDXGIKeyedMutex,0x9d8e1289,0xd7b3,0x465f,0x81,0x26,0x25,0x0e,0x34,0x9a,0xf8,0x5d);
+DEFINE_GUID(IID_IDXGISurface,0xcafcb56c,0x6ac3,0x4889,0xbf,0x47,0x9e,0x23,0xbb,0xd2,0x60,0xec);
+DEFINE_GUID(IID_IDXGISurface1,0x4AE63092,0x6327,0x4c1b,0x80,0xAE,0xBF,0xE1,0x2E,0xA3,0x2B,0x86);
+DEFINE_GUID(IID_IDXGIAdapter,0x2411e7e1,0x12ac,0x4ccf,0xbd,0x14,0x97,0x98,0xe8,0x53,0x4d,0xc0);
+DEFINE_GUID(IID_IDXGIOutput,0xae02eedb,0xc735,0x4690,0x8d,0x52,0x5a,0x8d,0xc2,0x02,0x13,0xaa);
+DEFINE_GUID(IID_IDXGISwapChain,0x310d36a0,0xd2e7,0x4c0a,0xaa,0x04,0x6a,0x9d,0x23,0xb8,0x88,0x6a);
+DEFINE_GUID(IID_IDXGIFactory,0x7b7166ec,0x21c7,0x44ae,0xb2,0x1a,0xc9,0xae,0x32,0x1a,0xe3,0x69);
+DEFINE_GUID(IID_IDXGIDevice,0x54ec77fa,0x1377,0x44e6,0x8c,0x32,0x88,0xfd,0x5f,0x44,0xc8,0x4c);
+DEFINE_GUID(IID_IDXGIFactory1,0x770aae78,0xf26f,0x4dba,0xa8,0x29,0x25,0x3c,0x83,0xd1,0xb3,0x87);
+DEFINE_GUID(IID_IDXGIAdapter1,0x29038f61,0x3839,0x4626,0x91,0xfd,0x08,0x68,0x79,0x01,0x1a,0x05);
+DEFINE_GUID(IID_IDXGIDevice1,0x77db970f,0x6276,0x48ba,0xba,0x28,0x07,0x01,0x43,0xb4,0x39,0x2c);
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0014_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0014_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/pc/gfx/dxsdk/dxgi1_4.h b/src/pc/gfx/dxsdk/dxgi1_4.h
new file mode 100644
index 0000000..8db995c
--- /dev/null
+++ b/src/pc/gfx/dxsdk/dxgi1_4.h
@@ -0,0 +1,1494 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 8.01.0622 */
+/* @@MIDL_FILE_HEADING(  ) */
+
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 500
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif /* __RPCNDR_H_VERSION__ */
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __dxgi1_4_h__
+#define __dxgi1_4_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IDXGISwapChain3_FWD_DEFINED__
+#define __IDXGISwapChain3_FWD_DEFINED__
+typedef interface IDXGISwapChain3 IDXGISwapChain3;
+
+#endif   /* __IDXGISwapChain3_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIOutput4_FWD_DEFINED__
+#define __IDXGIOutput4_FWD_DEFINED__
+typedef interface IDXGIOutput4 IDXGIOutput4;
+
+#endif   /* __IDXGIOutput4_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIFactory4_FWD_DEFINED__
+#define __IDXGIFactory4_FWD_DEFINED__
+typedef interface IDXGIFactory4 IDXGIFactory4;
+
+#endif   /* __IDXGIFactory4_FWD_DEFINED__ */
+
+
+#ifndef __IDXGIAdapter3_FWD_DEFINED__
+#define __IDXGIAdapter3_FWD_DEFINED__
+typedef interface IDXGIAdapter3 IDXGIAdapter3;
+
+#endif   /* __IDXGIAdapter3_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "dxgi1_3.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_dxgi1_4_0000_0000 */
+/* [local] */ 
+
+#include <winapifamily.h>
+#pragma region App Family
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_GAMES)
+typedef 
+enum DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG
+    {
+        DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT = 0x1,
+        DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_OVERLAY_PRESENT = 0x2
+    }  DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi1_4_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi1_4_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IDXGISwapChain3_INTERFACE_DEFINED__
+#define __IDXGISwapChain3_INTERFACE_DEFINED__
+
+/* interface IDXGISwapChain3 */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGISwapChain3;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("94d99bdb-f1f8-4ab0-b236-7da0170edab1")
+    IDXGISwapChain3 : public IDXGISwapChain2
+    {
+    public:
+        virtual UINT STDMETHODCALLTYPE GetCurrentBackBufferIndex( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE CheckColorSpaceSupport( 
+            /* [annotation][in] */ 
+            _In_  DXGI_COLOR_SPACE_TYPE ColorSpace,
+            /* [annotation][out] */ 
+            _Out_  UINT *pColorSpaceSupport) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetColorSpace1( 
+            /* [annotation][in] */ 
+            _In_  DXGI_COLOR_SPACE_TYPE ColorSpace) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ResizeBuffers1( 
+            /* [annotation][in] */ 
+            _In_  UINT BufferCount,
+            /* [annotation][in] */ 
+            _In_  UINT Width,
+            /* [annotation][in] */ 
+            _In_  UINT Height,
+            /* [annotation][in] */ 
+            _In_  DXGI_FORMAT Format,
+            /* [annotation][in] */ 
+            _In_  UINT SwapChainFlags,
+            /* [annotation][in] */ 
+            _In_reads_(BufferCount)  const UINT *pCreationNodeMask,
+            /* [annotation][in] */ 
+            _In_reads_(BufferCount)  IUnknown *const *ppPresentQueue) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGISwapChain3Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGISwapChain3 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGISwapChain3 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGISwapChain3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *Present )( 
+            IDXGISwapChain3 * This,
+            /* [in] */ UINT SyncInterval,
+            /* [in] */ UINT Flags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
+            IDXGISwapChain3 * This,
+            /* [in] */ UINT Buffer,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][out][in] */ 
+            _COM_Outptr_  void **ppSurface);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetFullscreenState )( 
+            IDXGISwapChain3 * This,
+            /* [in] */ BOOL Fullscreen,
+            /* [annotation][in] */ 
+            _In_opt_  IDXGIOutput *pTarget);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetFullscreenState )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_opt_  BOOL *pFullscreen,
+            /* [annotation][out] */ 
+            _COM_Outptr_opt_result_maybenull_  IDXGIOutput **ppTarget);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_SWAP_CHAIN_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *ResizeBuffers )( 
+            IDXGISwapChain3 * This,
+            /* [in] */ UINT BufferCount,
+            /* [in] */ UINT Width,
+            /* [in] */ UINT Height,
+            /* [in] */ DXGI_FORMAT NewFormat,
+            /* [in] */ UINT SwapChainFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *ResizeTarget )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_MODE_DESC *pNewTargetParameters);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetContainingOutput )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIOutput **ppOutput);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetFrameStatistics )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_FRAME_STATISTICS *pStats);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetLastPresentCount )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  UINT *pLastPresentCount);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc1 )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_SWAP_CHAIN_DESC1 *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetFullscreenDesc )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_SWAP_CHAIN_FULLSCREEN_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetHwnd )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  HWND *pHwnd);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCoreWindow )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID refiid,
+            /* [annotation][out] */ 
+            _COM_Outptr_  void **ppUnk);
+        
+        HRESULT ( STDMETHODCALLTYPE *Present1 )( 
+            IDXGISwapChain3 * This,
+            /* [in] */ UINT SyncInterval,
+            /* [in] */ UINT PresentFlags,
+            /* [annotation][in] */ 
+            _In_  const DXGI_PRESENT_PARAMETERS *pPresentParameters);
+        
+        BOOL ( STDMETHODCALLTYPE *IsTemporaryMonoSupported )( 
+            IDXGISwapChain3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRestrictToOutput )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  IDXGIOutput **ppRestrictToOutput);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetBackgroundColor )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_RGBA *pColor);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetBackgroundColor )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_RGBA *pColor);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetRotation )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  DXGI_MODE_ROTATION Rotation);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRotation )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_MODE_ROTATION *pRotation);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetSourceSize )( 
+            IDXGISwapChain3 * This,
+            UINT Width,
+            UINT Height);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSourceSize )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  UINT *pWidth,
+            /* [annotation][out] */ 
+            _Out_  UINT *pHeight);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetMaximumFrameLatency )( 
+            IDXGISwapChain3 * This,
+            UINT MaxLatency);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetMaximumFrameLatency )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  UINT *pMaxLatency);
+        
+        HANDLE ( STDMETHODCALLTYPE *GetFrameLatencyWaitableObject )( 
+            IDXGISwapChain3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetMatrixTransform )( 
+            IDXGISwapChain3 * This,
+            const DXGI_MATRIX_3X2_F *pMatrix);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetMatrixTransform )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_MATRIX_3X2_F *pMatrix);
+        
+        UINT ( STDMETHODCALLTYPE *GetCurrentBackBufferIndex )( 
+            IDXGISwapChain3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckColorSpaceSupport )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  DXGI_COLOR_SPACE_TYPE ColorSpace,
+            /* [annotation][out] */ 
+            _Out_  UINT *pColorSpaceSupport);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetColorSpace1 )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  DXGI_COLOR_SPACE_TYPE ColorSpace);
+        
+        HRESULT ( STDMETHODCALLTYPE *ResizeBuffers1 )( 
+            IDXGISwapChain3 * This,
+            /* [annotation][in] */ 
+            _In_  UINT BufferCount,
+            /* [annotation][in] */ 
+            _In_  UINT Width,
+            /* [annotation][in] */ 
+            _In_  UINT Height,
+            /* [annotation][in] */ 
+            _In_  DXGI_FORMAT Format,
+            /* [annotation][in] */ 
+            _In_  UINT SwapChainFlags,
+            /* [annotation][in] */ 
+            _In_reads_(BufferCount)  const UINT *pCreationNodeMask,
+            /* [annotation][in] */ 
+            _In_reads_(BufferCount)  IUnknown *const *ppPresentQueue);
+        
+        END_INTERFACE
+    } IDXGISwapChain3Vtbl;
+
+    interface IDXGISwapChain3
+    {
+        CONST_VTBL struct IDXGISwapChain3Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGISwapChain3_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGISwapChain3_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGISwapChain3_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGISwapChain3_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGISwapChain3_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGISwapChain3_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGISwapChain3_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGISwapChain3_GetDevice(This,riid,ppDevice)  \
+    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 
+
+
+#define IDXGISwapChain3_Present(This,SyncInterval,Flags) \
+    ( (This)->lpVtbl -> Present(This,SyncInterval,Flags) ) 
+
+#define IDXGISwapChain3_GetBuffer(This,Buffer,riid,ppSurface)  \
+    ( (This)->lpVtbl -> GetBuffer(This,Buffer,riid,ppSurface) ) 
+
+#define IDXGISwapChain3_SetFullscreenState(This,Fullscreen,pTarget)  \
+    ( (This)->lpVtbl -> SetFullscreenState(This,Fullscreen,pTarget) ) 
+
+#define IDXGISwapChain3_GetFullscreenState(This,pFullscreen,ppTarget)  \
+    ( (This)->lpVtbl -> GetFullscreenState(This,pFullscreen,ppTarget) ) 
+
+#define IDXGISwapChain3_GetDesc(This,pDesc)  \
+    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 
+
+#define IDXGISwapChain3_ResizeBuffers(This,BufferCount,Width,Height,NewFormat,SwapChainFlags)  \
+    ( (This)->lpVtbl -> ResizeBuffers(This,BufferCount,Width,Height,NewFormat,SwapChainFlags) ) 
+
+#define IDXGISwapChain3_ResizeTarget(This,pNewTargetParameters)  \
+    ( (This)->lpVtbl -> ResizeTarget(This,pNewTargetParameters) ) 
+
+#define IDXGISwapChain3_GetContainingOutput(This,ppOutput) \
+    ( (This)->lpVtbl -> GetContainingOutput(This,ppOutput) ) 
+
+#define IDXGISwapChain3_GetFrameStatistics(This,pStats)  \
+    ( (This)->lpVtbl -> GetFrameStatistics(This,pStats) ) 
+
+#define IDXGISwapChain3_GetLastPresentCount(This,pLastPresentCount)  \
+    ( (This)->lpVtbl -> GetLastPresentCount(This,pLastPresentCount) ) 
+
+
+#define IDXGISwapChain3_GetDesc1(This,pDesc) \
+    ( (This)->lpVtbl -> GetDesc1(This,pDesc) ) 
+
+#define IDXGISwapChain3_GetFullscreenDesc(This,pDesc)  \
+    ( (This)->lpVtbl -> GetFullscreenDesc(This,pDesc) ) 
+
+#define IDXGISwapChain3_GetHwnd(This,pHwnd)  \
+    ( (This)->lpVtbl -> GetHwnd(This,pHwnd) ) 
+
+#define IDXGISwapChain3_GetCoreWindow(This,refiid,ppUnk) \
+    ( (This)->lpVtbl -> GetCoreWindow(This,refiid,ppUnk) ) 
+
+#define IDXGISwapChain3_Present1(This,SyncInterval,PresentFlags,pPresentParameters)  \
+    ( (This)->lpVtbl -> Present1(This,SyncInterval,PresentFlags,pPresentParameters) ) 
+
+#define IDXGISwapChain3_IsTemporaryMonoSupported(This) \
+    ( (This)->lpVtbl -> IsTemporaryMonoSupported(This) ) 
+
+#define IDXGISwapChain3_GetRestrictToOutput(This,ppRestrictToOutput) \
+    ( (This)->lpVtbl -> GetRestrictToOutput(This,ppRestrictToOutput) ) 
+
+#define IDXGISwapChain3_SetBackgroundColor(This,pColor)  \
+    ( (This)->lpVtbl -> SetBackgroundColor(This,pColor) ) 
+
+#define IDXGISwapChain3_GetBackgroundColor(This,pColor)  \
+    ( (This)->lpVtbl -> GetBackgroundColor(This,pColor) ) 
+
+#define IDXGISwapChain3_SetRotation(This,Rotation) \
+    ( (This)->lpVtbl -> SetRotation(This,Rotation) ) 
+
+#define IDXGISwapChain3_GetRotation(This,pRotation)  \
+    ( (This)->lpVtbl -> GetRotation(This,pRotation) ) 
+
+
+#define IDXGISwapChain3_SetSourceSize(This,Width,Height) \
+    ( (This)->lpVtbl -> SetSourceSize(This,Width,Height) ) 
+
+#define IDXGISwapChain3_GetSourceSize(This,pWidth,pHeight) \
+    ( (This)->lpVtbl -> GetSourceSize(This,pWidth,pHeight) ) 
+
+#define IDXGISwapChain3_SetMaximumFrameLatency(This,MaxLatency)  \
+    ( (This)->lpVtbl -> SetMaximumFrameLatency(This,MaxLatency) ) 
+
+#define IDXGISwapChain3_GetMaximumFrameLatency(This,pMaxLatency) \
+    ( (This)->lpVtbl -> GetMaximumFrameLatency(This,pMaxLatency) ) 
+
+#define IDXGISwapChain3_GetFrameLatencyWaitableObject(This)  \
+    ( (This)->lpVtbl -> GetFrameLatencyWaitableObject(This) ) 
+
+#define IDXGISwapChain3_SetMatrixTransform(This,pMatrix) \
+    ( (This)->lpVtbl -> SetMatrixTransform(This,pMatrix) ) 
+
+#define IDXGISwapChain3_GetMatrixTransform(This,pMatrix) \
+    ( (This)->lpVtbl -> GetMatrixTransform(This,pMatrix) ) 
+
+
+#define IDXGISwapChain3_GetCurrentBackBufferIndex(This)  \
+    ( (This)->lpVtbl -> GetCurrentBackBufferIndex(This) ) 
+
+#define IDXGISwapChain3_CheckColorSpaceSupport(This,ColorSpace,pColorSpaceSupport) \
+    ( (This)->lpVtbl -> CheckColorSpaceSupport(This,ColorSpace,pColorSpaceSupport) ) 
+
+#define IDXGISwapChain3_SetColorSpace1(This,ColorSpace)  \
+    ( (This)->lpVtbl -> SetColorSpace1(This,ColorSpace) ) 
+
+#define IDXGISwapChain3_ResizeBuffers1(This,BufferCount,Width,Height,Format,SwapChainFlags,pCreationNodeMask,ppPresentQueue) \
+    ( (This)->lpVtbl -> ResizeBuffers1(This,BufferCount,Width,Height,Format,SwapChainFlags,pCreationNodeMask,ppPresentQueue) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGISwapChain3_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi1_4_0000_0001 */
+/* [local] */ 
+
+typedef 
+enum DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG
+    {
+        DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG_PRESENT  = 0x1
+    }  DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi1_4_0000_0001_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi1_4_0000_0001_v0_0_s_ifspec;
+
+#ifndef __IDXGIOutput4_INTERFACE_DEFINED__
+#define __IDXGIOutput4_INTERFACE_DEFINED__
+
+/* interface IDXGIOutput4 */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIOutput4;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("dc7dca35-2196-414d-9F53-617884032a60")
+    IDXGIOutput4 : public IDXGIOutput3
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE CheckOverlayColorSpaceSupport( 
+            /* [annotation][in] */ 
+            _In_  DXGI_FORMAT Format,
+            /* [annotation][in] */ 
+            _In_  DXGI_COLOR_SPACE_TYPE ColorSpace,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pConcernedDevice,
+            /* [annotation][out] */ 
+            _Out_  UINT *pFlags) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIOutput4Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIOutput4 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIOutput4 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIOutput4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
+            IDXGIOutput4 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_OUTPUT_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayModeList )( 
+            IDXGIOutput4 * This,
+            /* [in] */ DXGI_FORMAT EnumFormat,
+            /* [in] */ UINT Flags,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pNumModes,
+            /* [annotation][out] */ 
+            _Out_writes_to_opt_(*pNumModes,*pNumModes)  DXGI_MODE_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *FindClosestMatchingMode )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_MODE_DESC *pModeToMatch,
+            /* [annotation][out] */ 
+            _Out_  DXGI_MODE_DESC *pClosestMatch,
+            /* [annotation][in] */ 
+            _In_opt_  IUnknown *pConcernedDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *WaitForVBlank )( 
+            IDXGIOutput4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *TakeOwnership )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            BOOL Exclusive);
+        
+        void ( STDMETHODCALLTYPE *ReleaseOwnership )( 
+            IDXGIOutput4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetGammaControlCapabilities )( 
+            IDXGIOutput4 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_GAMMA_CONTROL_CAPABILITIES *pGammaCaps);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetGammaControl )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_GAMMA_CONTROL *pArray);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetGammaControl )( 
+            IDXGIOutput4 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_GAMMA_CONTROL *pArray);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetDisplaySurface )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  IDXGISurface *pScanoutSurface);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplaySurfaceData )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  IDXGISurface *pDestination);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetFrameStatistics )( 
+            IDXGIOutput4 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_FRAME_STATISTICS *pStats);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayModeList1 )( 
+            IDXGIOutput4 * This,
+            /* [in] */ DXGI_FORMAT EnumFormat,
+            /* [in] */ UINT Flags,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pNumModes,
+            /* [annotation][out] */ 
+            _Out_writes_to_opt_(*pNumModes,*pNumModes)  DXGI_MODE_DESC1 *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *FindClosestMatchingMode1 )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  const DXGI_MODE_DESC1 *pModeToMatch,
+            /* [annotation][out] */ 
+            _Out_  DXGI_MODE_DESC1 *pClosestMatch,
+            /* [annotation][in] */ 
+            _In_opt_  IUnknown *pConcernedDevice);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplaySurfaceData1 )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  IDXGIResource *pDestination);
+        
+        HRESULT ( STDMETHODCALLTYPE *DuplicateOutput )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIOutputDuplication **ppOutputDuplication);
+        
+        BOOL ( STDMETHODCALLTYPE *SupportsOverlays )( 
+            IDXGIOutput4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckOverlaySupport )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  DXGI_FORMAT EnumFormat,
+            /* [annotation][out] */ 
+            _In_  IUnknown *pConcernedDevice,
+            /* [annotation][out] */ 
+            _Out_  UINT *pFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckOverlayColorSpaceSupport )( 
+            IDXGIOutput4 * This,
+            /* [annotation][in] */ 
+            _In_  DXGI_FORMAT Format,
+            /* [annotation][in] */ 
+            _In_  DXGI_COLOR_SPACE_TYPE ColorSpace,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pConcernedDevice,
+            /* [annotation][out] */ 
+            _Out_  UINT *pFlags);
+        
+        END_INTERFACE
+    } IDXGIOutput4Vtbl;
+
+    interface IDXGIOutput4
+    {
+        CONST_VTBL struct IDXGIOutput4Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIOutput4_QueryInterface(This,riid,ppvObject) \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIOutput4_AddRef(This)  \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIOutput4_Release(This) \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIOutput4_SetPrivateData(This,Name,DataSize,pData)  \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIOutput4_SetPrivateDataInterface(This,Name,pUnknown) \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIOutput4_GetPrivateData(This,Name,pDataSize,pData) \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIOutput4_GetParent(This,riid,ppParent) \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIOutput4_GetDesc(This,pDesc) \
+    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 
+
+#define IDXGIOutput4_GetDisplayModeList(This,EnumFormat,Flags,pNumModes,pDesc) \
+    ( (This)->lpVtbl -> GetDisplayModeList(This,EnumFormat,Flags,pNumModes,pDesc) ) 
+
+#define IDXGIOutput4_FindClosestMatchingMode(This,pModeToMatch,pClosestMatch,pConcernedDevice) \
+    ( (This)->lpVtbl -> FindClosestMatchingMode(This,pModeToMatch,pClosestMatch,pConcernedDevice) ) 
+
+#define IDXGIOutput4_WaitForVBlank(This) \
+    ( (This)->lpVtbl -> WaitForVBlank(This) ) 
+
+#define IDXGIOutput4_TakeOwnership(This,pDevice,Exclusive) \
+    ( (This)->lpVtbl -> TakeOwnership(This,pDevice,Exclusive) ) 
+
+#define IDXGIOutput4_ReleaseOwnership(This)  \
+    ( (This)->lpVtbl -> ReleaseOwnership(This) ) 
+
+#define IDXGIOutput4_GetGammaControlCapabilities(This,pGammaCaps)  \
+    ( (This)->lpVtbl -> GetGammaControlCapabilities(This,pGammaCaps) ) 
+
+#define IDXGIOutput4_SetGammaControl(This,pArray)  \
+    ( (This)->lpVtbl -> SetGammaControl(This,pArray) ) 
+
+#define IDXGIOutput4_GetGammaControl(This,pArray)  \
+    ( (This)->lpVtbl -> GetGammaControl(This,pArray) ) 
+
+#define IDXGIOutput4_SetDisplaySurface(This,pScanoutSurface) \
+    ( (This)->lpVtbl -> SetDisplaySurface(This,pScanoutSurface) ) 
+
+#define IDXGIOutput4_GetDisplaySurfaceData(This,pDestination)  \
+    ( (This)->lpVtbl -> GetDisplaySurfaceData(This,pDestination) ) 
+
+#define IDXGIOutput4_GetFrameStatistics(This,pStats) \
+    ( (This)->lpVtbl -> GetFrameStatistics(This,pStats) ) 
+
+
+#define IDXGIOutput4_GetDisplayModeList1(This,EnumFormat,Flags,pNumModes,pDesc)  \
+    ( (This)->lpVtbl -> GetDisplayModeList1(This,EnumFormat,Flags,pNumModes,pDesc) ) 
+
+#define IDXGIOutput4_FindClosestMatchingMode1(This,pModeToMatch,pClosestMatch,pConcernedDevice)  \
+    ( (This)->lpVtbl -> FindClosestMatchingMode1(This,pModeToMatch,pClosestMatch,pConcernedDevice) ) 
+
+#define IDXGIOutput4_GetDisplaySurfaceData1(This,pDestination) \
+    ( (This)->lpVtbl -> GetDisplaySurfaceData1(This,pDestination) ) 
+
+#define IDXGIOutput4_DuplicateOutput(This,pDevice,ppOutputDuplication) \
+    ( (This)->lpVtbl -> DuplicateOutput(This,pDevice,ppOutputDuplication) ) 
+
+
+#define IDXGIOutput4_SupportsOverlays(This)  \
+    ( (This)->lpVtbl -> SupportsOverlays(This) ) 
+
+
+#define IDXGIOutput4_CheckOverlaySupport(This,EnumFormat,pConcernedDevice,pFlags)  \
+    ( (This)->lpVtbl -> CheckOverlaySupport(This,EnumFormat,pConcernedDevice,pFlags) ) 
+
+
+#define IDXGIOutput4_CheckOverlayColorSpaceSupport(This,Format,ColorSpace,pConcernedDevice,pFlags) \
+    ( (This)->lpVtbl -> CheckOverlayColorSpaceSupport(This,Format,ColorSpace,pConcernedDevice,pFlags) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIOutput4_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDXGIFactory4_INTERFACE_DEFINED__
+#define __IDXGIFactory4_INTERFACE_DEFINED__
+
+/* interface IDXGIFactory4 */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIFactory4;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("1bc6ea02-ef36-464f-bf0c-21ca39e5168a")
+    IDXGIFactory4 : public IDXGIFactory3
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE EnumAdapterByLuid( 
+            /* [annotation] */ 
+            _In_  LUID AdapterLuid,
+            /* [annotation] */ 
+            _In_  REFIID riid,
+            /* [annotation] */ 
+            _COM_Outptr_  void **ppvAdapter) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE EnumWarpAdapter( 
+            /* [annotation] */ 
+            _In_  REFIID riid,
+            /* [annotation] */ 
+            _COM_Outptr_  void **ppvAdapter) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIFactory4Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIFactory4 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIFactory4 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIFactory4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumAdapters )( 
+            IDXGIFactory4 * This,
+            /* [in] */ UINT Adapter,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **ppAdapter);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeWindowAssociation )( 
+            IDXGIFactory4 * This,
+            HWND WindowHandle,
+            UINT Flags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetWindowAssociation )( 
+            IDXGIFactory4 * This,
+            /* [annotation][out] */ 
+            _Out_  HWND *pWindowHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSwapChain )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            /* [annotation][in] */ 
+            _In_  DXGI_SWAP_CHAIN_DESC *pDesc,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISwapChain **ppSwapChain);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSoftwareAdapter )( 
+            IDXGIFactory4 * This,
+            /* [in] */ HMODULE Module,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter **ppAdapter);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumAdapters1 )( 
+            IDXGIFactory4 * This,
+            /* [in] */ UINT Adapter,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGIAdapter1 **ppAdapter);
+        
+        BOOL ( STDMETHODCALLTYPE *IsCurrent )( 
+            IDXGIFactory4 * This);
+        
+        BOOL ( STDMETHODCALLTYPE *IsWindowedStereoEnabled )( 
+            IDXGIFactory4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSwapChainForHwnd )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            /* [annotation][in] */ 
+            _In_  HWND hWnd,
+            /* [annotation][in] */ 
+            _In_  const DXGI_SWAP_CHAIN_DESC1 *pDesc,
+            /* [annotation][in] */ 
+            _In_opt_  const DXGI_SWAP_CHAIN_FULLSCREEN_DESC *pFullscreenDesc,
+            /* [annotation][in] */ 
+            _In_opt_  IDXGIOutput *pRestrictToOutput,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISwapChain1 **ppSwapChain);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSwapChainForCoreWindow )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pWindow,
+            /* [annotation][in] */ 
+            _In_  const DXGI_SWAP_CHAIN_DESC1 *pDesc,
+            /* [annotation][in] */ 
+            _In_opt_  IDXGIOutput *pRestrictToOutput,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISwapChain1 **ppSwapChain);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSharedResourceAdapterLuid )( 
+            IDXGIFactory4 * This,
+            /* [annotation] */ 
+            _In_  HANDLE hResource,
+            /* [annotation] */ 
+            _Out_  LUID *pLuid);
+        
+        HRESULT ( STDMETHODCALLTYPE *RegisterStereoStatusWindow )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  HWND WindowHandle,
+            /* [annotation][in] */ 
+            _In_  UINT wMsg,
+            /* [annotation][out] */ 
+            _Out_  DWORD *pdwCookie);
+        
+        HRESULT ( STDMETHODCALLTYPE *RegisterStereoStatusEvent )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  HANDLE hEvent,
+            /* [annotation][out] */ 
+            _Out_  DWORD *pdwCookie);
+        
+        void ( STDMETHODCALLTYPE *UnregisterStereoStatus )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  DWORD dwCookie);
+        
+        HRESULT ( STDMETHODCALLTYPE *RegisterOcclusionStatusWindow )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  HWND WindowHandle,
+            /* [annotation][in] */ 
+            _In_  UINT wMsg,
+            /* [annotation][out] */ 
+            _Out_  DWORD *pdwCookie);
+        
+        HRESULT ( STDMETHODCALLTYPE *RegisterOcclusionStatusEvent )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  HANDLE hEvent,
+            /* [annotation][out] */ 
+            _Out_  DWORD *pdwCookie);
+        
+        void ( STDMETHODCALLTYPE *UnregisterOcclusionStatus )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  DWORD dwCookie);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateSwapChainForComposition )( 
+            IDXGIFactory4 * This,
+            /* [annotation][in] */ 
+            _In_  IUnknown *pDevice,
+            /* [annotation][in] */ 
+            _In_  const DXGI_SWAP_CHAIN_DESC1 *pDesc,
+            /* [annotation][in] */ 
+            _In_opt_  IDXGIOutput *pRestrictToOutput,
+            /* [annotation][out] */ 
+            _COM_Outptr_  IDXGISwapChain1 **ppSwapChain);
+        
+        UINT ( STDMETHODCALLTYPE *GetCreationFlags )( 
+            IDXGIFactory4 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumAdapterByLuid )( 
+            IDXGIFactory4 * This,
+            /* [annotation] */ 
+            _In_  LUID AdapterLuid,
+            /* [annotation] */ 
+            _In_  REFIID riid,
+            /* [annotation] */ 
+            _COM_Outptr_  void **ppvAdapter);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumWarpAdapter )( 
+            IDXGIFactory4 * This,
+            /* [annotation] */ 
+            _In_  REFIID riid,
+            /* [annotation] */ 
+            _COM_Outptr_  void **ppvAdapter);
+        
+        END_INTERFACE
+    } IDXGIFactory4Vtbl;
+
+    interface IDXGIFactory4
+    {
+        CONST_VTBL struct IDXGIFactory4Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIFactory4_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIFactory4_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIFactory4_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIFactory4_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIFactory4_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIFactory4_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIFactory4_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIFactory4_EnumAdapters(This,Adapter,ppAdapter) \
+    ( (This)->lpVtbl -> EnumAdapters(This,Adapter,ppAdapter) ) 
+
+#define IDXGIFactory4_MakeWindowAssociation(This,WindowHandle,Flags) \
+    ( (This)->lpVtbl -> MakeWindowAssociation(This,WindowHandle,Flags) ) 
+
+#define IDXGIFactory4_GetWindowAssociation(This,pWindowHandle) \
+    ( (This)->lpVtbl -> GetWindowAssociation(This,pWindowHandle) ) 
+
+#define IDXGIFactory4_CreateSwapChain(This,pDevice,pDesc,ppSwapChain)  \
+    ( (This)->lpVtbl -> CreateSwapChain(This,pDevice,pDesc,ppSwapChain) ) 
+
+#define IDXGIFactory4_CreateSoftwareAdapter(This,Module,ppAdapter) \
+    ( (This)->lpVtbl -> CreateSoftwareAdapter(This,Module,ppAdapter) ) 
+
+
+#define IDXGIFactory4_EnumAdapters1(This,Adapter,ppAdapter)  \
+    ( (This)->lpVtbl -> EnumAdapters1(This,Adapter,ppAdapter) ) 
+
+#define IDXGIFactory4_IsCurrent(This)  \
+    ( (This)->lpVtbl -> IsCurrent(This) ) 
+
+
+#define IDXGIFactory4_IsWindowedStereoEnabled(This)  \
+    ( (This)->lpVtbl -> IsWindowedStereoEnabled(This) ) 
+
+#define IDXGIFactory4_CreateSwapChainForHwnd(This,pDevice,hWnd,pDesc,pFullscreenDesc,pRestrictToOutput,ppSwapChain)  \
+    ( (This)->lpVtbl -> CreateSwapChainForHwnd(This,pDevice,hWnd,pDesc,pFullscreenDesc,pRestrictToOutput,ppSwapChain) ) 
+
+#define IDXGIFactory4_CreateSwapChainForCoreWindow(This,pDevice,pWindow,pDesc,pRestrictToOutput,ppSwapChain) \
+    ( (This)->lpVtbl -> CreateSwapChainForCoreWindow(This,pDevice,pWindow,pDesc,pRestrictToOutput,ppSwapChain) ) 
+
+#define IDXGIFactory4_GetSharedResourceAdapterLuid(This,hResource,pLuid) \
+    ( (This)->lpVtbl -> GetSharedResourceAdapterLuid(This,hResource,pLuid) ) 
+
+#define IDXGIFactory4_RegisterStereoStatusWindow(This,WindowHandle,wMsg,pdwCookie) \
+    ( (This)->lpVtbl -> RegisterStereoStatusWindow(This,WindowHandle,wMsg,pdwCookie) ) 
+
+#define IDXGIFactory4_RegisterStereoStatusEvent(This,hEvent,pdwCookie) \
+    ( (This)->lpVtbl -> RegisterStereoStatusEvent(This,hEvent,pdwCookie) ) 
+
+#define IDXGIFactory4_UnregisterStereoStatus(This,dwCookie)  \
+    ( (This)->lpVtbl -> UnregisterStereoStatus(This,dwCookie) ) 
+
+#define IDXGIFactory4_RegisterOcclusionStatusWindow(This,WindowHandle,wMsg,pdwCookie)  \
+    ( (This)->lpVtbl -> RegisterOcclusionStatusWindow(This,WindowHandle,wMsg,pdwCookie) ) 
+
+#define IDXGIFactory4_RegisterOcclusionStatusEvent(This,hEvent,pdwCookie)  \
+    ( (This)->lpVtbl -> RegisterOcclusionStatusEvent(This,hEvent,pdwCookie) ) 
+
+#define IDXGIFactory4_UnregisterOcclusionStatus(This,dwCookie) \
+    ( (This)->lpVtbl -> UnregisterOcclusionStatus(This,dwCookie) ) 
+
+#define IDXGIFactory4_CreateSwapChainForComposition(This,pDevice,pDesc,pRestrictToOutput,ppSwapChain)  \
+    ( (This)->lpVtbl -> CreateSwapChainForComposition(This,pDevice,pDesc,pRestrictToOutput,ppSwapChain) ) 
+
+
+#define IDXGIFactory4_GetCreationFlags(This) \
+    ( (This)->lpVtbl -> GetCreationFlags(This) ) 
+
+
+#define IDXGIFactory4_EnumAdapterByLuid(This,AdapterLuid,riid,ppvAdapter)  \
+    ( (This)->lpVtbl -> EnumAdapterByLuid(This,AdapterLuid,riid,ppvAdapter) ) 
+
+#define IDXGIFactory4_EnumWarpAdapter(This,riid,ppvAdapter)  \
+    ( (This)->lpVtbl -> EnumWarpAdapter(This,riid,ppvAdapter) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIFactory4_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi1_4_0000_0003 */
+/* [local] */ 
+
+typedef 
+enum DXGI_MEMORY_SEGMENT_GROUP
+    {
+        DXGI_MEMORY_SEGMENT_GROUP_LOCAL  = 0,
+        DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL  = 1
+    }  DXGI_MEMORY_SEGMENT_GROUP;
+
+typedef struct DXGI_QUERY_VIDEO_MEMORY_INFO
+    {
+    UINT64 Budget;
+    UINT64 CurrentUsage;
+    UINT64 AvailableForReservation;
+    UINT64 CurrentReservation;
+    }  DXGI_QUERY_VIDEO_MEMORY_INFO;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi1_4_0000_0003_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi1_4_0000_0003_v0_0_s_ifspec;
+
+#ifndef __IDXGIAdapter3_INTERFACE_DEFINED__
+#define __IDXGIAdapter3_INTERFACE_DEFINED__
+
+/* interface IDXGIAdapter3 */
+/* [unique][local][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IDXGIAdapter3;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("645967A4-1392-4310-A798-8053CE3E93FD")
+    IDXGIAdapter3 : public IDXGIAdapter2
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE RegisterHardwareContentProtectionTeardownStatusEvent( 
+            /* [annotation][in] */ 
+            _In_  HANDLE hEvent,
+            /* [annotation][out] */ 
+            _Out_  DWORD *pdwCookie) = 0;
+        
+        virtual void STDMETHODCALLTYPE UnregisterHardwareContentProtectionTeardownStatus( 
+            /* [annotation][in] */ 
+            _In_  DWORD dwCookie) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE QueryVideoMemoryInfo( 
+            /* [annotation][in] */ 
+            _In_  UINT NodeIndex,
+            /* [annotation][in] */ 
+            _In_  DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,
+            /* [annotation][out] */ 
+            _Out_  DXGI_QUERY_VIDEO_MEMORY_INFO *pVideoMemoryInfo) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetVideoMemoryReservation( 
+            /* [annotation][in] */ 
+            _In_  UINT NodeIndex,
+            /* [annotation][in] */ 
+            _In_  DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,
+            /* [annotation][in] */ 
+            _In_  UINT64 Reservation) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE RegisterVideoMemoryBudgetChangeNotificationEvent( 
+            /* [annotation][in] */ 
+            _In_  HANDLE hEvent,
+            /* [annotation][out] */ 
+            _Out_  DWORD *pdwCookie) = 0;
+        
+        virtual void STDMETHODCALLTYPE UnregisterVideoMemoryBudgetChangeNotification( 
+            /* [annotation][in] */ 
+            _In_  DWORD dwCookie) = 0;
+        
+    };
+    
+    
+#else  /* C style interface */
+
+    typedef struct IDXGIAdapter3Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDXGIAdapter3 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            _COM_Outptr_  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDXGIAdapter3 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDXGIAdapter3 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [in] */ UINT DataSize,
+            /* [annotation][in] */ 
+            _In_reads_bytes_(DataSize)  const void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][in] */ 
+            _In_opt_  const IUnknown *pUnknown);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID Name,
+            /* [annotation][out][in] */ 
+            _Inout_  UINT *pDataSize,
+            /* [annotation][out] */ 
+            _Out_writes_bytes_(*pDataSize)  void *pData);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  REFIID riid,
+            /* [annotation][retval][out] */ 
+            _COM_Outptr_  void **ppParent);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumOutputs )( 
+            IDXGIAdapter3 * This,
+            /* [in] */ UINT Output,
+            /* [annotation][out][in] */ 
+            _COM_Outptr_  IDXGIOutput **ppOutput);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_ADAPTER_DESC *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *CheckInterfaceSupport )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  REFGUID InterfaceName,
+            /* [annotation][out] */ 
+            _Out_  LARGE_INTEGER *pUMDVersion);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc1 )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_ADAPTER_DESC1 *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDesc2 )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][out] */ 
+            _Out_  DXGI_ADAPTER_DESC2 *pDesc);
+        
+        HRESULT ( STDMETHODCALLTYPE *RegisterHardwareContentProtectionTeardownStatusEvent )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  HANDLE hEvent,
+            /* [annotation][out] */ 
+            _Out_  DWORD *pdwCookie);
+        
+        void ( STDMETHODCALLTYPE *UnregisterHardwareContentProtectionTeardownStatus )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  DWORD dwCookie);
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryVideoMemoryInfo )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  UINT NodeIndex,
+            /* [annotation][in] */ 
+            _In_  DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,
+            /* [annotation][out] */ 
+            _Out_  DXGI_QUERY_VIDEO_MEMORY_INFO *pVideoMemoryInfo);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetVideoMemoryReservation )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  UINT NodeIndex,
+            /* [annotation][in] */ 
+            _In_  DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,
+            /* [annotation][in] */ 
+            _In_  UINT64 Reservation);
+        
+        HRESULT ( STDMETHODCALLTYPE *RegisterVideoMemoryBudgetChangeNotificationEvent )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  HANDLE hEvent,
+            /* [annotation][out] */ 
+            _Out_  DWORD *pdwCookie);
+        
+        void ( STDMETHODCALLTYPE *UnregisterVideoMemoryBudgetChangeNotification )( 
+            IDXGIAdapter3 * This,
+            /* [annotation][in] */ 
+            _In_  DWORD dwCookie);
+        
+        END_INTERFACE
+    } IDXGIAdapter3Vtbl;
+
+    interface IDXGIAdapter3
+    {
+        CONST_VTBL struct IDXGIAdapter3Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDXGIAdapter3_QueryInterface(This,riid,ppvObject)  \
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDXGIAdapter3_AddRef(This) \
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDXGIAdapter3_Release(This)  \
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDXGIAdapter3_SetPrivateData(This,Name,DataSize,pData) \
+    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 
+
+#define IDXGIAdapter3_SetPrivateDataInterface(This,Name,pUnknown)  \
+    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 
+
+#define IDXGIAdapter3_GetPrivateData(This,Name,pDataSize,pData)  \
+    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 
+
+#define IDXGIAdapter3_GetParent(This,riid,ppParent)  \
+    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 
+
+
+#define IDXGIAdapter3_EnumOutputs(This,Output,ppOutput)  \
+    ( (This)->lpVtbl -> EnumOutputs(This,Output,ppOutput) ) 
+
+#define IDXGIAdapter3_GetDesc(This,pDesc)  \
+    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 
+
+#define IDXGIAdapter3_CheckInterfaceSupport(This,InterfaceName,pUMDVersion)  \
+    ( (This)->lpVtbl -> CheckInterfaceSupport(This,InterfaceName,pUMDVersion) ) 
+
+
+#define IDXGIAdapter3_GetDesc1(This,pDesc) \
+    ( (This)->lpVtbl -> GetDesc1(This,pDesc) ) 
+
+
+#define IDXGIAdapter3_GetDesc2(This,pDesc) \
+    ( (This)->lpVtbl -> GetDesc2(This,pDesc) ) 
+
+
+#define IDXGIAdapter3_RegisterHardwareContentProtectionTeardownStatusEvent(This,hEvent,pdwCookie)  \
+    ( (This)->lpVtbl -> RegisterHardwareContentProtectionTeardownStatusEvent(This,hEvent,pdwCookie) ) 
+
+#define IDXGIAdapter3_UnregisterHardwareContentProtectionTeardownStatus(This,dwCookie) \
+    ( (This)->lpVtbl -> UnregisterHardwareContentProtectionTeardownStatus(This,dwCookie) ) 
+
+#define IDXGIAdapter3_QueryVideoMemoryInfo(This,NodeIndex,MemorySegmentGroup,pVideoMemoryInfo) \
+    ( (This)->lpVtbl -> QueryVideoMemoryInfo(This,NodeIndex,MemorySegmentGroup,pVideoMemoryInfo) ) 
+
+#define IDXGIAdapter3_SetVideoMemoryReservation(This,NodeIndex,MemorySegmentGroup,Reservation) \
+    ( (This)->lpVtbl -> SetVideoMemoryReservation(This,NodeIndex,MemorySegmentGroup,Reservation) ) 
+
+#define IDXGIAdapter3_RegisterVideoMemoryBudgetChangeNotificationEvent(This,hEvent,pdwCookie)  \
+    ( (This)->lpVtbl -> RegisterVideoMemoryBudgetChangeNotificationEvent(This,hEvent,pdwCookie) ) 
+
+#define IDXGIAdapter3_UnregisterVideoMemoryBudgetChangeNotification(This,dwCookie) \
+    ( (This)->lpVtbl -> UnregisterVideoMemoryBudgetChangeNotification(This,dwCookie) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif   /* C style interface */
+
+
+
+
+#endif   /* __IDXGIAdapter3_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_dxgi1_4_0000_0004 */
+/* [local] */ 
+
+#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_GAMES) */
+#pragma endregion
+DEFINE_GUID(IID_IDXGISwapChain3,0x94d99bdb,0xf1f8,0x4ab0,0xb2,0x36,0x7d,0xa0,0x17,0x0e,0xda,0xb1);
+DEFINE_GUID(IID_IDXGIOutput4,0xdc7dca35,0x2196,0x414d,0x9F,0x53,0x61,0x78,0x84,0x03,0x2a,0x60);
+DEFINE_GUID(IID_IDXGIFactory4,0x1bc6ea02,0xef36,0x464f,0xbf,0x0c,0x21,0xca,0x39,0xe5,0x16,0x8a);
+DEFINE_GUID(IID_IDXGIAdapter3,0x645967A4,0x1392,0x4310,0xA7,0x98,0x80,0x53,0xCE,0x3E,0x93,0xFD);
+
+
+extern RPC_IF_HANDLE __MIDL_itf_dxgi1_4_0000_0004_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_dxgi1_4_0000_0004_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/pc/gfx/gfx_cc.h b/src/pc/gfx/gfx_cc.h
new file mode 100644
index 0000000..ba60f6e
--- /dev/null
+++ b/src/pc/gfx/gfx_cc.h
@@ -0,0 +1,25 @@
+enum {
+    CC_0,
+    CC_TEXEL0,
+    CC_TEXEL1,
+    CC_PRIM,
+    CC_SHADE,
+    CC_ENV,
+    CC_TEXEL0A,
+    CC_LOD
+};
+
+enum {
+    SHADER_0,
+    SHADER_INPUT_1,
+    SHADER_INPUT_2,
+    SHADER_INPUT_3,
+    SHADER_INPUT_4,
+    SHADER_TEXEL0,
+    SHADER_TEXEL0A,
+    SHADER_TEXEL1
+};
+
+#define SHADER_OPT_ALPHA (1 << 24)
+#define SHADER_OPT_FOG (1 << 25)
+#define SHADER_OPT_TEXTURE_EDGE (1 << 26)
diff --git a/src/pc/gfx/gfx_direct3d12.cpp b/src/pc/gfx/gfx_direct3d12.cpp
new file mode 100644
index 0000000..3dee984
--- /dev/null
+++ b/src/pc/gfx/gfx_direct3d12.cpp
@@ -0,0 +1,1375 @@
+#if defined(_WIN32) || defined(_WIN64)
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <math.h>
+
+#include <map>
+#include <set>
+#include <vector>
+
+#include <windows.h>
+#include <wrl/client.h>
+
+// These are needed when compiling with MinGW
+#include <sal.h>
+#include <specstrings.h>
+#define __in_ecount_opt(size)
+#define __in
+#define __out
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#include <rpcndr.h>
+
+#include "dxsdk/dxgi.h"
+#include "dxsdk/dxgi1_4.h"
+#include "dxsdk/d3d12.h"
+#include "dxsdk/d3dcompiler.h"
+
+#include "dxsdk/d3dx12.h"
+
+#ifndef _LANGUAGE_C
+#define _LANGUAGE_C
+#endif
+#include <PR/gbi.h>
+
+#include "gfx_cc.h"
+#include "gfx_window_manager_api.h"
+#include "gfx_rendering_api.h"
+#include "src/pc/controller/controller_keyboard.h"
+
+#include "gfx_screen_config.h"
+
+#define WINCLASS_NAME L"SUPERMARIO64"
+
+#define DEBUG_D3D 0
+
+using namespace Microsoft::WRL; // For ComPtr
+
+struct ShaderProgram {
+    uint32_t shader_id;
+    uint8_t num_inputs;
+    bool used_textures[2];
+    uint8_t num_floats;
+    uint8_t num_attribs;
+    
+    ComPtr<ID3DBlob> vertex_shader;
+    ComPtr<ID3DBlob> pixel_shader;
+    ComPtr<ID3D12RootSignature> root_signature;
+};
+
+struct PipelineDesc {
+    uint32_t shader_id;
+    bool depth_test;
+    bool depth_mask;
+    bool zmode_decal;
+    bool _padding;
+    
+    bool operator==(const PipelineDesc& o) const {
+        return memcmp(this, &o, sizeof(*this)) == 0;
+    }
+    
+    bool operator<(const PipelineDesc& o) const {
+        return memcmp(this, &o, sizeof(*this)) < 0;
+    }
+};
+
+struct TextureHeap {
+    ComPtr<ID3D12Heap> heap;
+    std::vector<uint8_t> free_list;
+};
+
+struct TextureData {
+    ComPtr<ID3D12Resource> resource;
+    struct TextureHeap *heap;
+    uint8_t heap_offset;
+    
+    uint64_t last_frame_counter;
+    uint32_t descriptor_index;
+    int sampler_parameters;
+};
+
+static struct {
+    struct ShaderProgram shader_program_pool[64];
+    uint8_t shader_program_pool_size;
+    
+    uint32_t current_width, current_height;
+    
+    ComPtr<IDXGIFactory4> factory;
+    ComPtr<ID3D12Device> device;
+    ComPtr<ID3D12CommandQueue> command_queue;
+    ComPtr<ID3D12CommandQueue> copy_command_queue;
+    ComPtr<IDXGISwapChain3> swap_chain;
+    ComPtr<ID3D12DescriptorHeap> rtv_heap;
+    UINT rtv_descriptor_size;
+    ComPtr<ID3D12Resource> render_targets[2];
+    ComPtr<ID3D12CommandAllocator> command_allocator;
+    ComPtr<ID3D12CommandAllocator> copy_command_allocator;
+    ComPtr<ID3D12GraphicsCommandList> command_list;
+    ComPtr<ID3D12GraphicsCommandList> copy_command_list;
+    ComPtr<ID3D12DescriptorHeap> dsv_heap;
+    ComPtr<ID3D12Resource> depth_stencil_buffer;
+    ComPtr<ID3D12DescriptorHeap> srv_heap;
+    UINT srv_descriptor_size;
+    ComPtr<ID3D12DescriptorHeap> sampler_heap;
+    UINT sampler_descriptor_size;
+    
+    std::map<std::pair<uint32_t, uint32_t>, std::list<struct TextureHeap>> texture_heaps;
+    
+    std::map<size_t, std::vector<ComPtr<ID3D12Resource>>> upload_heaps;
+    std::vector<std::pair<size_t, ComPtr<ID3D12Resource>>> upload_heaps_in_flight;
+    ComPtr<ID3D12Fence> copy_fence;
+    uint64_t copy_fence_value;
+    
+    std::vector<struct TextureData> textures;
+    int current_tile;
+    uint32_t current_texture_ids[2];
+    uint32_t srv_pos;
+
+    int frame_index;
+    ComPtr<ID3D12Fence> fence;
+    HANDLE fence_event;
+    HANDLE waitable_object;
+    uint64_t qpc_init, qpc_freq;
+    uint64_t frame_timestamp; // in units of 1/3 microseconds
+    std::map<UINT, DXGI_FRAME_STATISTICS> frame_stats;
+    std::set<std::pair<UINT, UINT>> pending_frame_stats;
+    bool dropped_frame;
+    bool sync_interval_means_frames_to_wait;
+    UINT length_in_vsync_frames;
+    
+    uint64_t frame_counter;
+    
+    ComPtr<ID3D12Resource> vertex_buffer;
+    void *mapped_vbuf_address;
+    int vbuf_pos;
+    
+    std::vector<ComPtr<ID3D12Resource>> resources_to_clean_at_end_of_frame;
+    std::vector<std::pair<struct TextureHeap *, uint8_t>> texture_heap_allocations_to_reclaim_at_end_of_frame;
+    
+    std::map<PipelineDesc, ComPtr<ID3D12PipelineState>> pipeline_states;
+    bool must_reload_pipeline;
+    
+    // Current state:
+    ID3D12PipelineState *pipeline_state;
+    struct ShaderProgram *shader_program;
+    bool depth_test;
+    bool depth_mask;
+    bool zmode_decal;
+    
+    CD3DX12_VIEWPORT viewport;
+    CD3DX12_RECT scissor;
+    
+    void (*run_one_game_iter)(void);
+} d3d;
+
+static int texture_uploads = 0;
+static int max_texture_uploads;
+
+static void ThrowIfFailed(HRESULT res) {
+    if (FAILED(res)) {
+        throw res;
+    }
+}
+
+static D3D12_CPU_DESCRIPTOR_HANDLE get_cpu_descriptor_handle(ComPtr<ID3D12DescriptorHeap>& heap) {
+#if __MINGW32__
+    // We would like to do this:
+ // D3D12_CPU_DESCRIPTOR_HANDLE handle = heap->GetCPUDescriptorHandleForHeapStart();
+    // but MinGW64 doesn't follow the calling conventions of VC++ for some reason.
+    // Per MS documentation "User-defined types can be returned by value from global functions and static member functions"...
+    // "Otherwise, the caller assumes the responsibility of allocating memory and passing a pointer for the return value as the first argument".
+    // The method here is a non-static member function, and hence we need to pass the address to the return value as a parameter.
+    // MinGW32 has the same issue.
+    auto fn = heap->GetCPUDescriptorHandleForHeapStart;
+    void (STDMETHODCALLTYPE ID3D12DescriptorHeap::*fun)(D3D12_CPU_DESCRIPTOR_HANDLE *out) = (void (STDMETHODCALLTYPE ID3D12DescriptorHeap::*)(D3D12_CPU_DESCRIPTOR_HANDLE *out))fn;
+    D3D12_CPU_DESCRIPTOR_HANDLE handle;
+    (heap.Get()->*fun)(&handle);
+    return handle;
+#else
+    return heap->GetCPUDescriptorHandleForHeapStart();
+#endif
+}
+
+static D3D12_GPU_DESCRIPTOR_HANDLE get_gpu_descriptor_handle(ComPtr<ID3D12DescriptorHeap>& heap) {
+#ifdef __MINGW32__
+    // See get_cpu_descriptor_handle
+    auto fn = heap->GetGPUDescriptorHandleForHeapStart;
+    void (STDMETHODCALLTYPE ID3D12DescriptorHeap::*fun)(D3D12_GPU_DESCRIPTOR_HANDLE *out) = (void (STDMETHODCALLTYPE ID3D12DescriptorHeap::*)(D3D12_GPU_DESCRIPTOR_HANDLE *out))fn;
+    D3D12_GPU_DESCRIPTOR_HANDLE handle;
+    (heap.Get()->*fun)(&handle);
+    return handle;
+#else
+    return heap->GetGPUDescriptorHandleForHeapStart();
+#endif
+}
+
+static D3D12_RESOURCE_ALLOCATION_INFO get_resource_allocation_info(const D3D12_RESOURCE_DESC *resource_desc) {
+#ifdef __MINGW32__
+    // See get_cpu_descriptor_handle
+    auto fn = d3d.device->GetResourceAllocationInfo;
+    void (STDMETHODCALLTYPE ID3D12Device::*fun)(D3D12_RESOURCE_ALLOCATION_INFO *out, UINT visibleMask, UINT numResourceDescs, const D3D12_RESOURCE_DESC *pResourceDescs) =
+    (void (STDMETHODCALLTYPE ID3D12Device::*)(D3D12_RESOURCE_ALLOCATION_INFO *out, UINT visibleMask, UINT numResourceDescs, const D3D12_RESOURCE_DESC *pResourceDescs))fn;
+    D3D12_RESOURCE_ALLOCATION_INFO out;
+    (d3d.device.Get()->*fun)(&out, 0, 1, resource_desc);
+    return out;
+#else
+    return d3d.device->GetResourceAllocationInfo(0, 1, resource_desc);
+#endif
+}
+
+static bool gfx_direct3d12_z_is_from_0_to_1(void) {
+    return true;
+}
+
+static void gfx_direct3d12_unload_shader(struct ShaderProgram *old_prg) {
+}
+
+static void gfx_direct3d12_load_shader(struct ShaderProgram *new_prg) {
+    d3d.shader_program = new_prg;
+    d3d.must_reload_pipeline = true;
+}
+
+static void append_str(char *buf, size_t *len, const char *str) {
+    while (*str != '\0') buf[(*len)++] = *str++;
+}
+
+static void append_line(char *buf, size_t *len, const char *str) {
+    while (*str != '\0') buf[(*len)++] = *str++;
+    buf[(*len)++] = '\r';
+    buf[(*len)++] = '\n';
+}
+
+static const char *shader_item_to_str(uint32_t item, bool with_alpha, bool only_alpha, bool inputs_have_alpha, bool hint_single_element) {
+    if (!only_alpha) {
+        switch (item) {
+            case SHADER_0:
+                return with_alpha ? "float4(0.0, 0.0, 0.0, 0.0)" : "float3(0.0, 0.0, 0.0)";
+            case SHADER_INPUT_1:
+                return with_alpha || !inputs_have_alpha ? "input.input1" : "input.input1.rgb";
+            case SHADER_INPUT_2:
+                return with_alpha || !inputs_have_alpha ? "input.input2" : "input.input2.rgb";
+            case SHADER_INPUT_3:
+                return with_alpha || !inputs_have_alpha ? "input.input3" : "input.input3.rgb";
+            case SHADER_INPUT_4:
+                return with_alpha || !inputs_have_alpha ? "input.input4" : "input.input4.rgb";
+            case SHADER_TEXEL0:
+                return with_alpha ? "texVal0" : "texVal0.rgb";
+            case SHADER_TEXEL0A:
+                return hint_single_element ? "texVal0.a" :
+                    (with_alpha ? "vec4(texelVal0.a, texelVal0.a, texelVal0.a, texelVal0.a)" : "float3(texelVal0.a, texelVal0.a, texelVal0.a)");
+            case SHADER_TEXEL1:
+                return with_alpha ? "texVal1" : "texVal1.rgb";
+        }
+    } else {
+        switch (item) {
+            case SHADER_0:
+                return "0.0";
+            case SHADER_INPUT_1:
+                return "input.input1.a";
+            case SHADER_INPUT_2:
+                return "input.input2.a";
+            case SHADER_INPUT_3:
+                return "input.input3.a";
+            case SHADER_INPUT_4:
+                return "input.input4.a";
+            case SHADER_TEXEL0:
+                return "texVal0.a";
+            case SHADER_TEXEL0A:
+                return "texVal0.a";
+            case SHADER_TEXEL1:
+                return "texVal1.a";
+        }
+    }
+}
+
+static void append_formula(char *buf, size_t *len, uint8_t c[2][4], bool do_single, bool do_multiply, bool do_mix, bool with_alpha, bool only_alpha, bool opt_alpha) {
+    if (do_single) {
+        append_str(buf, len, shader_item_to_str(c[only_alpha][3], with_alpha, only_alpha, opt_alpha, false));
+    } else if (do_multiply) {
+        append_str(buf, len, shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, " * ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, true));
+    } else if (do_mix) {
+        append_str(buf, len, "lerp(");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][1], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, ", ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, ", ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, true));
+        append_str(buf, len, ")");
+    } else {
+        append_str(buf, len, "(");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, " - ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][1], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, ") * ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, true));
+        append_str(buf, len, " + ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][3], with_alpha, only_alpha, opt_alpha, false));
+    }
+}
+
+static struct ShaderProgram *gfx_direct3d12_create_and_load_new_shader(uint32_t shader_id) {
+    /*static FILE *fp;
+    if (!fp) {
+        fp = fopen("shaders.txt", "w");
+    }
+    fprintf(fp, "0x%08x\n", shader_id);
+    fflush(fp);*/
+    
+    struct ShaderProgram *prg = &d3d.shader_program_pool[d3d.shader_program_pool_size++];
+    uint8_t c[2][4];
+    for (int i = 0; i < 4; i++) {
+        c[0][i] = (shader_id >> (i * 3)) & 7;
+        c[1][i] = (shader_id >> (12 + i * 3)) & 7;
+    }
+    bool opt_alpha = (shader_id & SHADER_OPT_ALPHA) != 0;
+    bool opt_fog = (shader_id & SHADER_OPT_FOG) != 0;
+    bool opt_texture_edge = (shader_id & SHADER_OPT_TEXTURE_EDGE) != 0;
+    bool used_textures[2] = {0, 0};
+    int num_inputs = 0;
+    for (int i = 0; i < 2; i++) {
+        for (int j = 0; j < 4; j++) {
+            if (c[i][j] >= SHADER_INPUT_1 && c[i][j] <= SHADER_INPUT_4) {
+                if (c[i][j] > num_inputs) {
+                    num_inputs = c[i][j];
+                }
+            }
+            if (c[i][j] == SHADER_TEXEL0 || c[i][j] == SHADER_TEXEL0A) {
+                used_textures[0] = true;
+            }
+            if (c[i][j] == SHADER_TEXEL1) {
+                used_textures[1] = true;
+            }
+        }
+    }
+    bool do_single[2] = {c[0][2] == 0, c[1][2] == 0};
+    bool do_multiply[2] = {c[0][1] == 0 && c[0][3] == 0, c[1][1] == 0 && c[1][3] == 0};
+    bool do_mix[2] = {c[0][1] == c[0][3], c[1][1] == c[1][3]};
+    bool color_alpha_same = (shader_id & 0xfff) == ((shader_id >> 12) & 0xfff);
+    
+    char buf[2048];
+    size_t len = 0;
+    size_t num_floats = 4;
+    
+    append_str(buf, &len, "#define RS \"RootFlags(ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT | DENY_VERTEX_SHADER_ROOT_ACCESS)");
+    if (used_textures[0]) {
+        append_str(buf, &len, ",DescriptorTable(SRV(t0), visibility = SHADER_VISIBILITY_PIXEL)");
+        append_str(buf, &len, ",DescriptorTable(Sampler(s0), visibility = SHADER_VISIBILITY_PIXEL)");
+    }
+    if (used_textures[1]) {
+        append_str(buf, &len, ",DescriptorTable(SRV(t1), visibility = SHADER_VISIBILITY_PIXEL)");
+        append_str(buf, &len, ",DescriptorTable(Sampler(s1), visibility = SHADER_VISIBILITY_PIXEL)");
+    }
+    append_line(buf, &len, "\"");
+    
+    append_line(buf, &len, "struct PSInput {");
+    append_line(buf, &len, "float4 position : SV_POSITION;");
+    if (used_textures[0] || used_textures[1]) {
+        append_line(buf, &len, "float2 uv : TEXCOORD;");
+        num_floats += 2;
+    }
+    if (opt_fog) {
+        append_line(buf, &len, "float4 fog : FOG;");
+        num_floats += 4;
+    }
+    for (int i = 0; i < num_inputs; i++) {
+        len += sprintf(buf + len, "float%d input%d : INPUT%d;\r\n", opt_alpha ? 4 : 3, i + 1, i);
+        num_floats += opt_alpha ? 4 : 3;
+    }
+    append_line(buf, &len, "};");
+    
+    if (used_textures[0]) {
+        append_line(buf, &len, "Texture2D g_texture0 : register(t0);");
+        append_line(buf, &len, "SamplerState g_sampler0 : register(s0);");
+    }
+    if (used_textures[1]) {
+        append_line(buf, &len, "Texture2D g_texture1 : register(t1);");
+        append_line(buf, &len, "SamplerState g_sampler1 : register(s1);");
+    }
+    
+    // Vertex shader
+    append_str(buf, &len, "PSInput VSMain(float4 position : POSITION");
+    if (used_textures[0] || used_textures[1]) {
+        append_str(buf, &len, ", float2 uv : TEXCOORD");
+    }
+    if (opt_fog) {
+        append_str(buf, &len, ", float4 fog : FOG");
+    }
+    for (int i = 0; i < num_inputs; i++) {
+        len += sprintf(buf + len, ", float%d input%d : INPUT%d", opt_alpha ? 4 : 3, i + 1, i);
+    }
+    append_line(buf, &len, ") {");
+    append_line(buf, &len, "PSInput result;");
+    append_line(buf, &len, "result.position = position;");
+    if (used_textures[0] || used_textures[1]) {
+        append_line(buf, &len, "result.uv = uv;");
+    }
+    if (opt_fog) {
+        append_line(buf, &len, "result.fog = fog;");
+    }
+    for (int i = 0; i < num_inputs; i++) {
+        len += sprintf(buf + len, "result.input%d = input%d;\r\n", i + 1, i + 1);
+    }
+    append_line(buf, &len, "return result;");
+    append_line(buf, &len, "}");
+    
+    // Pixel shader
+    append_line(buf, &len, "[RootSignature(RS)]");
+    append_line(buf, &len, "float4 PSMain(PSInput input) : SV_TARGET {");
+    if (used_textures[0]) {
+        append_line(buf, &len, "float4 texVal0 = g_texture0.Sample(g_sampler0, input.uv);");
+    }
+    if (used_textures[1]) {
+        append_line(buf, &len, "float4 texVal1 = g_texture1.Sample(g_sampler1, input.uv);");
+    }
+    
+    append_str(buf, &len, opt_alpha ? "float4 texel = " : "float3 texel = ");
+    if (!color_alpha_same && opt_alpha) {
+        append_str(buf, &len, "float4(");
+        append_formula(buf, &len, c, do_single[0], do_multiply[0], do_mix[0], false, false, true);
+        append_str(buf, &len, ", ");
+        append_formula(buf, &len, c, do_single[1], do_multiply[1], do_mix[1], true, true, true);
+        append_str(buf, &len, ")");
+    } else {
+        append_formula(buf, &len, c, do_single[0], do_multiply[0], do_mix[0], opt_alpha, false, opt_alpha);
+    }
+    append_line(buf, &len, ";");
+    
+    if (opt_texture_edge && opt_alpha) {
+        append_line(buf, &len, "if (texel.a > 0.3) texel.a = 1.0; else discard;");
+    }
+    // TODO discard if alpha is 0?
+    if (opt_fog) {
+        if (opt_alpha) {
+            append_line(buf, &len, "texel = float4(lerp(texel.rgb, input.fog.rgb, input.fog.a), texel.a);");
+        } else {
+            append_line(buf, &len, "texel = lerp(texel, input.fog.rgb, input.fog.a);");
+        }
+    }
+    
+    if (opt_alpha) {
+        append_line(buf, &len, "return texel;");
+    } else {
+        append_line(buf, &len, "return float4(texel, 1.0);");
+    }
+    append_line(buf, &len, "}");
+    
+    //fwrite(buf, 1, len, stdout);
+    
+    ThrowIfFailed(D3DCompile(buf, len, nullptr, nullptr, nullptr, "VSMain", "vs_5_1", /*D3DCOMPILE_OPTIMIZATION_LEVEL3*/0, 0, &prg->vertex_shader, nullptr));
+    ThrowIfFailed(D3DCompile(buf, len, nullptr, nullptr, nullptr, "PSMain", "ps_5_1", /*D3DCOMPILE_OPTIMIZATION_LEVEL3*/0, 0, &prg->pixel_shader, nullptr));
+    
+    ThrowIfFailed(d3d.device->CreateRootSignature(0, prg->pixel_shader->GetBufferPointer(), prg->pixel_shader->GetBufferSize(), IID_ID3D12RootSignature, IID_PPV_ARGS_Helper(&prg->root_signature)));
+    
+    prg->shader_id = shader_id;
+    prg->num_inputs = num_inputs;
+    prg->used_textures[0] = used_textures[0];
+    prg->used_textures[1] = used_textures[1];
+    prg->num_floats = num_floats;
+    //prg->num_attribs = cnt;
+    
+    d3d.must_reload_pipeline = true;
+    return d3d.shader_program = prg;
+}
+
+static struct ShaderProgram *gfx_direct3d12_lookup_shader(uint32_t shader_id) {
+    for (size_t i = 0; i < d3d.shader_program_pool_size; i++) {
+        if (d3d.shader_program_pool[i].shader_id == shader_id) {
+            return &d3d.shader_program_pool[i];
+        }
+    }
+    return NULL;
+}
+
+static void gfx_direct3d12_shader_get_info(struct ShaderProgram *prg, uint8_t *num_inputs, bool used_textures[2]) {
+    *num_inputs = prg->num_inputs;
+    used_textures[0] = prg->used_textures[0];
+    used_textures[1] = prg->used_textures[1];
+}
+
+static uint32_t gfx_direct3d12_new_texture(void) {
+    d3d.textures.resize(d3d.textures.size() + 1);
+    return (uint32_t)(d3d.textures.size() - 1);
+}
+
+static void gfx_direct3d12_select_texture(int tile, uint32_t texture_id) {
+    d3d.current_tile = tile;
+    d3d.current_texture_ids[tile] = texture_id;
+}
+
+static void gfx_direct3d12_upload_texture(uint8_t *rgba32_buf, int width, int height) {
+    texture_uploads++;
+    
+    ComPtr<ID3D12Resource> texture_resource;
+    
+    // Describe and create a Texture2D.
+    D3D12_RESOURCE_DESC texture_desc = {};
+    texture_desc.MipLevels = 1;
+    texture_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
+    texture_desc.Width = width;
+    texture_desc.Height = height;
+    texture_desc.Flags = D3D12_RESOURCE_FLAG_NONE;
+    texture_desc.DepthOrArraySize = 1;
+    texture_desc.SampleDesc.Count = 1;
+    texture_desc.SampleDesc.Quality = 0;
+    texture_desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
+    texture_desc.Alignment = D3D12_SMALL_RESOURCE_PLACEMENT_ALIGNMENT;
+    
+    D3D12_RESOURCE_ALLOCATION_INFO alloc_info = get_resource_allocation_info(&texture_desc);
+    
+    std::list<struct TextureHeap>& heaps = d3d.texture_heaps[std::pair<uint32_t, uint32_t>(alloc_info.SizeInBytes, alloc_info.Alignment)];
+    
+    struct TextureHeap *found_heap = nullptr;
+    for (struct TextureHeap& heap : heaps) {
+        if (!heap.free_list.empty()) {
+            found_heap = &heap;
+        }
+    }
+    if (found_heap == nullptr) {
+        heaps.resize(heaps.size() + 1);
+        found_heap = &heaps.back();
+        
+        const int textures_per_heap = 64;
+        
+        D3D12_HEAP_DESC heap_desc = {};
+   heap_desc.SizeInBytes = alloc_info.SizeInBytes * textures_per_heap;
+        if (alloc_info.Alignment == D3D12_SMALL_RESOURCE_PLACEMENT_ALIGNMENT) {
+            heap_desc.Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
+        } else {
+            heap_desc.Alignment = alloc_info.Alignment;
+        }
+   heap_desc.Properties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
+   heap_desc.Properties.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
+   heap_desc.Properties.Type = D3D12_HEAP_TYPE_DEFAULT;
+   heap_desc.Flags = D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES;
+        ThrowIfFailed(d3d.device->CreateHeap(&heap_desc, IID_ID3D12Heap, IID_PPV_ARGS_Helper(&found_heap->heap)));
+        for (int i = 0; i < textures_per_heap; i++) {
+            found_heap->free_list.push_back(i);
+        }
+    }
+    
+    uint8_t heap_offset = found_heap->free_list.back();
+    found_heap->free_list.pop_back();
+    ThrowIfFailed(d3d.device->CreatePlacedResource(found_heap->heap.Get(), heap_offset * alloc_info.SizeInBytes, &texture_desc, D3D12_RESOURCE_STATE_COPY_DEST, nullptr, IID_ID3D12Resource, IID_PPV_ARGS_Helper(&texture_resource)));
+    
+    D3D12_PLACED_SUBRESOURCE_FOOTPRINT layout;
+    UINT num_rows;
+    UINT64 row_size_in_bytes;
+    UINT64 upload_buffer_size;
+    d3d.device->GetCopyableFootprints(&texture_desc, 0, 1, 0, &layout, &num_rows, &row_size_in_bytes, &upload_buffer_size);
+    
+    std::vector<ComPtr<ID3D12Resource>>& upload_heaps = d3d.upload_heaps[upload_buffer_size];
+    ComPtr<ID3D12Resource> upload_heap;
+    if (upload_heaps.empty()) {
+        CD3DX12_HEAP_PROPERTIES hp(D3D12_HEAP_TYPE_UPLOAD);
+        CD3DX12_RESOURCE_DESC rdb = CD3DX12_RESOURCE_DESC::Buffer(upload_buffer_size);
+        ThrowIfFailed(d3d.device->CreateCommittedResource(
+     &hp,
+     D3D12_HEAP_FLAG_NONE,
+     &rdb,
+     D3D12_RESOURCE_STATE_GENERIC_READ,
+     nullptr,
+     IID_ID3D12Resource, IID_PPV_ARGS_Helper(&upload_heap)));
+    } else {
+        upload_heap = upload_heaps.back();
+        upload_heaps.pop_back();
+    }
+    
+    {
+        D3D12_SUBRESOURCE_DATA texture_data = {};
+        texture_data.pData = rgba32_buf;
+        texture_data.RowPitch = width * 4; // RGBA
+        texture_data.SlicePitch = texture_data.RowPitch * height;
+        
+        void *data;
+        upload_heap->Map(0, nullptr, &data);
+        D3D12_MEMCPY_DEST dest_data = { (uint8_t *)data + layout.Offset, layout.Footprint.RowPitch, SIZE_T(layout.Footprint.RowPitch) * SIZE_T(num_rows) };
+        MemcpySubresource(&dest_data, &texture_data, static_cast<SIZE_T>(row_size_in_bytes), num_rows, layout.Footprint.Depth);
+        upload_heap->Unmap(0, nullptr);
+
+        CD3DX12_TEXTURE_COPY_LOCATION dst(texture_resource.Get(), 0);
+        CD3DX12_TEXTURE_COPY_LOCATION src(upload_heap.Get(), layout);
+        d3d.copy_command_list->CopyTextureRegion(&dst, 0, 0, 0, &src, nullptr);
+    }
+    
+    CD3DX12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(texture_resource.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
+    d3d.command_list->ResourceBarrier(1, &barrier);
+    
+    d3d.upload_heaps_in_flight.push_back(std::make_pair((size_t)upload_buffer_size, std::move(upload_heap)));
+    
+    struct TextureData& td = d3d.textures[d3d.current_texture_ids[d3d.current_tile]];
+    if (td.resource.Get() != nullptr) {
+        d3d.resources_to_clean_at_end_of_frame.push_back(std::move(td.resource));
+        d3d.texture_heap_allocations_to_reclaim_at_end_of_frame.push_back(std::make_pair(td.heap, td.heap_offset));
+        td.last_frame_counter = 0;
+    }
+    td.resource = std::move(texture_resource);
+    td.heap = found_heap;
+    td.heap_offset = heap_offset;
+}
+
+static int gfx_cm_to_index(uint32_t val) {
+    if (val & G_TX_CLAMP) {
+        return 2;
+    }
+    return (val & G_TX_MIRROR) ? 1 : 0;
+}
+
+static void gfx_direct3d12_set_sampler_parameters(int tile, bool linear_filter, uint32_t cms, uint32_t cmt) {
+    d3d.textures[d3d.current_texture_ids[tile]].sampler_parameters = linear_filter * 9 + gfx_cm_to_index(cms) * 3 + gfx_cm_to_index(cmt);
+}
+
+static void gfx_direct3d12_set_depth_test(bool depth_test) {
+    d3d.depth_test = depth_test;
+    d3d.must_reload_pipeline = true;
+}
+
+static void gfx_direct3d12_set_depth_mask(bool z_upd) {
+    d3d.depth_mask = z_upd;
+    d3d.must_reload_pipeline = true;
+}
+
+static void gfx_direct3d12_set_zmode_decal(bool zmode_decal) {
+    d3d.zmode_decal = zmode_decal;
+    d3d.must_reload_pipeline = true;
+}
+
+static void gfx_direct3d12_set_viewport(int x, int y, int width, int height) {
+    d3d.viewport = CD3DX12_VIEWPORT(x, d3d.current_height - y - height, width, height);
+}
+
+static void gfx_direct3d12_set_scissor(int x, int y, int width, int height) {
+    d3d.scissor = CD3DX12_RECT(x, d3d.current_height - y - height, x + width, d3d.current_height - y);
+}
+
+static void gfx_direct3d12_set_use_alpha(bool use_alpha) {
+    // Already part of the pipeline state from shader info
+}
+
+static void gfx_direct3d12_draw_triangles(float buf_vbo[], size_t buf_vbo_len, size_t buf_vbo_num_tris) {
+    struct ShaderProgram *prg = d3d.shader_program;
+    
+    if (d3d.must_reload_pipeline) {
+        ComPtr<ID3D12PipelineState>& pipeline_state = d3d.pipeline_states[PipelineDesc{
+            prg->shader_id,
+            d3d.depth_test,
+            d3d.depth_mask,
+            d3d.zmode_decal,
+            0
+        }];
+        if (pipeline_state.Get() == nullptr) {
+            D3D12_INPUT_ELEMENT_DESC ied[7] = {
+               {"POSITION", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }
+            };
+            uint32_t ied_pos = 1;
+            if (prg->used_textures[0] || prg->used_textures[1]) {
+                ied[ied_pos++] = D3D12_INPUT_ELEMENT_DESC{"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0};
+            }
+            if (prg->shader_id & SHADER_OPT_FOG) {
+                ied[ied_pos++] = D3D12_INPUT_ELEMENT_DESC{"FOG", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0};
+            }
+            for (int i = 0; i < prg->num_inputs; i++) {
+                DXGI_FORMAT format = (prg->shader_id & SHADER_OPT_ALPHA) ? DXGI_FORMAT_R32G32B32A32_FLOAT : DXGI_FORMAT_R32G32B32_FLOAT;
+                ied[ied_pos++] = D3D12_INPUT_ELEMENT_DESC{"INPUT", (UINT)i, format, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0};
+            }
+            
+            D3D12_GRAPHICS_PIPELINE_STATE_DESC desc = {};
+            desc.InputLayout = { ied, ied_pos };
+            desc.pRootSignature = prg->root_signature.Get();
+            desc.VS = CD3DX12_SHADER_BYTECODE(prg->vertex_shader.Get());
+            desc.PS = CD3DX12_SHADER_BYTECODE(prg->pixel_shader.Get());
+            desc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
+            if (d3d.zmode_decal) {
+                desc.RasterizerState.SlopeScaledDepthBias = -2.0f;
+            }
+            desc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
+            if (prg->shader_id & SHADER_OPT_ALPHA) {
+                D3D12_BLEND_DESC bd = {};
+                bd.AlphaToCoverageEnable = FALSE;
+                bd.IndependentBlendEnable = FALSE;
+                static const D3D12_RENDER_TARGET_BLEND_DESC default_rtbd = {
+                    TRUE, FALSE,
+                    D3D12_BLEND_SRC_ALPHA, D3D12_BLEND_INV_SRC_ALPHA, D3D12_BLEND_OP_ADD,
+                    D3D12_BLEND_ONE, D3D12_BLEND_INV_SRC_ALPHA, D3D12_BLEND_OP_ADD,
+                    D3D12_LOGIC_OP_NOOP,
+                    D3D12_COLOR_WRITE_ENABLE_ALL
+                };
+                for (UINT i = 0; i < D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT; i++) {
+                    bd.RenderTarget[i] = default_rtbd;
+                }
+                desc.BlendState = bd;
+            } else {
+                desc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
+            }
+            desc.DepthStencilState.DepthEnable = d3d.depth_test;
+            desc.DepthStencilState.DepthWriteMask = d3d.depth_mask ? D3D12_DEPTH_WRITE_MASK_ALL : D3D12_DEPTH_WRITE_MASK_ZERO;
+            desc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
+            desc.DSVFormat = d3d.depth_test ? DXGI_FORMAT_D32_FLOAT : DXGI_FORMAT_UNKNOWN;
+            desc.SampleMask = UINT_MAX;
+            desc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
+            desc.NumRenderTargets = 1;
+            desc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
+            desc.SampleDesc.Count = 1;
+            ThrowIfFailed(d3d.device->CreateGraphicsPipelineState(&desc, IID_ID3D12PipelineState, IID_PPV_ARGS_Helper(&pipeline_state)));
+        }
+        d3d.pipeline_state = pipeline_state.Get();
+        d3d.must_reload_pipeline = false;
+    }
+    
+    d3d.command_list->SetGraphicsRootSignature(prg->root_signature.Get());
+    d3d.command_list->SetPipelineState(d3d.pipeline_state);
+    
+    ID3D12DescriptorHeap *heaps[] = { d3d.srv_heap.Get(), d3d.sampler_heap.Get() };
+    d3d.command_list->SetDescriptorHeaps(2, heaps);
+    
+    int texture_pos = 0;
+    for (int i = 0; i < 2; i++) {
+        if (prg->used_textures[i]) {
+            struct TextureData& td = d3d.textures[d3d.current_texture_ids[i]];
+            if (td.last_frame_counter != d3d.frame_counter) {
+                td.descriptor_index = d3d.srv_pos;
+                td.last_frame_counter = d3d.frame_counter;
+                
+                D3D12_SHADER_RESOURCE_VIEW_DESC srv_desc = {};
+                srv_desc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
+                srv_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
+                srv_desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
+                srv_desc.Texture2D.MipLevels = 1;
+                
+                CD3DX12_CPU_DESCRIPTOR_HANDLE srv_handle(get_cpu_descriptor_handle(d3d.srv_heap), d3d.srv_pos++, d3d.srv_descriptor_size);
+                d3d.device->CreateShaderResourceView(td.resource.Get(), &srv_desc, srv_handle);
+            }
+            
+            CD3DX12_GPU_DESCRIPTOR_HANDLE srv_gpu_handle(get_gpu_descriptor_handle(d3d.srv_heap), td.descriptor_index, d3d.srv_descriptor_size);
+            d3d.command_list->SetGraphicsRootDescriptorTable(2 * texture_pos, srv_gpu_handle);
+            
+            CD3DX12_GPU_DESCRIPTOR_HANDLE sampler_gpu_handle(get_gpu_descriptor_handle(d3d.sampler_heap), td.sampler_parameters, d3d.sampler_descriptor_size);
+            d3d.command_list->SetGraphicsRootDescriptorTable(2 * texture_pos + 1, sampler_gpu_handle);
+            
+            ++texture_pos;
+        }
+    }
+    
+    CD3DX12_CPU_DESCRIPTOR_HANDLE rtv_handle(get_cpu_descriptor_handle(d3d.rtv_heap), d3d.frame_index, d3d.rtv_descriptor_size);
+    D3D12_CPU_DESCRIPTOR_HANDLE dsv_handle = get_cpu_descriptor_handle(d3d.dsv_heap);
+    d3d.command_list->OMSetRenderTargets(1, &rtv_handle, FALSE, &dsv_handle);
+    
+    d3d.command_list->RSSetViewports(1, &d3d.viewport);
+    d3d.command_list->RSSetScissorRects(1, &d3d.scissor);
+    
+    int current_pos = d3d.vbuf_pos;
+    memcpy((uint8_t *)d3d.mapped_vbuf_address + current_pos, buf_vbo, buf_vbo_len * sizeof(float));
+    d3d.vbuf_pos += buf_vbo_len * sizeof(float);
+    static int maxpos;
+    if (d3d.vbuf_pos > maxpos) {
+        maxpos = d3d.vbuf_pos;
+        //printf("NEW MAXPOS: %d\n", maxpos);
+    }
+    
+    D3D12_VERTEX_BUFFER_VIEW vertex_buffer_view;
+    vertex_buffer_view.BufferLocation = d3d.vertex_buffer->GetGPUVirtualAddress() + current_pos;
+    vertex_buffer_view.StrideInBytes = buf_vbo_len / (3 * buf_vbo_num_tris) * sizeof(float);
+    vertex_buffer_view.SizeInBytes = buf_vbo_len * sizeof(float);
+    
+    d3d.command_list->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
+    d3d.command_list->IASetVertexBuffers(0, 1, &vertex_buffer_view);
+    d3d.command_list->DrawInstanced(3 * buf_vbo_num_tris, 1, 0, 0);
+}
+
+static void gfx_direct3d12_init(void) {
+}
+
+static void gfx_direct3d12_start_frame(void) {
+    ++d3d.frame_counter;
+    d3d.srv_pos = 0;
+    texture_uploads = 0;
+    ThrowIfFailed(d3d.command_allocator->Reset());
+    ThrowIfFailed(d3d.command_list->Reset(d3d.command_allocator.Get(), nullptr));
+    
+    CD3DX12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(
+        d3d.render_targets[d3d.frame_index].Get(),
+        D3D12_RESOURCE_STATE_PRESENT,
+        D3D12_RESOURCE_STATE_RENDER_TARGET);
+ d3d.command_list->ResourceBarrier(1, &barrier);
+    
+    CD3DX12_CPU_DESCRIPTOR_HANDLE rtv_handle(get_cpu_descriptor_handle(d3d.rtv_heap), d3d.frame_index, d3d.rtv_descriptor_size);
+    D3D12_CPU_DESCRIPTOR_HANDLE dsv_handle = get_cpu_descriptor_handle(d3d.dsv_heap);
+    d3d.command_list->OMSetRenderTargets(1, &rtv_handle, FALSE, &dsv_handle);
+    
+    static unsigned char c;
+ const float clear_color[] = { 0.0f, 0.0f, 0.0f, 1.0f };
+ d3d.command_list->ClearRenderTargetView(rtv_handle, clear_color, 0, nullptr);
+    d3d.command_list->ClearDepthStencilView(dsv_handle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
+    
+    d3d.vbuf_pos = 0;
+}
+
+static void create_render_target_views(void) {
+    D3D12_CPU_DESCRIPTOR_HANDLE rtv_handle = get_cpu_descriptor_handle(d3d.rtv_heap);
+ for (UINT i = 0; i < 2; i++) {
+   ThrowIfFailed(d3d.swap_chain->GetBuffer(i, IID_ID3D12Resource, (void **)&d3d.render_targets[i]));
+   d3d.device->CreateRenderTargetView(d3d.render_targets[i].Get(), nullptr, rtv_handle);
+   rtv_handle.ptr += d3d.rtv_descriptor_size;
+ }
+}
+
+static void create_depth_buffer(void) {
+    DXGI_SWAP_CHAIN_DESC1 desc1;
+    ThrowIfFailed(d3d.swap_chain->GetDesc1(&desc1));
+    UINT width = desc1.Width;
+    UINT height = desc1.Height;
+    
+    d3d.current_width = width;
+    d3d.current_height = height;
+    
+    D3D12_DEPTH_STENCIL_VIEW_DESC dsv_desc = {};
+    dsv_desc.Format = DXGI_FORMAT_D32_FLOAT;
+    dsv_desc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
+    dsv_desc.Flags = D3D12_DSV_FLAG_NONE;
+
+    D3D12_CLEAR_VALUE depth_optimized_cv = {};
+    depth_optimized_cv.Format = DXGI_FORMAT_D32_FLOAT;
+    depth_optimized_cv.DepthStencil.Depth = 1.0f;
+
+    D3D12_HEAP_PROPERTIES hp = {};
+    hp.Type = D3D12_HEAP_TYPE_DEFAULT;
+    hp.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
+    hp.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
+    hp.CreationNodeMask = 1;
+    hp.VisibleNodeMask = 1;
+
+    D3D12_RESOURCE_DESC rd = {};
+    rd.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
+    rd.Alignment = 0;
+    rd.Width = width;
+    rd.Height = height;
+    rd.DepthOrArraySize = 1;
+    rd.MipLevels = 0;
+    rd.Format = DXGI_FORMAT_D32_FLOAT;
+    rd.SampleDesc.Count = 1;
+    rd.SampleDesc.Quality = 0;
+    rd.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
+    rd.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
+    ThrowIfFailed(d3d.device->CreateCommittedResource(&hp, D3D12_HEAP_FLAG_NONE, &rd, D3D12_RESOURCE_STATE_DEPTH_WRITE, &depth_optimized_cv, IID_ID3D12Resource, IID_PPV_ARGS_Helper(&d3d.depth_stencil_buffer)));
+    
+    d3d.device->CreateDepthStencilView(d3d.depth_stencil_buffer.Get(), &dsv_desc, get_cpu_descriptor_handle(d3d.dsv_heap));
+}
+
+static void gfx_dxgi_on_resize(void) {
+    if (d3d.render_targets[0].Get() != nullptr) {
+        d3d.render_targets[0].Reset();
+        d3d.render_targets[1].Reset();
+        ThrowIfFailed(d3d.swap_chain->ResizeBuffers(0, 0, 0, DXGI_FORMAT_UNKNOWN, DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT));
+        d3d.frame_index = d3d.swap_chain->GetCurrentBackBufferIndex();
+        create_render_target_views();
+        create_depth_buffer();
+    }
+}
+
+static void onkeydown(WPARAM w_param, LPARAM l_param) {
+    keyboard_on_key_down((l_param >> 16) & 0x1ff);
+}
+static void onkeyup(WPARAM w_param, LPARAM l_param) {
+    keyboard_on_key_up((l_param >> 16) & 0x1ff);
+}
+
+LRESULT CALLBACK gfx_dxgi_wnd_proc(HWND h_wnd, UINT message, WPARAM w_param, LPARAM l_param) {
+    switch (message) {
+        case WM_SIZE:
+            gfx_dxgi_on_resize();
+            break;
+        case WM_DESTROY:
+            exit(0);
+        case WM_PAINT:
+            if (d3d.run_one_game_iter != nullptr) {
+                d3d.run_one_game_iter();
+            }
+            break;
+        case WM_ACTIVATEAPP:
+            keyboard_on_all_keys_up();
+            break;
+        case WM_KEYDOWN:
+            onkeydown(w_param, l_param);
+            break;
+        case WM_KEYUP:
+            onkeyup(w_param, l_param);
+            break;
+        default:
+            return DefWindowProcW(h_wnd, message, w_param, l_param);
+    }
+    return 0;
+}
+
+static void gfx_dxgi_init(void) {
+    LARGE_INTEGER qpc_init, qpc_freq;
+    QueryPerformanceCounter(&qpc_init);
+    QueryPerformanceFrequency(&qpc_freq);
+    d3d.qpc_init = qpc_init.QuadPart;
+    d3d.qpc_freq = qpc_freq.QuadPart;
+    
+    // Create window
+    WNDCLASSEXW wcex;
+
+    wcex.cbSize = sizeof(WNDCLASSEX);
+
+    wcex.style          = CS_HREDRAW | CS_VREDRAW;
+    wcex.lpfnWndProc    = gfx_dxgi_wnd_proc;
+    wcex.cbClsExtra     = 0;
+    wcex.cbWndExtra     = 0;
+    wcex.hInstance      = nullptr;
+    wcex.hIcon          = nullptr;
+    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
+    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
+    wcex.lpszMenuName   = nullptr;
+    wcex.lpszClassName  = WINCLASS_NAME;
+    wcex.hIconSm        = nullptr;
+
+    ATOM winclass = RegisterClassExW(&wcex);
+    
+    RECT wr = {0, 0, DESIRED_SCREEN_WIDTH, DESIRED_SCREEN_HEIGHT};
+    AdjustWindowRect(&wr, WS_OVERLAPPEDWINDOW, FALSE);
+    
+    HWND h_wnd = CreateWindowW(WINCLASS_NAME, L"Super Mario 64 PC-Port", WS_OVERLAPPEDWINDOW,
+        CW_USEDEFAULT, 0, wr.right - wr.left, wr.bottom - wr.top, nullptr, nullptr, nullptr, nullptr);
+    
+    // Create device
+    {
+        UINT debug_flags = 0;
+#if DEBUG_D3D
+        ComPtr<ID3D12Debug> debug_controller;
+        if (SUCCEEDED(D3D12GetDebugInterface(IID_ID3D12Debug, IID_PPV_ARGS_Helper(&debug_controller)))) {
+            debug_controller->EnableDebugLayer();
+            debug_flags |= DXGI_CREATE_FACTORY_DEBUG;
+        }
+#endif
+        
+        ThrowIfFailed(CreateDXGIFactory2(debug_flags, IID_IDXGIFactory4, &d3d.factory));
+        ComPtr<IDXGIAdapter1> hw_adapter;
+        for (UINT i = 0; d3d.factory->EnumAdapters1(i, &hw_adapter) != DXGI_ERROR_NOT_FOUND; i++) {
+            DXGI_ADAPTER_DESC1 desc;
+            hw_adapter->GetDesc1(&desc);
+            if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
+                continue;
+            }
+            if (SUCCEEDED(D3D12CreateDevice(hw_adapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_ID3D12Device, nullptr))) {
+                break;
+            }
+        }
+        ThrowIfFailed(D3D12CreateDevice(hw_adapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_ID3D12Device, IID_PPV_ARGS_Helper(&d3d.device)));
+    }
+    
+    // Create command queues
+    {
+        D3D12_COMMAND_QUEUE_DESC queue_desc = {};
+        queue_desc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
+        queue_desc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
+        ThrowIfFailed(d3d.device->CreateCommandQueue(&queue_desc, IID_ID3D12CommandQueue, IID_PPV_ARGS_Helper(&d3d.command_queue)));
+    }
+    {
+        D3D12_COMMAND_QUEUE_DESC queue_desc = {};
+        queue_desc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
+        queue_desc.Type = D3D12_COMMAND_LIST_TYPE_COPY;
+        ThrowIfFailed(d3d.device->CreateCommandQueue(&queue_desc, IID_ID3D12CommandQueue, IID_PPV_ARGS_Helper(&d3d.copy_command_queue)));
+    }
+    
+    // Create swap chain
+    {
+        DXGI_SWAP_CHAIN_DESC1 swap_chain_desc = {};
+        swap_chain_desc.BufferCount = 2;
+        swap_chain_desc.Width = DESIRED_SCREEN_WIDTH;
+        swap_chain_desc.Height = DESIRED_SCREEN_HEIGHT;
+        swap_chain_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
+        swap_chain_desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+        swap_chain_desc.Scaling = DXGI_SCALING_NONE;
+        swap_chain_desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
+        swap_chain_desc.Flags = DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
+        swap_chain_desc.SampleDesc.Count = 1;
+
+        ComPtr<IDXGISwapChain1> swap_chain1;
+        ThrowIfFailed(d3d.factory->CreateSwapChainForHwnd(d3d.command_queue.Get(), h_wnd, &swap_chain_desc, nullptr, nullptr, &swap_chain1));
+        //ThrowIfFailed(factory->MakeWindowAssociation(h_wnd, DXGI_MWA_NO_ALT_ENTER));
+        ThrowIfFailed(swap_chain1->QueryInterface(IID_IDXGISwapChain3, &d3d.swap_chain));
+        d3d.frame_index = d3d.swap_chain->GetCurrentBackBufferIndex();
+        ThrowIfFailed(d3d.swap_chain->SetMaximumFrameLatency(1));
+        d3d.waitable_object = d3d.swap_chain->GetFrameLatencyWaitableObject();
+        WaitForSingleObject(d3d.waitable_object, INFINITE);
+    }
+    
+    // Create render target views
+    {
+        D3D12_DESCRIPTOR_HEAP_DESC rtv_heap_desc = {};
+        rtv_heap_desc.NumDescriptors = 2;
+        rtv_heap_desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
+        rtv_heap_desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
+        ThrowIfFailed(d3d.device->CreateDescriptorHeap(&rtv_heap_desc, IID_ID3D12DescriptorHeap, IID_PPV_ARGS_Helper(&d3d.rtv_heap)));
+        d3d.rtv_descriptor_size = d3d.device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
+
+        create_render_target_views();
+    }
+    
+    // Create Z-buffer
+    {
+        D3D12_DESCRIPTOR_HEAP_DESC dsv_heap_desc = {};
+        dsv_heap_desc.NumDescriptors = 1;
+        dsv_heap_desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
+        dsv_heap_desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
+        ThrowIfFailed(d3d.device->CreateDescriptorHeap(&dsv_heap_desc, IID_ID3D12DescriptorHeap, IID_PPV_ARGS_Helper(&d3d.dsv_heap)));
+
+        create_depth_buffer();
+    }
+    
+    // Create SRV heap for texture descriptors
+    {
+        D3D12_DESCRIPTOR_HEAP_DESC srv_heap_desc = {};
+   srv_heap_desc.NumDescriptors = 1024; // Max unique textures per frame
+   srv_heap_desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
+   srv_heap_desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
+   ThrowIfFailed(d3d.device->CreateDescriptorHeap(&srv_heap_desc, IID_ID3D12DescriptorHeap, IID_PPV_ARGS_Helper(&d3d.srv_heap)));
+        d3d.srv_descriptor_size = d3d.device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
+    }
+    
+    // Create sampler heap and descriptors
+    {
+        D3D12_DESCRIPTOR_HEAP_DESC sampler_heap_desc = {};
+        sampler_heap_desc.NumDescriptors = 18;
+        sampler_heap_desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER;
+        sampler_heap_desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
+        ThrowIfFailed(d3d.device->CreateDescriptorHeap(&sampler_heap_desc, IID_ID3D12DescriptorHeap, IID_PPV_ARGS_Helper(&d3d.sampler_heap)));
+        d3d.sampler_descriptor_size = d3d.device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
+        
+        static const D3D12_TEXTURE_ADDRESS_MODE address_modes[] = {
+            D3D12_TEXTURE_ADDRESS_MODE_WRAP,
+            D3D12_TEXTURE_ADDRESS_MODE_MIRROR,
+            D3D12_TEXTURE_ADDRESS_MODE_CLAMP
+        };
+        
+        D3D12_CPU_DESCRIPTOR_HANDLE sampler_handle = get_cpu_descriptor_handle(d3d.sampler_heap);
+        int pos = 0;
+        for (int linear_filter = 0; linear_filter < 2; linear_filter++) {
+            for (int cms = 0; cms < 3; cms++) {
+                for (int cmt = 0; cmt < 3; cmt++) {
+                    D3D12_SAMPLER_DESC sampler_desc = {};
+                    sampler_desc.Filter = linear_filter ? D3D12_FILTER_MIN_MAG_MIP_LINEAR : D3D12_FILTER_MIN_MAG_MIP_POINT;
+                    sampler_desc.AddressU = address_modes[cms];
+                    sampler_desc.AddressV = address_modes[cmt];
+                    sampler_desc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
+                    sampler_desc.MinLOD = 0;
+                    sampler_desc.MaxLOD = D3D12_FLOAT32_MAX;
+                    sampler_desc.MipLODBias = 0.0f;
+                    sampler_desc.MaxAnisotropy = 1;
+                    sampler_desc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
+                    d3d.device->CreateSampler(&sampler_desc, CD3DX12_CPU_DESCRIPTOR_HANDLE(sampler_handle, pos++, d3d.sampler_descriptor_size));
+                }
+            }
+        }
+    }
+    
+    ThrowIfFailed(d3d.device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_ID3D12CommandAllocator, IID_PPV_ARGS_Helper(&d3d.command_allocator)));
+    ThrowIfFailed(d3d.device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_COPY, IID_ID3D12CommandAllocator, IID_PPV_ARGS_Helper(&d3d.copy_command_allocator)));
+    
+    ThrowIfFailed(d3d.device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, d3d.command_allocator.Get(), nullptr, IID_ID3D12GraphicsCommandList, IID_PPV_ARGS_Helper(&d3d.command_list)));
+    ThrowIfFailed(d3d.device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_COPY, d3d.copy_command_allocator.Get(), nullptr, IID_ID3D12GraphicsCommandList, IID_PPV_ARGS_Helper(&d3d.copy_command_list)));
+    
+    ThrowIfFailed(d3d.command_list->Close());
+    
+    ThrowIfFailed(d3d.device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_ID3D12Fence, IID_PPV_ARGS_Helper(&d3d.fence)));
+    d3d.fence_event = CreateEvent(nullptr, FALSE, FALSE, nullptr);
+    if (d3d.fence_event == nullptr) {
+        ThrowIfFailed(HRESULT_FROM_WIN32(GetLastError()));
+    }
+    
+    ThrowIfFailed(d3d.device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_ID3D12Fence, IID_PPV_ARGS_Helper(&d3d.copy_fence)));
+    
+    {
+        // Create a buffer of 1 MB in size. With a 120 star speed run 192 kB seems to be max usage.
+        CD3DX12_HEAP_PROPERTIES hp(D3D12_HEAP_TYPE_UPLOAD);
+        CD3DX12_RESOURCE_DESC rdb = CD3DX12_RESOURCE_DESC::Buffer(256 * 1024 * sizeof(float));
+        ThrowIfFailed(d3d.device->CreateCommittedResource(
+            &hp,
+            D3D12_HEAP_FLAG_NONE,
+            &rdb,
+            D3D12_RESOURCE_STATE_GENERIC_READ,
+            nullptr,
+            IID_ID3D12Resource,
+            IID_PPV_ARGS_Helper(&d3d.vertex_buffer)));
+        
+        CD3DX12_RANGE read_range(0, 0); // Read not possible from CPU
+        ThrowIfFailed(d3d.vertex_buffer->Map(0, &read_range, &d3d.mapped_vbuf_address));
+    }
+    
+    ShowWindow(h_wnd, SW_SHOW);
+    UpdateWindow(h_wnd);
+}
+
+static void gfx_dxgi_main_loop(void (*run_one_game_iter)(void)) {
+    d3d.run_one_game_iter = run_one_game_iter;
+    
+    MSG msg;
+    while (GetMessage(&msg, nullptr, 0, 0)) {
+        TranslateMessage(&msg);
+        DispatchMessage(&msg);
+    }
+}
+
+static void gfx_dxgi_get_dimensions(uint32_t *width, uint32_t *height) {
+    *width = d3d.current_width;
+    *height = d3d.current_height;
+}
+
+static void gfx_dxgi_handle_events(void) {
+    /*MSG msg;
+    while (PeekMessageW(&msg, nullptr, 0, 0, PM_REMOVE)) {
+        TranslateMessage(&msg);
+        DispatchMessage(&msg);
+    }*/
+}
+
+static uint64_t qpc_to_us(uint64_t qpc) {
+    return qpc / d3d.qpc_freq * 1000000 + qpc % d3d.qpc_freq * 1000000 / d3d.qpc_freq;
+}
+
+static bool gfx_dxgi_start_frame(void) {
+    DXGI_FRAME_STATISTICS stats;
+    if (d3d.swap_chain->GetFrameStatistics(&stats) == S_OK && (stats.SyncRefreshCount != 0 || stats.SyncQPCTime.QuadPart != 0ULL)) {
+        {
+            LARGE_INTEGER t0;
+            QueryPerformanceCounter(&t0);
+            //printf("Get frame stats: %llu\n", (unsigned long long)(t0.QuadPart - d3d.qpc_init));
+        }
+        //printf("stats: %u %u %u %u %u %.6f\n", d3d.pending_frame_stats.rbegin()->first, d3d.pending_frame_stats.rbegin()->second, stats.PresentCount, stats.PresentRefreshCount, stats.SyncRefreshCount, (double)(stats.SyncQPCTime.QuadPart - d3d.qpc_init) / d3d.qpc_freq);
+        if (d3d.frame_stats.empty() || d3d.frame_stats.rbegin()->second.PresentCount != stats.PresentCount) {
+            d3d.frame_stats.insert(std::make_pair(stats.PresentCount, stats));
+        }
+        if (d3d.frame_stats.size() > 3) {
+            d3d.frame_stats.erase(d3d.frame_stats.begin());
+        }
+    }
+    if (!d3d.frame_stats.empty()) {
+        while (!d3d.pending_frame_stats.empty() && d3d.pending_frame_stats.begin()->first < d3d.frame_stats.rbegin()->first) {
+            d3d.pending_frame_stats.erase(d3d.pending_frame_stats.begin());
+        }
+    }
+    while (d3d.pending_frame_stats.size() > 15) {
+        // Just make sure the list doesn't grow too large if GetFrameStatistics fails.
+        d3d.pending_frame_stats.erase(d3d.pending_frame_stats.begin());
+    }
+    
+    d3d.frame_timestamp += 100000;
+    
+    if (d3d.frame_stats.size() >= 2) {
+        DXGI_FRAME_STATISTICS *first = &d3d.frame_stats.begin()->second;
+        DXGI_FRAME_STATISTICS *last = &d3d.frame_stats.rbegin()->second;
+        uint64_t sync_qpc_diff = last->SyncQPCTime.QuadPart - first->SyncQPCTime.QuadPart;
+        UINT sync_vsync_diff = last->SyncRefreshCount - first->SyncRefreshCount;
+        UINT present_vsync_diff = last->PresentRefreshCount - first->PresentRefreshCount;
+        UINT present_diff = last->PresentCount - first->PresentCount;
+        
+        if (sync_vsync_diff == 0) {
+            sync_vsync_diff = 1;
+        }
+        
+        double estimated_vsync_interval = (double)sync_qpc_diff / (double)sync_vsync_diff;
+        //printf("Estimated vsync_interval: %f\n", estimated_vsync_interval);
+        uint64_t estimated_vsync_interval_us = qpc_to_us(estimated_vsync_interval);
+        if (estimated_vsync_interval_us < 2 || estimated_vsync_interval_us > 1000000) {
+            // Unreasonable, maybe a monitor change
+            estimated_vsync_interval_us = 16666;
+            estimated_vsync_interval = estimated_vsync_interval_us * d3d.qpc_freq / 1000000;
+        }
+        
+        UINT queued_vsyncs = 0;
+        bool is_first = true;
+        for (const std::pair<UINT, UINT>& p : d3d.pending_frame_stats) {
+            if (is_first && d3d.sync_interval_means_frames_to_wait) {
+                is_first = false;
+                continue;
+            }
+            queued_vsyncs += p.second;
+        }
+        
+        uint64_t last_frame_present_end_qpc = (last->SyncQPCTime.QuadPart - d3d.qpc_init) + estimated_vsync_interval * queued_vsyncs;
+        uint64_t last_end_us = qpc_to_us(last_frame_present_end_qpc);
+        
+        double vsyncs_to_wait = (double)(int64_t)(d3d.frame_timestamp / 3 - last_end_us) / estimated_vsync_interval_us;
+        //printf("ts: %llu, last_end_us: %llu, Init v: %f\n", d3d.frame_timestamp / 3, last_end_us, vsyncs_to_wait);
+        
+        if (vsyncs_to_wait <= 0) {
+            // Too late
+            
+            if ((int64_t)(d3d.frame_timestamp / 3 - last_end_us) < -66666) {
+                // The application must have been paused or similar
+                vsyncs_to_wait = round(33333.3 / estimated_vsync_interval_us);
+                if (vsyncs_to_wait < 1) {
+                    vsyncs_to_wait = 1;
+                }
+                d3d.frame_timestamp = 3 * (last_end_us + vsyncs_to_wait * estimated_vsync_interval_us);
+            } else {
+                // Drop frame
+                //printf("Dropping frame\n");
+                d3d.dropped_frame = true;
+                return false;
+            }
+        }
+        if (floor(vsyncs_to_wait) != vsyncs_to_wait) {
+            uint64_t left = last_end_us + floor(vsyncs_to_wait) * estimated_vsync_interval_us;
+            uint64_t right = last_end_us + ceil(vsyncs_to_wait) * estimated_vsync_interval_us;
+            uint64_t adjusted_desired_time = d3d.frame_timestamp / 3 + (last_end_us + 33333 > d3d.frame_timestamp / 3 ? 2000 : -2000);
+            int64_t diff_left = adjusted_desired_time - left;
+            int64_t diff_right = right - adjusted_desired_time;
+            if (diff_left < 0) {
+                diff_left = -diff_left;
+            }
+            if (diff_right < 0) {
+                diff_right = -diff_right;
+            }
+            if (diff_left < diff_right) {
+                vsyncs_to_wait = floor(vsyncs_to_wait);
+            } else {
+                vsyncs_to_wait = ceil(vsyncs_to_wait);
+            }
+            if (vsyncs_to_wait == 0) {
+                //printf("vsyncs_to_wait became 0 so dropping frame\n");
+                d3d.dropped_frame = true;
+                return false;
+            }
+        }
+        //printf("v: %d\n", (int)vsyncs_to_wait);
+        if (vsyncs_to_wait > 4) {
+            // Invalid, so change to 4
+            vsyncs_to_wait = 4;
+        }
+        d3d.length_in_vsync_frames = vsyncs_to_wait;
+    } else {
+        d3d.length_in_vsync_frames = 2;
+    }
+    
+    return true;
+}
+
+static void gfx_dxgi_swap_buffers_begin(void) {
+    if (max_texture_uploads < texture_uploads && texture_uploads != 38 && texture_uploads != 34 && texture_uploads != 29) {
+        max_texture_uploads = texture_uploads;
+    }
+    //printf("Texture uploads: %d %d\n", max_texture_uploads, texture_uploads);
+    texture_uploads = 0;
+    
+    ThrowIfFailed(d3d.copy_command_list->Close());
+    {
+        ID3D12CommandList *lists[] = { d3d.copy_command_list.Get() };
+        d3d.copy_command_queue->ExecuteCommandLists(1, lists);
+        d3d.copy_command_queue->Signal(d3d.copy_fence.Get(), ++d3d.copy_fence_value);
+    }
+    
+    CD3DX12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(
+        d3d.render_targets[d3d.frame_index].Get(),
+        D3D12_RESOURCE_STATE_RENDER_TARGET,
+        D3D12_RESOURCE_STATE_PRESENT);
+ d3d.command_list->ResourceBarrier(1, &barrier);
+    
+    d3d.command_queue->Wait(d3d.copy_fence.Get(), d3d.copy_fence_value);
+    
+    ThrowIfFailed(d3d.command_list->Close());
+    
+    {
+        ID3D12CommandList *lists[] = { d3d.command_list.Get() };
+        d3d.command_queue->ExecuteCommandLists(1, lists);
+    }
+    
+    {
+        LARGE_INTEGER t0;
+        QueryPerformanceCounter(&t0);
+        //printf("Present: %llu %u\n", (unsigned long long)(t0.QuadPart - d3d.qpc_init), d3d.length_in_vsync_frames);
+    }
+    
+    //d3d.length_in_vsync_frames = 1;
+    ThrowIfFailed(d3d.swap_chain->Present(d3d.length_in_vsync_frames, 0));
+    UINT this_present_id;
+    if (d3d.swap_chain->GetLastPresentCount(&this_present_id) == S_OK) {
+        d3d.pending_frame_stats.insert(std::make_pair(this_present_id, d3d.length_in_vsync_frames));
+    }
+    d3d.dropped_frame = false;
+}
+
+static void gfx_dxgi_swap_buffers_end(void) {
+    LARGE_INTEGER t0, t1, t2;
+    QueryPerformanceCounter(&t0);
+    
+    static UINT64 fence_value;
+ ThrowIfFailed(d3d.command_queue->Signal(d3d.fence.Get(), ++fence_value));
+ if (d3d.fence->GetCompletedValue() < fence_value) {
+   ThrowIfFailed(d3d.fence->SetEventOnCompletion(fence_value, d3d.fence_event));
+   WaitForSingleObject(d3d.fence_event, INFINITE);
+ }
+    QueryPerformanceCounter(&t1);
+    
+    d3d.resources_to_clean_at_end_of_frame.clear();
+    for (std::pair<size_t, ComPtr<ID3D12Resource>>& heap : d3d.upload_heaps_in_flight) {
+        d3d.upload_heaps[heap.first].push_back(std::move(heap.second));
+    }
+    d3d.upload_heaps_in_flight.clear();
+    for (std::pair<struct TextureHeap *, uint8_t>& item : d3d.texture_heap_allocations_to_reclaim_at_end_of_frame) {
+        item.first->free_list.push_back(item.second);
+    }
+    d3d.texture_heap_allocations_to_reclaim_at_end_of_frame.clear();
+    
+    if (!d3d.dropped_frame) {
+        WaitForSingleObject(d3d.waitable_object, INFINITE);
+    }
+    
+    DXGI_FRAME_STATISTICS stats;
+    d3d.swap_chain->GetFrameStatistics(&stats);
+    
+    QueryPerformanceCounter(&t2);
+    
+    d3d.frame_index = d3d.swap_chain->GetCurrentBackBufferIndex();
+    
+    ThrowIfFailed(d3d.copy_command_allocator->Reset());
+    ThrowIfFailed(d3d.copy_command_list->Reset(d3d.copy_command_allocator.Get(), nullptr));
+    
+    d3d.sync_interval_means_frames_to_wait = d3d.pending_frame_stats.rbegin()->first == stats.PresentCount;
+    
+    //printf("done %llu gpu:%d wait:%d freed:%llu frame:%u %u monitor:%u t:%llu\n", (unsigned long long)(t0.QuadPart - d3d.qpc_init), (int)(t1.QuadPart - t0.QuadPart), (int)(t2.QuadPart - t0.QuadPart), (unsigned long long)(t2.QuadPart - d3d.qpc_init), d3d.pending_frame_stats.rbegin()->first, stats.PresentCount, stats.SyncRefreshCount, (unsigned long long)(stats.SyncQPCTime.QuadPart - d3d.qpc_init));
+}
+
+double gfx_dxgi_get_time(void) {
+    LARGE_INTEGER t;
+    QueryPerformanceCounter(&t);
+    return (double)(t.QuadPart - d3d.qpc_init) / d3d.qpc_freq;
+}
+
+struct GfxRenderingAPI gfx_direct3d12_api = {
+    gfx_direct3d12_z_is_from_0_to_1,
+    gfx_direct3d12_unload_shader,
+    gfx_direct3d12_load_shader,
+    gfx_direct3d12_create_and_load_new_shader,
+    gfx_direct3d12_lookup_shader,
+    gfx_direct3d12_shader_get_info,
+    gfx_direct3d12_new_texture,
+    gfx_direct3d12_select_texture,
+    gfx_direct3d12_upload_texture,
+    gfx_direct3d12_set_sampler_parameters,
+    gfx_direct3d12_set_depth_test,
+    gfx_direct3d12_set_depth_mask,
+    gfx_direct3d12_set_zmode_decal,
+    gfx_direct3d12_set_viewport,
+    gfx_direct3d12_set_scissor,
+    gfx_direct3d12_set_use_alpha,
+    gfx_direct3d12_draw_triangles,
+    gfx_direct3d12_init,
+    gfx_direct3d12_start_frame
+};
+
+struct GfxWindowManagerAPI gfx_dxgi_api = {
+    gfx_dxgi_init,
+    gfx_dxgi_main_loop,
+    gfx_dxgi_get_dimensions,
+    gfx_dxgi_handle_events,
+    gfx_dxgi_start_frame,
+    gfx_dxgi_swap_buffers_begin,
+    gfx_dxgi_swap_buffers_end,
+    gfx_dxgi_get_time,
+};
+
+#endif
diff --git a/src/pc/gfx/gfx_direct3d12.h b/src/pc/gfx/gfx_direct3d12.h
new file mode 100644
index 0000000..35187c8
--- /dev/null
+++ b/src/pc/gfx/gfx_direct3d12.h
@@ -0,0 +1,10 @@
+#ifndef GFX_DIRECT3D12_H
+#define GFX_DIRECT3D12_H
+
+#include "gfx_window_manager_api.h"
+#include "gfx_rendering_api.h"
+
+extern struct GfxWindowManagerAPI gfx_dxgi_api;
+extern struct GfxRenderingAPI gfx_direct3d12_api;
+
+#endif
diff --git a/src/pc/gfx/gfx_glfw.c b/src/pc/gfx/gfx_glfw.c
new file mode 100644
index 0000000..c430cf5
--- /dev/null
+++ b/src/pc/gfx/gfx_glfw.c
@@ -0,0 +1,150 @@
+#if 0
+#include <stdlib.h>
+#include <stdio.h>
+#include <GLFW/glfw3.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>
+
+#define GLFW_EXPOSE_NATIVE_X11
+#include <GLFW/glfw3native.h>
+
+Bool glXGetSyncValuesOML(Display* dpy,
+                         Drawable drawable,
+                         int64_t* ust,
+                         int64_t* msc,
+                         int64_t* sbc);
+
+Bool glXGetMscRateOML(Display* dpy,
+                      Drawable drawable,
+                      int32_t* numerator,
+                      int32_t* denominator);
+
+int64_t glXSwapBuffersMscOML(Display* dpy,
+                             Drawable drawable,
+                             int64_t target_msc,
+                             int64_t divisor,
+                             int64_t remainder);
+
+Bool glXWaitForMscOML(Display* dpy,
+                      Drawable drawable,
+                      int64_t target_msc,
+                      int64_t divisor,
+                      int64_t remainder,
+                      int64_t* ust,
+                      int64_t* msc,
+                      int64_t* sbc);
+
+Bool glXWaitForSbcOML(Display* dpy,
+                      Drawable drawable,
+                      int64_t target_sbc,
+                      int64_t* ust,
+                      int64_t* msc,
+                      int64_t* sbc);
+
+static struct {
+    GLFWwindow *window;
+} glfw;
+
+static void gfx_glfw_error_callback(int error, const char *description) {
+    fprintf(stderr, "GLFW error: %s\n", description);
+}
+
+static void gfx_glfw_monitor_callback(GLFWmonitor *monitor, int event) {
+    printf("Monitor %p changed %d\n", monitor, event);
+    if (event != GLFW_DISCONNECTED) {
+        int xpos, ypos;
+        glfwGetMonitorPos(monitor, &xpos, &ypos);
+        printf("x: %d, y: %d\n", xpos, ypos);
+    }
+}
+
+void gfx_glfw_init(void) {
+    glfwSetErrorCallback(gfx_glfw_error_callback);
+    if (!glfwInit()) {
+        fprintf(stderr, "GLFW init failed\n");
+        exit(1);
+    }
+    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
+    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);
+    glfw.window = glfwCreateWindow(640, 480, "Super Mario 64 GLFW", NULL, NULL);
+    if (glfw.window == NULL) {
+        fprintf(stderr, "glfwCreateWindow failed\n");
+        exit(1);
+    }
+    glfwMakeContextCurrent(glfw.window);
+    glfwSetMonitorCallback(gfx_glfw_monitor_callback);
+}
+
+void gfx_glfw_handle_events(void) {
+    glfwPollEvents();
+    if (glfwWindowShouldClose(glfw.window)) {
+        exit(0);
+    }
+}
+
+void gfx_glfw_swap_buffers(void) {
+    static uint64_t cnt = 0;
+    if (0) {
+        int mc;
+        GLFWmonitor **monitors = glfwGetMonitors(&mc);
+        for (int i = 0; i < mc; i++) {
+            GLFWmonitor *monitor = monitors[i];
+            int xpos, ypos;
+            glfwGetMonitorPos(monitor, &xpos, &ypos);
+            if (++cnt % 60 == 0) printf("x: %d, y: %d\n", xpos, ypos);
+        }
+    }
+    if (1) {
+        XWindowAttributes xwa;
+        XGetWindowAttributes(glfwGetX11Display(), glfwGetX11Window(glfw.window), &xwa);
+        int rootx, rooty;
+        Window child;
+        XTranslateCoordinates(glfwGetX11Display(), glfwGetX11Window(glfw.window), xwa.root, xwa.x, xwa.y, &rootx, &rooty, &child);
+        printf("%d %d\n", rootx, rooty);
+        
+        int32_t numerator = 0, denominator = 0;
+        Bool ok = glXGetMscRateOML(glfwGetX11Display(), glfwGetX11Window(glfw.window), &numerator, &denominator);
+        printf("%d %d %d %f\n", ok, numerator, denominator, (double)numerator / denominator);
+        
+        int mc;
+        GLFWmonitor **monitors = glfwGetMonitors(&mc);
+        XRRScreenResources *sr = XRRGetScreenResourcesCurrent(glfwGetX11Display(), glfwGetX11Window(glfw.window));
+        for (int i = 0; i < mc; i++) {
+            GLFWvidmode *vidmode = glfwGetVideoMode(monitors[i]);
+            printf("glfw Hz: %d\n", vidmode->refreshRate);
+            RRCrtc crtc = glfwGetX11Adapter(monitors[i]);
+            XRRCrtcInfo *ci = XRRGetCrtcInfo(glfwGetX11Display(), sr, crtc);
+            for (int j = 0; j < sr->nmode; j++) {
+                if (sr->modes[j].id == ci->mode) {
+                    unsigned long numerator = sr->modes[j].dotClock;
+                    unsigned long denominator = (unsigned long)sr->modes[j].vTotal * (unsigned long)sr->modes[j].hTotal;
+                    if (sr->modes[j].modeFlags & RR_DoubleScan) {
+                        denominator *= 2;
+                    }
+                    if (sr->modes[j].modeFlags & RR_Interlace) {
+                        // We want fields per second and not full frames per second
+                        numerator *= 2;
+                    }
+                    printf("%d %d %f\n", i, j, (double)numerator / (double)denominator);
+                    break;
+                }
+            }
+            XRRFreeCrtcInfo(ci);
+        }
+        XRRFreeScreenResources(sr);
+    }
+    glfwSwapBuffers(glfw.window);
+}
+
+void gfx_window_system_init(void) {
+    gfx_glfw_init();
+}
+
+void gfx_window_system_handle_events(void) {
+    gfx_glfw_handle_events();
+}
+
+void gfx_window_system_swap_buffers(void) {
+    gfx_glfw_swap_buffers();
+}
+#endif
diff --git a/src/pc/gfx/gfx_glx.c b/src/pc/gfx/gfx_glx.c
new file mode 100644
index 0000000..a669716
--- /dev/null
+++ b/src/pc/gfx/gfx_glx.c
@@ -0,0 +1,403 @@
+#ifdef __linux__
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <string.h>
+#include <math.h>
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <GL/glx.h>
+#include <X11/extensions/Xrandr.h>
+#include <X11/XKBlib.h>
+#include <X11/Xatom.h>
+
+#include "gfx_window_manager_api.h"
+#include "gfx_screen_config.h"
+
+#include "src/pc/controller/controller_keyboard.h"
+
+#include "../configfile.h"
+
+Bool glXGetSyncValuesOML(Display* dpy,
+                         GLXDrawable drawable,
+                         int64_t* ust,
+                         int64_t* msc,
+                         int64_t* sbc);
+
+Bool glXGetMscRateOML(Display* dpy,
+                      GLXDrawable drawable,
+                      int32_t* numerator,
+                      int32_t* denominator);
+
+int64_t glXSwapBuffersMscOML(Display* dpy,
+                             GLXDrawable drawable,
+                             int64_t target_msc,
+                             int64_t divisor,
+                             int64_t remainder);
+
+Bool glXWaitForMscOML(Display* dpy,
+                      GLXDrawable drawable,
+                      int64_t target_msc,
+                      int64_t divisor,
+                      int64_t remainder,
+                      int64_t* ust,
+                      int64_t* msc,
+                      int64_t* sbc);
+
+Bool glXWaitForSbcOML(Display* dpy,
+                      GLXDrawable drawable,
+                      int64_t target_sbc,
+                      int64_t* ust,
+                      int64_t* msc,
+                      int64_t* sbc);
+
+const struct {
+    const char *name;
+    int scancode;
+} keymap_name_to_scancode[] = {
+    {"ESC", 0x01},
+    {"AE01", 0x02 },
+    {"AE02", 0x03 },
+    {"AE03", 0x04 },
+    {"AE04", 0x05 },
+    {"AE05", 0x06 },
+    {"AE06", 0x07 },
+    {"AE07", 0x08 },
+    {"AE08", 0x09 },
+    {"AE09", 0x0a },
+    {"AE10", 0x0b },
+    {"AE11", 0x0c },
+    {"AE12", 0x0d },
+    {"BKSP", 0x0e },
+    {"TAB", 0x0f },
+    {"AD01", 0x10 },
+    {"AD02", 0x11 },
+    {"AD03", 0x12 },
+    {"AD04", 0x13 },
+    {"AD05", 0x14 },
+    {"AD06", 0x15 },
+    {"AD07", 0x16 },
+    {"AD08", 0x17 },
+    {"AD09", 0x18 },
+    {"AD10", 0x19 },
+    {"AD11", 0x1a },
+    {"AD12", 0x1b },
+    {"RTRN", 0x1c },
+    {"LCTL", 0x1d },
+    {"AC01", 0x1e },
+    {"AC02", 0x1f },
+    {"AC03", 0x20 },
+    {"AC04", 0x21 },
+    {"AC05", 0x22 },
+    {"AC06", 0x23 },
+    {"AC07", 0x24 },
+    {"AC08", 0x25 },
+    {"AC09", 0x26 },
+    {"AC10", 0x27 },
+    {"AC11", 0x28 },
+    {"TLDE", 0x29 },
+    {"LFSH", 0x2a },
+    {"BKSL", 0x2b },
+    {"AB01", 0x2c },
+    {"AB02", 0x2d },
+    {"AB03", 0x2e },
+    {"AB04", 0x2f },
+    {"AB05", 0x30 },
+    {"AB06", 0x31 },
+    {"AB07", 0x32 },
+    {"AB08", 0x33 },
+    {"AB09", 0x34 },
+    {"AB10", 0x35 },
+    {"RTSH", 0x36 },
+    {"KPMU", 0x37 },
+    {"LALT", 0x38 },
+    {"SPCE", 0x39 },
+    {"CAPS", 0x3a },
+    {"FK01", 0x3b },
+    {"FK02", 0x3c },
+    {"FK03", 0x3d },
+    {"FK04", 0x3e },
+    {"FK05", 0x3f },
+    {"FK06", 0x40 },
+    {"FK07", 0x41 },
+    {"FK08", 0x42 },
+    {"FK09", 0x43 },
+    {"FK10", 0x44 },
+    {"NMLK", 0x45 },
+    {"SCLK", 0x46 },
+    {"KP7", 0x47 },
+    {"KP8", 0x48 },
+    {"KP9", 0x49 },
+    {"KPSU", 0x4a },
+    {"KP4", 0x4b },
+    {"KP5", 0x4c },
+    {"KP6", 0x4d },
+    {"KPAD", 0x4e },
+    {"KP1", 0x4f },
+    {"KP2", 0x50 },
+    {"KP3", 0x51 },
+    {"KP0", 0x52 },
+    {"KPDL", 0x53 },
+    {"LVL3", 0x54 }, // correct?
+    {"", 0x55 }, // not mapped?
+    {"LSGT", 0x56 },
+    {"FK11", 0x57 },
+    {"FK12", 0x58 },
+    {"AB11", 0x59 },
+    {"KATA", 0 },
+    {"HIRA", 0 },
+    {"HENK", 0 },
+    {"HKTG", 0 },
+    {"MUHE", 0 },
+    {"JPCM", 0 },
+    {"KPEN", 0x11c },
+    {"RCTL", 0x11d },
+    {"KPDV", 0x135 },
+    {"PRSC", 0x54 }, // ?
+    {"RALT", 0x138 },
+    {"LNFD", 0 },
+    {"HOME", 0x147 },
+    {"UP", 0x148 },
+    {"PGUP", 0x149 },
+    {"LEFT", 0x14b },
+    {"RGHT", 0x14d },
+    {"END", 0x14f },
+    {"DOWN", 0x150 },
+    {"PGDN", 0x151 },
+    {"INS", 0x152 },
+    {"DELE", 0x153 },
+    {"PAUS", 0x21d },
+    {"LWIN", 0x15b },
+    {"RWIN", 0x15c },
+    {"COMP", 0x15d },
+};
+
+static struct {
+    Display *dpy;
+    Window root;
+    Window win;
+    
+    Atom atom_wm_state;
+    Atom atom_wm_state_fullscreen;
+    
+    bool is_fullscreen;
+    
+    int keymap[256];
+    
+    uint64_t ust0;
+    int64_t last_msc;
+    uint64_t wanted_ust; // multiplied by 3
+    uint64_t vsync_interval;
+    uint64_t last_ust;
+    int64_t target_msc;
+    bool dropped_frame;
+} glx;
+
+static void init_keymap(void) {
+    XkbDescPtr desc = XkbGetMap(glx.dpy, 0, XkbUseCoreKbd);
+    XkbGetNames(glx.dpy, XkbKeyNamesMask, desc);
+    
+    for (int i = desc->min_key_code; i <= desc->max_key_code && i < 256; i++) {
+        char name[XkbKeyNameLength + 1];
+        memcpy(name, desc->names->keys[i].name, XkbKeyNameLength);
+        name[XkbKeyNameLength] = '\0';
+        for (size_t j = 0; j < sizeof(keymap_name_to_scancode) / sizeof(keymap_name_to_scancode[0]); j++) {
+            if (strcmp(keymap_name_to_scancode[j].name, name) == 0) {
+                glx.keymap[i] = keymap_name_to_scancode[j].scancode;
+                break;
+            }
+        }
+    }
+    
+    XkbFreeNames(desc, XkbKeyNamesMask, True);
+    XkbFreeKeyboard(desc, 0, True);
+}
+
+static void gfx_glx_set_fullscreen(bool on);
+
+static void gfx_glx_init(void) {
+    glx.dpy = XOpenDisplay(NULL);
+    if (glx.dpy == NULL) {
+        fprintf(stderr, "Cannot connect to X server\n");
+        exit(1);
+    }
+    glx.root = DefaultRootWindow(glx.dpy);
+    
+    GLint att[] = { GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_DOUBLEBUFFER, None };
+    XVisualInfo *vi = glXChooseVisual(glx.dpy, 0, att);
+    if (vi == NULL) {
+        fprintf(stderr, "No appropriate GLX visual found\n");
+        exit(1);
+    }
+    Colormap cmap = XCreateColormap(glx.dpy, glx.root, vi->visual, AllocNone);
+    XSetWindowAttributes swa;
+    swa.colormap = cmap;
+    swa.event_mask = ExposureMask | KeyPressMask | KeyReleaseMask | FocusChangeMask;
+    glx.win = XCreateWindow(glx.dpy, glx.root, 0, 0, DESIRED_SCREEN_WIDTH, DESIRED_SCREEN_HEIGHT, 0, vi->depth, InputOutput, vi->visual, CWColormap | CWEventMask, &swa);
+    
+    glx.atom_wm_state = XInternAtom(glx.dpy, "_NET_WM_STATE", False);
+    glx.atom_wm_state_fullscreen = XInternAtom(glx.dpy, "_NET_WM_STATE_FULLSCREEN", False);
+    XMapWindow(glx.dpy, glx.win);
+
+    if (configFullscreen)
+ gfx_glx_set_fullscreen(true);
+
+    XStoreName(glx.dpy, glx.win, "Super Mario 64 PC-port GLX");
+    GLXContext glc = glXCreateContext(glx.dpy, vi, NULL, GL_TRUE);
+    glXMakeCurrent(glx.dpy, glx.win, glc);
+    
+    init_keymap();
+    
+    int64_t ust, msc, sbc;
+    glXGetSyncValuesOML(glx.dpy, glx.win, &ust, &msc, &sbc);
+    glx.ust0 = (uint64_t)ust;
+    glx.vsync_interval = 16666;
+}
+
+static void gfx_glx_main_loop(void (*run_one_game_iter)(void)) {
+    while (1) {
+        run_one_game_iter();
+    }
+}
+
+static void gfx_glx_get_dimensions(uint32_t *width, uint32_t *height) {
+    XWindowAttributes attributes;
+    XGetWindowAttributes(glx.dpy, glx.win, &attributes);
+    *width = attributes.width;
+    *height = attributes.height;
+}
+
+static void gfx_glx_set_fullscreen(bool on) {
+    XEvent xev;
+    configFullscreen = on;
+    xev.xany.type = ClientMessage;
+    xev.xclient.message_type = glx.atom_wm_state;
+    xev.xclient.format = 32;
+    xev.xclient.window = glx.win;
+    xev.xclient.data.l[0] = on;
+    xev.xclient.data.l[1] = glx.atom_wm_state_fullscreen;
+    xev.xclient.data.l[2] = 0;
+    xev.xclient.data.l[3] = 0;
+    XSendEvent(glx.dpy, glx.root, 0, SubstructureNotifyMask | SubstructureRedirectMask, &xev);
+}
+
+static void gfx_glx_handle_events(void) {
+    while (XPending(glx.dpy)) {
+        XEvent xev;
+        XNextEvent(glx.dpy, &xev);
+        if (xev.type == FocusOut) {
+            keyboard_on_all_keys_up();
+        }
+        if (xev.type == KeyPress || xev.type == KeyRelease) {
+            if (xev.xkey.keycode < 256) {
+                int scancode = glx.keymap[xev.xkey.keycode];
+                if (scancode != 0) {
+                    if (xev.type == KeyPress) {
+                        if (scancode == 0x44) { // F10
+                            glx.is_fullscreen = !glx.is_fullscreen;
+                            gfx_glx_set_fullscreen(glx.is_fullscreen);
+                        }
+                        keyboard_on_key_down(scancode);
+                    } else {
+                        keyboard_on_key_up(scancode);
+                    }
+                }
+            }
+        }
+    }
+}
+
+static bool gfx_glx_start_frame(void) {
+    return true;
+}
+
+static void gfx_glx_swap_buffers_begin(void) {
+    glx.wanted_ust += 100000; // advance 1/30 second
+    
+    double vsyncs_to_wait = (int64_t)(glx.wanted_ust / 3 - glx.last_ust) / (double)glx.vsync_interval;
+    if (vsyncs_to_wait <= 0) {
+        printf("Dropping frame\n");
+        // Drop frame
+        glx.dropped_frame = true;
+        return;
+    }
+    if (floor(vsyncs_to_wait) != vsyncs_to_wait) {
+        uint64_t left_ust = glx.last_ust + floor(vsyncs_to_wait) * glx.vsync_interval;
+        uint64_t right_ust = glx.last_ust + ceil(vsyncs_to_wait) * glx.vsync_interval;
+        uint64_t adjusted_wanted_ust = glx.wanted_ust / 3 + (glx.last_ust + 33333 > glx.wanted_ust / 3 ? 2000 : -2000);
+        int64_t diff_left = adjusted_wanted_ust - left_ust;
+        int64_t diff_right = right_ust - adjusted_wanted_ust;
+        if (diff_left < 0) {
+            diff_left = -diff_left;
+        }
+        if (diff_right < 0) {
+            diff_right = -diff_right;
+        }
+        if (diff_left < diff_right) {
+            vsyncs_to_wait = floor(vsyncs_to_wait);
+        } else {
+            vsyncs_to_wait = ceil(vsyncs_to_wait);
+        }
+        if (vsyncs_to_wait == 0) {
+            printf("vsyncs_to_wait became 0 so dropping frame\n");
+            glx.dropped_frame = true;
+            return;
+        }
+    }
+    glx.dropped_frame = false;
+    //printf("Vsyncs to wait: %d, diff: %d\n", (int)vsyncs_to_wait, (int)(glx.last_ust + (int64_t)vsyncs_to_wait * glx.vsync_interval - glx.wanted_ust / 3));
+    if (vsyncs_to_wait > 30) {
+        // Unreasonable, so change to 2
+        vsyncs_to_wait = 2;
+    }
+    glx.target_msc = glx.last_msc + vsyncs_to_wait;
+    
+    glXSwapBuffersMscOML(glx.dpy, glx.win, glx.target_msc, 0, 0);
+}
+
+static void gfx_glx_swap_buffers_end(void) {
+    if (glx.dropped_frame) {
+        return;
+    }
+    
+    int64_t ust, msc, sbc;
+    if (!glXWaitForSbcOML(glx.dpy, glx.win, 0, &ust, &msc, &sbc)) {
+        // X connection broke or something?
+        glx.last_ust += (glx.target_msc - glx.last_msc) * glx.vsync_interval;
+        glx.last_msc = glx.target_msc;
+        return;
+    }
+    uint64_t this_ust = ust - glx.ust0;
+    uint64_t vsyncs_passed = msc - glx.last_msc;
+    if (glx.last_ust != 0 && vsyncs_passed != 0) {
+        glx.vsync_interval = (this_ust - glx.last_ust) / vsyncs_passed;
+        //printf("glx.vsync_interval: %d\n", (int)glx.vsync_interval);
+    }
+    glx.last_ust = this_ust;
+    glx.last_msc = msc;
+    if (msc != glx.target_msc) {
+        printf("Frame too late by %d vsyncs\n", (int)(msc - glx.target_msc));
+    }
+    if (msc - glx.target_msc >= 2) {
+        // Frame arrived way too late, so reset timer from here
+        printf("Reseting timer\n");
+        glx.wanted_ust = this_ust * 3;
+    }
+}
+
+static double gfx_glx_get_time(void) {
+    return 0.0;
+}
+
+struct GfxWindowManagerAPI gfx_glx = {
+    gfx_glx_init,
+    gfx_glx_main_loop,
+    gfx_glx_get_dimensions,
+    gfx_glx_handle_events,
+    gfx_glx_start_frame,
+    gfx_glx_swap_buffers_begin,
+    gfx_glx_swap_buffers_end,
+    gfx_glx_get_time
+};
+
+#endif
diff --git a/src/pc/gfx/gfx_glx.h b/src/pc/gfx/gfx_glx.h
new file mode 100644
index 0000000..fe78db9
--- /dev/null
+++ b/src/pc/gfx/gfx_glx.h
@@ -0,0 +1,8 @@
+#ifndef GFX_GLX_H
+#define GFX_GLX_H
+
+#include "gfx_window_manager_api.h"
+
+struct GfxWindowManagerAPI gfx_glx;
+
+#endif
diff --git a/src/pc/gfx/gfx_opengl.c b/src/pc/gfx/gfx_opengl.c
new file mode 100644
index 0000000..c0aa22b
--- /dev/null
+++ b/src/pc/gfx/gfx_opengl.c
@@ -0,0 +1,506 @@
+#if !defined(_WIN32) && !defined(_WIN64)
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#ifndef _LANGUAGE_C
+#define _LANGUAGE_C
+#endif
+#include <PR/gbi.h>
+
+#ifdef __MINGW32__
+#define FOR_WINDOWS 1
+#else
+#define FOR_WINDOWS 0
+#endif
+
+#if FOR_WINDOWS
+#include <GL/glew.h>
+#include "SDL.h"
+#define GL_GLEXT_PROTOTYPES 1
+#include "SDL_opengl.h"
+#else
+#include <SDL2/SDL.h>
+#define GL_GLEXT_PROTOTYPES 1
+#include <SDL2/SDL_opengles2.h>
+#endif
+
+#include "gfx_cc.h"
+#include "gfx_rendering_api.h"
+
+struct ShaderProgram {
+    uint32_t shader_id;
+    GLuint opengl_program_id;
+    uint8_t num_inputs;
+    bool used_textures[2];
+    uint8_t num_floats;
+    GLint attrib_locations[7];
+    uint8_t attrib_sizes[7];
+    uint8_t num_attribs;
+};
+
+static struct ShaderProgram shader_program_pool[64];
+static uint8_t shader_program_pool_size;
+static GLuint opengl_vbo;
+
+static bool gfx_opengl_z_is_from_0_to_1(void) {
+    return false;
+}
+
+static void gfx_opengl_vertex_array_set_attribs(struct ShaderProgram *prg) {
+    size_t num_floats = prg->num_floats;
+    size_t pos = 0;
+    
+    for (int i = 0; i < prg->num_attribs; i++) {
+        glEnableVertexAttribArray(prg->attrib_locations[i]);
+        glVertexAttribPointer(prg->attrib_locations[i], prg->attrib_sizes[i], GL_FLOAT, GL_FALSE, num_floats * sizeof(float), (void *)(pos * sizeof(float)));
+        pos += prg->attrib_sizes[i];
+    }
+}
+
+static void gfx_opengl_unload_shader(struct ShaderProgram *old_prg) {
+    if (old_prg != NULL) {
+        for (int i = 0; i < old_prg->num_attribs; i++) {
+            glDisableVertexAttribArray(old_prg->attrib_locations[i]);
+        }
+    }
+}
+
+static void gfx_opengl_load_shader(struct ShaderProgram *new_prg) {
+    glUseProgram(new_prg->opengl_program_id);
+    gfx_opengl_vertex_array_set_attribs(new_prg);
+}
+
+static void append_str(char *buf, size_t *len, const char *str) {
+    while (*str != '\0') buf[(*len)++] = *str++;
+}
+
+static void append_line(char *buf, size_t *len, const char *str) {
+    while (*str != '\0') buf[(*len)++] = *str++;
+    buf[(*len)++] = '\n';
+}
+
+static const char *shader_item_to_str(uint32_t item, bool with_alpha, bool only_alpha, bool inputs_have_alpha, bool hint_single_element) {
+    if (!only_alpha) {
+        switch (item) {
+            case SHADER_0:
+                return with_alpha ? "vec4(0.0, 0.0, 0.0, 0.0)" : "vec3(0.0, 0.0, 0.0)";
+            case SHADER_INPUT_1:
+                return with_alpha || !inputs_have_alpha ? "vInput1" : "vInput1.rgb";
+            case SHADER_INPUT_2:
+                return with_alpha || !inputs_have_alpha ? "vInput2" : "vInput2.rgb";
+            case SHADER_INPUT_3:
+                return with_alpha || !inputs_have_alpha ? "vInput3" : "vInput3.rgb";
+            case SHADER_INPUT_4:
+                return with_alpha || !inputs_have_alpha ? "vInput4" : "vInput4.rgb";
+            case SHADER_TEXEL0:
+                return with_alpha ? "texVal0" : "texVal0.rgb";
+            case SHADER_TEXEL0A:
+                return hint_single_element ? "texVal0.a" :
+                    (with_alpha ? "vec4(texelVal0.a, texelVal0.a, texelVal0.a, texelVal0.a)" : "vec3(texelVal0.a, texelVal0.a, texelVal0.a)");
+            case SHADER_TEXEL1:
+                return with_alpha ? "texVal1" : "texVal1.rgb";
+        }
+    } else {
+        switch (item) {
+            case SHADER_0:
+                return "0.0";
+            case SHADER_INPUT_1:
+                return "vInput1.a";
+            case SHADER_INPUT_2:
+                return "vInput2.a";
+            case SHADER_INPUT_3:
+                return "vInput3.a";
+            case SHADER_INPUT_4:
+                return "vInput4.a";
+            case SHADER_TEXEL0:
+                return "texVal0.a";
+            case SHADER_TEXEL0A:
+                return "texVal0.a";
+            case SHADER_TEXEL1:
+                return "texVal1.a";
+        }
+    }
+}
+
+static void append_formula(char *buf, size_t *len, uint8_t c[2][4], bool do_single, bool do_multiply, bool do_mix, bool with_alpha, bool only_alpha, bool opt_alpha) {
+    if (do_single) {
+        append_str(buf, len, shader_item_to_str(c[only_alpha][3], with_alpha, only_alpha, opt_alpha, false));
+    } else if (do_multiply) {
+        append_str(buf, len, shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, " * ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, true));
+    } else if (do_mix) {
+        append_str(buf, len, "mix(");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][1], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, ", ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, ", ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, true));
+        append_str(buf, len, ")");
+    } else {
+        append_str(buf, len, "(");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][0], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, " - ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][1], with_alpha, only_alpha, opt_alpha, false));
+        append_str(buf, len, ") * ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][2], with_alpha, only_alpha, opt_alpha, true));
+        append_str(buf, len, " + ");
+        append_str(buf, len, shader_item_to_str(c[only_alpha][3], with_alpha, only_alpha, opt_alpha, false));
+    }
+}
+
+static struct ShaderProgram *gfx_opengl_create_and_load_new_shader(uint32_t shader_id) {
+    uint8_t c[2][4];
+    for (int i = 0; i < 4; i++) {
+        c[0][i] = (shader_id >> (i * 3)) & 7;
+        c[1][i] = (shader_id >> (12 + i * 3)) & 7;
+    }
+    bool opt_alpha = (shader_id & SHADER_OPT_ALPHA) != 0;
+    bool opt_fog = (shader_id & SHADER_OPT_FOG) != 0;
+    bool opt_texture_edge = (shader_id & SHADER_OPT_TEXTURE_EDGE) != 0;
+    bool used_textures[2] = {0, 0};
+    int num_inputs = 0;
+    for (int i = 0; i < 2; i++) {
+        for (int j = 0; j < 4; j++) {
+            if (c[i][j] >= SHADER_INPUT_1 && c[i][j] <= SHADER_INPUT_4) {
+                if (c[i][j] > num_inputs) {
+                    num_inputs = c[i][j];
+                }
+            }
+            if (c[i][j] == SHADER_TEXEL0 || c[i][j] == SHADER_TEXEL0A) {
+                used_textures[0] = true;
+            }
+            if (c[i][j] == SHADER_TEXEL1) {
+                used_textures[1] = true;
+            }
+        }
+    }
+    bool do_single[2] = {c[0][2] == 0, c[1][2] == 0};
+    bool do_multiply[2] = {c[0][1] == 0 && c[0][3] == 0, c[1][1] == 0 && c[1][3] == 0};
+    bool do_mix[2] = {c[0][1] == c[0][3], c[1][1] == c[1][3]};
+    bool color_alpha_same = (shader_id & 0xfff) == ((shader_id >> 12) & 0xfff);
+    
+    char vs_buf[1024];
+    char fs_buf[1024];
+    size_t vs_len = 0;
+    size_t fs_len = 0;
+    size_t num_floats = 4;
+    
+    // Vertex shader
+    append_line(vs_buf, &vs_len, "#version 100");
+    append_line(vs_buf, &vs_len, "attribute vec4 aVtxPos;");
+    if (used_textures[0] || used_textures[1]) {
+        append_line(vs_buf, &vs_len, "attribute vec2 aTexCoord;");
+        append_line(vs_buf, &vs_len, "varying vec2 vTexCoord;");
+        num_floats += 2;
+    }
+    if (opt_fog) {
+        append_line(vs_buf, &vs_len, "attribute vec4 aFog;");
+        append_line(vs_buf, &vs_len, "varying vec4 vFog;");
+        num_floats += 4;
+    }
+    for (int i = 0; i < num_inputs; i++) {
+        vs_len += sprintf(vs_buf + vs_len, "attribute vec%d aInput%d;\n", opt_alpha ? 4 : 3, i + 1);
+        vs_len += sprintf(vs_buf + vs_len, "varying vec%d vInput%d;\n", opt_alpha ? 4 : 3, i + 1);
+        num_floats += opt_alpha ? 4 : 3;
+    }
+    append_line(vs_buf, &vs_len, "void main() {");
+    if (used_textures[0] || used_textures[1]) {
+        append_line(vs_buf, &vs_len, "vTexCoord = aTexCoord;");
+    }
+    if (opt_fog) {
+        append_line(vs_buf, &vs_len, "vFog = aFog;");
+    }
+    for (int i = 0; i < num_inputs; i++) {
+        vs_len += sprintf(vs_buf + vs_len, "vInput%d = aInput%d;\n", i + 1, i + 1);
+    }
+    append_line(vs_buf, &vs_len, "gl_Position = aVtxPos;");
+    append_line(vs_buf, &vs_len, "}");
+    
+    // Fragment shader
+    append_line(fs_buf, &fs_len, "#version 100");
+    append_line(fs_buf, &fs_len, "precision mediump float;");
+    if (used_textures[0] || used_textures[1]) {
+        append_line(fs_buf, &fs_len, "varying vec2 vTexCoord;");
+    }
+    if (opt_fog) {
+        append_line(fs_buf, &fs_len, "varying vec4 vFog;");
+    }
+    for (int i = 0; i < num_inputs; i++) {
+        fs_len += sprintf(fs_buf + fs_len, "varying vec%d vInput%d;\n", opt_alpha ? 4 : 3, i + 1);
+    }
+    if (used_textures[0]) {
+        append_line(fs_buf, &fs_len, "uniform sampler2D uTex0;");
+    }
+    if (used_textures[1]) {
+        append_line(fs_buf, &fs_len, "uniform sampler2D uTex1;");
+    }
+    append_line(fs_buf, &fs_len, "void main() {");
+    
+    if (used_textures[0]) {
+        append_line(fs_buf, &fs_len, "vec4 texVal0 = texture2D(uTex0, vTexCoord);");
+    }
+    if (used_textures[1]) {
+        append_line(fs_buf, &fs_len, "vec4 texVal1 = texture2D(uTex1, vTexCoord);");
+    }
+    
+    append_str(fs_buf, &fs_len, opt_alpha ? "vec4 texel = " : "vec3 texel = ");
+    if (!color_alpha_same && opt_alpha) {
+        append_str(fs_buf, &fs_len, "vec4(");
+        append_formula(fs_buf, &fs_len, c, do_single[0], do_multiply[0], do_mix[0], false, false, true);
+        append_str(fs_buf, &fs_len, ", ");
+        append_formula(fs_buf, &fs_len, c, do_single[1], do_multiply[1], do_mix[1], true, true, true);
+        append_str(fs_buf, &fs_len, ")");
+    } else {
+        append_formula(fs_buf, &fs_len, c, do_single[0], do_multiply[0], do_mix[0], opt_alpha, false, opt_alpha);
+    }
+    append_line(fs_buf, &fs_len, ";");
+    
+    if (opt_texture_edge && opt_alpha) {
+        append_line(fs_buf, &fs_len, "if (texel.a > 0.3) texel.a = 1.0; else discard;");
+    }
+    // TODO discard if alpha is 0?
+    if (opt_fog) {
+        if (opt_alpha) {
+            append_line(fs_buf, &fs_len, "texel = vec4(mix(texel.rgb, vFog.rgb, vFog.a), texel.a);");
+        } else {
+            append_line(fs_buf, &fs_len, "texel = mix(texel, vFog.rgb, vFog.a);");
+        }
+    }
+    
+    if (opt_alpha) {
+        append_line(fs_buf, &fs_len, "gl_FragColor = texel;");
+    } else {
+        append_line(fs_buf, &fs_len, "gl_FragColor = vec4(texel, 1.0);");
+    }
+    append_line(fs_buf, &fs_len, "}");
+    
+    vs_buf[vs_len] = '\0';
+    fs_buf[fs_len] = '\0';
+    
+    /*puts("Vertex shader:");
+    puts(vs_buf);
+    puts("Fragment shader:");
+    puts(fs_buf);
+    puts("End");*/
+    
+    const GLchar *sources[2] = {vs_buf, fs_buf};
+    const GLint lengths[2] = {vs_len, fs_len};
+    GLint success;
+    
+    GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
+    glShaderSource(vertex_shader, 1, &sources[0], &lengths[0]);
+    glCompileShader(vertex_shader);
+    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);
+    if (!success) {
+        GLint max_length = 0;
+        glGetShaderiv(vertex_shader, GL_INFO_LOG_LENGTH, &max_length);
+        char error_log[1024];
+        fprintf(stderr, "Vertex shader compilation failed\n");
+        glGetShaderInfoLog(vertex_shader, max_length, &max_length, &error_log[0]);
+        fprintf(stderr, "%s\n", &error_log[0]);
+        abort();
+    }
+    
+    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
+    glShaderSource(fragment_shader, 1, &sources[1], &lengths[1]);
+    glCompileShader(fragment_shader);
+    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);
+    if (!success) {
+        GLint max_length = 0;
+        glGetShaderiv(fragment_shader, GL_INFO_LOG_LENGTH, &max_length);
+        char error_log[1024];
+        fprintf(stderr, "Fragment shader compilation failed\n");
+        glGetShaderInfoLog(fragment_shader, max_length, &max_length, &error_log[0]);
+        fprintf(stderr, "%s\n", &error_log[0]);
+        abort();
+    }
+    
+    GLuint shader_program = glCreateProgram();
+    glAttachShader(shader_program, vertex_shader);
+    glAttachShader(shader_program, fragment_shader);
+    glLinkProgram(shader_program);
+    
+    size_t cnt = 0;
+    
+    struct ShaderProgram *prg = &shader_program_pool[shader_program_pool_size++];
+    prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, "aVtxPos");
+    prg->attrib_sizes[cnt] = 4;
+    ++cnt;
+    
+    if (used_textures[0] || used_textures[1]) {
+        prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, "aTexCoord");
+        prg->attrib_sizes[cnt] = 2;
+        ++cnt;
+    }
+    
+    if (opt_fog) {
+        prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, "aFog");
+        prg->attrib_sizes[cnt] = 4;
+        ++cnt;
+    }
+    
+    for (int i = 0; i < num_inputs; i++) {
+        char name[16];
+        sprintf(name, "aInput%d", i + 1);
+        prg->attrib_locations[cnt] = glGetAttribLocation(shader_program, name);
+        prg->attrib_sizes[cnt] = opt_alpha ? 4 : 3;
+        ++cnt;
+    }
+    
+    prg->shader_id = shader_id;
+    prg->opengl_program_id = shader_program;
+    prg->num_inputs = num_inputs;
+    prg->used_textures[0] = used_textures[0];
+    prg->used_textures[1] = used_textures[1];
+    prg->num_floats = num_floats;
+    prg->num_attribs = cnt;
+    
+    gfx_opengl_load_shader(prg);
+    
+    if (used_textures[0]) {
+        GLint sampler_attrib = glGetUniformLocation(shader_program, "uTex0");
+        glUniform1i(sampler_attrib, 0);
+    }
+    if (used_textures[1]) {
+        GLint sampler_attrib = glGetUniformLocation(shader_program, "uTex1");
+        glUniform1i(sampler_attrib, 1);
+    }
+    
+    return prg;
+}
+
+static struct ShaderProgram *gfx_opengl_lookup_shader(uint32_t shader_id) {
+    for (size_t i = 0; i < shader_program_pool_size; i++) {
+        if (shader_program_pool[i].shader_id == shader_id) {
+            return &shader_program_pool[i];
+        }
+    }
+    return NULL;
+}
+
+static void gfx_opengl_shader_get_info(struct ShaderProgram *prg, uint8_t *num_inputs, bool used_textures[2]) {
+    *num_inputs = prg->num_inputs;
+    used_textures[0] = prg->used_textures[0];
+    used_textures[1] = prg->used_textures[1];
+}
+
+static GLuint gfx_opengl_new_texture(void) {
+    GLuint ret;
+    glGenTextures(1, &ret);
+    return ret;
+}
+
+static void gfx_opengl_select_texture(int tile, GLuint texture_id) {
+    glActiveTexture(GL_TEXTURE0 + tile);
+    glBindTexture(GL_TEXTURE_2D, texture_id);
+}
+
+static void gfx_opengl_upload_texture(uint8_t *rgba32_buf, int width, int height) {
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, rgba32_buf);
+}
+
+static uint32_t gfx_cm_to_opengl(uint32_t val) {
+    if (val & G_TX_CLAMP) {
+        return GL_CLAMP_TO_EDGE;
+    }
+    return (val & G_TX_MIRROR) ? GL_MIRRORED_REPEAT : GL_REPEAT;
+}
+
+static void gfx_opengl_set_sampler_parameters(int tile, bool linear_filter, uint32_t cms, uint32_t cmt) {
+    glActiveTexture(GL_TEXTURE0 + tile);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, linear_filter ? GL_LINEAR : GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, linear_filter ? GL_LINEAR : GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, gfx_cm_to_opengl(cms));
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, gfx_cm_to_opengl(cmt));
+}
+
+static void gfx_opengl_set_depth_test(bool depth_test) {
+    if (depth_test) {
+        glEnable(GL_DEPTH_TEST);
+    } else {
+        glDisable(GL_DEPTH_TEST);
+    }
+}
+
+static void gfx_opengl_set_depth_mask(bool z_upd) {
+    glDepthMask(z_upd ? GL_TRUE : GL_FALSE);
+}
+
+static void gfx_opengl_set_zmode_decal(bool zmode_decal) {
+    if (zmode_decal) {
+        glPolygonOffset(-2, -2);
+        glEnable(GL_POLYGON_OFFSET_FILL);
+    } else {
+        glPolygonOffset(0, 0);
+        glDisable(GL_POLYGON_OFFSET_FILL);
+    }
+}
+
+static void gfx_opengl_set_viewport(int x, int y, int width, int height) {
+    glViewport(x, y, width, height);
+}
+
+static void gfx_opengl_set_scissor(int x, int y, int width, int height) {
+    glScissor(x, y, width, height);
+}
+
+static void gfx_opengl_set_use_alpha(bool use_alpha) {
+    if (use_alpha) {
+        glEnable(GL_BLEND);
+    } else {
+        glDisable(GL_BLEND);
+    }
+}
+
+static void gfx_opengl_draw_triangles(float buf_vbo[], size_t buf_vbo_len, size_t buf_vbo_num_tris) {
+    //printf("flushing %d tris\n", buf_vbo_num_tris);
+    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * buf_vbo_len, buf_vbo, GL_STREAM_DRAW);
+    glDrawArrays(GL_TRIANGLES, 0, 3 * buf_vbo_num_tris);
+}
+
+static void gfx_opengl_init(void) {
+#if FOR_WINDOWS
+    glewInit();
+#endif
+    
+    glGenBuffers(1, &opengl_vbo);
+    
+    glBindBuffer(GL_ARRAY_BUFFER, opengl_vbo);
+    
+    glDepthFunc(GL_LEQUAL);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+}
+
+static void gfx_opengl_start_frame(void) {
+    glDisable(GL_SCISSOR_TEST);
+    glDepthMask(GL_TRUE); // Must be set to clear Z-buffer
+    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    glEnable(GL_SCISSOR_TEST);
+}
+
+struct GfxRenderingAPI gfx_opengl_api = {
+    gfx_opengl_z_is_from_0_to_1,
+    gfx_opengl_unload_shader,
+    gfx_opengl_load_shader,
+    gfx_opengl_create_and_load_new_shader,
+    gfx_opengl_lookup_shader,
+    gfx_opengl_shader_get_info,
+    gfx_opengl_new_texture,
+    gfx_opengl_select_texture,
+    gfx_opengl_upload_texture,
+    gfx_opengl_set_sampler_parameters,
+    gfx_opengl_set_depth_test,
+    gfx_opengl_set_depth_mask,
+    gfx_opengl_set_zmode_decal,
+    gfx_opengl_set_viewport,
+    gfx_opengl_set_scissor,
+    gfx_opengl_set_use_alpha,
+    gfx_opengl_draw_triangles,
+    gfx_opengl_init,
+    gfx_opengl_start_frame
+};
+
+#endif
diff --git a/src/pc/gfx/gfx_opengl.h b/src/pc/gfx/gfx_opengl.h
new file mode 100644
index 0000000..95be897
--- /dev/null
+++ b/src/pc/gfx/gfx_opengl.h
@@ -0,0 +1,8 @@
+#ifndef GFX_OPENGL_H
+#define GFX_OPENGL_H
+
+#include "gfx_rendering_api.h"
+
+extern struct GfxRenderingAPI gfx_opengl_api;
+
+#endif
diff --git a/src/pc/gfx/gfx_pc.c b/src/pc/gfx/gfx_pc.c
new file mode 100644
index 0000000..d674a4d
--- /dev/null
+++ b/src/pc/gfx/gfx_pc.c
@@ -0,0 +1,1547 @@
+#include <math.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <assert.h>
+
+#ifndef _LANGUAGE_C
+#define _LANGUAGE_C
+#endif
+#include <PR/gbi.h>
+
+#include "config.h"
+
+#include "gfx_pc.h"
+#include "gfx_cc.h"
+#include "gfx_window_manager_api.h"
+#include "gfx_rendering_api.h"
+#include "gfx_screen_config.h"
+
+#define SUPPORT_CHECK(x) assert(x)
+
+// SCALE_M_N: upscale/downscale M-bit integer to N-bit
+#define SCALE_5_8(VAL_) (((VAL_) * 0xFF) / 0x1F)
+#define SCALE_8_5(VAL_) ((((VAL_) + 4) * 0x1F) / 0xFF)
+#define SCALE_4_8(VAL_) ((VAL_) * 0x11)
+#define SCALE_8_4(VAL_) ((VAL_) / 0x11)
+#define SCALE_3_8(VAL_) ((VAL_) * 0x24)
+#define SCALE_8_3(VAL_) ((VAL_) / 0x24)
+
+#define HALF_SCREEN_WIDTH (SCREEN_WIDTH / 2)
+#define HALF_SCREEN_HEIGHT (SCREEN_HEIGHT / 2)
+
+#define RATIO_X (gfx_current_dimensions.width / (2.0f * HALF_SCREEN_WIDTH))
+#define RATIO_Y (gfx_current_dimensions.height / (2.0f * HALF_SCREEN_HEIGHT))
+
+#define MAX_BUFFERED 256
+#define MAX_LIGHTS 2
+#define MAX_VERTICES 64
+
+struct RGBA {
+    uint8_t r, g, b, a;
+};
+
+struct XYWidthHeight {
+    uint16_t x, y, width, height;
+};
+
+struct LoadedVertex {
+    float x, y, z, w;
+    float u, v;
+    struct RGBA color;
+    uint8_t clip_rej;
+};
+
+struct TextureHashmapNode {
+    struct TextureHashmapNode *next;
+    
+    const uint8_t *texture_addr;
+    uint8_t fmt, siz;
+    
+    uint32_t texture_id;
+    uint8_t cms, cmt;
+    bool linear_filter;
+};
+static struct {
+    struct TextureHashmapNode *hashmap[1024];
+    struct TextureHashmapNode pool[512];
+    uint32_t pool_pos;
+} gfx_texture_cache;
+
+struct ColorCombiner {
+    uint32_t cc_id;
+    struct ShaderProgram *prg;
+    uint8_t shader_input_mapping[2][4];
+};
+
+static struct ColorCombiner color_combiner_pool[64];
+static uint8_t color_combiner_pool_size;
+
+static struct RSP {
+    float modelview_matrix_stack[11][4][4];
+    uint8_t modelview_matrix_stack_size;
+    
+    float MP_matrix[4][4];
+    float P_matrix[4][4];
+    
+    Light_t current_lights[MAX_LIGHTS + 1];
+    float current_lights_coeffs[MAX_LIGHTS][3];
+    float current_lookat_coeffs[2][3]; // lookat_x, lookat_y
+    uint8_t current_num_lights; // includes ambient light
+    bool lights_changed;
+    
+    uint32_t geometry_mode;
+    int16_t fog_mul, fog_offset;
+    
+    struct {
+        // U0.16
+        uint16_t s, t;
+    } texture_scaling_factor;
+    
+    struct LoadedVertex loaded_vertices[MAX_VERTICES + 4];
+} rsp;
+
+static struct RDP {
+    const uint8_t *palette;
+    struct {
+        const uint8_t *addr;
+        uint8_t siz;
+        uint8_t tile_number;
+    } texture_to_load;
+    struct {
+        const uint8_t *addr;
+        uint32_t size_bytes;
+    } loaded_texture[2];
+    struct {
+        uint8_t fmt;
+        uint8_t siz;
+        uint8_t cms, cmt;
+        uint16_t uls, ult, lrs, lrt; // U10.2
+        uint32_t line_size_bytes;
+    } texture_tile;
+    bool textures_changed[2];
+    
+    uint32_t other_mode_l, other_mode_h;
+    uint32_t combine_mode;
+    
+    struct RGBA env_color, prim_color, fog_color, fill_color;
+    struct XYWidthHeight viewport, scissor;
+    bool viewport_or_scissor_changed;
+    void *z_buf_address;
+    void *color_image_address;
+} rdp;
+
+static struct RenderingState {
+    bool depth_test;
+    bool depth_mask;
+    bool decal_mode;
+    bool alpha_blend;
+    struct XYWidthHeight viewport, scissor;
+    struct ShaderProgram *shader_program;
+    struct TextureHashmapNode *textures[2];
+} rendering_state;
+
+struct GfxDimensions gfx_current_dimensions;
+
+static bool dropped_frame;
+
+static float buf_vbo[MAX_BUFFERED * (26 * 3)]; // 3 vertices in a triangle and 26 floats per vtx
+static size_t buf_vbo_len;
+static size_t buf_vbo_num_tris;
+
+static struct GfxWindowManagerAPI *gfx_wapi;
+static struct GfxRenderingAPI *gfx_rapi;
+
+#include <time.h>
+static unsigned long get_time(void) {
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    return (unsigned long)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
+}
+
+static void gfx_flush(void) {
+    if (buf_vbo_len > 0) {
+        int num = buf_vbo_num_tris;
+        unsigned long t0 = get_time();
+        gfx_rapi->draw_triangles(buf_vbo, buf_vbo_len, buf_vbo_num_tris);
+        buf_vbo_len = 0;
+        buf_vbo_num_tris = 0;
+        unsigned long t1 = get_time();
+        /*if (t1 - t0 > 1000) {
+            printf("f: %d %d\n", num, (int)(t1 - t0));
+        }*/
+    }
+}
+
+static struct ShaderProgram *gfx_lookup_or_create_shader_program(uint32_t shader_id) {
+    struct ShaderProgram *prg = gfx_rapi->lookup_shader(shader_id);
+    if (prg == NULL) {
+        gfx_rapi->unload_shader(rendering_state.shader_program);
+        prg = gfx_rapi->create_and_load_new_shader(shader_id);
+        rendering_state.shader_program = prg;
+    }
+    return prg;
+}
+
+static void gfx_generate_cc(struct ColorCombiner *comb, uint32_t cc_id) {
+    uint8_t c[2][4];
+    uint32_t shader_id = (cc_id >> 24) << 24;
+    uint8_t shader_input_mapping[2][4] = {{0}};
+    for (int i = 0; i < 4; i++) {
+        c[0][i] = (cc_id >> (i * 3)) & 7;
+        c[1][i] = (cc_id >> (12 + i * 3)) & 7;
+    }
+    for (int i = 0; i < 2; i++) {
+        if (c[i][0] == c[i][1] || c[i][2] == CC_0) {
+            c[i][0] = c[i][1] = c[i][2] = 0;
+        }
+        uint8_t input_number[8] = {0};
+        int next_input_number = SHADER_INPUT_1;
+        for (int j = 0; j < 4; j++) {
+            int val = 0;
+            switch (c[i][j]) {
+                case CC_0:
+                    break;
+                case CC_TEXEL0:
+                    val = SHADER_TEXEL0;
+                    break;
+                case CC_TEXEL1:
+                    val = SHADER_TEXEL1;
+                    break;
+                case CC_TEXEL0A:
+                    val = SHADER_TEXEL0A;
+                    break;
+                case CC_PRIM:
+                case CC_SHADE:
+                case CC_ENV:
+                case CC_LOD:
+                    if (input_number[c[i][j]] == 0) {
+                        shader_input_mapping[i][next_input_number - 1] = c[i][j];
+                        input_number[c[i][j]] = next_input_number++;
+                    }
+                    val = input_number[c[i][j]];
+                    break;
+            }
+            shader_id |= val << (i * 12 + j * 3);
+        }
+    }
+    comb->cc_id = cc_id;
+    comb->prg = gfx_lookup_or_create_shader_program(shader_id);
+    memcpy(comb->shader_input_mapping, shader_input_mapping, sizeof(shader_input_mapping));
+}
+
+static struct ColorCombiner *gfx_lookup_or_create_color_combiner(uint32_t cc_id) {
+    static struct ColorCombiner *prev_combiner;
+    if (prev_combiner != NULL && prev_combiner->cc_id == cc_id) {
+        return prev_combiner;
+    }
+    
+    for (size_t i = 0; i < color_combiner_pool_size; i++) {
+        if (color_combiner_pool[i].cc_id == cc_id) {
+            return prev_combiner = &color_combiner_pool[i];
+        }
+    }
+    gfx_flush();
+    struct ColorCombiner *comb = &color_combiner_pool[color_combiner_pool_size++];
+    gfx_generate_cc(comb, cc_id);
+    return prev_combiner = comb;
+}
+
+static bool gfx_texture_cache_lookup(int tile, struct TextureHashmapNode **n, const uint8_t *orig_addr, uint32_t fmt, uint32_t siz) {
+    size_t hash = (uintptr_t)orig_addr;
+    hash = (hash >> 5) & 0x3ff;
+    struct TextureHashmapNode **node = &gfx_texture_cache.hashmap[hash];
+    while (*node != NULL && *node - gfx_texture_cache.pool < gfx_texture_cache.pool_pos) {
+        if ((*node)->texture_addr == orig_addr && (*node)->fmt == fmt && (*node)->siz == siz) {
+            gfx_rapi->select_texture(tile, (*node)->texture_id);
+            *n = *node;
+            return true;
+        }
+        node = &(*node)->next;
+    }
+    if (gfx_texture_cache.pool_pos == sizeof(gfx_texture_cache.pool) / sizeof(struct TextureHashmapNode)) {
+        // Pool is full. We just invalidate everything and start over.
+        gfx_texture_cache.pool_pos = 0;
+        node = &gfx_texture_cache.hashmap[hash];
+        //puts("Clearing texture cache");
+    }
+    *node = &gfx_texture_cache.pool[gfx_texture_cache.pool_pos++];
+    if ((*node)->texture_addr == NULL) {
+        (*node)->texture_id = gfx_rapi->new_texture();
+    }
+    gfx_rapi->select_texture(tile, (*node)->texture_id);
+    gfx_rapi->set_sampler_parameters(tile, false, 0, 0);
+    (*node)->cms = 0;
+    (*node)->cmt = 0;
+    (*node)->linear_filter = false;
+    (*node)->next = NULL;
+    (*node)->texture_addr = orig_addr;
+    (*node)->fmt = fmt;
+    (*node)->siz = siz;
+    *n = *node;
+    return false;
+}
+
+static void import_texture_rgba16(int tile) {
+    uint8_t rgba32_buf[8192];
+    
+    for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes / 2; i++) {
+        uint16_t col16 = (rdp.loaded_texture[tile].addr[2 * i] << 8) | rdp.loaded_texture[tile].addr[2 * i + 1];
+        uint8_t a = col16 & 1;
+        uint8_t r = col16 >> 11;
+        uint8_t g = (col16 >> 6) & 0x1f;
+        uint8_t b = (col16 >> 1) & 0x1f;
+        rgba32_buf[4*i + 0] = SCALE_5_8(r);
+        rgba32_buf[4*i + 1] = SCALE_5_8(g);
+        rgba32_buf[4*i + 2] = SCALE_5_8(b);
+        rgba32_buf[4*i + 3] = a ? 255 : 0;
+    }
+    
+    uint32_t width = rdp.texture_tile.line_size_bytes / 2;
+    uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
+    
+    gfx_rapi->upload_texture(rgba32_buf, width, height);
+}
+
+static void import_texture_ia4(int tile) {
+    uint8_t rgba32_buf[32768];
+    
+    for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes * 2; i++) {
+        uint8_t byte = rdp.loaded_texture[tile].addr[i / 2];
+        uint8_t part = (byte >> (4 - (i % 2) * 4)) & 0xf;
+        uint8_t intensity = part >> 1;
+        uint8_t alpha = part & 1;
+        uint8_t r = intensity;
+        uint8_t g = intensity;
+        uint8_t b = intensity;
+        rgba32_buf[4*i + 0] = SCALE_3_8(r);
+        rgba32_buf[4*i + 1] = SCALE_3_8(g);
+        rgba32_buf[4*i + 2] = SCALE_3_8(b);
+        rgba32_buf[4*i + 3] = alpha ? 255 : 0;
+    }
+    
+    uint32_t width = rdp.texture_tile.line_size_bytes * 2;
+    uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
+    
+    gfx_rapi->upload_texture(rgba32_buf, width, height);
+}
+
+static void import_texture_ia8(int tile) {
+    uint8_t rgba32_buf[16384];
+    
+    for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes; i++) {
+        uint8_t intensity = rdp.loaded_texture[tile].addr[i] >> 4;
+        uint8_t alpha = rdp.loaded_texture[tile].addr[i] & 0xf;
+        uint8_t r = intensity;
+        uint8_t g = intensity;
+        uint8_t b = intensity;
+        rgba32_buf[4*i + 0] = SCALE_4_8(r);
+        rgba32_buf[4*i + 1] = SCALE_4_8(g);
+        rgba32_buf[4*i + 2] = SCALE_4_8(b);
+        rgba32_buf[4*i + 3] = SCALE_4_8(alpha);
+    }
+    
+    uint32_t width = rdp.texture_tile.line_size_bytes;
+    uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
+    
+    gfx_rapi->upload_texture(rgba32_buf, width, height);
+}
+
+static void import_texture_ia16(int tile) {
+    uint8_t rgba32_buf[8192];
+    
+    for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes / 2; i++) {
+        uint8_t intensity = rdp.loaded_texture[tile].addr[2 * i];
+        uint8_t alpha = rdp.loaded_texture[tile].addr[2 * i + 1];
+        uint8_t r = intensity;
+        uint8_t g = intensity;
+        uint8_t b = intensity;
+        rgba32_buf[4*i + 0] = r;
+        rgba32_buf[4*i + 1] = g;
+        rgba32_buf[4*i + 2] = b;
+        rgba32_buf[4*i + 3] = alpha;
+    }
+    
+    uint32_t width = rdp.texture_tile.line_size_bytes / 2;
+    uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
+    
+    gfx_rapi->upload_texture(rgba32_buf, width, height);
+}
+
+static void import_texture_ci4(int tile) {
+    uint8_t rgba32_buf[32768];
+    
+    for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes * 2; i++) {
+        uint8_t byte = rdp.loaded_texture[tile].addr[i / 2];
+        uint8_t idx = (byte >> (4 - (i % 2) * 4)) & 0xf;
+        uint16_t col16 = (rdp.palette[idx * 2] << 8) | rdp.palette[idx * 2 + 1]; // Big endian load
+        uint8_t a = col16 & 1;
+        uint8_t r = col16 >> 11;
+        uint8_t g = (col16 >> 6) & 0x1f;
+        uint8_t b = (col16 >> 1) & 0x1f;
+        rgba32_buf[4*i + 0] = SCALE_5_8(r);
+        rgba32_buf[4*i + 1] = SCALE_5_8(g);
+        rgba32_buf[4*i + 2] = SCALE_5_8(b);
+        rgba32_buf[4*i + 3] = a ? 255 : 0;
+    }
+    
+    uint32_t width = rdp.texture_tile.line_size_bytes * 2;
+    uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
+    
+    gfx_rapi->upload_texture(rgba32_buf, width, height);
+}
+
+static void import_texture_ci8(int tile) {
+    uint8_t rgba32_buf[16384];
+    
+    for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes; i++) {
+        uint8_t idx = rdp.loaded_texture[tile].addr[i];
+        uint16_t col16 = (rdp.palette[idx * 2] << 8) | rdp.palette[idx * 2 + 1]; // Big endian load
+        uint8_t a = col16 & 1;
+        uint8_t r = col16 >> 11;
+        uint8_t g = (col16 >> 6) & 0x1f;
+        uint8_t b = (col16 >> 1) & 0x1f;
+        rgba32_buf[4*i + 0] = SCALE_5_8(r);
+        rgba32_buf[4*i + 1] = SCALE_5_8(g);
+        rgba32_buf[4*i + 2] = SCALE_5_8(b);
+        rgba32_buf[4*i + 3] = a ? 255 : 0;
+    }
+    
+    uint32_t width = rdp.texture_tile.line_size_bytes;
+    uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
+    
+    gfx_rapi->upload_texture(rgba32_buf, width, height);
+}
+
+static void import_texture(int tile) {
+    uint8_t fmt = rdp.texture_tile.fmt;
+    uint8_t siz = rdp.texture_tile.siz;
+    
+    if (gfx_texture_cache_lookup(tile, &rendering_state.textures[tile], rdp.loaded_texture[tile].addr, fmt, siz)) {
+        return;
+    }
+    
+    int t0 = get_time();
+    if (fmt == G_IM_FMT_RGBA) {
+        if (siz == G_IM_SIZ_16b) {
+            import_texture_rgba16(tile);
+        } else {
+            abort();
+        }
+    } else if (fmt == G_IM_FMT_IA) {
+        if (siz == G_IM_SIZ_4b) {
+            import_texture_ia4(tile);
+        } else if (siz == G_IM_SIZ_8b) {
+            import_texture_ia8(tile);
+        } else if (siz == G_IM_SIZ_16b) {
+            import_texture_ia16(tile);
+        } else {
+            abort();
+        }
+    } else if (fmt == G_IM_FMT_CI) {
+        if (siz == G_IM_SIZ_4b) {
+            import_texture_ci4(tile);
+        } else if (siz == G_IM_SIZ_8b) {
+            import_texture_ci8(tile);
+        } else {
+            abort();
+        }
+    } else {
+        abort();
+    }
+    int t1 = get_time();
+    //printf("Time diff: %d\n", t1 - t0);
+}
+
+static void gfx_normalize_vector(float v[3]) {
+    float s = sqrtf(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
+    v[0] /= s;
+    v[1] /= s;
+    v[2] /= s;
+}
+
+static void gfx_transposed_matrix_mul(float res[3], const float a[3], const float b[4][4]) {
+    res[0] = a[0] * b[0][0] + a[1] * b[0][1] + a[2] * b[0][2];
+    res[1] = a[0] * b[1][0] + a[1] * b[1][1] + a[2] * b[1][2];
+    res[2] = a[0] * b[2][0] + a[1] * b[2][1] + a[2] * b[2][2];
+}
+
+static void calculate_normal_dir(const Light_t *light, float coeffs[3]) {
+    float light_dir[3] = {
+        light->dir[0] / 127.0f,
+        light->dir[1] / 127.0f,
+        light->dir[2] / 127.0f
+    };
+    gfx_transposed_matrix_mul(coeffs, light_dir, rsp.modelview_matrix_stack[rsp.modelview_matrix_stack_size - 1]);
+    gfx_normalize_vector(coeffs);
+}
+
+static void gfx_matrix_mul(float res[4][4], const float a[4][4], const float b[4][4]) {
+    float tmp[4][4];
+    for (int i = 0; i < 4; i++) {
+        for (int j = 0; j < 4; j++) {
+            tmp[i][j] = a[i][0] * b[0][j] +
+                        a[i][1] * b[1][j] +
+                        a[i][2] * b[2][j] +
+                        a[i][3] * b[3][j];
+        }
+    }
+    memcpy(res, tmp, sizeof(tmp));
+}
+
+static void gfx_sp_matrix(uint8_t parameters, const int32_t *addr) {
+    float matrix[4][4];
+#if 0
+    // Original code when fixed point matrices were used
+    for (int i = 0; i < 4; i++) {
+        for (int j = 0; j < 4; j += 2) {
+            int32_t int_part = addr[i * 2 + j / 2];
+            uint32_t frac_part = addr[8 + i * 2 + j / 2];
+            matrix[i][j] = (int32_t)((int_part & 0xffff0000) | (frac_part >> 16)) / 65536.0f;
+            matrix[i][j + 1] = (int32_t)((int_part << 16) | (frac_part & 0xffff)) / 65536.0f;
+        }
+    }
+#else
+    memcpy(matrix, addr, sizeof(matrix));
+#endif
+    
+    if (parameters & G_MTX_PROJECTION) {
+        if (parameters & G_MTX_LOAD) {
+            memcpy(rsp.P_matrix, matrix, sizeof(matrix));
+        } else {
+            gfx_matrix_mul(rsp.P_matrix, matrix, rsp.P_matrix);
+        }
+    } else { // G_MTX_MODELVIEW
+        if ((parameters & G_MTX_PUSH) && rsp.modelview_matrix_stack_size < 11) {
+            ++rsp.modelview_matrix_stack_size;
+            memcpy(rsp.modelview_matrix_stack[rsp.modelview_matrix_stack_size - 1], rsp.modelview_matrix_stack[rsp.modelview_matrix_stack_size - 2], sizeof(matrix));
+        }
+        if (parameters & G_MTX_LOAD) {
+            memcpy(rsp.modelview_matrix_stack[rsp.modelview_matrix_stack_size - 1], matrix, sizeof(matrix));
+        } else {
+            gfx_matrix_mul(rsp.modelview_matrix_stack[rsp.modelview_matrix_stack_size - 1], matrix, rsp.modelview_matrix_stack[rsp.modelview_matrix_stack_size - 1]);
+        }
+        rsp.lights_changed = 1;
+    }
+    gfx_matrix_mul(rsp.MP_matrix, rsp.modelview_matrix_stack[rsp.modelview_matrix_stack_size - 1], rsp.P_matrix);
+}
+
+static void gfx_sp_pop_matrix(uint32_t count) {
+    while (count--) {
+        if (rsp.modelview_matrix_stack_size > 0) {
+            --rsp.modelview_matrix_stack_size;
+            if (rsp.modelview_matrix_stack_size > 0) {
+                gfx_matrix_mul(rsp.MP_matrix, rsp.modelview_matrix_stack[rsp.modelview_matrix_stack_size - 1], rsp.P_matrix);
+            }
+        }
+    }
+}
+
+static float gfx_adjust_x_for_aspect_ratio(float x) {
+    return x * (4.0f / 3.0f) / ((float)gfx_current_dimensions.width / (float)gfx_current_dimensions.height);
+}
+
+static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const Vtx *vertices) {
+    for (size_t i = 0; i < n_vertices; i++, dest_index++) {
+        const Vtx_t *v = &vertices[i].v;
+        const Vtx_tn *vn = &vertices[i].n;
+        struct LoadedVertex *d = &rsp.loaded_vertices[dest_index];
+        
+        float x = v->ob[0] * rsp.MP_matrix[0][0] + v->ob[1] * rsp.MP_matrix[1][0] + v->ob[2] * rsp.MP_matrix[2][0] + rsp.MP_matrix[3][0];
+        float y = v->ob[0] * rsp.MP_matrix[0][1] + v->ob[1] * rsp.MP_matrix[1][1] + v->ob[2] * rsp.MP_matrix[2][1] + rsp.MP_matrix[3][1];
+        float z = v->ob[0] * rsp.MP_matrix[0][2] + v->ob[1] * rsp.MP_matrix[1][2] + v->ob[2] * rsp.MP_matrix[2][2] + rsp.MP_matrix[3][2];
+        float w = v->ob[0] * rsp.MP_matrix[0][3] + v->ob[1] * rsp.MP_matrix[1][3] + v->ob[2] * rsp.MP_matrix[2][3] + rsp.MP_matrix[3][3];
+        
+        x = gfx_adjust_x_for_aspect_ratio(x);
+        
+        short U = v->tc[0] * rsp.texture_scaling_factor.s >> 16;
+        short V = v->tc[1] * rsp.texture_scaling_factor.t >> 16;
+        
+        if (rsp.geometry_mode & G_LIGHTING) {
+            if (rsp.lights_changed) {
+                for (int i = 0; i < rsp.current_num_lights - 1; i++) {
+                    calculate_normal_dir(&rsp.current_lights[i], rsp.current_lights_coeffs[i]);
+                }
+                static const Light_t lookat_x = {{0, 0, 0}, 0, {0, 0, 0}, 0, {127, 0, 0}, 0};
+                static const Light_t lookat_y = {{0, 0, 0}, 0, {0, 0, 0}, 0, {0, 127, 0}, 0};
+                calculate_normal_dir(&lookat_x, rsp.current_lookat_coeffs[0]);
+                calculate_normal_dir(&lookat_y, rsp.current_lookat_coeffs[1]);
+                rsp.lights_changed = false;
+            }
+            
+            int r = rsp.current_lights[rsp.current_num_lights - 1].col[0];
+            int g = rsp.current_lights[rsp.current_num_lights - 1].col[1];
+            int b = rsp.current_lights[rsp.current_num_lights - 1].col[2];
+            
+            for (int i = 0; i < rsp.current_num_lights - 1; i++) {
+                float intensity = 0;
+                intensity += vn->n[0] * rsp.current_lights_coeffs[i][0];
+                intensity += vn->n[1] * rsp.current_lights_coeffs[i][1];
+                intensity += vn->n[2] * rsp.current_lights_coeffs[i][2];
+                intensity /= 127.0f;
+                if (intensity > 0.0f) {
+                    r += intensity * rsp.current_lights[i].col[0];
+                    g += intensity * rsp.current_lights[i].col[1];
+                    b += intensity * rsp.current_lights[i].col[2];
+                }
+            }
+            
+            d->color.r = r > 255 ? 255 : r;
+            d->color.g = g > 255 ? 255 : g;
+            d->color.b = b > 255 ? 255 : b;
+            
+            if (rsp.geometry_mode & G_TEXTURE_GEN) {
+                float dotx = 0, doty = 0;
+                dotx += vn->n[0] * rsp.current_lookat_coeffs[0][0];
+                dotx += vn->n[1] * rsp.current_lookat_coeffs[0][1];
+                dotx += vn->n[2] * rsp.current_lookat_coeffs[0][2];
+                doty += vn->n[0] * rsp.current_lookat_coeffs[1][0];
+                doty += vn->n[1] * rsp.current_lookat_coeffs[1][1];
+                doty += vn->n[2] * rsp.current_lookat_coeffs[1][2];
+                
+                U = (int32_t)((dotx / 127.0f + 1.0f) / 4.0f * rsp.texture_scaling_factor.s);
+                V = (int32_t)((doty / 127.0f + 1.0f) / 4.0f * rsp.texture_scaling_factor.t);
+            }
+        } else {
+            d->color.r = v->cn[0];
+            d->color.g = v->cn[1];
+            d->color.b = v->cn[2];
+        }
+        
+        d->u = U;
+        d->v = V;
+        
+        // trivial clip rejection
+        d->clip_rej = 0;
+        if (x < -w) d->clip_rej |= 1;
+        if (x > w) d->clip_rej |= 2;
+        if (y < -w) d->clip_rej |= 4;
+        if (y > w) d->clip_rej |= 8;
+        if (z < -w) d->clip_rej |= 16;
+        if (z > w) d->clip_rej |= 32;
+        
+        d->x = x;
+        d->y = y;
+        d->z = z;
+        d->w = w;
+        
+        if (rsp.geometry_mode & G_FOG) {
+            if (fabsf(w) < 0.001f) {
+                // To avoid division by zero
+                w = 0.001f;
+            }
+            
+            float winv = 1.0f / w;
+            if (winv < 0.0f) {
+                winv = 32767.0f;
+            }
+            
+            float fog_z = z * winv * rsp.fog_mul + rsp.fog_offset;
+            if (fog_z < 0) fog_z = 0;
+            if (fog_z > 255) fog_z = 255;
+            d->color.a = fog_z; // Use alpha variable to store fog factor
+        } else {
+            d->color.a = v->cn[3];
+        }
+    }
+}
+
+static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx) {
+    struct LoadedVertex *v1 = &rsp.loaded_vertices[vtx1_idx];
+    struct LoadedVertex *v2 = &rsp.loaded_vertices[vtx2_idx];
+    struct LoadedVertex *v3 = &rsp.loaded_vertices[vtx3_idx];
+    struct LoadedVertex *v_arr[3] = {v1, v2, v3};
+    
+    //if (rand()%2) return;
+    
+    if (v1->clip_rej & v2->clip_rej & v3->clip_rej) {
+        // The whole triangle lies outside the visible area
+        return;
+    }
+    
+    if ((rsp.geometry_mode & G_CULL_BOTH) != 0) {
+        float dx1 = v1->x / (v1->w) - v2->x / (v2->w);
+        float dy1 = v1->y / (v1->w) - v2->y / (v2->w);
+        float dx2 = v3->x / (v3->w) - v2->x / (v2->w);
+        float dy2 = v3->y / (v3->w) - v2->y / (v2->w);
+        float cross = dx1 * dy2 - dy1 * dx2;
+        
+        if ((v1->w < 0) ^ (v2->w < 0) ^ (v3->w < 0)) {
+            // If one vertex lies behind the eye, negating cross will give the correct result.
+            // If all vertices lie behind the eye, the triangle will be rejected anyway.
+            cross = -cross;
+        }
+        
+        switch (rsp.geometry_mode & G_CULL_BOTH) {
+            case G_CULL_FRONT:
+                if (cross <= 0) return;
+                break;
+            case G_CULL_BACK:
+                if (cross >= 0) return;
+                break;
+            case G_CULL_BOTH:
+                // Why is this even an option?
+                return;
+        }
+    }
+    
+    bool depth_test = (rsp.geometry_mode & G_ZBUFFER) == G_ZBUFFER;
+    if (depth_test != rendering_state.depth_test) {
+        gfx_flush();
+        gfx_rapi->set_depth_test(depth_test);
+        rendering_state.depth_test = depth_test;
+    }
+    
+    bool z_upd = (rdp.other_mode_l & Z_UPD) == Z_UPD;
+    if (z_upd != rendering_state.depth_mask) {
+        gfx_flush();
+        gfx_rapi->set_depth_mask(z_upd);
+        rendering_state.depth_mask = z_upd;
+    }
+    
+    bool zmode_decal = (rdp.other_mode_l & ZMODE_DEC) == ZMODE_DEC;
+    if (zmode_decal != rendering_state.decal_mode) {
+        gfx_flush();
+        gfx_rapi->set_zmode_decal(zmode_decal);
+        rendering_state.decal_mode = zmode_decal;
+    }
+    
+    if (rdp.viewport_or_scissor_changed) {
+        if (memcmp(&rdp.viewport, &rendering_state.viewport, sizeof(rdp.viewport)) != 0) {
+            gfx_flush();
+            gfx_rapi->set_viewport(rdp.viewport.x, rdp.viewport.y, rdp.viewport.width, rdp.viewport.height);
+            rendering_state.viewport = rdp.viewport;
+        }
+        if (memcmp(&rdp.scissor, &rendering_state.scissor, sizeof(rdp.scissor)) != 0) {
+            gfx_flush();
+            gfx_rapi->set_scissor(rdp.scissor.x, rdp.scissor.y, rdp.scissor.width, rdp.scissor.height);
+            rendering_state.scissor = rdp.scissor;
+        }
+        rdp.viewport_or_scissor_changed = false;
+    }
+    
+    uint32_t cc_id = rdp.combine_mode;
+    
+    bool use_alpha = (rdp.other_mode_l & (G_BL_A_MEM << 18)) == 0;
+    bool use_fog = (rdp.other_mode_l >> 30) == G_BL_CLR_FOG;
+    bool texture_edge = (rdp.other_mode_l & CVG_X_ALPHA) == CVG_X_ALPHA;
+    
+    if (texture_edge) {
+        use_alpha = true;
+    }
+    
+    if (use_alpha) cc_id |= SHADER_OPT_ALPHA;
+    if (use_fog) cc_id |= SHADER_OPT_FOG;
+    if (texture_edge) cc_id |= SHADER_OPT_TEXTURE_EDGE;
+    
+    if (!use_alpha) {
+        cc_id &= ~0xfff000;
+    }
+    
+    struct ColorCombiner *comb = gfx_lookup_or_create_color_combiner(cc_id);
+    struct ShaderProgram *prg = comb->prg;
+    if (prg != rendering_state.shader_program) {
+        gfx_flush();
+        gfx_rapi->unload_shader(rendering_state.shader_program);
+        gfx_rapi->load_shader(prg);
+        rendering_state.shader_program = prg;
+    }
+    if (use_alpha != rendering_state.alpha_blend) {
+        gfx_flush();
+        gfx_rapi->set_use_alpha(use_alpha);
+        rendering_state.alpha_blend = use_alpha;
+    }
+    uint8_t num_inputs;
+    bool used_textures[2];
+    gfx_rapi->shader_get_info(prg, &num_inputs, used_textures);
+    
+    for (int i = 0; i < 2; i++) {
+        if (used_textures[i]) {
+            if (rdp.textures_changed[i]) {
+                gfx_flush();
+                import_texture(i);
+                rdp.textures_changed[i] = false;
+            }
+            bool linear_filter = (rdp.other_mode_h & (3U << G_MDSFT_TEXTFILT)) != G_TF_POINT;
+            if (linear_filter != rendering_state.textures[i]->linear_filter || rdp.texture_tile.cms != rendering_state.textures[i]->cms || rdp.texture_tile.cmt != rendering_state.textures[i]->cmt) {
+                gfx_flush();
+                gfx_rapi->set_sampler_parameters(i, linear_filter, rdp.texture_tile.cms, rdp.texture_tile.cmt);
+                rendering_state.textures[i]->linear_filter = linear_filter;
+                rendering_state.textures[i]->cms = rdp.texture_tile.cms;
+                rendering_state.textures[i]->cmt = rdp.texture_tile.cmt;
+            }
+        }
+    }
+    
+    bool use_texture = used_textures[0] || used_textures[1];
+    uint32_t tex_width = (rdp.texture_tile.lrs - rdp.texture_tile.uls + 4) / 4;
+    uint32_t tex_height = (rdp.texture_tile.lrt - rdp.texture_tile.ult + 4) / 4;
+    
+    bool z_is_from_0_to_1 = gfx_rapi->z_is_from_0_to_1();
+    
+    for (int i = 0; i < 3; i++) {
+        float z = v_arr[i]->z, w = v_arr[i]->w;
+        if (z_is_from_0_to_1) {
+            z = (z + w) / 2.0f;
+        }
+        buf_vbo[buf_vbo_len++] = v_arr[i]->x;
+        buf_vbo[buf_vbo_len++] = v_arr[i]->y;
+        buf_vbo[buf_vbo_len++] = z;
+        buf_vbo[buf_vbo_len++] = w;
+        
+        if (use_texture) {
+            float u = (v_arr[i]->u - rdp.texture_tile.uls * 8) / 32.0f;
+            float v = (v_arr[i]->v - rdp.texture_tile.ult * 8) / 32.0f;
+            if ((rdp.other_mode_h & (3U << G_MDSFT_TEXTFILT)) != G_TF_POINT) {
+                // Linear filter adds 0.5f to the coordinates
+                u += 0.5f;
+                v += 0.5f;
+            }
+            buf_vbo[buf_vbo_len++] = u / tex_width;
+            buf_vbo[buf_vbo_len++] = v / tex_height;
+        }
+        
+        if (use_fog) {
+            buf_vbo[buf_vbo_len++] = rdp.fog_color.r / 255.0f;
+            buf_vbo[buf_vbo_len++] = rdp.fog_color.g / 255.0f;
+            buf_vbo[buf_vbo_len++] = rdp.fog_color.b / 255.0f;
+            buf_vbo[buf_vbo_len++] = v_arr[i]->color.a / 255.0f; // fog factor (not alpha)
+        }
+        
+        for (int j = 0; j < num_inputs; j++) {
+            struct RGBA *color;
+            struct RGBA tmp;
+            for (int k = 0; k < 1 + (use_alpha ? 1 : 0); k++) {
+                switch (comb->shader_input_mapping[k][j]) {
+                    case CC_PRIM:
+                        color = &rdp.prim_color;
+                        break;
+                    case CC_SHADE:
+                        color = &v_arr[i]->color;
+                        break;
+                    case CC_ENV:
+                        color = &rdp.env_color;
+                        break;
+                    case CC_LOD:
+                    {
+                        float distance_frac = (v1->w - 3000.0f) / 3000.0f;
+                        if (distance_frac < 0.0f) distance_frac = 0.0f;
+                        if (distance_frac > 1.0f) distance_frac = 1.0f;
+                        tmp.r = tmp.g = tmp.b = tmp.a = distance_frac * 255.0f;
+                        color = &tmp;
+                        break;
+                    }
+                    default:
+                        memset(&tmp, 0, sizeof(tmp));
+                        color = &tmp;
+                        break;
+                }
+                if (k == 0) {
+                    buf_vbo[buf_vbo_len++] = color->r / 255.0f;
+                    buf_vbo[buf_vbo_len++] = color->g / 255.0f;
+                    buf_vbo[buf_vbo_len++] = color->b / 255.0f;
+                } else {
+                    if (use_fog && color == &v_arr[i]->color) {
+                        // Shade alpha is 100% for fog
+                        buf_vbo[buf_vbo_len++] = 1.0f;
+                    } else {
+                        buf_vbo[buf_vbo_len++] = color->a / 255.0f;
+                    }
+                }
+            }
+        }
+        /*struct RGBA *color = &v_arr[i]->color;
+        buf_vbo[buf_vbo_len++] = color->r / 255.0f;
+        buf_vbo[buf_vbo_len++] = color->g / 255.0f;
+        buf_vbo[buf_vbo_len++] = color->b / 255.0f;
+        buf_vbo[buf_vbo_len++] = color->a / 255.0f;*/
+    }
+    if (++buf_vbo_num_tris == MAX_BUFFERED) {
+        gfx_flush();
+    }
+}
+
+static void gfx_sp_geometry_mode(uint32_t clear, uint32_t set) {
+    rsp.geometry_mode &= ~clear;
+    rsp.geometry_mode |= set;
+}
+
+static void gfx_calc_and_set_viewport(const Vp_t *viewport) {
+    // 2 bits fraction
+    float width = 2.0f * viewport->vscale[0] / 4.0f;
+    float height = 2.0f * viewport->vscale[1] / 4.0f;
+    float x = (viewport->vtrans[0] / 4.0f) - width / 2.0f;
+    float y = SCREEN_HEIGHT - ((viewport->vtrans[1] / 4.0f) + height / 2.0f);
+    
+    width *= RATIO_X;
+    height *= RATIO_Y;
+    x *= RATIO_X;
+    y *= RATIO_Y;
+    
+    rdp.viewport.x = x;
+    rdp.viewport.y = y;
+    rdp.viewport.width = width;
+    rdp.viewport.height = height;
+    
+    rdp.viewport_or_scissor_changed = true;
+}
+
+static void gfx_sp_movemem(uint8_t index, uint8_t offset, const void* data) {
+    switch (index) {
+        case G_MV_VIEWPORT:
+            gfx_calc_and_set_viewport((const Vp_t *) data);
+            break;
+#if 0
+        case G_MV_LOOKATY:
+        case G_MV_LOOKATX:
+            memcpy(rsp.current_lookat + (index - G_MV_LOOKATY) / 2, data, sizeof(Light_t));
+            //rsp.lights_changed = 1;
+            break;
+#endif
+#ifdef F3DEX_GBI_2
+        case G_MV_LIGHT: {
+            int lightidx = offset / 24 - 2;
+            if (lightidx >= 0 && lightidx <= MAX_LIGHTS) { // skip lookat
+                // NOTE: reads out of bounds if it is an ambient light
+                memcpy(rsp.current_lights + lightidx, data, sizeof(Light_t));
+            }
+            break;
+        }
+#else
+        case G_MV_L0:
+        case G_MV_L1:
+        case G_MV_L2:
+            // NOTE: reads out of bounds if it is an ambient light
+            memcpy(rsp.current_lights + (index - G_MV_L0) / 2, data, sizeof(Light_t));
+            break;
+#endif
+    }
+}
+
+static void gfx_sp_moveword(uint8_t index, uint16_t offset, uint32_t data) {
+    switch (index) {
+        case G_MW_NUMLIGHT:
+#ifdef F3DEX_GBI_2
+            rsp.current_num_lights = data / 24 + 1; // add ambient light
+#else
+            // Ambient light is included
+            // The 31th bit is a flag that lights should be recalculated
+            rsp.current_num_lights = (data - 0x80000000U) / 32;
+#endif
+            rsp.lights_changed = 1;
+            break;
+        case G_MW_FOG:
+            rsp.fog_mul = (int16_t)(data >> 16);
+            rsp.fog_offset = (int16_t)data;
+            break;
+    }
+}
+
+static void gfx_sp_texture(uint16_t sc, uint16_t tc, uint8_t level, uint8_t tile, uint8_t on) {
+    rsp.texture_scaling_factor.s = sc;
+    rsp.texture_scaling_factor.t = tc;
+}
+
+static void gfx_dp_set_scissor(uint32_t mode, uint32_t ulx, uint32_t uly, uint32_t lrx, uint32_t lry) {
+    float x = ulx / 4.0f * RATIO_X;
+    float y = (SCREEN_HEIGHT - lry / 4.0f) * RATIO_Y;
+    float width = (lrx - ulx) / 4.0f * RATIO_X;
+    float height = (lry - uly) / 4.0f * RATIO_Y;
+    
+    rdp.scissor.x = x;
+    rdp.scissor.y = y;
+    rdp.scissor.width = width;
+    rdp.scissor.height = height;
+    
+    rdp.viewport_or_scissor_changed = true;
+}
+
+static void gfx_dp_set_texture_image(uint32_t format, uint32_t size, uint32_t width, const void* addr) {
+    rdp.texture_to_load.addr = addr;
+    rdp.texture_to_load.siz = size;
+}
+
+static void gfx_dp_set_tile(uint8_t fmt, uint32_t siz, uint32_t line, uint32_t tmem, uint8_t tile, uint32_t palette, uint32_t cmt, uint32_t maskt, uint32_t shiftt, uint32_t cms, uint32_t masks, uint32_t shifts) {
+    SUPPORT_CHECK(siz != G_IM_SIZ_32b);
+    
+    if (tile == G_TX_RENDERTILE) {
+        SUPPORT_CHECK(palette == 0); // palette should set upper 4 bits of color index in 4b mode
+        rdp.texture_tile.fmt = fmt;
+        rdp.texture_tile.siz = siz;
+        rdp.texture_tile.cms = cms;
+        rdp.texture_tile.cmt = cmt;
+        rdp.texture_tile.line_size_bytes = line * 8;
+        rdp.textures_changed[0] = true;
+        rdp.textures_changed[1] = true;
+    }
+    
+    if (tile == G_TX_LOADTILE) {
+        rdp.texture_to_load.tile_number = tmem / 256;
+    }
+}
+
+static void gfx_dp_set_tile_size(uint8_t tile, uint16_t uls, uint16_t ult, uint16_t lrs, uint16_t lrt) {
+    if (tile == G_TX_RENDERTILE) {
+        rdp.texture_tile.uls = uls;
+        rdp.texture_tile.ult = ult;
+        rdp.texture_tile.lrs = lrs;
+        rdp.texture_tile.lrt = lrt;
+        rdp.textures_changed[0] = true;
+        rdp.textures_changed[1] = true;
+    }
+}
+
+static void gfx_dp_load_tlut(uint8_t tile, uint32_t high_index) {
+    SUPPORT_CHECK(tile == G_TX_LOADTILE);
+    SUPPORT_CHECK(rdp.texture_to_load.siz == G_IM_SIZ_16b);
+    rdp.palette = rdp.texture_to_load.addr;
+}
+
+static void gfx_dp_load_block(uint8_t tile, uint32_t uls, uint32_t ult, uint32_t lrs, uint32_t dxt) {
+    if (tile == 1) return;
+    SUPPORT_CHECK(tile == G_TX_LOADTILE);
+    SUPPORT_CHECK(uls == 0);
+    SUPPORT_CHECK(ult == 0);
+    
+    // The lrs field rather seems to be number of pixels to load
+    uint32_t word_size_shift;
+    switch (rdp.texture_to_load.siz) {
+        case G_IM_SIZ_4b:
+            word_size_shift = 0; // Or -1? It's unused in SM64 anyway.
+            break;
+        case G_IM_SIZ_8b:
+            word_size_shift = 0;
+            break;
+        case G_IM_SIZ_16b:
+            word_size_shift = 1;
+            break;
+        case G_IM_SIZ_32b:
+            word_size_shift = 2;
+            break;
+    }
+    uint32_t size_bytes = (lrs + 1) << word_size_shift;
+    rdp.loaded_texture[rdp.texture_to_load.tile_number].size_bytes = size_bytes;
+    assert(size_bytes <= 4096 && "bug: too big texture");
+    rdp.loaded_texture[rdp.texture_to_load.tile_number].addr = rdp.texture_to_load.addr;
+    
+    rdp.textures_changed[rdp.texture_to_load.tile_number] = true;
+}
+
+static uint8_t color_comb_component(uint32_t v) {
+    switch (v) {
+        case G_CCMUX_TEXEL0:
+            return CC_TEXEL0;
+        case G_CCMUX_TEXEL1:
+            return CC_TEXEL1;
+        case G_CCMUX_PRIMITIVE:
+            return CC_PRIM;
+        case G_CCMUX_SHADE:
+            return CC_SHADE;
+        case G_CCMUX_ENVIRONMENT:
+            return CC_ENV;
+        case G_CCMUX_TEXEL0_ALPHA:
+            return CC_TEXEL0A;
+        case G_CCMUX_LOD_FRACTION:
+            return CC_LOD;
+        default:
+            return CC_0;
+    }
+}
+
+static inline uint32_t color_comb(uint32_t a, uint32_t b, uint32_t c, uint32_t d) {
+    return color_comb_component(a) |
+           (color_comb_component(b) << 3) |
+           (color_comb_component(c) << 6) |
+           (color_comb_component(d) << 9);
+}
+
+static void gfx_dp_set_combine_mode(uint32_t rgb, uint32_t alpha) {
+    rdp.combine_mode = rgb | (alpha << 12);
+}
+
+static void gfx_dp_set_env_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
+    rdp.env_color.r = r;
+    rdp.env_color.g = g;
+    rdp.env_color.b = b;
+    rdp.env_color.a = a;
+}
+
+static void gfx_dp_set_prim_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
+    rdp.prim_color.r = r;
+    rdp.prim_color.g = g;
+    rdp.prim_color.b = b;
+    rdp.prim_color.a = a;
+}
+
+static void gfx_dp_set_fog_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
+    rdp.fog_color.r = r;
+    rdp.fog_color.g = g;
+    rdp.fog_color.b = b;
+    rdp.fog_color.a = a;
+}
+
+static void gfx_dp_set_fill_color(uint32_t packed_color) {
+    uint16_t col16 = (uint16_t)packed_color;
+    uint32_t r = col16 >> 11;
+    uint32_t g = (col16 >> 6) & 0x1f;
+    uint32_t b = (col16 >> 1) & 0x1f;
+    uint32_t a = col16 & 1;
+    rdp.fill_color.r = SCALE_5_8(r);
+    rdp.fill_color.g = SCALE_5_8(g);
+    rdp.fill_color.b = SCALE_5_8(b);
+    rdp.fill_color.a = a * 255;
+}
+
+static void gfx_draw_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry) {
+    uint32_t saved_other_mode_h = rdp.other_mode_h;
+    uint32_t cycle_type = (rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE));
+    
+    if (cycle_type == G_CYC_COPY) {
+        rdp.other_mode_h = (rdp.other_mode_h & ~(3U << G_MDSFT_TEXTFILT)) | G_TF_POINT;
+    }
+    
+    // U10.2 coordinates
+    float ulxf = ulx;
+    float ulyf = uly;
+    float lrxf = lrx;
+    float lryf = lry;
+    
+    ulxf = ulxf / (4.0f * HALF_SCREEN_WIDTH) - 1.0f;
+    ulyf = -(ulyf / (4.0f * HALF_SCREEN_HEIGHT)) + 1.0f;
+    lrxf = lrxf / (4.0f * HALF_SCREEN_WIDTH) - 1.0f;
+    lryf = -(lryf / (4.0f * HALF_SCREEN_HEIGHT)) + 1.0f;
+    
+    ulxf = gfx_adjust_x_for_aspect_ratio(ulxf);
+    lrxf = gfx_adjust_x_for_aspect_ratio(lrxf);
+    
+    struct LoadedVertex* ul = &rsp.loaded_vertices[MAX_VERTICES + 0];
+    struct LoadedVertex* ll = &rsp.loaded_vertices[MAX_VERTICES + 1];
+    struct LoadedVertex* lr = &rsp.loaded_vertices[MAX_VERTICES + 2];
+    struct LoadedVertex* ur = &rsp.loaded_vertices[MAX_VERTICES + 3];
+    
+    ul->x = ulxf;
+    ul->y = ulyf;
+    ul->z = -1.0f;
+    ul->w = 1.0f;
+    
+    ll->x = ulxf;
+    ll->y = lryf;
+    ll->z = -1.0f;
+    ll->w = 1.0f;
+    
+    lr->x = lrxf;
+    lr->y = lryf;
+    lr->z = -1.0f;
+    lr->w = 1.0f;
+    
+    ur->x = lrxf;
+    ur->y = ulyf;
+    ur->z = -1.0f;
+    ur->w = 1.0f;
+    
+    // The coordinates for texture rectangle shall bypass the viewport setting
+    struct XYWidthHeight default_viewport = {0, 0, gfx_current_dimensions.width, gfx_current_dimensions.height};
+    struct XYWidthHeight viewport_saved = rdp.viewport;
+    uint32_t geometry_mode_saved = rsp.geometry_mode;
+    
+    rdp.viewport = default_viewport;
+    rdp.viewport_or_scissor_changed = true;
+    rsp.geometry_mode = 0;
+    
+    gfx_sp_tri1(MAX_VERTICES + 0, MAX_VERTICES + 1, MAX_VERTICES + 3);
+    gfx_sp_tri1(MAX_VERTICES + 1, MAX_VERTICES + 2, MAX_VERTICES + 3);
+    
+    rsp.geometry_mode = geometry_mode_saved;
+    rdp.viewport = viewport_saved;
+    rdp.viewport_or_scissor_changed = true;
+    
+    if (cycle_type == G_CYC_COPY) {
+        rdp.other_mode_h = saved_other_mode_h;
+    }
+}
+
+static void gfx_dp_texture_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry, uint8_t tile, int16_t uls, int16_t ult, int16_t dsdx, int16_t dtdy, bool flip) {
+    uint32_t saved_combine_mode = rdp.combine_mode;
+    if ((rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE)) == G_CYC_COPY) {
+        // Per RDP Command Summary Set Tile's shift s and this dsdx should be set to 4 texels
+        // Divide by 4 to get 1 instead
+        dsdx >>= 2;
+        
+        // Color combiner is turned off in copy mode
+        gfx_dp_set_combine_mode(color_comb(0, 0, 0, G_CCMUX_TEXEL0), color_comb(0, 0, 0, G_ACMUX_TEXEL0));
+        
+        // Per documentation one extra pixel is added in this modes to each edge
+        lrx += 1 << 2;
+        lry += 1 << 2;
+    }
+    
+    // uls and ult are S10.5
+    // dsdx and dtdy are S5.10
+    // lrx, lry, ulx, uly are U10.2
+    // lrs, lrt are S10.5
+    if (flip) {
+        dsdx = -dsdx;
+        dtdy = -dtdy;
+    }
+    int16_t width = !flip ? lrx - ulx : lry - uly;
+    int16_t height = !flip ? lry - uly : lrx - ulx;
+    float lrs = ((uls << 7) + dsdx * width) >> 7;
+    float lrt = ((ult << 7) + dtdy * height) >> 7;
+    
+    struct LoadedVertex* ul = &rsp.loaded_vertices[MAX_VERTICES + 0];
+    struct LoadedVertex* ll = &rsp.loaded_vertices[MAX_VERTICES + 1];
+    struct LoadedVertex* lr = &rsp.loaded_vertices[MAX_VERTICES + 2];
+    struct LoadedVertex* ur = &rsp.loaded_vertices[MAX_VERTICES + 3];
+    ul->u = uls;
+    ul->v = ult;
+    lr->u = lrs;
+    lr->v = lrt;
+    if (!flip) {
+        ll->u = uls;
+        ll->v = lrt;
+        ur->u = lrs;
+        ur->v = ult;
+    } else {
+        ll->u = lrs;
+        ll->v = ult;
+        ur->u = uls;
+        ur->v = lrt;
+    }
+    
+    gfx_draw_rectangle(ulx, uly, lrx, lry);
+    rdp.combine_mode = saved_combine_mode;
+}
+
+static void gfx_dp_fill_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry) {
+    if (rdp.color_image_address == rdp.z_buf_address) {
+        // Don't clear Z buffer here since we already did it with glClear
+        return;
+    }
+    uint32_t mode = (rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE));
+    
+    if (mode == G_CYC_COPY || mode == G_CYC_FILL) {
+        // Per documentation one extra pixel is added in this modes to each edge
+        lrx += 1 << 2;
+        lry += 1 << 2;
+    }
+    
+    for (int i = MAX_VERTICES; i < MAX_VERTICES + 4; i++) {
+        struct LoadedVertex* v = &rsp.loaded_vertices[i];
+        v->color = rdp.fill_color;
+    }
+    
+    uint32_t saved_combine_mode = rdp.combine_mode;
+    gfx_dp_set_combine_mode(color_comb(0, 0, 0, G_CCMUX_SHADE), color_comb(0, 0, 0, G_ACMUX_SHADE));
+    gfx_draw_rectangle(ulx, uly, lrx, lry);
+    rdp.combine_mode = saved_combine_mode;
+}
+
+static void gfx_dp_set_z_image(void *z_buf_address) {
+    rdp.z_buf_address = z_buf_address;
+}
+
+static void gfx_dp_set_color_image(uint32_t format, uint32_t size, uint32_t width, void* address) {
+    rdp.color_image_address = address;
+}
+
+static void gfx_sp_set_other_mode(uint32_t shift, uint32_t num_bits, uint64_t mode) {
+    uint64_t mask = (((uint64_t)1 << num_bits) - 1) << shift;
+    uint64_t om = rdp.other_mode_l | ((uint64_t)rdp.other_mode_h << 32);
+    om = (om & ~mask) | mode;
+    rdp.other_mode_l = (uint32_t)om;
+    rdp.other_mode_h = (uint32_t)(om >> 32);
+}
+
+static inline void *seg_addr(uintptr_t w1) {
+    return (void *) w1;
+}
+
+#define C0(pos, width) ((cmd->words.w0 >> (pos)) & ((1U << width) - 1))
+#define C1(pos, width) ((cmd->words.w1 >> (pos)) & ((1U << width) - 1))
+
+static void gfx_run_dl(Gfx* cmd) {
+    int dummy = 0;
+    for (;;) {
+        uint32_t opcode = cmd->words.w0 >> 24;
+        
+        switch (opcode) {
+            // RSP commands:
+            case G_MTX:
+#ifdef F3DEX_GBI_2
+                gfx_sp_matrix(C0(0, 8) ^ G_MTX_PUSH, (const int32_t *) seg_addr(cmd->words.w1));
+#else
+                gfx_sp_matrix(C0(16, 8), (const int32_t *) seg_addr(cmd->words.w1));
+#endif
+                break;
+            case (uint8_t)G_POPMTX:
+#ifdef F3DEX_GBI_2
+                gfx_sp_pop_matrix(cmd->words.w1 / 64);
+#else
+                gfx_sp_pop_matrix(1);
+#endif
+                break;
+            case G_MOVEMEM:
+#ifdef F3DEX_GBI_2
+                gfx_sp_movemem(C0(0, 8), C0(8, 8) * 8, seg_addr(cmd->words.w1));
+#else
+                gfx_sp_movemem(C0(16, 8), 0, seg_addr(cmd->words.w1));
+#endif
+                break;
+            case (uint8_t)G_MOVEWORD:
+#ifdef F3DEX_GBI_2
+                gfx_sp_moveword(C0(16, 8), C0(0, 16), cmd->words.w1);
+#else
+                gfx_sp_moveword(C0(0, 8), C0(8, 16), cmd->words.w1);
+#endif
+                break;
+            case (uint8_t)G_TEXTURE:
+#ifdef F3DEX_GBI_2
+                gfx_sp_texture(C1(16, 16), C1(0, 16), C0(11, 3), C0(8, 3), C0(1, 7));
+#else
+                gfx_sp_texture(C1(16, 16), C1(0, 16), C0(11, 3), C0(8, 3), C0(0, 8));
+#endif
+                break;
+            case G_VTX:
+#ifdef F3DEX_GBI_2
+                gfx_sp_vertex(C0(12, 8), C0(1, 7) - C0(12, 8), seg_addr(cmd->words.w1));
+#elif defined(F3DEX_GBI) || defined(F3DLP_GBI)
+                gfx_sp_vertex(C0(10, 6), C0(16, 8) / 2, seg_addr(cmd->words.w1));
+#else
+                gfx_sp_vertex((C0(0, 16)) / sizeof(Vtx), C0(16, 4), seg_addr(cmd->words.w1));
+#endif
+                break;
+            case G_DL:
+                if (C0(16, 1) == 0) {
+                    // Push return address
+                    gfx_run_dl((Gfx *)seg_addr(cmd->words.w1));
+                } else {
+                    cmd = (Gfx *)seg_addr(cmd->words.w1);
+                    --cmd; // increase after break
+                }
+                break;
+            case (uint8_t)G_ENDDL:
+                return;
+#ifdef F3DEX_GBI_2
+            case G_GEOMETRYMODE:
+                gfx_sp_geometry_mode(~C0(0, 24), cmd->words.w1);
+                break;
+#else
+            case (uint8_t)G_SETGEOMETRYMODE:
+                gfx_sp_geometry_mode(0, cmd->words.w1);
+                break;
+            case (uint8_t)G_CLEARGEOMETRYMODE:
+                gfx_sp_geometry_mode(cmd->words.w1, 0);
+                break;
+#endif
+            case (uint8_t)G_TRI1:
+#ifdef F3DEX_GBI_2
+                gfx_sp_tri1(C0(16, 8) / 2, C0(8, 8) / 2, C0(0, 8) / 2);
+#elif defined(F3DEX_GBI) || defined(F3DLP_GBI)
+                gfx_sp_tri1(C1(16, 8) / 2, C1(8, 8) / 2, C1(0, 8) / 2);
+#else
+                gfx_sp_tri1(C1(16, 8) / 10, C1(8, 8) / 10, C1(0, 8) / 10);
+#endif
+                break;
+#if defined(F3DEX_GBI) || defined(F3DLP_GBI)
+            case (uint8_t)G_TRI2:
+                gfx_sp_tri1(C0(16, 8) / 2, C0(8, 8) / 2, C0(0, 8) / 2);
+                gfx_sp_tri1(C1(16, 8) / 2, C1(8, 8) / 2, C1(0, 8) / 2);
+                break;
+#endif
+            case (uint8_t)G_SETOTHERMODE_L:
+#ifdef F3DEX_GBI_2
+                gfx_sp_set_other_mode(31 - C0(8, 8) - C0(0, 8), C0(0, 8) + 1, cmd->words.w1);
+#else
+                gfx_sp_set_other_mode(C0(8, 8), C0(0, 8), cmd->words.w1);
+#endif
+                break;
+            case (uint8_t)G_SETOTHERMODE_H:
+#ifdef F3DEX_GBI_2
+                gfx_sp_set_other_mode(63 - C0(8, 8) - C0(0, 8), C0(0, 8) + 1, (uint64_t) cmd->words.w1 << 32);
+#else
+                gfx_sp_set_other_mode(C0(8, 8) + 32, C0(0, 8), (uint64_t) cmd->words.w1 << 32);
+#endif
+                break;
+            
+            // RDP Commands:
+            case G_SETTIMG:
+                gfx_dp_set_texture_image(C0(21, 3), C0(19, 2), C0(0, 10), seg_addr(cmd->words.w1));
+                break;
+            case G_LOADBLOCK:
+                gfx_dp_load_block(C1(24, 3), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
+                break;
+            case G_SETTILE:
+                gfx_dp_set_tile(C0(21, 3), C0(19, 2), C0(9, 9), C0(0, 9), C1(24, 3), C1(20, 4), C1(18, 2), C1(14, 4), C1(10, 4), C1(8, 2), C1(4, 4), C1(0, 4));
+                break;
+            case G_SETTILESIZE:
+                gfx_dp_set_tile_size(C1(24, 3), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
+                break;
+            case G_LOADTLUT:
+                gfx_dp_load_tlut(C1(24, 3), C1(14, 10));
+                break;
+            case G_SETENVCOLOR:
+                gfx_dp_set_env_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
+                break;
+            case G_SETPRIMCOLOR:
+                gfx_dp_set_prim_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
+                break;
+            case G_SETFOGCOLOR:
+                gfx_dp_set_fog_color(C1(24, 8), C1(16, 8), C1(8, 8), C1(0, 8));
+                break;
+            case G_SETFILLCOLOR:
+                gfx_dp_set_fill_color(cmd->words.w1);
+                break;
+            case G_SETCOMBINE:
+                gfx_dp_set_combine_mode(
+                    color_comb(C0(20, 4), C1(28, 4), C0(15, 5), C1(15, 3)),
+                    color_comb(C0(12, 3), C1(12, 3), C0(9, 3), C1(9, 3)));
+                    /*color_comb(C0(5, 4), C1(24, 4), C0(0, 5), C1(6, 3)),
+                    color_comb(C1(21, 3), C1(3, 3), C1(18, 3), C1(0, 3)));*/
+                break;
+            // G_SETPRIMCOLOR, G_CCMUX_PRIMITIVE, G_ACMUX_PRIMITIVE, is used by Goddard
+            // G_CCMUX_TEXEL1, LOD_FRACTION is used in Bowser room 1
+            case G_TEXRECT:
+            case G_TEXRECTFLIP:
+            {
+                int32_t lrx, lry, tile, ulx, uly;
+                uint32_t uls, ult, dsdx, dtdy;
+#ifdef F3DEX_GBI_2E
+                lrx = (int32_t)(C0(0, 24) << 8) >> 8;
+                lry = (int32_t)(C1(0, 24) << 8) >> 8;
+                ++cmd;
+                ulx = (int32_t)(C0(0, 24) << 8) >> 8;
+                uly = (int32_t)(C1(0, 24) << 8) >> 8;
+                ++cmd;
+                uls = C0(16, 16);
+                ult = C0(0, 16);
+                dsdx = C1(16, 16);
+                dtdy = C1(0, 16);
+#else
+                lrx = C0(12, 12);
+                lry = C0(0, 12);
+                tile = C1(24, 3);
+                ulx = C1(12, 12);
+                uly = C1(0, 12);
+                ++cmd;
+                uls = C1(16, 16);
+                ult = C1(0, 16);
+                ++cmd;
+                dsdx = C1(16, 16);
+                dtdy = C1(0, 16);
+#endif
+                gfx_dp_texture_rectangle(ulx, uly, lrx, lry, tile, uls, ult, dsdx, dtdy, opcode == G_TEXRECTFLIP);
+                break;
+            }
+            case G_FILLRECT:
+#ifdef F3DEX_GBI_2E
+            {
+                int32_t lrx, lry, ulx, uly;
+                lrx = (int32_t)(C0(0, 24) << 8) >> 8;
+                lry = (int32_t)(C1(0, 24) << 8) >> 8;
+                ++cmd;
+                ulx = (int32_t)(C0(0, 24) << 8) >> 8;
+                uly = (int32_t)(C1(0, 24) << 8) >> 8;
+                gfx_dp_fill_rectangle(ulx, uly, lrx, lry);
+                break;
+            }
+#else
+                gfx_dp_fill_rectangle(C1(12, 12), C1(0, 12), C0(12, 12), C0(0, 12));
+                break;
+#endif
+            case G_SETSCISSOR:
+                gfx_dp_set_scissor(C1(24, 2), C0(12, 12), C0(0, 12), C1(12, 12), C1(0, 12));
+                break;
+            case G_SETZIMG:
+                gfx_dp_set_z_image(seg_addr(cmd->words.w1));
+                break;
+            case G_SETCIMG:
+                gfx_dp_set_color_image(C0(21, 3), C0(19, 2), C0(0, 11), seg_addr(cmd->words.w1));
+                break;
+        }
+        ++cmd;
+    }
+}
+
+static void gfx_sp_reset() {
+    rsp.modelview_matrix_stack_size = 1;
+    rsp.current_num_lights = 2;
+    rsp.lights_changed = true;
+}
+
+void gfx_get_dimensions(uint32_t *width, uint32_t *height) {
+    gfx_wapi->get_dimensions(width, height);
+}
+
+void gfx_init(struct GfxWindowManagerAPI *wapi, struct GfxRenderingAPI *rapi) {
+    gfx_wapi = wapi;
+    gfx_rapi = rapi;
+    gfx_wapi->init();
+    gfx_rapi->init();
+    
+    // Used in the 120 star TAS
+    static uint32_t precomp_shaders[] = {
+        0x01200200,
+        0x00000045,
+        0x00000200,
+        0x01200a00,
+        0x00000a00,
+        0x01a00045,
+        0x00000551,
+        0x01045045,
+        0x05a00a00,
+        0x01200045,
+        0x05045045,
+        0x01045a00,
+        0x01a00a00,
+        0x0000038d,
+        0x01081081,
+        0x0120038d,
+        0x03200045,
+        0x03200a00,
+        0x01a00a6f,
+        0x01141045,
+        0x07a00a00,
+        0x05200200,
+        0x03200200
+    };
+    for (size_t i = 0; i < sizeof(precomp_shaders) / sizeof(uint32_t); i++) {
+        gfx_lookup_or_create_shader_program(precomp_shaders[i]);
+    }
+}
+
+void gfx_start_frame(void) {
+    gfx_wapi->handle_events();
+    gfx_wapi->get_dimensions(&gfx_current_dimensions.width, &gfx_current_dimensions.height);
+    if (gfx_current_dimensions.height == 0) {
+        // Avoid division by zero
+        gfx_current_dimensions.height = 1;
+    }
+    gfx_current_dimensions.aspect_ratio = (float)gfx_current_dimensions.width / (float)gfx_current_dimensions.height;
+}
+
+void gfx_run(Gfx *commands) {
+    gfx_sp_reset();
+    
+    //puts("New frame");
+    
+    if (!gfx_wapi->start_frame()) {
+        dropped_frame = true;
+        return;
+    }
+    dropped_frame = false;
+    
+    double t0 = gfx_wapi->get_time();
+    gfx_rapi->start_frame();
+    gfx_run_dl(commands);
+    gfx_flush();
+    double t1 = gfx_wapi->get_time();
+    //printf("Process %f %f\n", t1, t1 - t0);
+    gfx_wapi->swap_buffers_begin();
+}
+
+void gfx_end_frame(void) {
+    if (!dropped_frame) {
+        gfx_wapi->swap_buffers_end();
+    }
+}
diff --git a/src/pc/gfx/gfx_pc.h b/src/pc/gfx/gfx_pc.h
new file mode 100644
index 0000000..6903597
--- /dev/null
+++ b/src/pc/gfx/gfx_pc.h
@@ -0,0 +1,19 @@
+#ifndef GFX_PC_H
+#define GFX_PC_H
+
+struct GfxRenderingAPI;
+struct GfxWindowManagerAPI;
+
+struct GfxDimensions {
+    uint32_t width, height;
+    float aspect_ratio;
+};
+
+extern struct GfxDimensions gfx_current_dimensions;
+
+void gfx_init(struct GfxWindowManagerAPI *wapi, struct GfxRenderingAPI *rapi);
+void gfx_start_frame(void);
+void gfx_run(Gfx *commands);
+void gfx_end_frame(void);
+
+#endif
diff --git a/src/pc/gfx/gfx_rendering_api.h b/src/pc/gfx/gfx_rendering_api.h
new file mode 100644
index 0000000..58d7943
--- /dev/null
+++ b/src/pc/gfx/gfx_rendering_api.h
@@ -0,0 +1,32 @@
+#ifndef GFX_RENDERING_API_H
+#define GFX_RENDERING_API_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+struct ShaderProgram;
+
+struct GfxRenderingAPI {
+    bool (*z_is_from_0_to_1)(void);
+    void (*unload_shader)(struct ShaderProgram *old_prg);
+    void (*load_shader)(struct ShaderProgram *new_prg);
+    struct ShaderProgram *(*create_and_load_new_shader)(uint32_t shader_id);
+    struct ShaderProgram *(*lookup_shader)(uint32_t shader_id);
+    void (*shader_get_info)(struct ShaderProgram *prg, uint8_t *num_inputs, bool used_textures[2]);
+    uint32_t (*new_texture)(void);
+    void (*select_texture)(int tile, uint32_t texture_id);
+    void (*upload_texture)(uint8_t *rgba32_buf, int width, int height);
+    void (*set_sampler_parameters)(int sampler, bool linear_filter, uint32_t cms, uint32_t cmt);
+    void (*set_depth_test)(bool depth_test);
+    void (*set_depth_mask)(bool z_upd);
+    void (*set_zmode_decal)(bool zmode_decal);
+    void (*set_viewport)(int x, int y, int width, int height);
+    void (*set_scissor)(int x, int y, int width, int height);
+    void (*set_use_alpha)(bool use_alpha);
+    void (*draw_triangles)(float buf_vbo[], size_t buf_vbo_len, size_t buf_vbo_num_tris);
+    void (*init)(void);
+    void (*start_frame)(void);
+};
+
+#endif
diff --git a/src/pc/gfx/gfx_screen_config.h b/src/pc/gfx/gfx_screen_config.h
new file mode 100644
index 0000000..5b933f8
--- /dev/null
+++ b/src/pc/gfx/gfx_screen_config.h
@@ -0,0 +1,7 @@
+#ifndef GFX_SCREEN_CONFIG_H
+#define GFX_SCREEN_CONFIG_H
+
+#define DESIRED_SCREEN_WIDTH 640
+#define DESIRED_SCREEN_HEIGHT 480
+
+#endif
diff --git a/src/pc/gfx/gfx_sdl.c b/src/pc/gfx/gfx_sdl.c
new file mode 100644
index 0000000..ba7f169
--- /dev/null
+++ b/src/pc/gfx/gfx_sdl.c
@@ -0,0 +1,105 @@
+#if 0
+#include <stdlib.h>
+#include <stdbool.h>
+
+#if FOR_WINDOWS
+#include <GL/glew.h>
+#include "SDL.h"
+#define GL_GLEXT_PROTOTYPES 1
+#include "SDL_opengl.h"
+#else
+#include <SDL2/SDL.h>
+#define GL_GLEXT_PROTOTYPES 1
+#include <SDL2/SDL_opengles2.h>
+#endif
+
+#define SCREEN_WIDTH 320
+#define SCREEN_HEIGHT 240
+#define HALF_SCREEN_WIDTH (SCREEN_WIDTH / 2)
+#define HALF_SCREEN_HEIGHT (SCREEN_HEIGHT / 2)
+
+#define DESIRED_SCREEN_WIDTH (SCREEN_WIDTH * 4)
+#define DESIRED_SCREEN_HEIGHT (SCREEN_HEIGHT * 4)
+
+static SDL_Window *wnd;
+
+static void gfx_sdl_init(void) {
+    SDL_Init(SDL_INIT_VIDEO);
+    
+    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
+    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
+    
+    //SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
+    //SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 4);
+    
+    wnd = SDL_CreateWindow("Super Mario 64 PC-Port", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
+            DESIRED_SCREEN_WIDTH, DESIRED_SCREEN_HEIGHT, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
+    
+    SDL_GL_CreateContext(wnd);
+    SDL_GL_SetSwapInterval(0); // TODO 0, 1 or 2 or remove this line?
+}
+
+static void gfx_sdl_handle_events(void) {
+    SDL_Event event;
+    while (SDL_PollEvent(&event)) {
+        switch (event.type) {
+            case SDL_QUIT:
+                exit(0);
+        }
+    }
+}
+
+static void swap_buffers() {
+    uint8_t *driverdata = *(uint8_t **)((uint8_t *)wnd + 192);
+    uintptr_t xwindow = *(uintptr_t *)(driverdata + sizeof(void *));
+    uint8_t *videodata = *(uint8_t **)(driverdata + 224);
+    uint8_t *display = *(uint8_t **)videodata;
+    
+    bool (*glXGetSyncValuesOML)(uint8_t *, uintptr_t, int64_t *, int64_t *, int64_t *) = SDL_GL_GetProcAddress("glXGetSyncValuesOML");
+    
+    bool (*glXGetMscRateOML)(uint8_t *, uintptr_t, int32_t *, int32_t *) = SDL_GL_GetProcAddress("glXGetMscRateOML");
+    
+    int64_t (*glXSwapBuffersMscOML)(uint8_t *, uintptr_t, int64_t, int64_t, int64_t) = SDL_GL_GetProcAddress("glXSwapBuffersMscOML");
+    
+    bool (*glXWaitForSbcOML)(uint8_t *, uintptr_t, int64_t, int64_t *, int64_t *, int64_t *) = SDL_GL_GetProcAddress("glXWaitForSbcOML");
+    
+    static int64_t last_msc;
+    
+    bool res;
+    int64_t ust, msc, sbc;
+    res = glXGetSyncValuesOML(display, xwindow, &ust, &msc, &sbc);
+    printf("%d %ld %ld %ld\n", res, ust, msc, sbc);
+    
+    int32_t numerator, denominator;
+    res = glXGetMscRateOML(display, xwindow, &numerator, &denominator);
+    printf("%d %d %d\n", res, numerator, denominator);
+    int32_t fps = numerator / denominator;
+    
+    int64_t next_msc = last_msc + (fps / 30);
+    
+    int64_t sbc_at_swap = glXSwapBuffersMscOML(display, xwindow, next_msc, 0, 0);
+    
+    res = glXWaitForSbcOML(display, xwindow, 0, &ust, &msc, &sbc);
+    if (msc != next_msc) {
+        printf("FRAME too late!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! %ld %ld\n", sbc, msc - next_msc);
+    }
+    last_msc = msc;
+}
+
+static void gfx_sdl_swap_buffers(void) {
+    //SDL_GL_SwapWindow(wnd);
+    swap_buffers();
+}
+
+void gfx_window_system_init(void) {
+    gfx_sdl_init();
+}
+
+void gfx_window_system_handle_events(void) {
+    gfx_sdl_handle_events();
+}
+
+void gfx_window_system_swap_buffers(void) {
+    gfx_sdl_swap_buffers();
+}
+#endif
diff --git a/src/pc/gfx/gfx_sdl.h b/src/pc/gfx/gfx_sdl.h
new file mode 100644
index 0000000..458eccb
--- /dev/null
+++ b/src/pc/gfx/gfx_sdl.h
@@ -0,0 +1,8 @@
+#ifndef GFX_SDL_H
+#define GFX_SDL_H
+
+#include "gfx_window_manager_api.h"
+
+extern struct GfxWindowManagerAPI gfx_sdl;
+
+#endif
diff --git a/src/pc/gfx/gfx_sdl2.c b/src/pc/gfx/gfx_sdl2.c
new file mode 100644
index 0000000..d2c8b21
--- /dev/null
+++ b/src/pc/gfx/gfx_sdl2.c
@@ -0,0 +1,180 @@
+#if TARGET_WEB
+
+#ifdef __MINGW32__
+#define FOR_WINDOWS 1
+#else
+#define FOR_WINDOWS 0
+#endif
+
+#if FOR_WINDOWS
+#include <GL/glew.h>
+#include "SDL.h"
+#define GL_GLEXT_PROTOTYPES 1
+#include "SDL_opengl.h"
+#else
+#include <SDL2/SDL.h>
+#define GL_GLEXT_PROTOTYPES 1
+#include <SDL2/SDL_opengles2.h>
+#endif
+
+#include "gfx_window_manager_api.h"
+#include "gfx_screen_config.h"
+
+#include "src/pc/controller/controller_keyboard.h"
+
+static SDL_Window *wnd;
+static int inverted_scancode_table[512];
+
+const SDL_Scancode windows_scancode_table[] =
+{ 
+ /*  0           1             2             3             4           5             6             7 */
+ /*  8           9             A             B             C           D             E             F */
+ SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_ESCAPE,    SDL_SCANCODE_1,       SDL_SCANCODE_2,       SDL_SCANCODE_3,     SDL_SCANCODE_4,       SDL_SCANCODE_5,       SDL_SCANCODE_6,     /* 0 */
+ SDL_SCANCODE_7,       SDL_SCANCODE_8,       SDL_SCANCODE_9,       SDL_SCANCODE_0,       SDL_SCANCODE_MINUS,   SDL_SCANCODE_EQUALS,    SDL_SCANCODE_BACKSPACE,   SDL_SCANCODE_TAB,   /* 0 */
+
+ SDL_SCANCODE_Q,       SDL_SCANCODE_W,       SDL_SCANCODE_E,       SDL_SCANCODE_R,       SDL_SCANCODE_T,     SDL_SCANCODE_Y,       SDL_SCANCODE_U,       SDL_SCANCODE_I,     /* 1 */
+ SDL_SCANCODE_O,       SDL_SCANCODE_P,       SDL_SCANCODE_LEFTBRACKET, SDL_SCANCODE_RIGHTBRACKET,  SDL_SCANCODE_RETURN,  SDL_SCANCODE_LCTRL,     SDL_SCANCODE_A,       SDL_SCANCODE_S,     /* 1 */
+
+ SDL_SCANCODE_D,       SDL_SCANCODE_F,       SDL_SCANCODE_G,       SDL_SCANCODE_H,       SDL_SCANCODE_J,     SDL_SCANCODE_K,       SDL_SCANCODE_L,       SDL_SCANCODE_SEMICOLON, /* 2 */
+ SDL_SCANCODE_APOSTROPHE,  SDL_SCANCODE_GRAVE,     SDL_SCANCODE_LSHIFT,    SDL_SCANCODE_BACKSLASH,   SDL_SCANCODE_Z,     SDL_SCANCODE_X,       SDL_SCANCODE_C,       SDL_SCANCODE_V,     /* 2 */
+
+ SDL_SCANCODE_B,       SDL_SCANCODE_N,       SDL_SCANCODE_M,       SDL_SCANCODE_COMMA,     SDL_SCANCODE_PERIOD,  SDL_SCANCODE_SLASH,     SDL_SCANCODE_RSHIFT,    SDL_SCANCODE_PRINTSCREEN,/* 3 */
+ SDL_SCANCODE_LALT,      SDL_SCANCODE_SPACE,     SDL_SCANCODE_CAPSLOCK,    SDL_SCANCODE_F1,      SDL_SCANCODE_F2,    SDL_SCANCODE_F3,      SDL_SCANCODE_F4,      SDL_SCANCODE_F5,    /* 3 */
+
+ SDL_SCANCODE_F6,      SDL_SCANCODE_F7,      SDL_SCANCODE_F8,      SDL_SCANCODE_F9,      SDL_SCANCODE_F10,   SDL_SCANCODE_NUMLOCKCLEAR,  SDL_SCANCODE_SCROLLLOCK,  SDL_SCANCODE_HOME,    /* 4 */
+ SDL_SCANCODE_UP,      SDL_SCANCODE_PAGEUP,    SDL_SCANCODE_KP_MINUS,    SDL_SCANCODE_LEFT,      SDL_SCANCODE_KP_5,    SDL_SCANCODE_RIGHT,     SDL_SCANCODE_KP_PLUS,   SDL_SCANCODE_END,   /* 4 */
+
+ SDL_SCANCODE_DOWN,      SDL_SCANCODE_PAGEDOWN,    SDL_SCANCODE_INSERT,    SDL_SCANCODE_DELETE,    SDL_SCANCODE_UNKNOWN, SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_NONUSBACKSLASH,SDL_SCANCODE_F11,   /* 5 */
+ SDL_SCANCODE_F12,     SDL_SCANCODE_PAUSE,     SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_LGUI,      SDL_SCANCODE_RGUI,    SDL_SCANCODE_APPLICATION, SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN, /* 5 */
+
+ SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_F13,   SDL_SCANCODE_F14,     SDL_SCANCODE_F15,     SDL_SCANCODE_F16,   /* 6 */
+ SDL_SCANCODE_F17,     SDL_SCANCODE_F18,     SDL_SCANCODE_F19,     SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN, SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN, /* 6 */
+ 
+ SDL_SCANCODE_INTERNATIONAL2,    SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_INTERNATIONAL1,    SDL_SCANCODE_UNKNOWN, SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN, /* 7 */
+ SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_INTERNATIONAL4,    SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_INTERNATIONAL5,    SDL_SCANCODE_UNKNOWN, SDL_SCANCODE_INTERNATIONAL3,    SDL_SCANCODE_UNKNOWN,   SDL_SCANCODE_UNKNOWN  /* 7 */
+};
+
+const SDL_Scancode scancode_rmapping_extended[][2] = {
+    {SDL_SCANCODE_KP_ENTER, SDL_SCANCODE_RETURN},
+    {SDL_SCANCODE_RALT, SDL_SCANCODE_LALT},
+    {SDL_SCANCODE_RCTRL, SDL_SCANCODE_LCTRL},
+    {SDL_SCANCODE_KP_DIVIDE, SDL_SCANCODE_SLASH},
+    //{SDL_SCANCODE_KP_PLUS, SDL_SCANCODE_CAPSLOCK}
+};
+
+const SDL_Scancode scancode_rmapping_nonextended[][2] = {
+    {SDL_SCANCODE_KP_7, SDL_SCANCODE_HOME},
+    {SDL_SCANCODE_KP_8, SDL_SCANCODE_UP},
+    {SDL_SCANCODE_KP_9, SDL_SCANCODE_PAGEUP},
+    {SDL_SCANCODE_KP_4, SDL_SCANCODE_LEFT},
+    {SDL_SCANCODE_KP_6, SDL_SCANCODE_RIGHT},
+    {SDL_SCANCODE_KP_1, SDL_SCANCODE_END},
+    {SDL_SCANCODE_KP_2, SDL_SCANCODE_DOWN},
+    {SDL_SCANCODE_KP_3, SDL_SCANCODE_PAGEDOWN},
+    {SDL_SCANCODE_KP_0, SDL_SCANCODE_INSERT},
+    {SDL_SCANCODE_KP_PERIOD, SDL_SCANCODE_DELETE},
+    {SDL_SCANCODE_KP_MULTIPLY, SDL_SCANCODE_PRINTSCREEN}
+};
+
+static void gfx_sdl_init(void) {
+    SDL_Init(SDL_INIT_VIDEO);
+    
+    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
+    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
+    
+    //SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
+    //SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 4);
+    
+    wnd = SDL_CreateWindow("Super Mario 64 PC-Port", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
+            DESIRED_SCREEN_WIDTH, DESIRED_SCREEN_HEIGHT, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
+    
+    SDL_GL_CreateContext(wnd);
+    SDL_GL_SetSwapInterval(2); // TODO 0, 1 or 2 or remove this line
+    
+    for (size_t i = 0; i < sizeof(windows_scancode_table) / sizeof(SDL_Scancode); i++) {
+        inverted_scancode_table[windows_scancode_table[i]] = i;
+    }
+    
+    for (size_t i = 0; i < sizeof(scancode_rmapping_extended) / sizeof(scancode_rmapping_extended[0]); i++) {
+        inverted_scancode_table[scancode_rmapping_extended[i][0]] = inverted_scancode_table[scancode_rmapping_extended[i][1]] + 0x100;
+    }
+    
+    for (size_t i = 0; i < sizeof(scancode_rmapping_nonextended) / sizeof(scancode_rmapping_nonextended[0]); i++) {
+        inverted_scancode_table[scancode_rmapping_extended[i][0]] = inverted_scancode_table[scancode_rmapping_extended[i][1]];
+        inverted_scancode_table[scancode_rmapping_extended[i][1]] += 0x100;
+    }
+}
+
+static void gfx_sdl_main_loop(void (*run_one_game_iter)(void)) {
+    while (1) {
+        run_one_game_iter();
+    }
+}
+
+static void gfx_sdl_get_dimensions(uint32_t *width, uint32_t *height) {
+    *width = DESIRED_SCREEN_WIDTH;
+    *height = DESIRED_SCREEN_HEIGHT;
+}
+
+static int translate_scancode(int scancode) {
+    if (scancode < 512) {
+        return inverted_scancode_table[scancode];
+    } else {
+        return 0;
+    }
+}
+
+static void gfx_sdl_onkeydown(int scancode) {
+    keyboard_on_key_down(translate_scancode(scancode));
+}
+
+static void gfx_sdl_onkeyup(int scancode) {
+    keyboard_on_key_up(translate_scancode(scancode));
+}
+
+static void gfx_sdl_handle_events(void) {
+    SDL_Event event;
+    while (SDL_PollEvent(&event)) {
+        switch (event.type) {
+#ifndef TARGET_WEB
+            // Scancodes are broken in Emscripten SDL2: https://bugzilla.libsdl.org/show_bug.cgi?id=3259
+            case SDL_KEYDOWN:
+                gfx_sdl_onkeydown(event.key.keysym.scancode);
+                break;
+            case SDL_KEYUP:
+                gfx_sdl_onkeyup(event.key.keysym.scancode);
+                break;
+#endif
+            case SDL_QUIT:
+                exit(0);
+        }
+    }
+}
+
+static bool gfx_sdl_start_frame(void) {
+    return true;
+}
+
+static void gfx_sdl_swap_buffers_begin(void) {
+    SDL_GL_SwapWindow(wnd);
+}
+
+static void gfx_sdl_swap_buffers_end(void) {
+}
+
+static double gfx_sdl_get_time(void) {
+    return 0.0;
+}
+
+struct GfxWindowManagerAPI gfx_sdl = {
+    gfx_sdl_init,
+    gfx_sdl_main_loop,
+    gfx_sdl_get_dimensions,
+    gfx_sdl_handle_events,
+    gfx_sdl_start_frame,
+    gfx_sdl_swap_buffers_begin,
+    gfx_sdl_swap_buffers_end,
+    gfx_sdl_get_time
+};
+
+#endif
diff --git a/src/pc/gfx/gfx_window_manager_api.h b/src/pc/gfx/gfx_window_manager_api.h
new file mode 100644
index 0000000..9c68cd1
--- /dev/null
+++ b/src/pc/gfx/gfx_window_manager_api.h
@@ -0,0 +1,18 @@
+#ifndef GFX_WINDOW_MANAGER_API_H
+#define GFX_WINDOW_MANAGER_API_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+struct GfxWindowManagerAPI {
+    void (*init)(void);
+    void (*main_loop)(void (*run_one_game_iter)(void));
+    void (*get_dimensions)(uint32_t *width, uint32_t *height);
+    void (*handle_events)(void);
+    bool (*start_frame)(void);
+    void (*swap_buffers_begin)(void);
+    void (*swap_buffers_end)(void);
+    double (*get_time)(void); // For debug
+};
+
+#endif
diff --git a/src/pc/mixer.c b/src/pc/mixer.c
new file mode 100644
index 0000000..0d1faa3
--- /dev/null
+++ b/src/pc/mixer.c
@@ -0,0 +1,490 @@
+#include <string.h>
+#include <stdint.h>
+#include <assert.h>
+
+// Note: Some of this is stolen from Mupen64Plus rsp audio plugin.
+// See abi.h for documentation.
+
+#define DMEM_BASE 0x5c0
+
+#define A_INIT     0x01
+#define A_CONTINUE   0x00
+#define A_LOOP                  0x02
+#define A_OUT                   0x02
+#define A_LEFT     0x02
+#define  A_RIGHT     0x00
+#define A_VOL      0x04
+#define A_RATE     0x00
+#define A_AUX      0x08
+#define A_NOAUX      0x00
+#define A_MAIN     0x00
+#define A_MIX      0x10
+
+struct alist_audio_t {
+    /* main buffers */
+    uint16_t in;
+    uint16_t out;
+    uint16_t count;
+
+    /* auxiliary buffers */
+    uint16_t dry_right;
+    uint16_t wet_left;
+    uint16_t wet_right;
+
+    /* gains */
+    int16_t dry;
+    int16_t wet;
+
+    /* envelopes (0:left, 1:right) */
+    int16_t vol[2];
+    int16_t target[2];
+    int32_t rate[2];
+
+    /* ADPCM loop point address */
+    uint16_t *loop;
+
+    /* storage for ADPCM table and polef coefficients */
+    int16_t table[16 * 8];
+};
+
+struct ramp_t
+{
+    int64_t value;
+    int64_t step;
+    int64_t target;
+};
+
+struct env_mix_save_buffer_t {
+    int16_t wet, pad0, dry, pad1;
+    uint32_t ramp_targets[2];
+    uint32_t exp_rates[2];
+    uint32_t exp_seq[2];
+    uint32_t ramp_values[2];
+};
+
+static const int16_t RESAMPLE_LUT[64 * 4] = {
+    (int16_t)0x0c39, (int16_t)0x66ad, (int16_t)0x0d46, (int16_t)0xffdf,
+    (int16_t)0x0b39, (int16_t)0x6696, (int16_t)0x0e5f, (int16_t)0xffd8,
+    (int16_t)0x0a44, (int16_t)0x6669, (int16_t)0x0f83, (int16_t)0xffd0,
+    (int16_t)0x095a, (int16_t)0x6626, (int16_t)0x10b4, (int16_t)0xffc8,
+    (int16_t)0x087d, (int16_t)0x65cd, (int16_t)0x11f0, (int16_t)0xffbf,
+    (int16_t)0x07ab, (int16_t)0x655e, (int16_t)0x1338, (int16_t)0xffb6,
+    (int16_t)0x06e4, (int16_t)0x64d9, (int16_t)0x148c, (int16_t)0xffac,
+    (int16_t)0x0628, (int16_t)0x643f, (int16_t)0x15eb, (int16_t)0xffa1,
+    (int16_t)0x0577, (int16_t)0x638f, (int16_t)0x1756, (int16_t)0xff96,
+    (int16_t)0x04d1, (int16_t)0x62cb, (int16_t)0x18cb, (int16_t)0xff8a,
+    (int16_t)0x0435, (int16_t)0x61f3, (int16_t)0x1a4c, (int16_t)0xff7e,
+    (int16_t)0x03a4, (int16_t)0x6106, (int16_t)0x1bd7, (int16_t)0xff71,
+    (int16_t)0x031c, (int16_t)0x6007, (int16_t)0x1d6c, (int16_t)0xff64,
+    (int16_t)0x029f, (int16_t)0x5ef5, (int16_t)0x1f0b, (int16_t)0xff56,
+    (int16_t)0x022a, (int16_t)0x5dd0, (int16_t)0x20b3, (int16_t)0xff48,
+    (int16_t)0x01be, (int16_t)0x5c9a, (int16_t)0x2264, (int16_t)0xff3a,
+    (int16_t)0x015b, (int16_t)0x5b53, (int16_t)0x241e, (int16_t)0xff2c,
+    (int16_t)0x0101, (int16_t)0x59fc, (int16_t)0x25e0, (int16_t)0xff1e,
+    (int16_t)0x00ae, (int16_t)0x5896, (int16_t)0x27a9, (int16_t)0xff10,
+    (int16_t)0x0063, (int16_t)0x5720, (int16_t)0x297a, (int16_t)0xff02,
+    (int16_t)0x001f, (int16_t)0x559d, (int16_t)0x2b50, (int16_t)0xfef4,
+    (int16_t)0xffe2, (int16_t)0x540d, (int16_t)0x2d2c, (int16_t)0xfee8,
+    (int16_t)0xffac, (int16_t)0x5270, (int16_t)0x2f0d, (int16_t)0xfedb,
+    (int16_t)0xff7c, (int16_t)0x50c7, (int16_t)0x30f3, (int16_t)0xfed0,
+    (int16_t)0xff53, (int16_t)0x4f14, (int16_t)0x32dc, (int16_t)0xfec6,
+    (int16_t)0xff2e, (int16_t)0x4d57, (int16_t)0x34c8, (int16_t)0xfebd,
+    (int16_t)0xff0f, (int16_t)0x4b91, (int16_t)0x36b6, (int16_t)0xfeb6,
+    (int16_t)0xfef5, (int16_t)0x49c2, (int16_t)0x38a5, (int16_t)0xfeb0,
+    (int16_t)0xfedf, (int16_t)0x47ed, (int16_t)0x3a95, (int16_t)0xfeac,
+    (int16_t)0xfece, (int16_t)0x4611, (int16_t)0x3c85, (int16_t)0xfeab,
+    (int16_t)0xfec0, (int16_t)0x4430, (int16_t)0x3e74, (int16_t)0xfeac,
+    (int16_t)0xfeb6, (int16_t)0x424a, (int16_t)0x4060, (int16_t)0xfeaf,
+    (int16_t)0xfeaf, (int16_t)0x4060, (int16_t)0x424a, (int16_t)0xfeb6,
+    (int16_t)0xfeac, (int16_t)0x3e74, (int16_t)0x4430, (int16_t)0xfec0,
+    (int16_t)0xfeab, (int16_t)0x3c85, (int16_t)0x4611, (int16_t)0xfece,
+    (int16_t)0xfeac, (int16_t)0x3a95, (int16_t)0x47ed, (int16_t)0xfedf,
+    (int16_t)0xfeb0, (int16_t)0x38a5, (int16_t)0x49c2, (int16_t)0xfef5,
+    (int16_t)0xfeb6, (int16_t)0x36b6, (int16_t)0x4b91, (int16_t)0xff0f,
+    (int16_t)0xfebd, (int16_t)0x34c8, (int16_t)0x4d57, (int16_t)0xff2e,
+    (int16_t)0xfec6, (int16_t)0x32dc, (int16_t)0x4f14, (int16_t)0xff53,
+    (int16_t)0xfed0, (int16_t)0x30f3, (int16_t)0x50c7, (int16_t)0xff7c,
+    (int16_t)0xfedb, (int16_t)0x2f0d, (int16_t)0x5270, (int16_t)0xffac,
+    (int16_t)0xfee8, (int16_t)0x2d2c, (int16_t)0x540d, (int16_t)0xffe2,
+    (int16_t)0xfef4, (int16_t)0x2b50, (int16_t)0x559d, (int16_t)0x001f,
+    (int16_t)0xff02, (int16_t)0x297a, (int16_t)0x5720, (int16_t)0x0063,
+    (int16_t)0xff10, (int16_t)0x27a9, (int16_t)0x5896, (int16_t)0x00ae,
+    (int16_t)0xff1e, (int16_t)0x25e0, (int16_t)0x59fc, (int16_t)0x0101,
+    (int16_t)0xff2c, (int16_t)0x241e, (int16_t)0x5b53, (int16_t)0x015b,
+    (int16_t)0xff3a, (int16_t)0x2264, (int16_t)0x5c9a, (int16_t)0x01be,
+    (int16_t)0xff48, (int16_t)0x20b3, (int16_t)0x5dd0, (int16_t)0x022a,
+    (int16_t)0xff56, (int16_t)0x1f0b, (int16_t)0x5ef5, (int16_t)0x029f,
+    (int16_t)0xff64, (int16_t)0x1d6c, (int16_t)0x6007, (int16_t)0x031c,
+    (int16_t)0xff71, (int16_t)0x1bd7, (int16_t)0x6106, (int16_t)0x03a4,
+    (int16_t)0xff7e, (int16_t)0x1a4c, (int16_t)0x61f3, (int16_t)0x0435,
+    (int16_t)0xff8a, (int16_t)0x18cb, (int16_t)0x62cb, (int16_t)0x04d1,
+    (int16_t)0xff96, (int16_t)0x1756, (int16_t)0x638f, (int16_t)0x0577,
+    (int16_t)0xffa1, (int16_t)0x15eb, (int16_t)0x643f, (int16_t)0x0628,
+    (int16_t)0xffac, (int16_t)0x148c, (int16_t)0x64d9, (int16_t)0x06e4,
+    (int16_t)0xffb6, (int16_t)0x1338, (int16_t)0x655e, (int16_t)0x07ab,
+    (int16_t)0xffbf, (int16_t)0x11f0, (int16_t)0x65cd, (int16_t)0x087d,
+    (int16_t)0xffc8, (int16_t)0x10b4, (int16_t)0x6626, (int16_t)0x095a,
+    (int16_t)0xffd0, (int16_t)0x0f83, (int16_t)0x6669, (int16_t)0x0a44,
+    (int16_t)0xffd8, (int16_t)0x0e5f, (int16_t)0x6696, (int16_t)0x0b39,
+    (int16_t)0xffdf, (int16_t)0x0d46, (int16_t)0x66ad, (int16_t)0x0c39
+};
+
+static uint8_t alist_buffer[0x1000];
+static struct alist_audio_t alist_audio;
+
+static inline size_t align(size_t x, size_t amount) {
+    --amount;
+    return (x + amount) & ~amount;
+}
+
+static inline int16_t clamp_s16(int32_t v) {
+    return v < -32768 ? -32768 : v > 32767 ? 32767 : v;
+}
+
+static inline int16_t sample_mix(int16_t dst, int16_t src, int16_t gain) {
+    int32_t src_modified = (src * gain) >> 15;
+    return clamp_s16(dst + src_modified);
+}
+
+void aClearBuffer(uint64_t *cmd, uint16_t dmem, uint16_t count) {
+    dmem += DMEM_BASE;
+    //assert(align(count, 16) == count);
+    count = align(count, 16);
+    memset(alist_buffer + dmem, 0, count);
+}
+
+void aSetBuffer(uint64_t *cmd, uint8_t flags, uint16_t dmemin, uint16_t dmemout, uint16_t count) {
+    if (flags & A_AUX) {
+        // Parameter names are not really correct for A_AUX
+        alist_audio.dry_right = dmemin + DMEM_BASE;
+        alist_audio.wet_left = dmemout + DMEM_BASE;
+        alist_audio.wet_right = count + DMEM_BASE;
+    } else {
+        alist_audio.in = dmemin + DMEM_BASE;
+        alist_audio.out = dmemout + DMEM_BASE;
+        alist_audio.count = count;
+    }
+}
+
+void aLoadBuffer(uint64_t *cmd, uint16_t *addr) {
+    // addr &= ~7
+    memcpy(alist_buffer + alist_audio.in, addr, alist_audio.count);
+}
+
+void aSaveBuffer(uint64_t *cmd, uint16_t *addr) {
+    memcpy(addr, alist_buffer + alist_audio.out, alist_audio.count);
+}
+
+void aDMEMMove(uint64_t *cmd, uint16_t dmemin, uint16_t dmemout, uint16_t count) {
+    dmemin += DMEM_BASE;
+    dmemout += DMEM_BASE;
+    //assert(align(count, 16) == count);
+    count = align(count, 16); // Microcode does this
+    memmove(alist_buffer + dmemout, alist_buffer + dmemin, count);
+}
+
+void aMix(uint64_t *cmd, uint8_t flags, uint16_t gain, uint16_t dmemin, uint16_t dmemout) {
+    dmemin += DMEM_BASE;
+    dmemout += DMEM_BASE;
+    
+    // originally count is rounded up to nearest 32 bytes
+    
+    int16_t *dst = (int16_t*)(alist_buffer + dmemout);
+    const int16_t *src = (const int16_t*)(alist_buffer + dmemin);
+    size_t count = alist_audio.count >> 1;
+    count = align(count, 16);
+    
+    while (count != 0) {
+        *dst = sample_mix(*dst, *src, gain);
+        ++dst;
+        ++src;
+        --count;
+    }
+}
+
+static inline int16_t ramp_step(struct ramp_t* ramp) {
+    int target_reached;
+
+    ramp->value += ramp->step;
+
+    target_reached = (ramp->step <= 0)
+        ? (ramp->value <= ramp->target)
+        : (ramp->value >= ramp->target);
+
+    if (target_reached)
+    {
+        ramp->value = ramp->target;
+        ramp->step  = 0;
+    }
+
+    return (int16_t)(ramp->value >> 16);
+}
+
+void aEnvMixer(uint64_t *cmd, uint8_t flags, uint16_t *addr) {
+    size_t n = (flags & A_AUX) ? 4 : 2;
+    
+    const int16_t *const in = (int16_t*)(alist_buffer + alist_audio.in);
+    int16_t *const dl = (int16_t*)(alist_buffer + alist_audio.out);
+    int16_t *const dr = (int16_t*)(alist_buffer + alist_audio.dry_right);
+    int16_t *const wl = (int16_t*)(alist_buffer + alist_audio.wet_left);
+    int16_t *const wr = (int16_t*)(alist_buffer + alist_audio.wet_right);
+    
+    struct ramp_t ramps[2];
+    int32_t exp_seq[2];
+    int32_t exp_rates[2];
+    int16_t dry;
+    int16_t wet;
+    
+    uint32_t ptr = 0;
+    uint32_t x, y;
+    uint32_t count = alist_audio.count;
+    struct env_mix_save_buffer_t *s = (struct env_mix_save_buffer_t*)addr;
+    
+    if (flags & A_INIT) {
+        ramps[0].value  = (alist_audio.vol[0] << 16);
+        ramps[1].value  = (alist_audio.vol[1] << 16);
+        ramps[0].target = (alist_audio.target[0] << 16);
+        ramps[1].target = (alist_audio.target[1] << 16);
+        exp_rates[0]    = alist_audio.rate[0];
+        exp_rates[1]    = alist_audio.rate[1];
+        exp_seq[0]      = (alist_audio.vol[0] * alist_audio.rate[0]);
+        exp_seq[1]      = (alist_audio.vol[1] * alist_audio.rate[1]);
+        dry = alist_audio.dry;
+        wet = alist_audio.wet;
+    } else {
+        wet = s->wet;
+        dry = s->dry;
+        ramps[0].target = s->ramp_targets[0];
+        ramps[1].target = s->ramp_targets[1];
+        exp_rates[0] = s->exp_rates[0];
+        exp_rates[1] = s->exp_rates[1];
+        exp_seq[0] = s->exp_seq[0];
+        exp_seq[1] = s->exp_seq[1];
+        ramps[0].value = s->ramp_values[0];
+        ramps[1].value = s->ramp_values[1];
+    }
+    
+    /* init which ensure ramp.step != 0 iff ramp.value == ramp.target */
+    ramps[0].step = ramps[0].target - ramps[0].value;
+    ramps[1].step = ramps[1].target - ramps[1].value;
+    
+    for (y = 0; y < count; y += 16)
+    {
+        if (ramps[0].step != 0)
+        {
+            exp_seq[0] = ((int64_t)exp_seq[0]*(int64_t)exp_rates[0]) >> 16;
+            ramps[0].step = (exp_seq[0] - ramps[0].value) >> 3;
+        }
+
+        if (ramps[1].step != 0)
+        {
+            exp_seq[1] = ((int64_t)exp_seq[1]*(int64_t)exp_rates[1]) >> 16;
+            ramps[1].step = (exp_seq[1] - ramps[1].value) >> 3;
+        }
+
+        for (x = 0; x < 8; ++x) {
+            int16_t l_vol = ramp_step(&ramps[0]);
+            int16_t r_vol = ramp_step(&ramps[1]);
+            int16_t in_sample = in[ptr];
+            
+            dl[ptr] = sample_mix(dl[ptr], in_sample, clamp_s16((l_vol * dry + 0x4000) >> 15));
+            dr[ptr] = sample_mix(dr[ptr], in_sample, clamp_s16((r_vol * dry + 0x4000) >> 15));
+            if (n == 4) {
+                wl[ptr] = sample_mix(wl[ptr], in_sample, clamp_s16((l_vol * wet + 0x4000) >> 15));
+                wr[ptr] = sample_mix(wr[ptr], in_sample, clamp_s16((r_vol * wet + 0x4000) >> 15));
+            }
+            ++ptr;
+        }
+    }
+    
+    s->wet = wet;
+    s->dry = dry;
+    s->ramp_targets[0] = ramps[0].target;
+    s->ramp_targets[1] = ramps[1].target;
+    s->exp_rates[0] = exp_rates[0];
+    s->exp_rates[1] = exp_rates[1];
+    s->exp_seq[0] = exp_seq[0];
+    s->exp_seq[1] = exp_seq[1];
+    s->ramp_values[0] = ramps[0].value;
+    s->ramp_values[1] = ramps[1].value;
+}
+
+void aResample(uint64_t *cmd, uint8_t flags, uint16_t pitch, uint16_t *state_addr) {
+    int16_t *dst = (int16_t*)(alist_buffer + alist_audio.out);
+    int16_t *src = (int16_t*)(alist_buffer + alist_audio.in);
+    size_t count = alist_audio.count >> 1;
+    uint32_t pitch_accumulator = 0;
+    
+    count = align(count, 8);
+    
+    src -= 4;
+    
+    if (flags & A_INIT) {
+        memset(src, 0, 4 * sizeof(int16_t));
+    } else {
+        memcpy(src, state_addr, 4 * sizeof(int16_t));
+        pitch_accumulator = state_addr[4];
+    }
+    
+    while (count != 0) {
+        const int16_t *lut = RESAMPLE_LUT + ((pitch_accumulator & 0xfc00) >> 8);
+        
+        *dst++ = clamp_s16((src[0] * lut[0] + src[1] * lut[1] + src[2] * lut[2] + src[3] * lut[3]) >> 15);
+        pitch_accumulator += (pitch << 1);
+        src += pitch_accumulator >> 16;
+        pitch_accumulator &= 0xffff;
+        --count;
+    }
+    
+    memcpy(state_addr, src, 4 * sizeof(int16_t));
+    state_addr[4] = pitch_accumulator;
+}
+
+void aInterleave(uint64_t *cmd, uint16_t inL, uint16_t inR) {
+    inL += DMEM_BASE;
+    inR += DMEM_BASE;
+    
+    int16_t *dst = (int16_t*)(alist_buffer + alist_audio.out);
+    int16_t *srcL = (int16_t*)(alist_buffer + inL);
+    int16_t *srcR = (int16_t*)(alist_buffer + inR);
+    
+    size_t count = alist_audio.count >> 2;
+    
+    count = align(count, 4);
+    
+    // Unroll a bit
+    while (count != 0) {
+        int16_t l1 = *srcL++;
+        int16_t l2 = *srcL++;
+        int16_t r1 = *srcR++;
+        int16_t r2 = *srcR++;
+        
+        *dst++ = l1;
+        *dst++ = r1;
+        *dst++ = l2;
+        *dst++ = r2;
+        
+        --count;
+    }
+}
+
+// These two share the same opcode but parameters and what they do are different depending on flags
+void aSetVolume(uint64_t *cmd, uint8_t flags, uint16_t vol, uint16_t voltgt, uint16_t volrate) {
+    if (flags & A_AUX) {
+        // Parameter names are not really correct for A_AUX
+        alist_audio.dry = vol;
+        alist_audio.wet = volrate;
+    } else {
+        size_t lr = (flags & A_LEFT) ? 0 : 1;
+        
+        assert(flags & A_VOL);
+        alist_audio.vol[lr] = vol;
+    }
+}
+void aSetVolume32(uint64_t *cmd, uint8_t flags, uint16_t voltgt, uint32_t volrate) {
+    size_t lr = (flags & A_LEFT) ? 0 : 1;
+    
+    assert(!(flags & A_VOL) && !(flags & A_AUX));
+    alist_audio.target[lr] = voltgt;
+    alist_audio.rate[lr] = volrate;
+}
+
+void aSetLoop(uint64_t *cmd, uint16_t *addr) {
+    alist_audio.loop = addr;
+}
+
+void aLoadADPCM(uint64_t *cmd, uint16_t count, uint16_t *addr) {
+    assert(align(count, 8) == count);
+    memcpy(alist_audio.table, addr, count);
+}
+
+static inline int16_t adpcm_predict_sample(uint8_t byte, uint8_t mask,
+        unsigned lshift, unsigned rshift) {
+    int16_t sample = (uint16_t)(byte & mask) << lshift;
+    sample >>= rshift; /* signed */
+    return sample;
+}
+
+static unsigned int adpcm_predict_frame_4bits(int16_t* dst, uint8_t* src, uint8_t scale) {
+    unsigned int i;
+    unsigned int rshift = (scale < 12) ? 12 - scale : 0;
+
+    for(i = 0; i < 8; ++i) {
+        uint8_t byte = *src++;
+
+        *(dst++) = adpcm_predict_sample(byte, 0xf0,  8, rshift);
+        *(dst++) = adpcm_predict_sample(byte, 0x0f, 12, rshift);
+    }
+
+    return 8;
+}
+
+static int32_t rdot(size_t n, const int16_t *x, const int16_t *y) {
+    int32_t accu = 0;
+
+    y += n;
+
+    while (n != 0) {
+        accu += *(x++) * *(--y);
+        --n;
+    }
+
+    return accu;
+}
+
+static void adpcm_compute_residuals(int16_t* dst, const int16_t* src,
+        const int16_t* cb_entry, const int16_t* last_samples, size_t count) {
+    const int16_t* const book1 = cb_entry;
+    const int16_t* const book2 = cb_entry + 8;
+
+    const int16_t l1 = last_samples[0];
+    const int16_t l2 = last_samples[1];
+
+    size_t i;
+
+    assert(count <= 8);
+
+    for(i = 0; i < count; ++i) {
+        int32_t accu = (int32_t)src[i] << 11;
+        accu += book1[i]*l1 + book2[i]*l2 + rdot(i, book2, src);
+        dst[i] = clamp_s16(accu >> 11);
+   }
+}
+
+void aADPCMdec(uint64_t *cmd, uint8_t flags, uint16_t *last_frame_addr) {
+    int16_t *dst = (int16_t*)(alist_buffer + alist_audio.out);
+    uint8_t *src = alist_buffer + alist_audio.in;
+    size_t count = alist_audio.count;
+    int16_t last_frame[16];
+
+    count = align(count, 32);
+    assert((count & 0x1f) == 0);
+    
+    if (flags & A_INIT) {
+        memset(last_frame, 0, sizeof(last_frame));
+    } else {
+        memcpy(last_frame, ((flags & A_LOOP) ? alist_audio.loop : last_frame_addr), sizeof(last_frame));
+    }
+    
+    memcpy(dst, last_frame, sizeof(last_frame));
+    dst += 16;
+    
+    while (count != 0) {
+        int16_t frame[16];
+        uint8_t code = *src++;
+        uint8_t scale = code >> 4;
+        const int16_t *const cb_entry = alist_audio.table + ((code & 0xf) * 16);
+        
+        src += adpcm_predict_frame_4bits(frame, src, scale);
+        
+        adpcm_compute_residuals(last_frame, frame, cb_entry, last_frame + 14, 8);
+        adpcm_compute_residuals(last_frame + 8, frame + 8, cb_entry, last_frame + 6, 8);
+        
+        memcpy(dst, last_frame, sizeof(last_frame));
+        dst += 16;
+        
+        count -= 32;
+    }
+    
+    memcpy(last_frame_addr, last_frame, sizeof(last_frame));
+}
diff --git a/src/pc/mixer.h b/src/pc/mixer.h
new file mode 100644
index 0000000..5fc3346
--- /dev/null
+++ b/src/pc/mixer.h
@@ -0,0 +1,39 @@
+#ifndef MIXER_H
+#define MIXER_H
+
+#include <PR/ultratypes.h>
+
+#undef aSegment
+#undef aClearBuffer
+#undef aSetBuffer
+#undef aLoadBuffer
+#undef aSaveBuffer
+#undef aDMEMMove
+#undef aMix
+#undef aEnvMixer
+#undef aResample
+#undef aInterleave
+#undef aSetVolume
+#undef aSetVolume32
+#undef aSetLoop
+#undef aLoadADPCM
+#undef aADPCMdec
+
+#define aSegment(pkt, s, b)
+void aClearBuffer(uint64_t *cmd, uint16_t dmem, uint16_t count);
+void aSetBuffer(uint64_t *cmd, uint8_t flags, uint16_t dmemin, uint16_t dmemout, uint16_t count);
+void aLoadBuffer(uint64_t *cmd, uint16_t *addr);
+void aSaveBuffer(uint64_t *cmd, uint16_t *addr);
+void aDMEMMove(uint64_t *cmd, uint16_t dmemin, uint16_t dmemout, uint16_t count);
+void aMix(uint64_t *cmd, uint8_t flags, uint16_t gain, uint16_t dmemin, uint16_t dmemout);
+void aEnvMixer(uint64_t *cmd, uint8_t flags, uint16_t *addr);
+void aResample(uint64_t *cmd, uint8_t flags, uint16_t pitch, uint16_t *state_addr);
+void aInterleave(uint64_t *cmd, uint16_t inL, uint16_t inR);
+void aSetVolume(uint64_t *cmd, uint8_t flags, uint16_t vol, uint16_t voltgt, uint16_t volrate);
+void aSetVolume32(uint64_t *cmd, uint8_t flags, uint16_t voltgt, uint32_t volrate);
+void aSetLoop(uint64_t *cmd, uint16_t *addr);
+void aLoadADPCM(uint64_t *cmd, uint16_t count, uint16_t *addr);
+void aADPCMdec(uint64_t *cmd, uint8_t flags, uint16_t *last_frame_addr);
+
+
+#endif
diff --git a/src/pc/pc_main.c b/src/pc/pc_main.c
new file mode 100644
index 0000000..d5a68c8
--- /dev/null
+++ b/src/pc/pc_main.c
@@ -0,0 +1,201 @@
+#include <stdlib.h>
+
+#ifdef TARGET_WEB
+#include <emscripten.h>
+#include <emscripten/html5.h>
+#endif
+
+#include "sm64.h"
+
+#include "game/memory.h"
+#include "audio/external.h"
+
+#include "gfx/gfx_pc.h"
+#include "gfx/gfx_opengl.h"
+#include "gfx/gfx_direct3d12.h"
+#include "gfx/gfx_glx.h"
+#include "gfx/gfx_sdl.h"
+
+#include "audio/audio_api.h"
+#include "audio/audio_wasapi.h"
+#include "audio/audio_pulse.h"
+#include "audio/audio_alsa.h"
+#include "audio/audio_sdl.h"
+#include "audio/audio_null.h"
+
+#include "configfile.h"
+
+#define CONFIG_FILE "sm64config.txt"
+
+OSMesg D_80339BEC;
+OSMesgQueue gSIEventMesgQueue;
+
+s8 gResetTimer;
+s8 D_8032C648;
+s8 gDebugLevelSelect;
+s8 gShowProfiler;
+s8 gShowDebugText;
+
+static struct AudioAPI *audio_api;
+static struct GfxWindowManagerAPI *wm_api;
+static struct GfxRenderingAPI *rendering_api;
+
+extern void gfx_run(Gfx *commands);
+extern void thread5_game_loop(void *arg);
+extern void create_next_audio_buffer(s16 *samples, u32 num_samples);
+void game_loop_one_iteration(void);
+
+void dispatch_audio_sptask(struct SPTask *spTask) {
+}
+
+void set_vblank_handler(s32 index, struct VblankHandler *handler, OSMesgQueue *queue, OSMesg *msg) {
+}
+
+static uint8_t inited = 0;
+
+#include "game/display.h" // for gGlobalTimer
+void send_display_list(struct SPTask *spTask) {
+    if (!inited) {
+        return;
+    }
+    gfx_run((Gfx *)spTask->task.t.data_ptr);
+}
+
+#define printf
+
+void produce_one_frame(void) {
+    gfx_start_frame();
+    game_loop_one_iteration();
+    
+    int samples_left = audio_api->buffered();
+    u32 num_audio_samples = samples_left < audio_api->get_desired_buffered() ? 544 : 528;
+    //printf("Audio samples: %d %u\n", samples_left, num_audio_samples);
+    s16 audio_buffer[544 * 2 * 2];
+    for (int i = 0; i < 2; i++) {
+        /*if (audio_cnt-- == 0) {
+            audio_cnt = 2;
+        }
+        u32 num_audio_samples = audio_cnt < 2 ? 528 : 544;*/
+        create_next_audio_buffer(audio_buffer + i * (num_audio_samples * 2), num_audio_samples);
+    }
+    //printf("Audio samples before submitting: %d\n", audio_api->buffered());
+    audio_api->play(audio_buffer, 2 * num_audio_samples * 4);
+    
+    gfx_end_frame();
+}
+
+#ifdef TARGET_WEB
+static void em_main_loop(void) {
+}
+
+static void request_anim_frame(void (*func)(double time)) {
+    EM_ASM(requestAnimationFrame(function(time) {
+        dynCall("vd", $0, [time]);
+    }), func);
+}
+
+static void on_anim_frame(double time) {
+    static double target_time;
+
+    time *= 0.03; // milliseconds to frame count (33.333 ms -> 1)
+
+    if (time >= target_time + 10.0) {
+        // We are lagging 10 frames behind, probably due to coming back after inactivity,
+        // so reset, with a small margin to avoid potential jitter later.
+        target_time = time - 0.010;
+    }
+
+    for (int i = 0; i < 2; i++) {
+        // If refresh rate is 15 Hz or something we might need to generate two frames
+        if (time >= target_time) {
+            produce_one_frame();
+            target_time = target_time + 1.0;
+        }
+    }
+
+    request_anim_frame(on_anim_frame);
+}
+#endif
+
+static void save_config(void) {
+    configfile_save(CONFIG_FILE);
+}
+
+void main_func(void) {
+    static u64 pool[0x165000/8 / 4 * sizeof(void *)];
+    main_pool_init(pool, pool + sizeof(pool) / sizeof(pool[0]));
+    gEffectsMemoryPool = mem_pool_init(0x4000, MEMORY_POOL_LEFT);
+
+    configfile_load(CONFIG_FILE);
+    atexit(save_config);
+
+#ifdef TARGET_WEB
+    emscripten_set_main_loop(em_main_loop, 0, 0);
+    request_anim_frame(on_anim_frame);
+#endif
+
+#if (defined(_WIN32) || defined(_WIN64))
+    wm_api = &gfx_dxgi_api;
+    rendering_api = &gfx_direct3d12_api;
+#elif defined(__linux__)
+    wm_api = &gfx_glx;
+    rendering_api = &gfx_opengl_api;
+#else
+    wm_api = &gfx_sdl;
+    rendering_api = &gfx_opengl_api;
+#endif
+    gfx_init(wm_api, rendering_api);
+    
+#if HAVE_WASAPI
+    if (audio_api == NULL && audio_wasapi.init()) {
+        audio_api = &audio_wasapi;
+    }
+#endif
+#if HAVE_PULSE_AUDIO
+    if (audio_api == NULL && audio_pulse.init()) {
+        audio_api = &audio_pulse;
+    }
+#endif
+#if HAVE_ALSA
+    if (audio_api == NULL && audio_alsa.init()) {
+        audio_api = &audio_alsa;
+    }
+#endif
+#ifdef TARGET_WEB
+    if (audio_api == NULL && audio_sdl.init()) {
+        audio_api = &audio_sdl;
+    }
+#endif
+    if (audio_api == NULL) {
+        audio_api = &audio_null;
+    }
+
+    audio_init();
+    sound_init();
+
+    thread5_game_loop(NULL);
+#ifdef TARGET_WEB
+    /*for (int i = 0; i < atoi(argv[1]); i++) {
+        game_loop_one_iteration();
+    }*/
+    inited = 1;
+#else
+    inited = 1;
+    while (1) {
+        wm_api->main_loop(produce_one_frame);
+    }
+#endif
+}
+
+#if defined(_WIN32) || defined(_WIN64)
+#include <windows.h>
+int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pCmdLine, int nCmdShow) {
+    main_func();
+    return 0;
+}
+#else
+int main(int argc, char *argv[]) {
+    main_func();
+    return 0;
+}
+#endif
diff --git a/src/pc/ultra_reimplementation.c b/src/pc/ultra_reimplementation.c
new file mode 100644
index 0000000..476e359
--- /dev/null
+++ b/src/pc/ultra_reimplementation.c
@@ -0,0 +1,160 @@
+#include <stdio.h>
+#include <string.h>
+#include "lib/src/libultra_internal.h"
+#include "macros.h"
+
+#ifdef TARGET_WEB
+#include <emscripten.h>
+#endif
+
+extern OSMgrArgs piMgrArgs;
+
+u64 osClockRate = 62500000;
+
+s32 osPiStartDma(UNUSED OSIoMesg *mb, UNUSED s32 priority, UNUSED s32 direction,
+                 uintptr_t devAddr, void *vAddr, size_t nbytes,
+                 UNUSED OSMesgQueue *mq) {
+    memcpy(vAddr, (const void *) devAddr, nbytes);
+    return 0;
+}
+
+void osSetEventMesg(UNUSED OSEvent e, UNUSED OSMesgQueue *mq, UNUSED OSMesg msg) {
+}
+s32 osJamMesg(UNUSED OSMesgQueue *mq, UNUSED OSMesg msg, UNUSED s32 flag) {
+    return 0;
+}
+s32 osSendMesg(UNUSED OSMesgQueue *mq, UNUSED OSMesg msg, UNUSED s32 flag) {
+    return 0;
+}
+s32 osRecvMesg(UNUSED OSMesgQueue *mq, UNUSED OSMesg *msg, UNUSED s32 flag) {
+    return 0;
+}
+
+uintptr_t osVirtualToPhysical(void *addr) {
+    return (uintptr_t) addr;
+}
+
+void osCreateViManager(UNUSED OSPri pri) {
+}
+void osViSetMode(UNUSED OSViMode *mode) {
+}
+void osViSetEvent(UNUSED OSMesgQueue *mq, UNUSED OSMesg msg, UNUSED u32 retraceCount) {
+}
+void osViBlack(UNUSED u8 active) {
+}
+void osViSetSpecialFeatures(UNUSED u32 func) {
+}
+void osViSwapBuffer(UNUSED void *vaddr) {
+}
+
+OSTime osGetTime(void) {
+    return 0;
+}
+
+void osWritebackDCacheAll(void) {
+}
+
+void osWritebackDCache(UNUSED void *a, UNUSED size_t b) {
+}
+
+void osInvalDCache(UNUSED void *a, UNUSED size_t b) {
+}
+
+u32 osGetCount(void) {
+    static u32 counter;
+    return counter++;
+}
+
+s32 osAiSetFrequency(u32 freq) {
+    u32 a1;
+    s32 a2;
+    u32 D_8033491C;
+
+#ifdef VERSION_EU
+    D_8033491C = 0x02E6025C;
+#else
+    D_8033491C = 0x02E6D354;
+#endif
+
+    a1 = D_8033491C / (float) freq + .5f;
+
+    if (a1 < 0x84) {
+        return -1;
+    }
+
+    a2 = (a1 / 66) & 0xff;
+    if (a2 > 16) {
+        a2 = 16;
+    }
+
+    return D_8033491C / (s32) a1;
+}
+
+s32 osEepromProbe(UNUSED OSMesgQueue *mq) {
+    return 1;
+}
+
+s32 osEepromLongRead(UNUSED OSMesgQueue *mq, u8 address, u8 *buffer, int nbytes) {
+    u8 content[512];
+    s32 ret = -1;
+
+#ifdef TARGET_WEB
+    if (EM_ASM_INT({
+        var s = localStorage.sm64_save_file;
+        if (s && s.length === 684) {
+            try {
+                var binary = atob(s);
+                if (binary.length === 512) {
+                    for (var i = 0; i < 512; i++) {
+                        HEAPU8[$0 + i] = binary.charCodeAt(i);
+                    }
+                    return 1;
+                }
+            } catch (e) {
+            }
+        }
+        return 0;
+    }, content)) {
+        memcpy(buffer, content + address * 8, nbytes);
+        ret = 0;
+    }
+#else
+    FILE *fp = fopen("sm64_save_file.bin", "rb");
+    if (fp == NULL) {
+        return -1;
+    }
+    if (fread(content, 1, 512, fp) == 512) {
+        memcpy(buffer, content + address * 8, nbytes);
+        ret = 0;
+    }
+    fclose(fp);
+#endif
+    return ret;
+}
+
+s32 osEepromLongWrite(UNUSED OSMesgQueue *mq, u8 address, u8 *buffer, int nbytes) {
+    u8 content[512] = {0};
+    if (address != 0 || nbytes != 512) {
+        osEepromLongRead(mq, 0, content, 512);
+    }
+    memcpy(content + address * 8, buffer, nbytes);
+
+#ifdef TARGET_WEB
+    EM_ASM({
+        var str = "";
+        for (var i = 0; i < 512; i++) {
+            str += String.fromCharCode(HEAPU8[$0 + i]);
+        }
+        localStorage.sm64_save_file = btoa(str);
+    }, content);
+    s32 ret = 0;
+#else
+    FILE* fp = fopen("sm64_save_file.bin", "wb");
+    if (fp == NULL) {
+        return -1;
+    }
+    s32 ret = fwrite(content, 1, 512, fp) == 512 ? 0 : -1;
+    fclose(fp);
+#endif
+    return ret;
+}
